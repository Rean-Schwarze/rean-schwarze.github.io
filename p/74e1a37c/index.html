<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>【Java】并发（一） | 进程 &amp; 线程 | Rean's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/favicon.png"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.8.10"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="https://cdn.staticfile.net/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdn.staticfile.net/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><link rel="stylesheet" href="https://cdn.staticfile.net/fancyapps-ui/5.0.36/fancybox/fancybox.min.css"><!-- katex--><!-- Open Graph--><meta name="description" content="Java 线程和操作系统的线程有啥区别？JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。 在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native T"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="Rean's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/favicon.png"><link rel="apple-touch-icon" href="/img/favicon.png" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.8.10",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2024-01-05 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.png'
    },
    copyright: {"limit":50,"author":"作者: Rean","link":"链接: ","source":"来源: Rean's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"}},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: ["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🎮 游戏爱好者"],
    },
    covercolor: {
        enable: true
    },
    comment: false,
    lightbox: 'fancybox',
    post_ai: false,
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","music":{"start":"播放音乐","stop":"暂停音乐"},"translate":{"translateDelay":0,"defaultEncoding":2}},
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false,
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><span class="music-switch" title="音乐开关"><i class="solitude st-disc-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">160</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>标签</span></a></li><li><a class="site-page child" href="/study/"><i class="solitude  st-gift-fill"></i><span>学习</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li><li><a class="site-page child" href="/essay/"><span>即刻短文</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/%E8%85%BE%E8%AE%AF/">腾讯<sup>1</sup></a><a href="/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发<sup>1</sup></a><a href="/tags/Markdown/">Markdown<sup>1</sup></a><a href="/tags/Butterfly/">Butterfly<sup>2</sup></a><a href="/tags/PyCharm/">PyCharm<sup>1</sup></a><a href="/tags/IDEA/">IDEA<sup>1</sup></a><a href="/tags/Git/">Git<sup>2</sup></a><a href="/tags/Halo/">Halo<sup>1</sup></a><a href="/tags/GitHub/">GitHub<sup>1</sup></a><a href="/tags/JavaFx/">JavaFx<sup>2</sup></a><a href="/tags/SpringBoot/">SpringBoot<sup>7</sup></a><a href="/tags/Java/">Java<sup>18</sup></a><a href="/tags/MyBatis/">MyBatis<sup>4</sup></a><a href="/tags/Hexo/">Hexo<sup>3</sup></a><a href="/tags/SyncTV/">SyncTV<sup>1</sup></a><a href="/tags/AList/">AList<sup>1</sup></a><a href="/tags/%E5%AE%9D%E5%A1%94/">宝塔<sup>3</sup></a><a href="/tags/Vue/">Vue<sup>18</sup></a><a href="/tags/Vite/">Vite<sup>6</sup></a><a href="/tags/JavaScript/">JavaScript<sup>4</sup></a><a href="/tags/TypeScript/">TypeScript<sup>3</sup></a><a href="/tags/Electron/">Electron<sup>4</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习<sup>1</sup></a><a href="/tags/scikit-learn/">scikit-learn<sup>1</sup></a><a href="/tags/vocalremover/">vocalremover<sup>1</sup></a><a href="/tags/BPM/">BPM<sup>1</sup></a><a href="/tags/%E9%BB%91%E7%A5%9E%E8%AF%9D%EF%BC%9A%E6%82%9F%E7%A9%BA/">黑神话：悟空<sup>1</sup></a><a href="/tags/HTTP/">HTTP<sup>5</sup></a><a href="/tags/HTTPS/">HTTPS<sup>2</sup></a><a href="/tags/%E7%9F%AD%E9%93%BE/">短链<sup>1</sup></a><a href="/tags/%E8%A7%86%E9%A2%91/">视频<sup>1</sup></a><a href="/tags/HTTP-1-1/">HTTP/1.1<sup>1</sup></a><a href="/tags/LaTex/">LaTex<sup>1</sup></a><a href="/tags/%E5%8A%A0%E5%AF%86/">加密<sup>1</sup></a><a href="/tags/IP/">IP<sup>2</sup></a><a href="/tags/ICMP/">ICMP<sup>1</sup></a><a href="/tags/I-O/">I/O<sup>2</sup></a><a href="/tags/JVM/">JVM<sup>2</sup></a><a href="/tags/Springboot/">Springboot<sup>1</sup></a><a href="/tags/ThreadLocal/">ThreadLocal<sup>1</sup></a><a href="/tags/UUID/">UUID<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/">并发<sup>4</sup></a><a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树<sup>2</sup></a><a href="/tags/%E9%93%BE%E8%A1%A8/">链表<sup>1</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3/">力扣<sup>1</sup></a><a href="/tags/LeetCode/">LeetCode<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库<sup>8</sup></a><a href="/tags/NLP/">NLP<sup>6</sup></a><a href="/tags/spaCy/">spaCy<sup>4</sup></a><a href="/tags/Python/">Python<sup>1</sup></a><a href="/tags/Redis/">Redis<sup>10</sup></a><a href="/tags/RDB/">RDB<sup>1</sup></a><a href="/tags/AOF/">AOF<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/">线程<sup>2</sup></a><a href="/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用<sup>2</sup></a><a href="/tags/Spring/">Spring<sup>5</sup></a><a href="/tags/TCP/">TCP<sup>7</sup></a><a href="/tags/UDP/">UDP<sup>1</sup></a><a href="/tags/Socket/">Socket<sup>1</sup></a><a href="/tags/FFMpeg/">FFMpeg<sup>1</sup></a><a href="/tags/%E6%A0%B7%E5%BC%8F/">样式<sup>1</sup></a><a href="/tags/ECMAScript/">ECMAScript<sup>2</sup></a><a href="/tags/Element/">Element<sup>3</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁<sup>1</sup></a><a href="/tags/%E5%91%A8%E6%B7%B1/">周深<sup>7</sup></a><a href="/tags/%E5%BE%B5%E7%BE%BD%E6%91%A9%E6%9F%AF/">徵羽摩柯<sup>1</sup></a><a href="/tags/%E9%9F%B3%E4%B9%90%E7%BC%98%E8%AE%A1%E5%88%92/">音乐缘计划<sup>4</sup></a><a href="/tags/%E5%A5%A5%E6%96%AF%E5%8D%A1/">奥斯卡<sup>3</sup></a><a href="/tags/%E5%BC%A0%E6%9D%B0/">张杰<sup>2</sup></a><a href="/tags/%E5%A3%B0%E7%94%9F%E4%B8%8D%E6%81%AF%C2%B7%E5%AE%9D%E5%B2%9B%E5%AD%A3/">声生不息·宝岛季<sup>3</sup></a><a href="/tags/%E5%BE%90%E4%BD%B3%E8%8E%B9/">徐佳莹<sup>1</sup></a><a href="/tags/SynthV/">SynthV<sup>22</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>4</sup></a><a href="/tags/%E6%B0%B8%E5%A4%9CMinus/">永夜Minus<sup>6</sup></a><a href="/tags/%E9%9F%A6%E7%A4%BC%E5%AE%89/">韦礼安<sup>1</sup></a><a href="/tags/%E8%94%A1%E4%BE%9D%E6%9E%97/">蔡依林<sup>1</sup></a><a href="/tags/%E6%97%A0%E5%8F%82/">无参<sup>46</sup></a><a href="/tags/%E5%8F%A4%E9%A3%8E/">古风<sup>12</sup></a><a href="/tags/%E4%B8%89%E6%97%A0Marblue/">三无Marblue<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/">索引<sup>1</sup></a><a href="/tags/B%E6%A0%91/">B树<sup>1</sup></a><a href="/tags/B-%E6%A0%91/">B+树<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构<sup>1</sup></a><a href="/tags/%E6%A0%91/">树<sup>1</sup></a><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树<sup>1</sup></a><a href="/tags/%E8%AE%B8%E9%92%A7/">许钧<sup>1</sup></a><a href="/tags/%E6%AD%8C%E6%89%8B2024/">歌手2024<sup>37</sup></a><a href="/tags/Chante-Moore/">Chanté Moore<sup>2</sup></a><a href="/tags/%E9%BB%84%E5%AE%A3/">黄宣<sup>1</sup></a><a href="/tags/Faouzia/">Faouzia<sup>4</sup></a><a href="/tags/Lenka/">Lenka<sup>1</sup></a><a href="/tags/%E5%BC%A0%E9%92%B0%E7%90%AA/">张钰琪<sup>1</sup></a><a href="/tags/%E9%82%A3%E8%8B%B1/">那英<sup>9</sup></a><a href="/tags/%E5%B0%A4%E9%95%BF%E9%9D%96/">尤长靖<sup>2</sup></a><a href="/tags/%E5%AD%99%E6%A5%A0/">孙楠<sup>5</sup></a><a href="/tags/%E8%B0%AD%E7%BB%B4%E7%BB%B4/">谭维维<sup>3</sup></a><a href="/tags/%E5%B4%A9%E5%9D%8F%EF%BC%9A%E6%98%9F%E7%A9%B9%E9%93%81%E9%81%93/">崩坏：星穹铁道<sup>4</sup></a><a href="/tags/%E8%B5%A4%E7%BE%BD/">赤羽<sup>1</sup></a><a href="/tags/%E6%B1%AA%E8%8B%8F%E6%B3%B7/">汪苏泷<sup>4</sup></a><a href="/tags/%E5%A3%B0%E7%94%9F%E4%B8%8D%E6%81%AF%C2%B7%E5%AE%B6%E5%B9%B4%E5%8D%8E/">声生不息·家年华<sup>3</sup></a><a href="/tags/%E9%99%88%E6%A5%9A%E7%94%9F/">陈楚生<sup>3</sup></a><a href="/tags/%E9%99%88%E4%BA%A6%E6%B4%BA/">陈亦洺<sup>1</sup></a><a href="/tags/%E5%B0%9A%E8%BE%B0/">尚辰<sup>1</sup></a><a href="/tags/%E5%BF%98%E5%B7%9D%E9%A3%8E%E5%8D%8E%E5%BD%95/">忘川风华录<sup>2</sup></a><a href="/tags/%E4%B9%90%E6%AD%A3%E9%BE%99%E7%89%99/">乐正龙牙<sup>1</sup></a><a href="/tags/%E6%98%9F%E5%B0%98Infinity/">星尘Infinity<sup>4</sup></a><a href="/tags/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F/">明日方舟<sup>3</sup></a><a href="/tags/%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C/">祖娅纳惜<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%AD%90/">电子<sup>1</sup></a><a href="/tags/%E6%98%9F%E5%B0%98/">星尘<sup>6</sup></a><a href="/tags/%E5%BC%A0%E4%BF%A1%E5%93%B2/">张信哲<sup>2</sup></a><a href="/tags/%E9%93%B6%E4%B8%B4/">银临<sup>1</sup></a><a href="/tags/%E6%9D%8E%E5%B8%B8%E8%B6%85/">李常超<sup>1</sup></a><a href="/tags/%E5%B1%B1%E8%89%B2%E6%9C%89%E6%97%A0%E4%B8%AD/">山色有无中<sup>1</sup></a><a href="/tags/%E5%91%A8%E6%9D%B0%E4%BC%A6/">周杰伦<sup>1</sup></a><a href="/tags/%E9%BB%84%E9%9C%84%E9%9B%B2/">黄霄雲<sup>1</sup></a><a href="/tags/%E5%AE%B9%E7%A5%96%E5%84%BF/">容祖儿<sup>1</sup></a><a href="/tags/%E6%88%91%E6%98%AF%E6%AD%8C%E6%89%8B%C2%B7%E7%AC%AC%E5%9B%9B%E5%AD%A3/">我是歌手·第四季<sup>1</sup></a><a href="/tags/%E6%9D%8E%E5%85%8B%E5%8B%A4/">李克勤<sup>1</sup></a><a href="/tags/%E7%B2%A4%E8%AF%AD/">粤语<sup>2</sup></a><a href="/tags/%E9%BB%84%E4%B8%BD%E7%8E%B2/">黄丽玲<sup>1</sup></a><a href="/tags/G-E-M-%E9%82%93%E7%B4%AB%E6%A3%8B/">G.E.M.邓紫棋<sup>7</sup></a><a href="/tags/T-I-M-E/">T.I.M.E.<sup>4</sup></a><a href="/tags/%E6%97%B6%E5%85%89%E9%9F%B3%E4%B9%90%E4%BC%9A%C2%B7%E8%80%81%E5%8F%8B%E8%AE%B0/">时光音乐会·老友记<sup>5</sup></a><a href="/tags/%E5%BC%A0%E5%AD%A6%E5%8F%8B/">张学友<sup>1</sup></a><a href="/tags/%E6%9D%A8%E4%B8%9E%E7%90%B3/">杨丞琳<sup>1</sup></a><a href="/tags/%E6%B1%AA%E5%B3%B0/">汪峰<sup>1</sup></a><a href="/tags/%E6%9C%AA%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%B0%BF/">未定事件簿<sup>1</sup></a><a href="/tags/%E5%BC%A0%E8%BF%9C/">张远<sup>1</sup></a><a href="/tags/%E5%AD%99%E7%87%95%E5%A7%BF/">孙燕姿<sup>2</sup></a><a href="/tags/%E6%B5%B7%E6%9D%A5%E9%98%BF%E6%9C%A8/">海来阿木<sup>1</sup></a><a href="/tags/%E6%9B%B9%E6%9D%A8/">曹杨<sup>3</sup></a><a href="/tags/%E4%B8%8B%E4%B8%80%E6%88%98%E6%AD%8C%E6%89%8B/">下一战歌手<sup>3</sup></a><a href="/tags/Fine%E4%B9%90%E5%9B%A2/">Fine乐团<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<sup>4</sup></a><a href="/tags/DNS/">DNS<sup>1</sup></a><a href="/tags/MAC/">MAC<sup>1</sup></a><a href="/tags/Adam-Lambert/">Adam Lambert<sup>1</sup></a><a href="/tags/%E4%BA%9A%E5%BD%93%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9/">亚当·兰伯特<sup>1</sup></a><a href="/tags/Hayden/">Hayden<sup>1</sup></a><a href="/tags/%E6%9A%AE%E5%A4%9C/">暮夜<sup>1</sup></a><a href="/tags/ACE-Studio/">ACE Studio<sup>3</sup></a><a href="/tags/%E5%B0%9A%E9%9B%AF%E5%A9%95/">尚雯婕<sup>1</sup></a><a href="/tags/%E4%B8%9C%E6%96%B9%E6%A0%80%E5%AD%90/">东方栀子<sup>2</sup></a><a href="/tags/%E9%BB%84%E7%BB%AE%E7%8F%8A/">黄绮珊<sup>1</sup></a><a href="/tags/%E5%8D%8E%E6%99%A8%E5%AE%87/">华晨宇<sup>1</sup></a><a href="/tags/JUN/">JUN<sup>1</sup></a><a href="/tags/%E6%9E%97%E5%BF%86%E8%8E%B2/">林忆莲<sup>1</sup></a><a href="/tags/UTAU/">UTAU<sup>1</sup></a><a href="/tags/Sheena/">Sheena<sup>1</sup></a><a href="/tags/%E5%89%A7%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C/">剧好听的歌<sup>1</sup></a><a href="/tags/Syncthing/">Syncthing<sup>1</sup></a><a href="/tags/%E5%90%8C%E6%AD%A5/">同步<sup>1</sup></a><a href="/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/">支付宝<sup>1</sup></a><a href="/tags/Apifox/">Apifox<sup>2</sup></a><a href="/tags/%E5%B2%B8%E6%99%93/">岸晓<sup>1</sup></a><a href="/tags/%E5%8D%95%E4%BE%9D%E7%BA%AF/">单依纯<sup>2</sup></a><a href="/tags/%E9%BB%84%E5%AD%90%E5%BC%98%E5%87%A1/">黄子弘凡<sup>1</sup></a><a href="/tags/%E5%A2%A8%E6%B8%85%E5%BC%A6/">墨清弦<sup>1</sup></a><a href="/tags/%E6%AD%8C%E6%89%8B2025/">歌手2025<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">Rean's Blog</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">【Java】并发（一） | 进程 &amp; 线程</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>标签</span></a></li><li><a class="site-page child" href="/study/"><i class="solitude  st-gift-fill"></i><span>学习</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li><li><a class="site-page child" href="/essay/"><span>即刻短文</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude st-signal-tower-fill"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><i class="solitude st-dashboard-fill"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://npm.elemecdn.com/justlovesmile-photo/darkmodepicture1.jpg" alt="【Java】并发（一） | 进程 &amp; 线程"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/"><span class="tags-name tags-punctuation">Java</span></a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tags-name tags-punctuation">并发</span></a></div></div></div></div><h1 class="post-title">【Java】并发（一） | 进程 &amp; 线程</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-08-16 16:44:37"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-08-16T08:44:37.000Z">2024-08-16T08:44:37.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-11-13 11:37:13"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-11-13T03:37:13.568Z">2024-11-13T03:37:13.568Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon solitude st-word-fill" title="文章字数"></i><span class="word-count">11.3k</span><span class="post-meta-separator"></span><i class="post-meta-icon solitude st-clock-fill" title="阅读耗时"></i><span>40 min</span></span><a class="post-meta-pv" href="/p/74e1a37c/" title="文章热度"><i class="post-meta-icon solitude st-fire-fill"></i><span id="busuanzi_page_pv"><i class="solitude st-loading-line"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java-线程和操作系统的线程有啥区别？"><a href="#Java-线程和操作系统的线程有啥区别？" class="headerlink" title="Java 线程和操作系统的线程有啥区别？"></a>Java 线程和操作系统的线程有啥区别？</h2><p>JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。</p>
<p>在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p>
<p>我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：</p>
<ul>
<li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li>
<li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li>
</ul>
<p>顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</p>
<br>

<h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><p><strong>进程</strong>：<strong>是资源分配的基本单位</strong>，每个进程都有自己独立的内存空间（代码段、数据段、堆栈等），可以看作是一个正在运行的程序实例。进程之间是相互独立的。</p>
<p><strong>线程</strong>：<strong>是 CPU 调度的基本单位</strong>，属于进程，一个进程中可以包含多个线程。线程共享进程的内存空间和资源（如文件句柄、数据段），但每个线程有自己独立的栈和寄存器。</p>
<p><strong>其它区别</strong>：</p>
<ul>
<li><strong>资源消耗不同</strong>：进程时需要为其分配独立的内存空间和系统资源，创建和切换进程的开销较大。线程间共享进程的资源，创建线程所需的开销较小，线程切换的开销也远小于进程切换。</li>
<li><strong>通信方式</strong>：因为各自独立的内存空间，进程间通信（IPC）较为复杂，需要使用管道、消息队列、共享内存、套接字等方式。同一进程内的线程共享内存空间，因此线程直接读写内存即可，但注意需要使用同步机制避免数据错误。</li>
</ul>
<p>从 JVM 角度说进程和线程之间的关系。</p>
<p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<br>

<h2 id="什么是协程？Java-支持协程吗？"><a href="#什么是协程？Java-支持协程吗？" class="headerlink" title="什么是协程？Java 支持协程吗？"></a>什么是协程？Java 支持协程吗？</h2><p>协程（Coroutine），是一个比线程轻量级的执行单位。尤其适合于高并发场景和异步编程。协程在某些语言中被称为绿色线程（Green Threads）。</p>
<p>协程是在程序层面的定义，它不属于操作系统的概念，你可以理解<strong>一个线程在执行中可切换执行不同的协程的任务</strong>，对 CPU 而言还是在运行同一个线程。</p>
<p>我们在程序层面切换不同的协程来执行任务，它<strong>不属于操作系统调用，不涉及系统上下文的切换</strong>，所以它的性能相比线程切换会更高。</p>
<p>协程暂停执行后会保存当前的状态，当协程恢复执行时，可以从之前保存的状态开始执行，也就是程序层面来进行协程的调度管理。</p>
<p>像 Java 之前也是有协程的，但是后面废除了，好像是因为难度比较高，但是经过不断地迭代，在 Java21 又引入了虚拟线程，它是用户线程，和其他语言区别在于，它的实现是 JVM 级别，而不是 Java 语言级别。</p>
<p>典型的像 Go 是语言级别支持协程的。</p>
<p>综上，我们要知晓协程是程序调度的基本单位。线程可以包含多个协程，协程可以在单个线程中运行，当然也可以在多个线程之间共享。</p>
<p>总结特征：</p>
<ul>
<li>协程的切换是由<strong>程序显式控制</strong>的，而不是由操作系统调度。</li>
<li>协程的开销非常小，比线程更轻量，因为它们不需要操作系统内核的干预。</li>
<li>协程之间的切换是<strong>非抢占式的</strong>，也就是说，协程只有在显式调用挂起操作时才会切换。</li>
</ul>
<p>协程优点：</p>
<ul>
<li>由于不需要内核的参与，协程切换的开销非常低，可以显著提高程序的性能。</li>
<li>协程通过协作式调度避免了许多传统多线程编程中的复杂问题，如锁和竞态条件。</li>
<li>协程更容易实现大量并发操作，因为它们消耗的资源（如内存和 CPU）更少。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>协程非常适合处理大量 I&#x2F;O 操作（如网络请求、文件读写等），因为它们可以在等待 I&#x2F;O 完成时释放 CPU 资源。</p>
<p>协程非常适合高并发场景，例如可以使用协程来处理大量并发连接，以提高吞吐量和响应时间。</p>
<h3 id="关联协程库和框架"><a href="#关联协程库和框架" class="headerlink" title="关联协程库和框架"></a>关联协程库和框架</h3><p>除了 Go 语言的 goroutine，还有许多其他语言和框架支持协程，例如：</p>
<ul>
<li>Python 的 asyncio</li>
<li>Kotlin 的 协程</li>
<li><strong>JavaScript 的 async&#x2F;await</strong></li>
<li>C# 的 async&#x2F;await</li>
</ul>
<br>

<h2 id="Java-线程的生命周期和状态"><a href="#Java-线程的生命周期和状态" class="headerlink" title="Java 线程的生命周期和状态"></a>Java 线程的生命周期和状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li>BLOCKED：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，需要被显式唤醒才能继续执行。</li>
<li>TIME_WAITING：超时等待状态，线程进入等待状态，但指定了等待时间，超时后会被唤醒。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p>Java 线程状态变迁图(图源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</a>)：</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/640.png" alt="Java 线程状态变迁图"></p>
<ul>
<li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>
<li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li>
<li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li>
</ul>
<br>

<h2 id="Java-中如何创建多线程？"><a href="#Java-中如何创建多线程？" class="headerlink" title="Java 中如何创建多线程？"></a>Java 中如何创建多线程？</h2><p>常见有以下五种方式创建使用多线程：</p>
<p>1）<strong>实现 <code>Runnable</code> 接口</strong>：</p>
<ul>
<li>实现 <code>Runnable</code> 接口的 <code>run()</code> 方法，使用 <code>Thread</code> 类的构造函数传入 <code>Runnable</code> 对象，调用 <code>start()</code> 方法启动线程。</li>
<li>例子：<code>Thread thread = new Thread(new MyRunnable()); thread.start();</code></li>
</ul>
<p>2）<strong>继承 <code>Thread</code> 类</strong>：</p>
<ul>
<li>继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，直接创建 <code>Thread</code> 子类对象并调用 <code>start()</code> 方法启动线程。</li>
<li>例子：<code>MyThread thread = new MyThread(); thread.start();</code></li>
</ul>
<p>3）**使用 <code>Callable</code> 和 <code>FutureTask</code>**：</p>
<ul>
<li>实现 <code>Callable</code> 接口的 <code>call()</code> 方法，使用 <code>FutureTask</code> 包装 <code>Callable</code> 对象，再通过 <code>Thread</code> 启动。</li>
<li>例子：<code>FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new MyCallable()); Thread thread = new Thread(task); thread.start();</code></li>
</ul>
<p>4）<strong>使用线程池（<code>ExecutorService</code>）</strong>：</p>
<ul>
<li>通过 <code>ExecutorService</code> 提交 <code>Runnable</code> 或 <code>Callable</code> 任务，不直接创建和管理线程，适合管理大量并发任务。</li>
<li>例子：<code>ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(new MyRunnable());</code></li>
</ul>
<p>5）<strong>CompletableFuture（本质也是线程池，默认 forkjoinpool）</strong>：</p>
<ul>
<li>Java 8 引入的功能，非常方便地进行异步任务调用，且通过 <code>thenApply</code>、<code>thenAccept</code> 等方法可以轻松处理异步任务之间的依赖关系。</li>
<li><code>CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;&#125;);</code></li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>1）**<code>Runnable</code> vs <code>Callable</code>**：</p>
<ul>
<li><code>Runnable</code> 的 <code>run()</code> 方法不返回结果，不能抛出检查异常；<code>Callable</code> 的 <code>call()</code> 方法可以返回结果，并允许抛出检查异常。使用 <code>Callable</code> 更适合需要返回结果或处理异常的并发任务。</li>
</ul>
<h2 id="什么是-Java-的-CompletableFuture？"><a href="#什么是-Java-的-CompletableFuture？" class="headerlink" title="什么是 Java 的 CompletableFuture？"></a>什么是 Java 的 CompletableFuture？</h2><p>实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。举个例子：用户请求获取订单信息，可能需要同时获取用户信息、商品详情、物流信息、商品推荐等数据。</p>
<p>如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 <strong>无前后顺序关联</strong> 的，可以 <strong>并行执行</strong> ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。对于存在前后调用顺序关系的任务，可以进行任务编排。</p>
<p>对于 Java 程序来说，Java 8 才被引入的 <code>CompletableFuture</code> 可以帮助我们来做多个任务的编排，功能非常强大。</p>
<h3 id="Future-是什么？"><a href="#Future-是什么？" class="headerlink" title="Future 是什么？"></a>Future 是什么？</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li>判断任务是否已经执行完成;</li>
<li>获取任务执行结果。</li>
</ul>
<p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p>
<p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>
<p>CompletableFuture 的核心特性如下：</p>
<p>1）异步执行：通过 runAsync 和 supplyAsync 方法，可以异步地执行任务。</p>
<p>2）任务完成回调：使用 thenApply、thenAccept、thenRun 等方法，可以在任务完成后执行回调。</p>
<p>3）任务组合：可以将多个 CompletableFuture 组合在一起，通过 thenCombine、thenCompose 等方法，处理多个异步任务之间的依赖关系。</p>
<p>4）异常处理：提供了 exceptionally、handle 等方法，可以在异步任务发生异常时进行处理。</p>
<p>5）并行处理：可以通过 allOf 和 anyOf 方法，并行地执行多个异步任务，并在所有任务完成或任意一个任务完成时执行回调。</p>
<h3 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p>
<ul>
<li><code>thenApply()</code></li>
<li><code>thenAccept()</code></li>
<li><code>thenRun()</code></li>
<li><code>whenComplete()</code></li>
</ul>
<p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thenApply()</code> 方法使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p>你还可以进行 <strong>流式调用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p>
<h2 id="Java-中线程之间如何进行通信？"><a href="#Java-中线程之间如何进行通信？" class="headerlink" title="Java 中线程之间如何进行通信？"></a>Java 中线程之间如何进行通信？</h2><p>线程之间的通信（Inter-Thread Communication, ITC）主要依赖于<strong>共享内存</strong>。由于线程共享同一个进程的内存空间，因此可以直接通过共享变量进行通信。</p>
<p>常见的线程通信方式包括：</p>
<p>1）共享变量：</p>
<ul>
<li>线程可以通过访问共享内存变量来交换信息（需要注意<strong>同步问题</strong>，防止数据竞争和不一致）。</li>
<li>共享的也可以是文件，例如写入同一个文件来进行通信。</li>
</ul>
<p>2）同步机制：</p>
<ul>
<li>synchronized：Java 中的同步关键字，用于确保同一时刻只有一个线程可以访问共享资源，利用 Object 类提供的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>实现线程之间的等待&#x2F;通知机制</li>
<li>ReentrantLock：配合 Condition 提供了类似于 wait()、notify() 的等待&#x2F;通知机制</li>
<li>BlockingQueue：通过阻塞队列实现生产者-消费者模式</li>
<li>CountDownLatch：可以允许一个或多个线程等待，直到在其他线程中执行的一组操作完成</li>
<li>CyclicBarrier：可以让一组线程互相等待，直到到达某个公共屏障点</li>
<li>Volatile：Java 中的关键字，确保变量的可见性，防止指令重排</li>
<li>Semaphore：信号量，可以控制对特定资源的访问线程数</li>
</ul>
<p>补充 Object 中的方法说明：</p>
<ul>
<li>wait()：使线程进入等待状态，释放锁。</li>
<li>notify()：唤醒单个等待线程。</li>
<li>notifyAll()：唤醒所有等待线程。</li>
</ul>
<h2 id="Java-中父子线程之间如何传递数据？"><a href="#Java-中父子线程之间如何传递数据？" class="headerlink" title="Java 中父子线程之间如何传递数据？"></a>Java 中父子线程之间如何传递数据？</h2><p>这个问题其实问的是 InheritableThreadLocal 类。</p>
<p>InheritableThreadLocal 相比 ThreadLocal 它可以在父线程创建子线程的时候，将 InheritableThreadLocal 变量复制给子线程而实现数据的传递。</p>
<p>使用方式和 ThreadLocal 一致，无非就是将类替换成 InheritableThreadLocal 即可。</p>
<p>原理也不难，就是父线程在创建一个新的线程时，会将 InheritableThreadLocal 值传递给子线程。因为 InheritableThreadLocal 重写了 ThreadLocal 类的 createMap 方法，它会在创建新线程时将父线程的 ThreadLocalMap 复制到子线程中，从而使得子线程可以继承父线程的 InheritableThreadLocal 值。</p>
<h2 id="Java-中的线程安全是什么意思？"><a href="#Java-中的线程安全是什么意思？" class="headerlink" title="Java 中的线程安全是什么意思？"></a>Java 中的线程安全是什么意思？</h2><p>在Java中，线程安全指的是当多个线程并发访问、变更共享的资源（包括但不限制为共享的全局变量、数据存储），能够保证程序的执行结果是正确和可预测的。</p>
<p>如果不能有效处理多线程对资源的并发访问和变更，就可能会导致并发问题，出现数据不一致、数据竞争等问题。</p>
<h3 id="线程安全实现方式"><a href="#线程安全实现方式" class="headerlink" title="线程安全实现方式"></a>线程安全实现方式</h3><p>为了实现线程安全，可以采用以下常见的方法：</p>
<p>1）原子操作：使用不可分割的操作，避免并发修改数据问题，例如基于Java并发包下的原子实现类<code>AtomicInteger</code>进行数据叠加。</p>
<p>2）锁机制：使用 <code>synchronized</code> 关键字或者 <code>Lock</code> 接口及其实现类（如 <code>ReentrantLock</code> ）来实现同步控制。</p>
<p>3）线程安全的集合类：使用如 <code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 等，而不是非线程安全的集合类（如 <code>HashMap</code> 、 <code>ArrayList</code> ）。</p>
<p>4）并发控制：使用信号量、条件变量等控制线程的执行顺序，例如<code>Semaphore</code>、<code>CountDownLatch</code></p>
<h2 id="线程安全的集合有哪些？"><a href="#线程安全的集合有哪些？" class="headerlink" title="线程安全的集合有哪些？"></a>线程安全的集合有哪些？</h2><p><code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 等。</p>
<p>这里的详细一点：<a href="https://rean-schwarze.github.io/p/9b8bc45a/">【Java】集合（二） | Rean’s Blog (rean-schwarze.github.io)</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>JDK 1.7 <code>ConcurrentHashMap</code> 采用的是<strong>分段锁</strong>，即每个 <code>Segment</code> 是独立的，可以并发访问不同的 <code>Segment</code>，默认是 16 个 <code>Segment</code>，所以最多有 16 个线程可以并发执行。具体上锁的方式来源于 Segment，<strong>这个类实际继承了 ReentrantLock</strong>，因此它自身具备加锁的功能。</p>
<p>而 JDK 1.8 移除了 <code>Segment</code>，锁的粒度变得更加细化，锁只在链表或红黑树的<strong>节点级别</strong>上进行。通过 CAS 进行插入操作，只有在更新链表或红黑树时才使用 <code>synchronized</code>，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。</p>
<p>并且 JDK 1.7 <code>ConcurrentHashMap</code> 只使用了<strong>数组 + 链表</strong>的结构，而 JDK 1.8 和 <code>HashMap</code>一样引入了红黑树。</p>
<p>除此之外，还有扩容的区别以及 <code>size</code> 方法的计算也不一样。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它通过<strong>写时复制</strong>机制，即在每次修改（写入）操作时，复制原始数组的内容来保证线程安全，在副本上进行修改，然后将修改后的副本替换原来的数据结构。</p>
<p>由于写操作涉及复制整个数组，所以它的写操作开销较大，但读取操作则完全无锁。这使得 <code>CopyOnWriteArrayList</code> 适合于<strong>读多写少</strong>的场景。</p>
<h2 id="你了解-Java-线程池的原理吗？"><a href="#你了解-Java-线程池的原理吗？" class="headerlink" title="你了解 Java 线程池的原理吗？"></a>你了解 Java 线程池的原理吗？</h2><p>首先，简述线程池的作用：线程池是一种池化技术，用于预先创建并管理一组线程，避免频繁创建和销毁线程的开销，提高性能和响应速度。</p>
<p>然后，简单带一下线程池的几个关键的配置：核心线程数、最大线程数、空闲存活时间、工作队列、拒绝策略。</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240816171159.png"></p>
<p>最后，简述一下线程池的工作原理，按照下面的顺序来回答即可：</p>
<ol>
<li>默认情况下线程不会预创建，任务提交之后才会创建线程（不过设置 prestartAllCoreThreads 可以预创建核心线程）。</li>
<li>当核心线程满了之后不会新建线程，而是把任务堆积到工作队列中。</li>
<li>如果工作队列放不下了，然后才会新增线程，直至达到最大线程数。</li>
<li>如果工作队列满了，然后也已经达到最大线程数了，这时候来任务会执行拒绝策略。</li>
<li>如果线程空闲时间超过空闲存活时间，并且线程线程数是大于核心线程数的则会销毁线程，直到线程数等于核心线程数（设置 allowCoreThreadTimeOut 为 true 可以回收核心线程，默认为 false）。</li>
</ol>
<h3 id="如何设置-Java-线程池的线程数？"><a href="#如何设置-Java-线程池的线程数？" class="headerlink" title="如何设置 Java 线程池的线程数？"></a>如何设置 Java 线程池的线程数？</h3><p>线程池的线程数设置需要看具体执行的任务是什么类型的。</p>
<p>任务类型可以分：CPU 密集型任务和 I&#x2F;O 密集型任务。</p>
<h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p>CPU 密集型任务，就好比单纯的数学计算任务，它不会涉及 I&#x2F;O 操作，也就是说它可以充分利用 CPU 资源（如果涉及 I&#x2F;O，在进行 I&#x2F;O 的时候 CPU 是空闲的），不会因为 I&#x2F;O 操作被阻塞，因此不需要很多线程，线程多了上下文开销反而会变多。</p>
<p>根据经验法则，<code>CPU 密集型任务线程数 = CPU 核心数 + 1</code>。</p>
<h4 id="I-O-密集型任务"><a href="#I-O-密集型任务" class="headerlink" title="I&#x2F;O 密集型任务"></a>I&#x2F;O 密集型任务</h4><p>I&#x2F;O 密集型任务，有很多 I&#x2F;O 操作，例如文件的读取、数据库的读取等等，任务在读取这些数据的时候，是无法利用 CPU 的，对应的线程会被阻塞等待 I&#x2F;O 读取完成，因此如果任务比较多，就需要有更多的线程来执行任务，来提高等待 I&#x2F;O 时候的 CPU 利用率。</p>
<p>根据经验法则，<code>I/O 密集型任务线程数 = CPU 核心数 * 2</code> 或更多一些。</p>
<p><strong>注意，实际的最佳线程数还是需要具体应用压测分析的，以上公式仅供参考！</strong></p>
<h3 id="Java-线程池核心线程数在运行过程中能修改吗？如何修改？"><a href="#Java-线程池核心线程数在运行过程中能修改吗？如何修改？" class="headerlink" title="Java 线程池核心线程数在运行过程中能修改吗？如何修改？"></a>Java 线程池核心线程数在运行过程中能修改吗？如何修改？</h3><p><strong>可以动态修改的</strong>。Java 的 <code>ThreadPoolExecutor</code> 提供了动态调整核心线程数和最大线程数的方法。</p>
<p>1）<strong>修改核心线程数的方法</strong>：</p>
<ul>
<li>使用 <code>ThreadPoolExecutor.setCorePoolSize(int corePoolSize)</code> 方法可以动态修改核心线程数。<code>corePoolSize</code> 参数代表线程池中的核心线程数，当池中线程数量少于核心线程数时，会创建新的线程来处理任务。这个修改可以在线程池运行的过程中进行，立即生效。</li>
</ul>
<p>2）<strong>注意事项</strong>：</p>
<ul>
<li>核心线程数的修改不会中断现有任务，新的核心线程数会在新任务到来时生效。</li>
<li><code>setCorePoolSize()</code> 方法可以减少核心线程数，但如果当前线程池中的线程数量超过了新的核心线程数，多余的线程不会立即被销毁，直到这些线程空闲后被回收。</li>
</ul>
<h3 id="线程池监控与调整"><a href="#线程池监控与调整" class="headerlink" title="线程池监控与调整"></a><strong>线程池监控与调整</strong></h3><ul>
<li>在实际生产环境中，可以通过监控线程池的状态（如当前活跃线程数、队列长度等）来决定是否动态调整线程池大小。</li>
<li>可以使用 JMX（Java Management Extensions）来监控 <code>ThreadPoolExecutor</code>，结合指标来自动调整线程池大小以优化性能。</li>
</ul>
<h3 id="Java-线程池有哪些拒绝策略？"><a href="#Java-线程池有哪些拒绝策略？" class="headerlink" title="Java 线程池有哪些拒绝策略？"></a>Java 线程池有哪些拒绝策略？</h3><p>看源码，一共提供了 4 种（其中的 blockPolicy 是 hutool 的不算 ThreadPoolExecutor）：</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QpgJV87M_1e539a6e-6c95-4007-a6ab-8657feeea739.png"></p>
<ol>
<li>AbortPolicy，当任务队列满且没有线程空闲，此时添加任务会直接<strong>抛出 RejectedExecutionException 错误</strong>，这也是默认的拒绝策略。适用于必须通知调用者任务未能被执行的场景。</li>
<li>CallerRunsPolicy，当任务队列满且没有线程空闲，此时<strong>添加任务由即调用者线程执行</strong>。适用于希望通过减缓任务提交速度来稳定系统的场景。</li>
<li>DiscardOldestPolicy，当任务队列满且没有线程空闲，会<strong>删除最早的任务</strong>，然后重新提交当前任务。适用于希望丢弃最旧的任务以保证新的重要任务能够被处理的场景。</li>
<li>DiscardPolicy，<strong>直接丢弃</strong>当前提交的任务，不会执行任何操作，也不会抛出异常。适用于对部分任务丢弃没有影响的场景，或系统负载较高时不需要处理所有任务。</li>
</ol>
<h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>可以实现 RejectedExecutionHandler 接口来定义自定义的拒绝策略。例如，记录日志或将任务重新排队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected&quot;</span>);</span><br><span class="line">        <span class="comment">// 可以在这里实现日志记录或其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？"><a href="#Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？" class="headerlink" title="Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？"></a>Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</h2><p>默认情况下，线程池不会直接报告哪个线程发生了异常，但是可以采取以下几种方法：</p>
<p>1）**自定义线程池的 <code>ThreadFactory</code>**：</p>
<ul>
<li>通过自定义 <code>ThreadFactory</code>，为每个线程设置一个异常处理器（<code>UncaughtExceptionHandler</code>），在其中记录发生异常的线程信息。</li>
</ul>
<p>2）**使用 <code>Future</code>**：</p>
<ul>
<li>提交任务时使用 <code>submit()</code> 方法，而不是 <code>execute()</code>，这样可以通过 <code>Future</code> 对象捕获并检查任务的执行结果和异常。</li>
</ul>
<p>3）<strong>任务内部手动捕获异常并记录</strong>：</p>
<ul>
<li>在任务的 <code>run()</code> 方法内部，使用 <code>try-catch</code> 结构捕获异常，并记录或处理异常，同时记录线程信息。</li>
</ul>
<h2 id="什么是-Java-的-Timer？"><a href="#什么是-Java-的-Timer？" class="headerlink" title="什么是 Java 的 Timer？"></a>什么是 Java 的 Timer？</h2><p>Timer 可以实现延时任务，也可以实现周期性任务，它的核心就是一个优先队列和封装的执行任务的线程。</p>
<p>实现原理是：维持一个小顶堆，即最快需要执行的任务排在优先队列的第一个，根据堆的特性我们知道插入和删除的时间复杂度都是 O(logn)。</p>
<p>然后有个 TimerThread 线程不断地拿排着的第一个任务的执行时间和当前时间做对比。</p>
<p>如果时间到了先看看这个任务是不是周期性执行的任务，如果是则修改当前任务时间为下次执行的时间，如果不是周期性任务则将任务从优先队列中移除。最后执行任务。如果时间还未到则调用 <code>wait()</code> 等待。</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/TrqE6H13_f1c9ec68-db02-4cf1-98b5-785fbf526725.png" alt="img"></p>
<p>可以看出 Timer 实际就是根据任务的执行时间维护了一个优先队列，并且起了一个线程不断地拉取任务执行。</p>
<p>有什么弊端呢？</p>
<p>首先优先队列的插入和删除的时间复杂度是O(logn)，当数据量大的时候，频繁的入堆出堆性能有待考虑。</p>
<p>并且是单线程执行，那么如果一个任务执行的时间过久则会影响下一个任务的执行时间(当然你任务的run要是异步执行也行)。</p>
<p>并且从代码可以看到对异常没有做什么处理，那么一个任务出错的时候会导致之后的任务都无法执行。</p>
<h2 id="Java-并发库中提供了哪些线程池实现？它们有什么区别？"><a href="#Java-并发库中提供了哪些线程池实现？它们有什么区别？" class="headerlink" title="Java 并发库中提供了哪些线程池实现？它们有什么区别？"></a>Java 并发库中提供了哪些线程池实现？它们有什么区别？</h2><p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p>
<ul>
<li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>这个线程池实现特点是<strong>核心线程数和最大线程数是一致的</strong>，然后 keepAliveTime 的时间是 0 ，队列是无界队列。</p>
<p>按照这几个设定可以得知它任务线程数是固定，如其名 Fixed。</p>
<p>然后可能出现 OOM 的现象，因为队列是无界的，所以任务可能挤爆内存。</p>
<p>它的特性就是<strong>我就固定出这么多线程，多余的任务就排队，就算队伍排爆了我也不管</strong>。</p>
<p>因此不建议用这个方式来创建线程池，仅用于提交相对稳定且数量确定的任务场景。</p>
<h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>这个实现 JDK8 才有，从代码可以看到返回的就是 ForkJoinPool，我们 JDK8 用的并行流就是这个线程池。</p>
<p>比如 <code>users.parallelStream().filter(...).sum();</code> 用的就是 ForkJoinPool 。</p>
<p>线程数会参照当前服务器可用的处理核心数，并行数是核心数-1。</p>
<p>这个线程池的特性从名字就可以看出 Stealing，<strong>会窃取任务</strong>。</p>
<p>每个线程都有自己的<strong>双端队列</strong>，当自己队列的任务处理完毕之后，会去<strong>别的线程的任务队列尾部拿任务来执行</strong>，加快任务的执行速率。</p>
<p>至于 ForkJoin 的话，就是<strong>分而治之</strong>，把大任务分解成一个个小任务，然后分配执行之后再总和结果。</p>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>一个线程池就一个线程，配备的也是无界队列。</p>
<p>它的特性就是能保证任务是按顺序执行的。</p>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>这个线程池<strong>核心线程数是 0，最大线程数看作无限大</strong>，且然后任务队列 SynchronousQueue 是没有存储空间的，每个插入操作必须等待一个删除操作。</p>
<p>简单理解就是<strong>来个任务就必须找个线程接着</strong>，不然就阻塞了。</p>
<p>cached 意思就是会缓存之前执行过的线程，缓存时间是 60 秒，这个时候如果有任务进来就可以用之前的线程来执行。</p>
<p>所以它<strong>适合用在短时间内有大量短任务的场景</strong>。如果暂无可用线程，那么来个任务就会新启一个线程去执行这个任务，快速响应任务。</p>
<p>但是如果任务的时间很长，那存在的线程就很多，上下文切换就很频繁，切换的消耗就很明显，并且存在太多线程在内存中，也有 OOM 的风险。</p>
<h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>用于需要定时或周期性执行任务的场景，底层使用 DelayedWorkQueue 实现延时任务。</p>
<h2 id="Java-中的-DelayQueue-和-ScheduledThreadPool-有什么区别？"><a href="#Java-中的-DelayQueue-和-ScheduledThreadPool-有什么区别？" class="headerlink" title="Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？"></a>Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？</h2><p>DelayQueue 是一个阻塞队列，而 ScheduledThreadPool 是线程池，不过内部核心原理都是差不多的。</p>
<p>DelayQueue 是利用优先队列存储元素，当从队列中获取任务的时候，如果最老的任务已经到了执行时间，可以从队列中出队一个任务，反之可以获得 null 或者阻塞等待任务到时。</p>
<p>ScheduledThreadPool 内部也使用的一个优先队列 DelayedWorkQueue 且可以内部多线程执行任务，支持定时执行的任务，即每隔一段时间执行一次的任务。</p>
<h2 id="如何在-Java-中控制多个线程的执行顺序？"><a href="#如何在-Java-中控制多个线程的执行顺序？" class="headerlink" title="如何在 Java 中控制多个线程的执行顺序？"></a>如何在 Java 中控制多个线程的执行顺序？</h2><p>1）CompletableFuture，它内部有 thenRun 的方法</p>
<p>2）synchronized + wait()&#x2F;notify() ，通过对象锁和线程间通信机制来控制线程的执行顺序。</p>
<p>3）ReentrantLock + condition。</p>
<p>4）Thread 类的 join()，通过调用这个方法，可以使一个线程等待另一个线程执行完毕后再继续执行。</p>
<p>5）CountDownLatch，使一个或多个线程等待其他线程完成各自工作后再继续执行。</p>
<p>6）CyclicBarrier，使多个线程互相等待，直到所有线程都到达某个共同点后再继续执行。</p>
<p>7）Semaphore，控制线程的执行顺序，适用于需要限制同时访问资源的线程数量的场景。</p>
<p>8）线程池，内部仅设置一个线程来执行任务，按序的将任务提交到线程池中就可以了。</p>
<h2 id="为什么在-Java-中需要使用-ThreadLocal？"><a href="#为什么在-Java-中需要使用-ThreadLocal？" class="headerlink" title="为什么在 Java 中需要使用 ThreadLocal？"></a>为什么在 Java 中需要使用 ThreadLocal？</h2><p>就是为了通过本地化资源来避免共享，避免了多线程竞争导致的锁等消耗。</p>
<p>这里需要强调一下，不是说任何东西都能直接通过避免共享来解决，因为有些时候就必须共享。</p>
<p>举个例子：当利用多线程同时累加一个变量的时候，此时就必须共享，因为一个线程的对变量的修改需要影响要另个线程，不然累加的结果就不对了。</p>
<p>再举个不需要共享的例子：比如现在每个线程需要判断当前请求的用户来进行权限判断，那这个用户信息其实就不需要共享，因为每个线程只需要管自己当前执行操作的用户信息，跟别的用户不需要有交集。</p>
<h2 id="Java-中的-ThreadLocal-是如何实现线程资源隔离的？"><a href="#Java-中的-ThreadLocal-是如何实现线程资源隔离的？" class="headerlink" title="Java 中的 ThreadLocal 是如何实现线程资源隔离的？"></a>Java 中的 ThreadLocal 是如何实现线程资源隔离的？</h2><p><strong>需要在每个线程的本地都存一份值</strong>，说白了就是每个线程需要有个变量，来存储这些需要本地化资源的值，并且值有可能有多个，所以怎么弄呢？</p>
<p>在线程对象内部搞个 map，把 ThreadLocal 对象自身作为 key，把它的值作为 map 的值。</p>
<p>这样每个线程可以利用同一个对象作为 key ，去各自的 map 中找到对应的值。</p>
<p>这不就完美了嘛！比如我现在有 3 个 ThreadLocal 对象，2 个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal1 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;Integer&gt; threadLocal2 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;Integer&gt; threadLocal3 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>那此时 ThreadLocal 对象和线程的关系如下图所示：</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f32303232303132333136353032302e706e67.png"></p>
<p>这样一来就满足了本地化资源的需求，每个线程维护自己的变量，互不干扰，实现了变量的线程隔离，同时也满足存储多个本地变量的需求，完美！</p>
<h2 id="为什么在-Java-中使用-ThreadLocal-时需要用弱引用来防止内存泄漏？"><a href="#为什么在-Java-中使用-ThreadLocal-时需要用弱引用来防止内存泄漏？" class="headerlink" title="为什么在 Java 中使用 ThreadLocal 时需要用弱引用来防止内存泄漏？"></a>为什么在 Java 中使用 ThreadLocal 时需要用弱引用来防止内存泄漏？</h2><p>我们知道，如果一个对象没有强引用，只有弱引用的话，这个对象是活不过一次 GC 的，所以这样的设计就是为了让当外部没有对 ThreadLocal 对象有强引用的时候，可以将 ThreadLocal 对象给清理掉。</p>
<p>那为什么要这样设计呢？</p>
<p>假设 Entry 对 key 的引用是强引用，那么来看一下这个引用链：</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240816220605.png"></p>
<p>从这条引用链可以得知，如果线程一直在，那么相关的 ThreadLocal 对象肯定会一直在，因为它一直被强引用着。</p>
<p>看到这里，可能有人会说那线程被回收之后就好了呀。</p>
<p>重点来了！线程在我们应用中，常常是以线程池的方式来使用的，比如 Tomcat 的线程池处理了一堆请求，而线程池中的线程一般是不会被清理掉的，所以这个引用链就会一直在，那么 ThreadLocal 对象即使没有用了，也会随着线程的存在，而一直存在着！</p>
<p>所以这条引用链需要弱化一下，而能操作的只有 Entry 和 key 之间的引用，所以它们之间用弱引用来实现。</p>
<p>与之对应的还有一个条引用链，结合着上面的线程引用链都画出来：</p>
<p><img src= "/img/spin.svg" data-lazy-src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f32303232303132333136353134362e706e67.png"></p>
<p>另一条引用链就是栈上的 ThreadLocal 引用指向堆中的 ThreadLocal 对象，这个引用是强引用。</p>
<p>如果有这条强引用存在，那说明此时的 ThreadLocal 是有用的，此时如果发生 GC 则 ThreadLocal 对象不会被清除，因为有个强引用存在。</p>
<p>当随着方法的执行完毕，相应的栈帧也出栈了，此时这条强引用链就没了，如果没有别的栈有对 ThreadLocal 对象的引用，那么说明 ThreadLocal 对象无法再被访问到(定义成静态变量的另说)。</p>
<p>那此时 ThreadLocal 只存在与 Entry 之间的弱引用，那此时发生 GC 它就可以被清除了，因为它无法被外部使用了，那就等于没用了，是个垃圾，应该被处理来节省空间。</p>
<p>至此，想必你已经明白为什么 Entry 和 key 之间要设计为弱引用，就是因为<strong>平日线程的使用方式基本上都是线程池</strong>，所以<strong>线程的生命周期就很长</strong>，可能从你部署上线后一直存在，<strong>而 ThreadLocal 对象的生命周期可能没这么长</strong>。</p>
<p>所以为了能让已经没用 ThreadLocal 对象得以回收，所以 Entry 和 key 要设计成弱引用，不然 Entry 和 key是强引用的话，ThreadLocal 对象就会一直在内存中存在。</p>
<p>但是这样设计就可能产生内存泄漏。</p>
<p>那什么叫内存泄漏？就是指：程序中已经无用的内存无法被释放，造成系统内存的浪费。</p>
<p>当 Entry 中的 key 即 ThreadLocal 对象被回收了之后，会发生 Entry 中 key 为 null 的情况，其实这个 Entry 就已经没用了，但是又无法被回收，因为有 Thread-&gt;ThreadLocalMap -&gt;Entry 这条强引用在，这样没用的内存无法被回收就是内存泄露。</p>
<p>那既然会有内存泄漏还这样实现？</p>
<p>这里就要填一填上面的坑了，也就是涉及到的关于 expungeStaleEntry即清理过期的 Entry 的操作。</p>
<p>设计者当然知道会出现这种情况，所以在多个地方都做了清理无用 Entry ，即 key 已经被回收的 Entry 的操作。</p>
<p>比如通过 key 查找 Entry 的时候，如果下标无法直接命中，那么就会向后遍历数组，此时遇到 key 为 null 的 Entry 就会清理掉。</p>
<h3 id="如果将-value-也设置为弱引用，是否可以防止内存泄漏？"><a href="#如果将-value-也设置为弱引用，是否可以防止内存泄漏？" class="headerlink" title="如果将 value 也设置为弱引用，是否可以防止内存泄漏？"></a>如果将 value 也设置为弱引用，是否可以防止内存泄漏？</h3><p>答案肯定是可以的。value 一般都是局部变量赋值，栈帧出栈后，局部变量的强引用没了，如果 Entry 对其是弱引用，那么发生一次 gc 后 value 就被回收了，肯定没内存泄漏问题。</p>
<p>但是一次 gc 就没了，等用到的时候不就找不到 value 了？<strong>所以 value 不能被设置为弱引用</strong>。</p>
<h2 id="Java-中使用-ThreadLocal-的最佳实践是什么？"><a href="#Java-中使用-ThreadLocal-的最佳实践是什么？" class="headerlink" title="Java 中使用 ThreadLocal 的最佳实践是什么？"></a>Java 中使用 ThreadLocal 的最佳实践是什么？</h2><p>最佳实践是用完了之后，调用一下 remove 方法，手工把 Entry 清理掉，这样就不会发生内存泄漏了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> yesDosth &#123;</span><br><span class="line">	threadlocal.set(xxx);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do sth</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		threadlocal.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是使用 Threadlocal 的一个正确姿势啦，即不需要的时候，显示的 remove 掉。</p>
<p>当然，如果不是线程池使用方式的话，其实不用关系内存泄漏，反正线程执行完了就都回收了，但是一般我们都是使用线程池的，可能只是你没感觉到。</p>
<p>比如你用了 tomcat ，其实请求的执行用的就是 tomcat 的线程池，这就是隐式使用。</p>
<p>还有一个问题，关于 withInitial 也就是初始化值的方法。</p>
<p>由于类似 tomcat 这种隐式线程池的存在，即线程第一次调用执行 Threadlocal 之后，如果没有显示调用 remove 方法，则这个 Entry 还是存在的，那么下次这个线程再执行任务的时候，不会再调用 withInitial 方法，也就是说会拿到上一次执行的值。</p>
<p><strong>但是你以为执行任务的是新线程，会初始化值，然而它是线程池里面的老线程，这就和预期不一致了，所以这里需要注意。</strong></p>
<h2 id="ThreadLocal-的缺点？"><a href="#ThreadLocal-的缺点？" class="headerlink" title="ThreadLocal 的缺点？"></a>ThreadLocal 的缺点？</h2><p>ThreadLocal 的一个缺点：hash 冲突用的是<strong>线性探测法</strong>，效率低。</p>
<p>还有一个缺点是 ThreadLocal 使用了 WeakReference 以保证资源可以被释放，但是这可能会产生一些 Etnry 的 key 为 null，即无用的 Entry 存在。</p>
<p>所以调用 ThreadLocal 的 get 或 set 方法时，会主动清理无用的 Entry，减轻内存泄漏的发生。</p>
<p>还有一个就是内存泄漏的问题了，当然这个问题只存在于用线程池使用的时候，并且上面也提到了 get 和 set 的时候也能清理一些无用的 Key，所以没有那么的夸张，只要记得用完后调用 ThreadLocal#remove 就不会有内存泄漏的问题了。</p>
<h2 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h2><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li>
</ul>
<h2 id="Java-中-Thread-sleep-0-的作用是什么？"><a href="#Java-中-Thread-sleep-0-的作用是什么？" class="headerlink" title="Java 中 Thread.sleep(0) 的作用是什么？"></a>Java 中 Thread.sleep(0) 的作用是什么？</h2><p>看起来 Thread.sleep(0) 很奇怪，让线程睡眠 0 毫秒？那不是等于没睡眠吗？</p>
<p>是的，确实没有睡眠，但是调用了 Thread.sleep(0) 当前的线程会暂时出让 CPU ，这使得 CPU 的资源短暂的空闲出来别的线程有机会得到 CPU 资源。</p>
<p>所以，在一些大循环场景，如果害怕这段逻辑一直占用 CPU 资源，则可以调用 Thread.sleep(0) 让别的线程有机会使用 CPU。</p>
<p>实际上 Thread.yield() 这个命令也可以让当前线程主动放弃 CPU 使用权，使得其他线程有机会使用 CPU。</p>
<h2 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h2><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">Java并发常见面试题总结（上） | JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://interview-points.readthedocs.io/en/latest/operating-system.html#id33">操作系统 — 八股文 (interview-points.readthedocs.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">Java并发常见面试题总结（中） | JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://interview-points.readthedocs.io/en/latest/java-basic-and-jvm.html#volatile">Java 与 JVM — 八股文 (interview-points.readthedocs.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/4_process/process_base.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src= "/img/spin.svg" data-lazy-src="/img/avatar.jpg"></a><div class="post-copyright__author_name">Rean's Blog</div><div class="post-copyright__author_desc">Enjoy technology and music</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">Rean's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/"><span class="tags-punctuation"></span>Java<span class="tagsPageCount">18</span></a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tags-punctuation"></span>并发<span class="tagsPageCount">4</span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/27705e17/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【无参配布】思华年【忘川风华录·李商隐】</div></div></a></div><div class="next-post pull-right"><a href="/p/b5223f80/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Halo 博客配置</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="solitude st-star-smile-fill"></i><span>喜欢这篇的人也看了</span><div class="relatedPosts-link"><a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a></div></div><div class="relatedPosts-list"><div><a href="/p/e6628f8e/" title="【Java】并发（三） | JMM"><img class="cover" src= "/img/spin.svg" data-lazy-src="https://npm.elemecdn.com/justlovesmile-photo/cover6.JPG" alt="cover"><div class="content is-center"><div class="title">【Java】并发（三） | JMM</div></div></a></div><div><a href="/p/4131eeff/" title="【Java】并发（二） | 锁"><img class="cover" src= "/img/spin.svg" data-lazy-src="https://npm.elemecdn.com/justlovesmile-photo/235335-1549900415dcc9.jpg" alt="cover"><div class="content is-center"><div class="title">【Java】并发（二） | 锁</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/spin.svg" data-lazy-src="/img/avatar.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src= "/img/spin.svg" data-lazy-src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对知识海洋<b>探索历程</b>，随机掉落<b>无参配布</b>以及<b>翻调</b>（主要是音综类，在B站因为版权基本过不了审（。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Rean</div><div class="author-info__desc">Enjoy technology and music</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/Rean-Schwarze" title="Github"><i class="solitude  st-github-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/6531436" title="Bilibili"><i class="solitude  st-bilibili-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 线程和操作系统的线程有啥区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">进程和线程的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-text">程序计数器为什么是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-text">虚拟机栈和本地方法栈为什么是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">一句话简单了解堆和方法区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9FJava-%E6%94%AF%E6%8C%81%E5%8D%8F%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">什么是协程？Java 支持协程吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">关联协程库和框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-text">Java 线程的生命周期和状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">Java 中如何创建多线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-CompletableFuture%EF%BC%9F"><span class="toc-text">什么是 Java 的 CompletableFuture？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Future 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompletableFuture"><span class="toc-text">CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">处理异步计算的结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-text">Java 中线程之间如何进行通信？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">Java 中父子线程之间如何传递数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">Java 中的线程安全是什么意思？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">线程安全实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">线程安全的集合有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 线程池的原理吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F"><span class="toc-text">如何设置 Java 线程池的线程数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-text">CPU 密集型任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-text">I&#x2F;O 密集型任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%83%BD%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-text">Java 线程池核心线程数在运行过程中能修改吗？如何修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E6%95%B4"><span class="toc-text">线程池监控与调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">Java 线程池有哪些拒绝策略？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-text">自定义拒绝策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E9%83%A8%E4%BB%BB%E5%8A%A1%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-Timer%EF%BC%9F"><span class="toc-text">什么是 Java 的 Timer？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%B9%B6%E5%8F%91%E5%BA%93%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 并发库中提供了哪些线程池实现？它们有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FixedThreadPool"><span class="toc-text">FixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkStealingPool"><span class="toc-text">WorkStealingPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleThreadExecutor"><span class="toc-text">SingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CachedThreadPool"><span class="toc-text">CachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPool"><span class="toc-text">ScheduledThreadPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-DelayQueue-%E5%92%8C-ScheduledThreadPool-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">如何在 Java 中控制多个线程的执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Java-%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-ThreadLocal%EF%BC%9F"><span class="toc-text">为什么在 Java 中需要使用 ThreadLocal？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-ThreadLocal-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 中的 ThreadLocal 是如何实现线程资源隔离的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-ThreadLocal-%E6%97%B6%E9%9C%80%E8%A6%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">为什么在 Java 中使用 ThreadLocal 时需要用弱引用来防止内存泄漏？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B0%86-value-%E4%B9%9F%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">如果将 value 也设置为弱引用，是否可以防止内存泄漏？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-ThreadLocal-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中使用 ThreadLocal 的最佳实践是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">ThreadLocal 的缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">sleep() 方法和 wait() 方法对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD-Thread-sleep-0-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 Thread.sleep(0) 的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD%EF%BC%9F"><span class="toc-text">为什么 wait() 方法不定义在 Thread 中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">可以直接调用 Thread 类的 run 方法吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/f2766b22/" title="【综述】LLM - Large Language Model"><img alt="【综述】LLM - Large Language Model" src= "/img/spin.svg" data-lazy-src="https://npm.elemecdn.com/justlovesmile-photo/221228-15574975489aa1.jpg"></a><div class="content"><a class="title" href="/p/f2766b22/" title="【综述】LLM - Large Language Model">【综述】LLM - Large Language Model</a><a class="article-recent_post_categories" href="/p/f2766b22/">学习</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/694e526e/" title="【Notes】LLM API+Agent+FastAPI+SSE+Docker"><img alt="【Notes】LLM API+Agent+FastAPI+SSE+Docker" src= "/img/spin.svg" data-lazy-src="https://npm.elemecdn.com/justlovesmile-photo/cover8.JPG"></a><div class="content"><a class="title" href="/p/694e526e/" title="【Notes】LLM API+Agent+FastAPI+SSE+Docker">【Notes】LLM API+Agent+FastAPI+SSE+Docker</a><a class="article-recent_post_categories" href="/p/694e526e/">学习</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/d2c104ef/" title="【星尘Infinity/未抒】逆光（Cover：周深/陈楚生）【Synthesizer V Cover】"><img alt="【星尘Infinity/未抒】逆光（Cover：周深/陈楚生）【Synthesizer V Cover】" src= "/img/spin.svg" data-lazy-src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/逆光_cover.png"></a><div class="content"><a class="title" href="/p/d2c104ef/" title="【星尘Infinity/未抒】逆光（Cover：周深/陈楚生）【Synthesizer V Cover】">【星尘Infinity/未抒】逆光（Cover：周深/陈楚生）【Synthesizer V Cover】</a><a class="article-recent_post_categories" href="/p/d2c104ef/">VOCALOID·UTAU</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/401d6e5a/" title="【永夜Minus】珠玉 (live)（Cover：单依纯）【歌手2025】【Synthesizer V Cover】"><img alt="【永夜Minus】珠玉 (live)（Cover：单依纯）【歌手2025】【Synthesizer V Cover】" src= "/img/spin.svg" data-lazy-src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/珠玉_cover.jpg"></a><div class="content"><a class="title" href="/p/401d6e5a/" title="【永夜Minus】珠玉 (live)（Cover：单依纯）【歌手2025】【Synthesizer V Cover】">【永夜Minus】珠玉 (live)（Cover：单依纯）【歌手2025】【Synthesizer V Cover】</a><a class="article-recent_post_categories" href="/p/401d6e5a/">VOCALOID·UTAU</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/197094e3/" title="【墨清弦AI】唯一（Cover：G.E.M.邓紫棋）【ACE Cover】"><img alt="【墨清弦AI】唯一（Cover：G.E.M.邓紫棋）【ACE Cover】" src= "/img/spin.svg" data-lazy-src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/唯一_cover.png"></a><div class="content"><a class="title" href="/p/197094e3/" title="【墨清弦AI】唯一（Cover：G.E.M.邓紫棋）【ACE Cover】">【墨清弦AI】唯一（Cover：G.E.M.邓紫棋）【ACE Cover】</a><a class="article-recent_post_categories" href="/p/197094e3/">VOCALOID·UTAU</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span class="solitude">Rean's Blog</span></div><div class="footer-bar-description">来自Rean's Blog - Enjoy technology and music的文章</div><a class="footer-bar-link" href="/">了解更多</a></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Rean-Schwarze" title="Github"><i class="solitude  st-github-line"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/6531436" title="Bilibili"><i class="solitude  st-bilibili-line"></i></a></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 - 2025 By&nbsp;<a class="footer-bar-link" href="/">Rean</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude st-arrow-left-line"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude st-arrow-right-line"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude st-restart-line"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude st-arrow-up-line"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude st-copy-fill"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude st-clipboard-fill"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude st-window-fill"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude st-link-line"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude st-copy-fill"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude st-download-cloud-fill"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude st-search-line"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="solitude st-play-fill"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="solitude st-skip-back-fill"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="solitude st-skip-forward-fill"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="solitude st-copy-fill"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-randomPost" onclick="toRandomPost()||rm.hideRightMenu()"><i class="solitude st-signal-tower-fill"></i><span>随机短文</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/categories/')||rm.hideRightMenu()"><i class="solitude st-checkbox-multiple-blank-fill"></i><span>全部分类</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/tags/')||rm.hideRightMenu()"><i class="solitude st-price-tag-fill"></i><span>全部标签</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span class="menu-darkmode-text">深色模式</span></div><div class="rightMenu-item" id="menu-translate"><i class="solitude st-panben-line"></i><span>轉為繁體</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=1.8.10"></script><script src="/js/main.js?v=1.8.10"></script><script src="/js/third_party/waterfall.min.js?v=1.8.10"></script><script src="https://cdn.staticfile.net/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.8.10"></script><script>dark()
</script><script src="/js/tw_cn.js?v=1.8.10"></script><script src="https://cdn.staticfile.net/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdn.staticfile.net/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdn.staticfile.net/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.staticfile.net/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="https://cdn.staticfile.net/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.staticfile.net/meting/2.0.1/Meting.min.js"></script><script>const coverColorConfig = {
    api: 'https://api.qjqq.cn/api/Imgcolor?img=',
    time: 43200000
}</script><script src="/js/covercolor/api.js?v=1.8.10"></script><script src="/js/music.js?v=1.8.10"></script><script src="https://cdn.staticfile.net/pace/1.2.4/pace.min.js"></script><script src="/js/right_menu.js?v=1.8.10"></script><div class="js-pjax"><script defer pjax src="https://cdn.staticfile.net/pearssauce-busuanzi/1.0.0/bsz.pure.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.8.10"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="421801417" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--efu-main)"></meting-js></div></body></html><script>const posts=["p/f2766b22/","p/694e526e/","p/d2c104ef/","p/401d6e5a/","p/197094e3/","p/867e546a/","p/9d906c2f/","p/8e8e2cc6/","p/2b6e13f/","p/e7845a78/","p/5871d67/","p/204d99f1/","p/b585efd0/","p/122902e7/","p/683f7c8e/","p/36b252a1/","p/bbd98f0d/","p/1b320550/","p/30cd73ca/","p/332adb42/","p/4f877c1e/","p/677c7789/","p/f7f0a5f3/","p/9b5a538c/","p/37360bc0/","p/bb996d5/","p/364ea8cc/","p/a027699d/","p/21cdaec5/","p/37c37880/","p/a02febe4/","p/d1ec0e4e/","p/25d2b878/","p/8324e4bc/","p/6021f67a/","p/305331f0/","p/66be4b4/","p/de2d10bc/","p/e6628f8e/","p/4131eeff/","p/27705e17/","p/74e1a37c/","p/b5223f80/","p/9b8bc45a/","p/c9cb7159/","p/82c942ab/","p/4c19fcc6/","p/27446c6a/","p/9f38852a/","p/2516f5f2/","p/b27c77b3/","p/7a3264f/","p/7beadfaa/","p/e1d9906f/","p/a440b512/","p/a46aa116/","p/fe8dd3bd/","p/51c99199/","p/91b418a/","p/421add40/","p/9d7a18c7/","p/26345198/","p/fa30e874/","p/dea9a817/","p/59203ba6/","p/e5616c72/","p/971e9859/","p/d7f6ccff/","p/1b2ec1c2/","p/a0d1cef9/","p/a58b6af0/","p/9381aa6d/","p/38b8becb/","p/d0a26095/","p/2b3bdada/","p/ba70636/","p/374630f5/","p/a964a243/","p/a06e9899/","p/ef9a99de/","p/108f7c52/","p/a91c1846/","p/413576cf/","p/9ee60c65/","p/e74db628/","p/888c8bf3/","p/477dbe08/","p/38e8a510/","p/dfb41864/","p/b0e3506b/","p/e17fd725/","p/e1fe458c/","p/636cfdea/","p/7b854cb7/","p/b3a61240/","p/64f43fb4/","p/800f9a11/","p/4a48b34c/","p/b3641215/","p/53bc1fc9/","p/fc02f9ee/","p/25b929f6/","p/dd30b42/","p/3aa261db/","p/fc078742/","p/22c9d1d0/","p/33fc02d2/","p/70335ae0/","p/f32ef110/","p/f756486c/","p/8dd4b91f/","p/a290d941/","p/61a8a4ef/","p/c2d0bb20/","p/9770d71c/","p/41bd2aed/","p/bfebe40b/","p/6b4006e6/","p/b5696360/","p/53ab7115/","p/e6fa9b9/","p/866abf45/","p/b718b92a/","p/d26f4c21/","p/bc5d6bbe/","p/5a18917b/","p/5f2b1e2f/","p/2532a2ee/","p/4337b2c0/","p/e042d029/","p/9b4a91e5/","p/9d8ce868/","p/a69f6a48/","p/f9b9edb2/","p/cbe55d0/","p/156c59d0/","p/d4d6f818/","p/2574cf15/","p/a0efc292/","p/ec2ecf28/","p/85f11265/","p/db95e6f5/","p/a8296e6d/","p/4cc89a71/","p/d0fe2d0f/","p/ffab2f6b/","p/95d9f91e/","p/7f869365/","p/5b246b1b/","p/a9c92fa9/","p/7d49fec0/","p/a9a25fcd/","p/43bb383e/","p/b9aeb4/","p/52eaf228/","p/4be90d2f/","p/ed500d41/","p/dcfbc8e5/","p/240e5e52/","p/18cda1b3/","p/66a6c396/","p/5f33341/","p/f9bef31e/","p/acac46b/","p/a4189438/","p/ae6b0147/","p/4e982f2d/","p/403e0cac/","p/495b9f0f/","p/8e966ab9/","p/f6e1007e/","p/6f562d19/","p/10eac329/","p/cc53cf58/","p/4f2beac6/","p/73e2aa1/","p/c677e75e/","p/3f13b766/","p/cc30f00/","p/807cab5e/","p/5b5991e4/","p/e941ffc/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>