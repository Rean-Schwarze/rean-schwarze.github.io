<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【墨清弦AI】唯一（Cover：G.E.M.邓紫棋）【ACE Cover】</title>
      <link href="/p/197094e3/"/>
      <url>/p/197094e3/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/唯一_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【墨清弦】唯一_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《唯一》</p><p>翻唱：墨清弦</p><p>扒谱：Rean__</p><p>调校：Rean__</p><p>混音：Rean__</p><br><p>日常被ACE气晕.jpg</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>词：潘云安</p><p>曲：潘云安</p><p>改编词曲：G.E.M. 邓紫棋</p><p>制作人：G.E.M. 邓紫棋&#x2F;T-Ma</p><p>编曲：G.E.M. 邓紫棋&#x2F;T-Ma</p><p>混音：Claudia Koh</p><p>母带：T-Ma</p><p>OP：更漂亮音乐工作室</p><p>SP：相信音乐国际股份有限公司</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>你真的懂唯一的定义</p><p>并不简单如呼吸</p><p>你真的希望你能厘清</p><p>若没交心怎么说明</p> <br><p>我真的爱你 句句不轻易</p><p>眼神中飘移</p><p>总是在关键时刻清楚洞悉</p><p>你的不坚定 配合我颠沛流离</p><p>死去中清醒 明白你背着我聪明</p> <br><p>那些我 想说的 没说的 话</p><p>有时我 怀疑呢 只是我 傻瓜</p><p>但如果真的爱 不会算计</p><p>爱是不嫉妒 不张狂 不求自己</p><p>无关你的回应 永不止息</p> <br><p>你知道</p><p>我真的爱你 没人能比拟</p><p>眼神没肯定</p><p>总是在关键时刻清楚洞悉</p><p>你的不坚定 配合我颠沛流离</p><p>死去中清醒 明白你背着我聪明</p> <br><p>我知道</p><p>爱本质无异 是因为人多得拥挤</p><p>你不想证明 证明我是你唯一</p><p>证明我是你唯一</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> 时光音乐会·老友记 </tag>
            
            <tag> ACE Studio </tag>
            
            <tag> 墨清弦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【永夜Minus/岸晓】终身孤独（Cover：单依纯/黄子弘凡）【AC059·25V吧调音赛】【Synthesizer V Cover】</title>
      <link href="/p/867e546a/"/>
      <url>/p/867e546a/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/终身孤独_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【永夜Minus、岸晓】终身孤独_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《终身孤独》</p><p>翻唱：永夜Minus、岸晓</p><p>和声：岸晓、翎婉、沨漪</p><p>扒谱：Rean__</p><p>调校：基本功天后亲传弟子</p><p>混音：Rean__</p><br><p>#我减一开口就找到声音的位置</p><p>#我减因不能暴力输出美美隐身</p><p>#岸晓真的好硬哦power都不用拉满的</p><p>感谢给我投票以及喜欢这个作品的每一位老师！</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV13Z1LYJEuW/">BV13Z1LYJEuW</a></p><p>词：叶青赛蓝</p><p>曲：叶青赛蓝</p><p>OP&#x2F;SP：北京千亩稻田文化传播有限公司</p><p>音乐总监：刘卓</p><p>音响总监：张小年</p><p>编曲：闫实</p><p>现场乐队：VBand</p><p>鼓：邓华龙</p><p>贝斯：杨琪</p><p>吉他：董珂铭&#x2F;王海洋</p><p>钢琴：傅一峥</p><p>键盘：孙维峰</p><p>Program：王禹茨</p><p>合音：关冰效&#x2F;石行&#x2F;邢晏侨</p><p>音频编辑：刘璇</p><p>混音：周天澈混音团队</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>敞开了心门</p><p>对魔鬼说请进</p><p>请它把我的怯懦恐惧</p><p>一并赶出门去</p><br><p>寸草不生的心</p><p>也曾绿草如茵</p><p>纯真死去那天</p><p>天空正万里无云</p><br><p>有一团黑色迷雾</p><p>在我的脑海漂浮</p><p>反正我也同样孤独</p><p>有什么理由将它驱逐</p><br><p>谁让我体无完肤</p><p>谁弃我于不顾</p><p>雪崩的时候没有一片雪无辜</p><p>我又该找谁倾诉</p><br><p>看着所爱之人</p><p>排着队离开身边</p><p>为何我越爱谁</p><p>越要选择恶语相对</p><br><p>将长在外的刺</p><p>根根倒插进自身</p><p>我拥抱我自己</p><p>感受这切肤之疼</p><br><p>有一团黑色迷雾</p><p>在我的脑海漂浮</p><p>反正我也同样孤独</p><p>有什么理由将它驱逐</p><br><p>谁让我体无完肤</p><p>谁弃我于不顾</p><p>雪崩的时候没有一片雪无辜</p><p>我又该找谁倾诉</p><br><p>不懂爱为何物</p><p>却对它趋之若鹜</p><p>任由妒火一寸寸燃过我皮肤</p><p>却无法止住</p><br><p>终有天心如槁木</p><p>才幡然醒悟</p><p>原来被判处终身孤独</p><p>才是对我最大宽恕</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐缘计划 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 永夜Minus </tag>
            
            <tag> 岸晓 </tag>
            
            <tag> 单依纯 </tag>
            
            <tag> 黄子弘凡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】【星尘Infinity】沉默的羔羊（Cover：周深）【AC025·25V吧调音赛】【Synthesizer V Cover】</title>
      <link href="/p/9d906c2f/"/>
      <url>/p/9d906c2f/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/沉默的羔羊_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【星尘Infinity】沉默的羔羊_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《沉默的羔羊》</p><p>翻唱：星尘Infinity</p><p>原唱：周深</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><br><p>#星尘女士在线挑战一口气唱10s共38个字</p><p>#星尘女士模仿周深吟唱</p><p>感谢给我投票的每一位老师！</p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接：<a href="https://pan.baidu.com/s/1r1KtR4zJyH-bLgq-kTT6eQ">https://pan.baidu.com/s/1r1KtR4zJyH-bLgq-kTT6eQ</a></p><p>提取码：qtpi</p><p>BPM：122</p><p>已灌词</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1P4421f7cV/">BV1P4421f7cV</a></p><p>词：芪静典</p><p>曲：于冬然</p><p>OP：昌禾文化</p><p>SP：北京千亩稻田文化传播有限公司</p><p>音乐总监：刘卓</p><p>音响总监：张小年</p><p>制作人：彭程&#x2F;周深</p><p>编曲：彭程</p><p>现场乐队：VBand</p><p>钢琴：傅一峥</p><p>键盘：孙维峰</p><p>吉他：董珂铭&#x2F;王海洋</p><p>鼓：邓华龙</p><p>贝斯：杨琪</p><p>合音：关晓林&#x2F;石行&#x2F;邢晏侨</p><p>和声：周深</p><p>PGM电脑工程：岳义</p><p>音频编辑：石行</p><p>混音：赵靖</p><p>音乐营销：昌禾文化</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>失落的雨飘向何处 一片迷雾</p><p>骄傲的花也会无助 凋零泥土</p><p>走向魔鬼的焚炉</p><p>再无归途 化为虚无</p><br><p>望着太阳恍恍惚惚 习惯孤独</p><p>多想拥抱简单幸福 结束痛苦</p><p>无声无泪的倾诉 为何命运</p><p>总是在 夜里才敢失声痛哭</p><br><p>贪 红了眼</p><p>一点点 碰碎崩塌瓦解</p><p>冷漠世界</p><p>凝望着深渊变成深渊</p><p>在人间 在风咆哮之前</p><p>游走在 善恶两面</p><br><p>沉默让人变成羔羊</p><p>躲在暗处不声张</p><p>溺爱让人变成恶狼</p><p>践踏在众生之上</p><p>鳄鱼没有忏悔泪光</p><p>谁也不能替他原谅</p><br><p>眼中无光世事无常</p><p>穷极一生在奔忙</p><p>扯下面具披上伪装</p><p>难道继续演高尚</p><p>多嚣张 刺破黑夜的光</p><p>终将会照亮这满纸荒唐</p><p>且等收场</p><br><p>贪 红了眼</p><p>一点点 破碎崩塌瓦解</p><p>冷漠世界</p><p>凝望着深渊变成深渊</p><p>在人间 在风咆哮之前</p><p>游走在 善恶两面</p><br><p>沉默让人变成羔羊</p><p>躲在暗处不声张</p><p>溺爱让人变成恶狼</p><p>践踏在众生之上</p><p>鳄鱼没有忏悔泪光</p><p>谁也不能替他原谅</p><br><p>眼中无光世事无常</p><p>穷极一生在奔忙</p><p>扯下面具披上伪装</p><p>难道继续演高尚</p><p>多嚣张 刺破黑夜的光</p><p>终将会照亮这满纸荒唐</p><br><p>眼中无光世事无常</p><p>穷极一生在奔忙</p><p>扯下面具披上伪装</p><p>难道继续演高尚</p><p>多嚣张 刺破黑夜的光</p><p>终将会照亮这满纸荒唐</p><p>且等收场</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
            <tag> 音乐缘计划 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 无参 </tag>
            
            <tag> 星尘Infinity </tag>
            
            <tag> 星尘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【岸晓】Do U（Cover：黄子弘凡）【音乐缘计划】【Synthesizer V Cover】</title>
      <link href="/p/8e8e2cc6/"/>
      <url>/p/8e8e2cc6/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Do+U_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%e3%80%90%e5%b2%b8%e6%99%93%e3%80%91Do+U_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Do U》</p><p>翻唱：岸晓</p><p>扒谱：Rean__</p><p>调校：Rean__</p><p>混音：Rean__</p><br><p>铲完了（擦汗.jpg）</p><p>隔壁哥哥情人节一个人在家跳绳，你可千万不能像他那样.jpg</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1Xw4m1r7uA">BV1Xw4m1r7uA</a></p><p>词：小麻M.Refre$H</p><p>曲：小麻M.Refre$H</p><p>OP：北京千亩稻田文化传播有限公司</p><p>SP：北京千亩稻田文化传播有限公司</p><p>音乐总监：刘卓</p><p>音响总监：张小年</p><p>制作人：刘卓</p><p>音乐统筹：郎梓朔</p><p>编曲：李思达&#x2F;郭力玮</p><p>和声编写：宇儿</p><p>和声：黄子弘凡&#x2F;宇儿</p><p>PGM电脑工程：岳义</p><p>音频编辑：石行</p><p>混音：黄可爱</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>我像是得了种怪病</p><p>瞳孔里全是你的影子</p><p>怎么会这样呢</p><p>我不知道</p><p>是我自己选的</p><p>说了一万遍还怀疑</p><p>怀疑我身不由己</p><p>如果可以</p><p>我想为你定格这四季</p><br><p>I promise I love U</p><p>Do U</p><p>我要让全世界知道我的顽固</p><p>所有人都会羡慕</p><p>I forever love U</p><p>Do U</p><p>注视你眼神 我不会闪躲</p><p>在月光下漫舞</p><br><p>望着你深邃的眼睛</p><p>期待你伸出你无名指</p><p>我期盼的那一刻</p><p>我的忐忑 都唱进这首歌</p><p>如果你说你还怀疑</p><p>怀疑我没有坚守的勇气</p><p>Baby I maybe</p><p>用尽我全部力气</p><p>对你说对你说 说我有多爱你</p><br><p>I promise I love U</p><p>Do U</p><p>我要让全世界知道我的顽固</p><p>所有人 都会羡慕</p><p>I forever love U</p><p>Do U</p><p>注视你眼神 我不会闪躲</p><p>在月光下漫舞</p><br><p>月光下只有你和我 越靠越近</p><p>好像全世界被按下了静音</p><p>心跳的声音</p><p>一拍一打像节奏的锤击</p><p>让我唱给你听</p><br><p>I promise I love U</p><p>Do U</p><p>我要让全世界知道我的顽固</p><p>所有人 都会羡慕</p><p>I forever love U</p><p>Do U</p><p>注视你眼神</p><p>我不会闪躲</p><p>在月光下漫舞</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐缘计划 </tag>
            
            <tag> SynthV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【星尘Infinity | 闽南语】嘉平歌（Cover：祖娅纳惜）【2025明日方舟新春会】【Synthesizer V Cover】</title>
      <link href="/p/2b6e13f/"/>
      <url>/p/2b6e13f/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/嘉平歌_cover.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【星尘Infinity】嘉平歌.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《嘉平歌》</p><p>翻唱：星尘Infinity</p><p>和声：星尘Infinity、JUN</p><p>扒谱：Rean__</p><p>调校：Rean__</p><p>混音：Rean__</p><br><p>极速滑铲，偶遇KB作曲以及10轨和声，拼尽全力勉强战胜，已老实</p><p>闽南语部分如果有误，欢迎评论区指正</p><br><p>“君荷锄来时稻香正浓，人间荫下做好梦。”</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1fqwre1E88/?spm_id_from=333.788.video.desc.click">BV1fqwre1E88</a></p><p>策划：杨颜</p><p>监制：千雨、杨颜</p><p>作曲：KBShinya</p><p>作词：冉语优</p><p>编曲：1AN孙毅然</p><p>演唱：祖娅纳惜</p><p>混音：祖娅纳惜&#x2F;圈太</p><p>和声：周弦&#x2F;祖娅纳惜</p><p>闽南语指导：薄荷Miint</p><p>吉他：大牛</p><p>映像：千雨</p><p>美术：乙配、目民子、阿尼鸭Any-a、风干咸鱼人、颜荼逆笙、Rasutohda</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>练时兮奉嘉殇</p><p>承天兮荣昌</p><p>师泽雨兮兰芳</p><p>归耕兮山莽</p><br><p>黑天白夜枯山寒水</p><p>肃风接严霜</p><p>鸟不敢餐兽不敢独往 茫茫</p><p>并肩朝暮行走陇野上</p><p>西风烈烈吹衣裳</p><p>周观天地 何以尽皆洪荒</p><br><p><font color="red">【闽南语】</font></p><p><font color="red">行伫云雷路</font></p><p><font color="red">近氨春水盈河</font></p><p><font color="red">衫带咧甘露</font></p><p><font color="red">乌暗暝欲落雨</font></p><p><font color="red">停佇厝头边</font></p><p><font color="red">青雀饮啄耕河沃澹草木</font></p><br><p><font color="red">记得持青禾</font></p><p><font color="red">四季落土成谷</font></p><p><font color="red">大地兮万象</font></p><p><font color="red">底时莽莽长满</font></p><p><font color="red">握琮</font></p><p><font color="red">借问何时春生 何时冬亡</font></p><br><p>雪丰万物荣</p><p>虫蛰百灾凶</p><p><font color="red">【闽南语】拢系天恩赏</font></p><p>灾候促良工</p><p>寒暑不误农</p><p><font color="red">【闽南语】这迹</font></p><p>坐山房田垄</p><p>看雨积云涌</p><p>君荷锄来时稻香正浓</p><p>人间荫下做好梦</p><br><p><font color="red">【闽南语】</font></p><p><font color="red">三更半夜路</font></p><p><font color="red">一点惊慌拢无</font></p><p><font color="red">若无邪煞毒</font></p><p><font color="red">怎晓故地纯净</font></p><p><font color="red">若无孽世岁</font></p><p><font color="red">哪按低头顾看人间辛苦</font></p><br><p><font color="red">问阮是啥物</font></p><p><font color="red">佮天同死同活</font></font></p><p><font color="red">同歹兮通顺</font></p><p><font color="red">是风亦是雨啊</font></p><p><font color="red">是山</font></p><p><font color="red">亦是河川是民</font></p><p><font color="red">亦是菩萨</font></p><br><p>天时来护身</p><p>调风雨纷纷</p><p><font color="red">【闽南语】邪魔无可近</font></p><p>舍我道法魂</p><p>救有情世人</p><p><font color="red">【闽南语】走揣</font></p><br><p>雷惊春雨动</p><p>夏去东无穷</p><p>休向天地万物追问我</p><p>我在天地万物中</p><br><p>啊~~~~~~</p><br><p><font color="red">【闽南语】</font></p><p><font color="red">青阳生长兮，劳耕织兮同行</font></p><p><font color="red">朱明烈腾兮，茂嘉树兮流影</font></p><p><font color="red">白藏发动兮，卜丰年兮知命</font></p><p><font color="red">玄英肃雍兮，反天地兮清明</font></p><br><p>天时来护身</p><p>调风雨纷纷</p><p><font color="red">【闽南语】邪魔无可近</font></p><p>舍我道法魂</p><p>救多难众生</p><p><font color="red">【闽南语】走揣</font></p><br><p>雷惊春雨动</p><p>夏去东无穷</p><p>休向天地万物追问我</p><p>我在天地万物中</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 古风 </tag>
            
            <tag> 星尘Infinity </tag>
            
            <tag> 明日方舟 </tag>
            
            <tag> 星尘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【岸晓】十二月的奇迹（Cover：曹杨）【Synthesizer V Cover】</title>
      <link href="/p/e7845a78/"/>
      <url>/p/e7845a78/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/十二月的奇迹_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【岸晓】十二月的奇迹（Cover：曹杨）_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《十二月的奇迹》</p><p>翻唱：岸晓</p><p>扒谱：Rean__</p><p>调校：Rean__</p><p>混音：Rean__</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 长友美知惠&#x2F;刘源</p><p>作曲 : Andreas Stone&#x2F;Ricky Hanley</p><p>原唱 : EXO</p><p>音乐总监 : 梁翘柏</p><p>音响总监 : 何飚</p><p>制作人 : 梁翘柏</p><p>改编编曲 : Johnny Yim</p><p>混音 : 林梦洋</p><p>乐队队长&#x2F;键盘 : 叶霖</p><p>键盘 : 白宇轩</p><p>钢琴 : Johnny Yim</p><p>吉他 : Tommy chan&#x2F;周奕绅Mike</p><p>贝斯 : 努而德柯</p><p>鼓 : 徐协伦</p><p>打击乐 : 王宏涛</p><p>长号 : Anthony</p><p>次中音萨克斯 &#x2F; 长笛 : Charlie</p><p>小号 : Ray</p><p>弦乐 : 靳海音®弦乐团</p><p>声乐指导&#x2F;和音 : 刘芳</p><p>和音 : 胡维纳&#x2F;林灵&#x2F;宋赫伦&#x2F;叶俊</p><p>PGM : 杨阳</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>我望眼欲穿 看我看不到的你</p><p>我侧耳倾听 听我听不到的你</p><p>看到曾看不见的画面</p><p>听到听不见的声线</p><p>你给了我超能力</p><p>在你离开了我以后</p> <br><p>曾经的我 太过自私</p><p>只照顾我自己</p><p>曾经的我 太傻不懂得你的心</p><p>现在的我 一天天在改变</p><p>明明你不在我身边</p><p>却因为你而改变</p><p>因为你给的爱</p><br><p>每一次我想你</p><p>全世界每一处都是你</p><p>夜空下的雪花</p><p>每一朵都是你的泪滴</p><br><p>好想你瞬间就在眼前</p><p>好想让你回到我身边</p><p>这无力的超能力</p><p>也没有办法挽回你</p><br><p>喔 曾经的我 太过自私</p><p>只照顾我自己</p><p>曾经的我 太傻不懂得你的心</p><p>现在的我 一天天在改变</p><p>明明你不在我身边</p><p>却因为你而改变</p><p>因为你给的爱</p><br><p>把时间冻结</p><p>回到你身边</p><p>那回忆的书</p><p>翻过去那一页</p><p>那一页的你我</p><p>Oh ho 那时候的你和我</p><br><p>不够坚强的我 天天在改变</p><p>因为你的爱</p><p>你改变了一切</p><p>我整个生命</p><p>这一切</p><p>我整个世界</p><br><p>曾经我对于爱情不懂感谢珍惜</p><p>曾经我以为爱结束也不可惜</p><p>而现在我 却因为你改变</p><p>明明你不在我身边</p><p>我的爱还在继续</p><p>就像没有边际</p><br><p>把时间冻结</p><p>我还想</p><p>回到你身边</p><p>回到你身边</p><p>那回忆的书</p><p>那回忆</p><p>充满悲伤的语言</p><p>随着眼泪消失</p><p>再回到那白色季节</p><br><p>我望眼欲穿 看我看不到的你</p><p>我侧耳倾听 听我听不到的你</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 曹杨 </tag>
            
            <tag> 下一战歌手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>woff 字体反扒方案</title>
      <link href="/p/5871d67/"/>
      <url>/p/5871d67/</url>
      
        <content type="html"><![CDATA[<h2 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/PixPin_2024-12-11_01-04-05.png"></p><p>可以看到，源代码里面的字都是混乱的，复制出来也是乱的，但是显示的却是正常的。</p><p>再仔细看看，这一块是使用了一种神秘的字体</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20241211170122677.png"></p><p>正常的字体就是 Unicode 编码和对应的字是一致的，而这种特殊的字体，则是 A 字的 Unicode 编码，实际上对应了 B 字的字形。</p><h2 id="woff-字体获取"><a href="#woff-字体获取" class="headerlink" title="woff 字体获取"></a>woff 字体获取</h2><p>不同的网站可能会有不同的方式，有的可能可以通过请求获取到</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/91feba240acbae1c12f4932a3c299f16.png"></p><p>有的可能是放在 css 中（通常使用 base64 加密）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20241211163901355.png"></p><p>针对这种情况，有很多方法可以解决，比如可以使用 Python 的 base64 库解码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据进行解码</span></span><br><span class="line">data_bytes = base64.b64decode(data)</span><br><span class="line"><span class="comment"># 将解码后的数据保存到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;font.woff&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(data_bytes)</span><br></pre></td></tr></table></figure><h2 id="woff-字体预览"><a href="#woff-字体预览" class="headerlink" title="woff 字体预览"></a>woff 字体预览</h2><p>可以通过一些在线网站直接预览（这里使用：<a href="https://tophix.com/zh-cn/font-tools/font-viewer">在线字体查看器 | 字形查看器 - Tophix</a>）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/PixPin_2024-12-11_01-08-45.png"></p><h2 id="woff-字体映射"><a href="#woff-字体映射" class="headerlink" title="woff 字体映射"></a>woff 字体映射</h2><p>比较省事的就用 Python 的 fontPreview 库：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.glyfDict = fontPreview.FontPreview().preview(<span class="string">&quot;font.woff&quot;</span>, <span class="string">&quot;images&quot;</span>)</span><br></pre></td></tr></table></figure><p>但是会存在一些比较简单的字识别错误的情况，目前没有什么比较好的解决方法，就只能是人工修复了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20241211164825522.png" alt="映射错误示例"></p><p>比如这里的「」都是错的。</p><p>可以通过调试拿到哈希表，自己修修，反正映射错的字就那么几个（）</p><p>推荐一个网站：<a href="https://symbl.cc/cn/unicode-table/#cjk-unified-ideographs">Unicode 符号表 - 所有 Unicode 字符及其代码都在一页上 (◕‿◕) SYMBL</a></p><p>以上面的 woff 为例，U+4EEC 实际显示的是“「”，通过网站可以查到 4EEC 对应的字是 “们”</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/PixPin_2024-12-11_01-09-18.png"></p><p>不过这样会有点慢，那么有没有更快的方法呢？有！</p><p>请看：<a href="https://www.toolhelper.cn/EncodeDecode/UnicodeChinese">Unicode与中文 编码&#x2F;解码 - 锤子在线工具</a></p><p>网上的工具还是很多的，这个可以直接转换编码</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20241211165534601.png"></p><p>修完之后手动存一个 json，使用的时候直接读取就好了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/huagangwang/article/details/132887899">python 爬虫遇到字体加密解决方案(woff2) ddddocr + 百度ocr 文字识别_python解决woff字体加密-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/385735259">python爬虫之woff 超详细 woff字体反扒 起点woff爬虫 字体爬虫 起点中文网woff - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】生命周期</title>
      <link href="/p/204d99f1/"/>
      <url>/p/204d99f1/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-的核心组件"><a href="#MyBatis-的核心组件" class="headerlink" title="MyBatis 的核心组件"></a>MyBatis 的核心组件</h2><p>MyBatis的核心组件分为4个部分。</p><ul><li>SqlSessionFactoryBuilder (构造器)：它会根据配置或者代码来生成SqISessionFactory，采用的是分步构建的 Builder 模式。</li><li>SqlSessionFactory (工厂接口)：依靠它来生成 SqlSession，使用的是工厂模式。</li><li>SqlSession (会话)：一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是 MyBatis 提供的 SQLMapper接口编程技术，它能提高代码的可读性和可维护性。</li><li>SQL Mapper (映射器)：MyBatis 新设计存在的组件，它由 一个 Java 接口和 XML 文件 (或注解) 构成，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，并返回结果 。</li></ul><h2 id="MyBatis-的生命周期"><a href="#MyBatis-的生命周期" class="headerlink" title="MyBatis 的生命周期"></a>MyBatis 的生命周期</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/en9odR8b_f788f91ed49b498d7b21c23c5266523_mianshiya.png"></p><h3 id="2-1-SqlSessionFactoryBuilder"><a href="#2-1-SqlSessionFactoryBuilder" class="headerlink" title="2.1.SqlSessionFactoryBuilder"></a>2.1.SqlSessionFactoryBuilder</h3><p>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以 SqlSessionFactoryBuilder 不需要长期存在，只作用于创建 SqlSessionFactory 的方法中即可。</p><h3 id="2-2-SqlSessionFactory"><a href="#2-2-SqlSessionFactory" class="headerlink" title="2.2.SqlSessionFactory"></a>2.2.SqlSessionFactory</h3><p>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。<strong>因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用中</strong>，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不在使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同与 MyBatis 的应用周期。</p><p>由于 SqlSessionFactory 是对一个数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，不利于对数据库资源的控制，也将导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免出现这种情况。因此在一般的应用中，我们往往希望 <strong>SqlSessionFactory 作为一个单例，让它在应用中被共享</strong>。</p><h3 id="2-3-SqlSession"><a href="#2-3-SqlSession" class="headerlink" title="2.3.SqlSession"></a>2.3.SqlSession</h3><p>SqlSession 就相当于一个数据库连接 (Connection 对象)，你可以在一个事务里面执行多条 SQL，然后通过它的 commit、 rollback 等方法，提交或者回滚事务。<strong>所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接</strong>，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally…语句来保证其正确关闭。</p><h3 id="2-4-SQL-Mapper"><a href="#2-4-SQL-Mapper" class="headerlink" title="2.4.SQL Mapper"></a>2.4.SQL Mapper</h3><p>Mapper 是一个接口，它由 SqlSession 所创建，所以它的最大生命周期至多和 SqlSession 保持一致，但是由于 SqlSession 的关闭，它的数据库连接资源也会消失，所以它的生命周期应该小于等于 SqlSession 的生命周期。 Mapper 代表的是一个请求中的业务处理 ，所以它应该在一个请求中，一旦处理完了相关的业务，就应该废弃它。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/libaoquan/p/9384389.html">Java 笔记——MyBatis 生命周期 - LiBaoquan - 博客园</a></p><p><a href="https://blog.csdn.net/qq_27706119/article/details/89791023">MyBatis(四)——MyBatis的生命周期及配置实例_mybatis生命周期-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏感词过滤方案总结</title>
      <link href="/p/b585efd0/"/>
      <url>/p/b585efd0/</url>
      
        <content type="html"><![CDATA[<p>敏感词过滤用的使用比较多的 <strong>Trie 树算法</strong> 和 <strong>DFA 算法</strong>。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><p><strong>Trie 树</strong> 也称为字典树、单词查找树，哈希树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示就可以基于 Trie 树来做的。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/brower-trie.png" alt="浏览器 Trie 树效果展示"></p><p>假如我们的敏感词库中有以下敏感词：</p><ul><li>高清视频</li><li>高清 CV</li><li>东京冷</li><li>东京热</li></ul><p>我们构造出来的敏感词 Trie 树就是下面这样的：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/sensitive-word-trie.png" alt="敏感词 Trie 树"></p><p>当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们从 Trie 树的根节点开始匹配。</p><p>可以看出， <strong>Trie 树的核心原理其实很简单，就是通过公共前缀来提高字符串匹配效率</strong>。</p><p>Trie 树是一种利用空间换时间的数据结构，占用的内存会比较大。也正是因为这个原因，实际工程项目中都是使用的改进版 Trie 树例如双数组 Trie 树（Double-Array Trie，DAT）。</p><p>DAT 的设计者是日本的 Aoe Jun-ichi，Mori Akira 和 Sato Takuya，他们在 1989 年发表了一篇论文<a href="https://www.co-ding.com/assets/pdf/dat.pdf">《An Efficient Implementation of Trie Structures》</a>，详细介绍了 DAT 的构造和应用，原作者写的示例代码地址：<a href="https://github.com/komiya-atsushi/darts-java/blob/e2986a55e648296cc0a6244ae4a2e457cd89fb82/src/main/java/darts/DoubleArrayTrie.java%E3%80%82%E7%9B%B8%E6%AF%94%E8%BE%83%E4%BA%8E">https://github.com/komiya-atsushi/darts-java/blob/e2986a55e648296cc0a6244ae4a2e457cd89fb82/src/main/java/darts/DoubleArrayTrie.java。相比较于</a> Trie 树，DAT 的内存占用极低，可以达到 Trie 树内存的 1%左右。DAT 在中文分词、自然语言处理、信息检索等领域有广泛的应用，是一种非常优秀的数据结构。</p><h3 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h3><p>Aho-Corasick（AC）自动机是一种建立在 Trie 树上的一种改进算法，是一种<strong>多模式匹配算法</strong>，由贝尔实验室的研究人员 Alfred V. Aho 和 Margaret J.Corasick 发明。</p><p>AC 自动机算法使用 Trie 树来存放模式串的前缀，通过失败匹配指针（失配指针）来处理匹配失败的跳转。关于 AC 自动机的详细介绍，可以查看这篇文章：<a href="https://zhuanlan.zhihu.com/p/146369212">地铁十分钟 | AC 自动机</a>。</p><p>AC自动机的构建，首先需要构建Trie树，其次需要添加失配指针（fail表），最后需要模式匹配。下图是用单词<strong>her、say、she、shr、he</strong>构成的AC自动机。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-0496a45cf40adc26a688cd782f970dd4_1440w.jpg"></p><p>匹配的核心是从目标串从头逐个开始，在ac自动机中进行匹配，匹配上的则计数，若未匹配上则跳转失配位置进行尝试匹配，直到全部匹配完成。</p><p>如果使用上面提到的 DAT 来表示 AC 自动机 ，就可以兼顾两者的优点，得到一种高效的多模式匹配算法。Github 上已经有了开源 Java 实现版本：<a href="https://github.com/hankcs/AhoCorasickDoubleArrayTrie">https://github.com/hankcs/AhoCorasickDoubleArrayTrie</a> 。</p><h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p><strong>DFA</strong>（Deterministic Finite Automata)即确定有穷自动机，与之对应的是 NFA（Non-Deterministic Finite Automata，不确定有穷自动机)。</p><p>关于 DFA 的详细介绍可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/30009083">有穷自动机 DFA&amp;NFA (学习笔记) - 小蜗牛的文章 - 知乎</a> 。</p><p><a href="https://hutool.cn/docs/#/dfa/%E6%A6%82%E8%BF%B0">Hutool</a> 提供了 DFA 算法的实现：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/hutool-dfa.png" alt="Hutool 的 DFA 算法"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WordTree</span> <span class="variable">wordTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordTree</span>();</span><br><span class="line">wordTree.addWord(<span class="string">&quot;大&quot;</span>);</span><br><span class="line">wordTree.addWord(<span class="string">&quot;大憨憨&quot;</span>);</span><br><span class="line">wordTree.addWord(<span class="string">&quot;憨憨&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;那人真是个大憨憨！&quot;</span>;</span><br><span class="line"><span class="comment">// 获得第一个匹配的关键字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">matchStr</span> <span class="operator">=</span> wordTree.match(text);</span><br><span class="line">System.out.println(matchStr);</span><br><span class="line"><span class="comment">// 标准匹配，匹配到最短关键词，并跳过已经匹配的关键词</span></span><br><span class="line">List&lt;String&gt; matchStrList = wordTree.matchAll(text, -<span class="number">1</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(matchStrList);</span><br><span class="line"><span class="comment">//匹配到最长关键词，跳过已经匹配的关键词</span></span><br><span class="line">List&lt;String&gt; matchStrList2 = wordTree.matchAll(text, -<span class="number">1</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">System.out.println(matchStrList2);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大</span><br><span class="line">[大, 憨憨]</span><br><span class="line">[大, 大憨憨]</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>其实还有公司使用的是前端正则表达式的模式来匹配敏感词</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textarea = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/傻子|坏蛋/g</span>; <span class="comment">//全局过滤词</span></span><br><span class="line">      btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> text = textarea.<span class="property">value</span>.<span class="title function_">replace</span>(reg, <span class="string">&#x27;*&#x27;</span>)  <span class="comment">//把敏感词替换成*</span></span><br><span class="line">          p.<span class="property">innerText</span> = text;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/f94bfe4c09d6bcda5c2298a99fb91e81.png"></p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><a href="https://github.com/toolgood/ToolGood.Words">ToolGood.Words</a>：一款高性能敏感词(非法词&#x2F;脏字)检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。</p><p><a href="https://github.com/hooj0/sensitive-words-filter">sensitive-words-filter</a>：敏感词过滤项目，提供 TTMP、DFA、DAT、hash bucket、Tire 算法支持过滤。可以支持文本的高亮、过滤、判词、替换的接口支持。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://javaguide.cn/system-design/security/sentive-words-filter.html">敏感词过滤方案总结 | JavaGuide</a></p><p><a href="https://zhuanlan.zhihu.com/p/146369212">地铁十分钟 | AC自动机 - 知乎</a></p><p><a href="https://blog.csdn.net/qq_59622162/article/details/135679109">常见的敏感词过滤方案汇总以及高效工具sensitive-word快速实践！-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【并发】高并发下库存扣减如何避免超卖和少卖？</title>
      <link href="/p/122902e7/"/>
      <url>/p/122902e7/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是超卖？"><a href="#什么是超卖？" class="headerlink" title="什么是超卖？"></a>什么是超卖？</h2><p>所谓”超卖”指的就是商品卖多了，一般我们在商品扣减库存的时候，都会先判断库存够不够如果够在进行扣减，不够则直接返回下单失败。</p><p>但是，如果在高并发场景中，可能存在以下情况：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/ca12aece0210908038bf0e471ec530fb.png"></p><p>当有两个并发线程，同时查询库存，这时数据库中库存剩余1，所以两个线程都得到1的库存，然后经过库存校验之后分别开始进行库存扣减，最终导致库存被扣减成负数。</p><p>以上，就是一个典型的高并发情况下的超卖问题。</p><p>之所以会发生以上问题，主要是因为并发导致的，所以，解决超卖的问题本质上是<strong>解决并发问题</strong>。以上问题，最终就是要实现库存扣减过程中的<strong>原子性和有序性</strong>。</p><p>原子性：库存查询、库存判断以及库存扣减动作，作为一个原子操作，过程中不会被打断，也不会有其他线程执行。</p><p>有序性：多个并发操作需要排队执行。</p><h2 id="数据库扣减"><a href="#数据库扣减" class="headerlink" title="数据库扣减"></a>数据库扣减</h2><p>数据库中进行库存扣减是最容易想到的方案，这个方案实现起来非常简单<br>在扣减过程中，想要保证原子性和有序性，我们可以采用<strong>加锁</strong>的方式，无论是悲观锁、还是乐观锁都可以实现的。</p><p>但是，如果使用悲观锁来实现的话，就会导致很多请求被迫阻塞并且排队，那么如果并发请求量很大的话，就可能直接把数据库给拖垮了。</p><p>如果是乐观锁的话，可以用版本号的方式来控制有序执行，但是这个问题在于高并发场景中会存在大量的失败，而且高并发场景中也不适合使用乐观锁，因为乐观锁在update的过程中也是需要<strong>加行级锁</strong>的，也是会出现阻塞的情况。</p><p>那么，在库存扣减时，如果不加锁可以吗？</p><p>其实是可以的，我们就借助数据库自己执行引擎的顺序执行机制，只要保证库存不要扣减成负数就行了，那么可行的方案是通过SQL语句就能控制，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> inventory</span><br><span class="line"><span class="keyword">set</span> quantity<span class="operator">=</span>quantity<span class="operator">-</span> #&#123;count&#125;</span><br><span class="line"><span class="keyword">where</span> sku id<span class="operator">=</span><span class="string">&#x27;123&#x27;</span><span class="keyword">and</span> quantity <span class="operator">&gt;=</span> #&#123;count&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果上述SQL可以执行成功的话，是可以确保库存余量大于等于0的，这就避免了超卖的发生。</p><p>但是这个方案好吗?其实是不好的。</p><p>因为这个方案本质上和乐观锁的方案缺点是一样的，都是完全依赖数据库，并且高并发情况下，多个线程同时update inventory 的时候会发生阻塞，不仅会很慢，还会把数据库拖垮的。</p><p>正常来说，MySQL的热点行更新最多也就抗200-300的并发更新，如果想要抗的更多，要么就是提升硬件水平，要么就是做一些技术改造，比如inventory hint的方式。</p><p>那么，不用数据库扣减的话，可以用什么呢?答案是可以借助缓存的扣减。</p><h2 id="Redis-扣减"><a href="#Redis-扣减" class="headerlink" title="Redis 扣减"></a>Redis 扣减</h2><p>我们可以基于Redis做库存扣减的，借助Redis的单线程执行的特性，再加上Lua脚本执行过程中的原子性保障，我们可以在Redis中通过Lua脚本进行库存扣减。<br>在Redis中，使用以下Lua脚本：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]<span class="comment">-- 商品的键名</span></span><br><span class="line"><span class="keyword">local</span> amount =<span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="comment">-- 扣减的数量</span></span><br><span class="line"><span class="comment">--获取商品当前的库存量--</span></span><br><span class="line"><span class="keyword">local</span> stock =<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,key))</span><br><span class="line"><span class="comment">--如果库存足够，则减少库存并返回新的库存量</span></span><br><span class="line"><span class="keyword">if</span> stock &gt;= amount <span class="keyword">then</span></span><br><span class="line">redis.call(<span class="string">&#x27;decrby&#x27;</span>, key, amount)<span class="keyword">return</span> redis.call(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;INSUFFICIENT STOCK&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>先从Redis中取出当前的剩余库存，然后判断是否足够扣减，如果足够的话，就进行扣减，否则就返回库存不足。</p><p>因为lua脚本在执行过程中，可以避免被打断，并且redis执行的过程也是单线程的，所以在脚本中进行判断，再扣减，这个过程是可以避免并发的。所以也就可以实现前面我们说的原子性+有序性了。</p><p>并且Redis是一个高性能的分布式缓存，使用Lua脚本扣减库存的方案也非常的高效。</p><h2 id="如何保证一致性"><a href="#如何保证一致性" class="headerlink" title="如何保证一致性"></a>如何保证一致性</h2><p>上面我们提到了两个方案，一个是通过数据库进行库存扣减，一个是通过redis实现扣减，一般，在实际应用过程中，这两种方案会结合使用。</p><p>也就是说先在Redis中做扣减，利用Redis来抗高并发流量，然后再同步到数据库中，在数据库中做扣减并进行持久化存储，避免Redis挂了导致数据丢失。</p><p>一般的做法是，先在Redis中做扣减，然后发送一个MQ消息，消费者在接到消息之后做数据库中库存的真正扣减及业务逻辑操作。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/976ca32429da61e07653daea957e4954.png"></p><p>这样做，我们可以保证Redis中的数据和数据库中的数据的一个最终一致性。并且也能避免超卖的发生。</p><p>但是，这个方案有个问题，就是可能导致少卖</p><h2 id="什么是少卖？"><a href="#什么是少卖？" class="headerlink" title="什么是少卖？"></a>什么是少卖？</h2><p>假设，上面的流程中，第1步执行成功了，Redis中库存成功扣减了，但是后续第2步的消息没有发出去，或者后面的消费过程中消息丢了或者失败了等情况。</p><p>就会导致Redis中的库存被扣减了，但是数据库库存没扣减，业务的实际操作没发生。这时候的结果就是Redis中发生了多扣，那么带来的业务问题就是少卖。</p><p>那么，想要解决这类问题呢，就需要引入一些对账的机制，做一些准实时的核对，针对这类情况及时发现，如果少卖很多的话，那么就需要再把这些库存加回去。</p><p>一般在很多成熟的电商公司中，不管前面的方案做的多么完善，这个核对系统都是必不可少的。及时的核对出超卖、少卖等问题。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_44543482/article/details/136036121">库存扣减如何避免超卖和少卖?_防止超卖的几种方式-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐歌名&amp;歌词获取方案收集</title>
      <link href="/p/683f7c8e/"/>
      <url>/p/683f7c8e/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天突然发现从上周开始（2024&#x2F;10&#x2F;23）通过网易云音乐 PC 客户端下载的歌（.ncm）连他自己都播放不了，拿去解密也说文件是损坏的。而且我的客户端版本很久没更新过了（因为新版刚出的时候是没有下载功能的，就退回去了一直没更新），于是猜测可能是下载的接口变了或者是其他原因，就去下载新版客户端，然后再去下载歌曲，结果发现没问题了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20241031192853015.png" alt="旧版客户端下载的文件"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20241031192938207.png" alt="新版客户端下载的文件"></p><p>那就用新版客户端好了，然后突发奇想看能不能顺便解决一下 OBS 获取歌曲其他信息的问题（现在一搜就能出来的 tuna  只能通过获取窗口标题来获取歌名这样，而且就算用 Spotify，也最多获取到歌曲时长、播放到哪，并且刷新很迷惑，有时候可能连续10s都能正确刷新，但又会卡住几秒）</p><h2 id="方案-1：实时获取播放进度"><a href="#方案-1：实时获取播放进度" class="headerlink" title="方案 1：实时获取播放进度"></a>方案 1：实时获取播放进度</h2><p>首先声明这个方法只适用于旧版客户端（2.x），新版客户端的日志已加密，然后原文也已经寄了，只能通过缓存窥见一斑</p><p>省略一些过程，总之原文通过浏览日志文件发现有一个文件是存播放历史的（<code>..\AppData\Local\NetEase\CloudMusic\webdata\file\history</code>）</p><p>所以我们可能就能够通过获取这个历史记录的最新记录来获得当前播放的歌曲。</p><p>当我们打开文件之后发现文件内容是这样的（已格式化）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;track&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1895395697</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;饿魔少女&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;emo girl&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;artists&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">34477557</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ChiliChill&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;album&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">138401837</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;每到夜里我就很饿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;109951166891913184&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://p3.music.126.net/Sdp6DpCQF5q-dDIiNOuBjQ==/109951166891913184.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;transNames&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span> <span class="number">185334</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mvId&quot;</span><span class="punctuation">:</span> <span class="number">14479857</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;recoverMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">38858501</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">999000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5f344376286b5fc50932f31c5db7574e&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;realSuffix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flac&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commentThreadId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R_SO_4_1895395697&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span> <span class="number">1400821</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mvid&quot;</span><span class="punctuation">:</span> <span class="number">14479857</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ringtone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rtUrl&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pstatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;songType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mst&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;popularity&quot;</span><span class="punctuation">:</span> <span class="number">85</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ftype&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rtUrls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;noCopyrightRcmd&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;originCoverType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span> <span class="number">17179877376</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">320000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">7415685</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-61396</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">192000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">4449428</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-58875</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">128000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2966300</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-57372</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;yunSong&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;privilege&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1895395697</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8-1-0-999-999-999-320-7-1-1-0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;payed&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxPlayBr&quot;</span><span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxDownBr&quot;</span><span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxSongBr&quot;</span><span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxFreeBr&quot;</span><span class="punctuation">:</span> <span class="number">320</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;sharePriv&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;commentPriv&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;subPriv&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cloudSong&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;toast&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="number">524292</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;now&quot;</span><span class="punctuation">:</span> <span class="number">1730354870000</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span> <span class="number">495</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lrcAbstractEnd&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lrcAbstractStart&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;indexId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NL1895395697&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;haslyric&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;starred&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;starredNum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;playedNum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dayPlays&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hearTime&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mp3Url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://m2.music.126.net/hmZoNQaqzZALvVp0rE7faA==/0.mp3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;originSongSimpleData&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;songJumpInfo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;audition&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;copyFrom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;disc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;no&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;bMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-61372</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span> <span class="number">185334</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">2161000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span> <span class="number">44100</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6954240686</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">50067454</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wav&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sqMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-61377</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span> <span class="number">185334</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">1673892</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span> <span class="number">44100</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6954266909</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">38778697</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flac&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hrMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-61372</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span> <span class="number">185334</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">2161000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span> <span class="number">44100</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6954240686</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">50067454</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wav&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;crbt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rtype&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rurl&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;recommendReason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;相似歌曲&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;offline-1895395697_-2_&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span> <span class="number">1895395697</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/m/offline/complete/?fromSource=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我下载的音乐&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fromButton&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ext&quot;</span><span class="punctuation">:</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;aiRcmd&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;startlogtime&quot;</span><span class="punctuation">:</span> <span class="number">1730354879626</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;loaderr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playedTime&quot;</span><span class="punctuation">:</span> <span class="number">1.72</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastTime&quot;</span><span class="punctuation">:</span> <span class="number">1.72</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;logDuration&quot;</span><span class="punctuation">:</span> <span class="number">1.72</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;qid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;offline-1895395697_-2_&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="number">1730354879635</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playBrt&quot;</span><span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Music\\VipSongsDownload\\ChiliChill\\每到夜里我就很饿\\ChiliChill - 饿魔少女.ncm&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lrctype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;online&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lrcid&quot;</span><span class="punctuation">:</span> <span class="number">1895395697</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;track&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;album&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">252091416</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;短期陪伴&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;109951170088106953&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://p4.music.126.net/nrDBWc-tMOcTemEuo7WZ6A==/109951170088106953.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;transNames&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;artists&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12277194</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LBI利比&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commentThreadId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R_SO_4_2640843881&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span> <span class="number">219968</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2640843881</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mvid&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;短期陪伴&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ringtone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rtUrl&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pstatus&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;songType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mst&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;popularity&quot;</span><span class="punctuation">:</span> <span class="number">95</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ftype&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rtUrls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;noCopyrightRcmd&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;originCoverType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span> <span class="number">17716748288</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;yunSong&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">320000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">8801325</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-34398</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">192000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5280813</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-31791</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lMusic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span> <span class="number">128000</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">3520557</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-30118</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;privilege&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2640843881</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8-1-0-1999-1999-1999-320-7-1-1-0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;payed&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxPlayBr&quot;</span><span class="punctuation">:</span> <span class="number">1999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxDownBr&quot;</span><span class="punctuation">:</span> <span class="number">1999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxSongBr&quot;</span><span class="punctuation">:</span> <span class="number">1999</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maxFreeBr&quot;</span><span class="punctuation">:</span> <span class="number">320</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;sharePriv&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;commentPriv&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;subPriv&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cloudSong&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;toast&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="number">528388</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;now&quot;</span><span class="punctuation">:</span> <span class="number">1730354870000</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span> <span class="number">44</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span> <span class="number">-7.8456</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;downloadQuality&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2640843881_1_421801417&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span> <span class="number">2640843881</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;421801417&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/m/playlist/?id=421801417&amp;rid=A_PL_0_421801417&amp;fromSource=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我喜欢的音乐&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fromButton&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;aiRcmd&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;startlogtime&quot;</span><span class="punctuation">:</span> <span class="number">1730354879513</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;loaderr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playedTime&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastTime&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;logDuration&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;qid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2640843881_1_421801417&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="number">1730354879535</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playBrt&quot;</span><span class="punctuation">:</span> <span class="number">1999</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Music\\LBI利比\\短期陪伴\\LBI利比 - 短期陪伴.ncm&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;playedTimeFromNative&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lrctype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;online&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lrcid&quot;</span><span class="punctuation">:</span> <span class="number">2640843881</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>这明显是json格式或者说类json格式。</p><p>然后我们发现这个列表的第一个字典元素就包含了我们当前播放的歌曲。那么这可能就是最终的解决方案了。</p><p>此外通过监控日志，还可以得到JSON中展示的歌曲的相关数据，包括歌曲所属专辑、歌曲名称、演唱者、时长、歌曲链接等信息。</p><p>此外还有：除了歌曲相关的信息，这段JSON还包括了一些评论、播放记录、特权和权限等信息。例如，每首歌曲都有一个评论线程ID、播放次数和评论数等；每个歌曲都有一个特权对象，其中包含了歌曲的ID、版本、价格等信息；同时，还有一些播放记录、时间戳、播放方式、音质等信息。</p><p>其中想要获得监控播放时间需要注意一下几个属性：</p><p>startlogtime、playedTime、lastTime、logDuration、time</p><p>这几个属性都与播放时间有关；</p><p>为了获取播放时长，需要对每个歌曲的 JSON 数据进行解析。以第一首歌曲”What You Know Bout Love”为例，其对应的 JSON 如下所示：</p><p>{ “track”: { …, “duration”: 160000, …, “playedTime”: 30.28, “lastTime”: 30.28, “logDuration”: 30.28, … }, … }</p><p>其中，”duration” 字段代表歌曲的总时长，单位为毫秒；”playedTime” 和 “lastTime” 字段代表已播放的时间和剩余的时间，单位为秒；”logDuration” 字段代表播放记录中记录的播放时长，单位为秒。</p><p>因此，我们可以通过访问这些字段来获取歌曲的播放时长。</p><h3 id="实时读取文件"><a href="#实时读取文件" class="headerlink" title="实时读取文件"></a>实时读取文件</h3><p>一个有效的方法是每隔一段时间查看文件的修改日期，如果修改日期改变的话才读取文件，然后再更新储存了当前播放歌曲的文件。</p><p>实际上有一个库叫做<strong>watchdog</strong>可以监听系统事件，其中也包括文件的修改，这样就不用我们重复造轮子了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> watchdog.observers <span class="keyword">import</span> Observer</span><br><span class="line"><span class="keyword">from</span> watchdog.events <span class="keyword">import</span> FileSystemEventHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingEventHandler</span>(<span class="title class_ inherited__">FileSystemEventHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_modified</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="built_in">super</span>(LoggingEventHandler, self).on_modified(event)</span><br><span class="line">        what = <span class="string">&#x27;directory&#x27;</span> <span class="keyword">if</span> event.is_directory <span class="keyword">else</span> <span class="string">&#x27;file&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Modified <span class="subst">&#123;what&#125;</span>: <span class="subst">&#123;event.src_path&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    event_handler = LoggingEventHandler()</span><br><span class="line">    observer = Observer()</span><br><span class="line">    observer.schedule(event_handler, path, recursive=<span class="literal">True</span>)</span><br><span class="line">    observer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        observer.stop()</span><br><span class="line">    observer.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>通过上述的代码，我们就可以监听当前目录下或者给定参数目录下的文件修改事件了。</p><h3 id="获取history文件所在目录"><a href="#获取history文件所在目录" class="headerlink" title="获取history文件所在目录"></a>获取history文件所在目录</h3><p>我们可以通过以下表达式获取history文件所在的目录。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = os.path.join(os.path.expanduser(<span class="string">&#x27;~&#x27;</span>), <span class="string">r&#x27;AppData\Local\Netease\CloudMusic\webdata\file&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="解析history文件"><a href="#解析history文件" class="headerlink" title="解析history文件"></a>解析history文件</h3><p>我们发现这个history文件一般都有200KB左右，当历史记录更多的时候可能更大。如果每次这个文件更改都解析整个json未免有点低效了，所以我们需要找个办法只解析这个json列表里面的第一个字典。</p><p>history文件中第一个字典长这样(history中整个文件都只有一行)：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>&#x27;track&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;album&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;id&#x27;<span class="punctuation">:</span> <span class="number">36634131</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;name&#x27;<span class="punctuation">:</span> &#x27;けいおん!はいれぞ!「Come with Me!!」セット&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;picId&#x27;<span class="punctuation">:</span> &#x27;<span class="number">109951163048673023</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;picUrl&#x27;<span class="punctuation">:</span> &#x27;https<span class="punctuation">:</span><span class="comment">//p4.music.126.net/e1n_xjLFAm_GY8ZETmka4g==/109951163048673023.jpg&#x27;,</span></span><br><span class="line">   &#x27;alias&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;transNames&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;alias&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;artists&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span>&#x27;id&#x27;<span class="punctuation">:</span> <span class="number">161782</span><span class="punctuation">,</span> &#x27;name&#x27;<span class="punctuation">:</span> &#x27;放課後ティータイム&#x27;<span class="punctuation">,</span> &#x27;tns&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> &#x27;alias&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;commentThreadId&#x27;<span class="punctuation">:</span> &#x27;R_SO_4_514765041&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;copyrightId&#x27;<span class="punctuation">:</span> <span class="number">663018</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;duration&#x27;<span class="punctuation">:</span> <span class="number">253280</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;id&#x27;<span class="punctuation">:</span> <span class="number">514765041</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;mvid&#x27;<span class="punctuation">:</span> <span class="number">10850421</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;name&#x27;<span class="punctuation">:</span> &#x27;NO<span class="punctuation">,</span> Thank You!&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;cd&#x27;<span class="punctuation">:</span> &#x27;<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;position&#x27;<span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;ringtone&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">  &#x27;rtUrl&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">  &#x27;status&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;pstatus&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;fee&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;version&#x27;<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;songType&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;mst&#x27;<span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;popularity&#x27;<span class="punctuation">:</span> <span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;ftype&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;rtUrls&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;yunSong&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;uid&#x27;<span class="punctuation">:</span> <span class="number">40396092</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;nickname&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;songName&#x27;<span class="punctuation">:</span> &#x27;NO<span class="punctuation">,</span> Thank You!&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;album&#x27;<span class="punctuation">:</span> &#x27;けいおん!はいれぞ!「Come with Me!!」セット&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;artist&#x27;<span class="punctuation">:</span> &#x27;放課後ティータイム&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;coverId&#x27;<span class="punctuation">:</span> &#x27;<span class="number">109951165018150110</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;fileExt&#x27;<span class="punctuation">:</span> &#x27;.mp3&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;bitrate&#x27;<span class="punctuation">:</span> <span class="number">326</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;hMusic&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;bitrate&#x27;<span class="punctuation">:</span> <span class="number">320000</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;dfsId&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;size&#x27;<span class="punctuation">:</span> <span class="number">10133464</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;volumeDelta&#x27;<span class="punctuation">:</span> <span class="number">-39100</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;mMusic&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;bitrate&#x27;<span class="punctuation">:</span> <span class="number">192000</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;dfsId&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;size&#x27;<span class="punctuation">:</span> <span class="number">6080096</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;volumeDelta&#x27;<span class="punctuation">:</span> <span class="number">-36700</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;lMusic&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;bitrate&#x27;<span class="punctuation">:</span> <span class="number">128000</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;dfsId&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;size&#x27;<span class="punctuation">:</span> <span class="number">4053412</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;volumeDelta&#x27;<span class="punctuation">:</span> <span class="number">-35500</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;privilege&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;id&#x27;<span class="punctuation">:</span> <span class="number">514765041</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;version&#x27;<span class="punctuation">:</span> &#x27;<span class="number">0</span><span class="number">-0</span><span class="number">-0</span><span class="number">-326</span><span class="number">-326</span><span class="number">-999</span><span class="number">-999</span><span class="number">-7</span><span class="number">-1</span><span class="number">-1</span><span class="number">-1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;fee&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;payed&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;status&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;maxPlayBr&#x27;<span class="punctuation">:</span> <span class="number">326</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;maxDownBr&#x27;<span class="punctuation">:</span> <span class="number">326</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;maxSongBr&#x27;<span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;maxFreeBr&#x27;<span class="punctuation">:</span> <span class="number">999</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;sharePriv&#x27;<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;commentPriv&#x27;<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;subPriv&#x27;<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;cloudSong&#x27;<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;toast&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line">   &#x27;flag&#x27;<span class="punctuation">:</span> <span class="number">136</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;now&#x27;<span class="punctuation">:</span> <span class="number">1595490687000</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;commentCount&#x27;<span class="punctuation">:</span> <span class="number">151</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;id&#x27;<span class="punctuation">:</span> &#x27;<span class="number">514765041</span>_1_33803710_1595480877683&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;tid&#x27;<span class="punctuation">:</span> <span class="number">514765041</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;program&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line"> &#x27;fid&#x27;<span class="punctuation">:</span> &#x27;<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;data&#x27;<span class="punctuation">:</span> &#x27;<span class="number">33803710</span>&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;href&#x27;<span class="punctuation">:</span> &#x27;/m/playlist/?id=<span class="number">33803710</span>&amp;rid=A_PL_0_33803710&amp;fromSource=<span class="number">1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;text&#x27;<span class="punctuation">:</span> &#x27;我喜欢的音乐&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;nickName&#x27;<span class="punctuation">:</span> &#x27;辣条ii&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;userId&#x27;<span class="punctuation">:</span> <span class="number">40396092</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;fromButton&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line"> &#x27;specialType&#x27;<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;startlogtime&#x27;<span class="punctuation">:</span> <span class="number">1595555807539</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;loaderr&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line"> &#x27;playedTime&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;lastTime&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;logDuration&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;isCloudMusic&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line"> &#x27;lastPlayInfo&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;bitrate&#x27;<span class="punctuation">:</span> <span class="number">320</span><span class="punctuation">,</span></span><br><span class="line">  &#x27;retJson&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;id&#x27;<span class="punctuation">:</span> <span class="number">514765041</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;url&#x27;<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span><span class="comment">//m8.music.126.net/20200502162942/dcb351459e414e759c04a4f0e3366c26/ymusic/6e3f/53bf/0cdc/c86b892db7c67f19604d2a77970f181e.mp3&#x27;,</span></span><br><span class="line">   &#x27;br&#x27;<span class="punctuation">:</span> <span class="number">320000</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;size&#x27;<span class="punctuation">:</span> <span class="number">10133464</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;md5&#x27;<span class="punctuation">:</span> &#x27;c86b892db7c67f19604d2a77970f181e&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;code&#x27;<span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;expi&#x27;<span class="punctuation">:</span> <span class="number">1200</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;type&#x27;<span class="punctuation">:</span> &#x27;mp3&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;gain&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;fee&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;uf&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">   &#x27;payed&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;flag&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   &#x27;canExtend&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line">   &#x27;freeTrialInfo&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">   &#x27;level&#x27;<span class="punctuation">:</span> &#x27;exhigh&#x27;<span class="punctuation">,</span></span><br><span class="line">   &#x27;encodeType&#x27;<span class="punctuation">:</span> &#x27;mp3&#x27;<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;playType&#x27;<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;playBrt&#x27;<span class="punctuation">:</span> <span class="number">320</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;playedTimeFromNative&#x27;<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> &#x27;aiRcmd&#x27;<span class="punctuation">:</span> False<span class="punctuation">,</span></span><br><span class="line"> &#x27;qid&#x27;<span class="punctuation">:</span> &#x27;<span class="number">514765041</span>_1_33803710&#x27;<span class="punctuation">,</span></span><br><span class="line"> &#x27;time&#x27;<span class="punctuation">:</span> <span class="number">1595555807594</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以发现里面每个字典的长度都是2000上下，如果保险起见那么为了能够解析到一个完整的字典，至少也要读取3000个字符的样子。</p><div class="note  flat"><p>插一句：当年的数据里面竟然还带了歌曲的真实 URL</p></div><h3 id="尝试使用正则"><a href="#尝试使用正则" class="headerlink" title="尝试使用正则"></a>尝试使用正则</h3><p>经过进一步考虑我们发现其实只需要读取前400个字符左右，然后用正则表达式 r’”name”:”(.*?)”‘来匹配就可以分别得到专辑名，艺术家和歌曲名了。</p><p>为了保险起见，我们读取前800个字符。</p><p>所以从history解析正在播放的歌曲的代码就是这样了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&quot;name&quot;:&quot;(.*?)&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_playing</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        new_content = f.read(<span class="number">800</span>)</span><br><span class="line">    <span class="keyword">return</span> pattern.findall(new_content)</span><br></pre></td></tr></table></figure><p>但是经过一番测试之后发现有些歌会没有专辑名，导致上面的正则表达式只能匹配到一个。</p><h3 id="还是决定用json解析"><a href="#还是决定用json解析" class="headerlink" title="还是决定用json解析"></a>还是决定用json解析</h3><p>我们测试完了正则表达式之后发现并不是很可靠，于是还是退回到用json解析的方法来。</p><p>但是我们又遇到了一个新的问题。</p><p>history文件里的json结构大概是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;...&quot;</span>, <span class="string">&quot;b&quot;</span>:<span class="string">&quot;...&quot;</span>, ...&#125;, &#123;<span class="string">&quot;c&quot;</span>:<span class="string">&quot;......&quot;</span>, <span class="string">&quot;d&quot;</span>:<span class="string">&quot;....&quot;</span>, ....&#125;, ...]</span><br></pre></td></tr></table></figure><p>这个列表里面的每个字典的长度是不定长的，我们需要想办法只把第一个字典的字符串送入json解析器里面，但是这有点复杂了。</p><p>经过搜索，我们发现了我们可以使用如下的代码来从字符串中解析第一个出现的完整json，忽略额外的字符串。</p><p>这里的raw_decode方法返回元组里第一个元素是解码器找到的第一个完整json，第二个元素是解析了的字符串长度。这个在流式传输的时候还挺有用的，这里我们就把它用作history文件的解析。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_playing</span>(<span class="params">path</span>):</span><br><span class="line">    track_info = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        read_string = f.read(<span class="number">3200</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                read_string += f.read(<span class="number">500</span>)</span><br><span class="line">                decoded_json = decoder.raw_decode(read_string[<span class="number">1</span>:])</span><br><span class="line">                track_info.update(decoded_json[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> json.JSONDecodeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> track_info:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    track_name = track_info[<span class="string">&#x27;track&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    artist_list = [i[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> track_info[<span class="string">&#x27;track&#x27;</span>][<span class="string">&#x27;artists&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> track_name, artist_list</span><br></pre></td></tr></table></figure><p>这里我们首先读取3200个字符，然后除去第一个字符送入json解析器，如果产生错误的话就再加500个字符，然后再次解析，尝试四次直到解析出来。</p><p>然后我们就可以从解析出来的字典里面获取歌曲名和艺术家列表了。</p><p>所以最后我们的程序就是这样了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> watchdog.observers <span class="keyword">import</span> Observer</span><br><span class="line"><span class="keyword">from</span> watchdog.events <span class="keyword">import</span> FileSystemEventHandler</span><br><span class="line"></span><br><span class="line">decoder = json.JSONDecoder()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_history_file</span>():</span><br><span class="line">    path = os.path.join(os.path.expanduser(<span class="string">&#x27;~&#x27;</span>), <span class="string">r&#x27;AppData\Local\Netease\CloudMusic\webdata\file&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cloudmusic data folder not found&#x27;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_playing</span>(<span class="params">path</span>):</span><br><span class="line">    track_info = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        read_string = f.read(<span class="number">3200</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                read_string += f.read(<span class="number">500</span>)</span><br><span class="line">                decoded_json = decoder.raw_decode(read_string[<span class="number">1</span>:])</span><br><span class="line">                track_info.update(decoded_json[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> json.JSONDecodeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> track_info:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    track_name = track_info[<span class="string">&#x27;track&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    artist_list = [i[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> track_info[<span class="string">&#x27;track&#x27;</span>][<span class="string">&#x27;artists&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> track_name, artist_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingEventHandler</span>(<span class="title class_ inherited__">FileSystemEventHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.file_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_modified</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="built_in">super</span>(LoggingEventHandler, self).on_modified(event)</span><br><span class="line">        path = event.src_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path.endswith(<span class="string">r&#x27;webdata\file\history&#x27;</span>):</span><br><span class="line">            current_size = os.path.getsize(path)</span><br><span class="line">            <span class="keyword">if</span> current_size != self.file_size:</span><br><span class="line">                self.file_size = current_size</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        song, artists = get_playing(path)</span><br><span class="line">                        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;playing.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                            playing = <span class="string">f&#x27;<span class="subst">&#123;song&#125;</span> - <span class="subst">&#123;<span class="string">&quot; / &quot;</span>.join(artists)&#125;</span>&#x27;</span></span><br><span class="line">                            <span class="built_in">print</span>(playing)</span><br><span class="line">                            f.write(playing)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">except</span> PermissionError:</span><br><span class="line">                        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path = get_history_file()</span><br><span class="line">    event_handler = LoggingEventHandler()</span><br><span class="line">    observer = Observer()</span><br><span class="line">    observer.schedule(event_handler, path, recursive=<span class="literal">True</span>)</span><br><span class="line">    observer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        observer.stop()</span><br><span class="line">    observer.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="方案-2：实时获取歌词"><a href="#方案-2：实时获取歌词" class="headerlink" title="方案 2：实时获取歌词"></a>方案 2：实时获取歌词</h2><p>原文：<a href="https://blog.csdn.net/jd3096/article/details/127345106">重磅！python获取同步输出的桌面网易云音乐歌词（内存偏移获取）_网易云音乐 dll进程注入-CSDN博客</a></p><p>再次首先声明，里面给出的代码只适用于某个版本，因为这个方法是直接抓内存，版本一变内存地址肯定也会变，不会抓的话等于没用（</p><p>首先，任何数据都在内存里，最直观的就是游戏数据，血量，金钱之类的，小时候应该很多人都用过金山游侠修改数据，就是那套原理，那么歌词作为文本，也是数据，为啥我不找找呢，于是搞了个CE打法，先显示英文的歌词，一直查找第一位字母的ASCII码，果然找到了，歌词不是什么敏感数据，一般也不会加密之类的，所以很典型很顺畅的找到了。</p><p>然后，网上教程说用OD去找偏移量，其实CE也可以搞定，一顿顺腾摸瓜，最最最重要的偏移量他来了，上图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/de13c3ee95fb4db78732e95db48040a0.png"></p><p>可以很清楚看到实时显示歌词的地址是怎么来的，从cloudmusic.dll的基址开始，经过三次偏移得道，当然最后一次是0，可以不用算。<br>原理知道了，愣着干嘛，一顿操作如虎，搞定了，这里，网易云音乐歌词的规则也被我看出来了，每个字，不管是英文还是中文，都占用两个bytes，中文用的是unicode编码，两个字符高低位反过来，如原来是\x34\x12就变成u1234，就行了，这里网上居然没找到现成的转换方式，网上找点有点的东西是真的费劲。。。于是自己手动写了坨屎山，转换了。英文就是\x00接ascii码，如果遇到连续两个\x00\x00视为词句歌词结束，现在规则全看透了，搞定。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/e733db9a533a8cade6871b207e77d55c.png"></p><p>这样就做好了，感觉干了件大事，网上没有相关资料代码，全靠自己摸索哦</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2022-10-15 by jd3096 vx:jd3096</span></span><br><span class="line"><span class="keyword">import</span> pymem</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> win32process</span><br><span class="line"><span class="keyword">from</span> win32con <span class="keyword">import</span> PROCESS_ALL_ACCESS </span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> win32gui <span class="keyword">import</span> FindWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetProcssID</span>(<span class="params">address,bufflength</span>):</span><br><span class="line">    pid = ctypes.c_ulong() </span><br><span class="line">    kernel32 = ctypes.windll.LoadLibrary(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">    hwnd = FindWindow(<span class="string">&quot;DesktopLyrics&quot;</span>, <span class="string">u&quot;桌面歌词&quot;</span>)<span class="comment">#获取窗口句柄</span></span><br><span class="line">    hpid, pid = win32process.GetWindowThreadProcessId(hwnd)<span class="comment">#获取窗口ID</span></span><br><span class="line">    hProcess = win32api.OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">False</span>, pid)<span class="comment">#获取进程句柄</span></span><br><span class="line">    ReadProcessMemory = kernel32.ReadProcessMemory</span><br><span class="line">    addr = ctypes.c_ulong()</span><br><span class="line">    ReadProcessMemory(<span class="built_in">int</span>(hProcess), address, ctypes.byref(addr), bufflength, <span class="literal">None</span>)<span class="comment">#读内存</span></span><br><span class="line">    win32api.CloseHandle(hProcess)<span class="comment">#关闭句柄</span></span><br><span class="line">    <span class="keyword">return</span> addr.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_moduladdr</span>(<span class="params">dll</span>):  <span class="comment">#找到dll的内存基址</span></span><br><span class="line">    modules = <span class="built_in">list</span>(Game.list_modules())</span><br><span class="line">    <span class="keyword">for</span> module <span class="keyword">in</span> modules:</span><br><span class="line">        <span class="keyword">if</span> module.name == dll:</span><br><span class="line">            Moduladdr = module.lpBaseOfDll</span><br><span class="line">    <span class="keyword">return</span> Moduladdr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_add</span>():   <span class="comment">#从基址加偏移量反复三次得到实际内存地址</span></span><br><span class="line">    Char_Modlue = Get_moduladdr(<span class="string">&quot;cloudmusic.dll&quot;</span>)</span><br><span class="line">    addr = GetProcssID((Char_Modlue + <span class="number">0xAF7C44</span>),<span class="number">4</span>)</span><br><span class="line">    ret = addr + <span class="number">0xc8</span></span><br><span class="line">    ret2 = GetProcssID(ret, <span class="number">4</span>)</span><br><span class="line">    ret3 = ret2 + <span class="number">0x14</span></span><br><span class="line">    ret4 = GetProcssID(ret3, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">hex</span>(ret4))</span><br><span class="line">    <span class="keyword">return</span> ret4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Game = pymem.Pymem(<span class="string">&quot;cloudmusic.exe&quot;</span>)</span><br><span class="line">lyrics_addr=get_add()<span class="comment">#实际内存地址</span></span><br><span class="line">lyrics_len=<span class="number">200</span></span><br><span class="line">last_lyrics=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B2Q</span>(<span class="params">uchar</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个字符 半角转全角&quot;&quot;&quot;</span></span><br><span class="line">    inside_code = <span class="built_in">ord</span>(uchar)</span><br><span class="line">    <span class="keyword">if</span> inside_code &lt; <span class="number">0x0020</span> <span class="keyword">or</span> inside_code &gt; <span class="number">0x7e</span>: <span class="comment"># 不是半角字符就返回原来的字符</span></span><br><span class="line">        <span class="keyword">return</span> uchar </span><br><span class="line">    <span class="keyword">if</span> inside_code == <span class="number">0x0020</span>: <span class="comment"># 除了空格其他的全角半角的公式为: 半角 = 全角 - 0xfee0</span></span><br><span class="line">        inside_code = <span class="number">0x3000</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inside_code += <span class="number">0xfee0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(inside_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringB2Q</span>(<span class="params">ustring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把字符串强行全角&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([B2Q(uchar) <span class="keyword">for</span> uchar <span class="keyword">in</span> ustring])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b2u</span>(<span class="params">b</span>):    <span class="comment">#bytes转unicode方法 我感觉应该有现成的函数，就是找不到好气，只能写了坨屎山凑合用</span></span><br><span class="line">    length=<span class="built_in">len</span>(b)</span><br><span class="line">    sr=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,length,<span class="number">2</span>):</span><br><span class="line">        b0=<span class="built_in">hex</span>(b[i])</span><br><span class="line">        b1=<span class="built_in">hex</span>(b[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> b0==<span class="string">&#x27;0x0&#x27;</span>:      <span class="comment">#第一位如果是0说明不是中文，中文占2bytes</span></span><br><span class="line">            s1=<span class="built_in">chr</span>(b[i+<span class="number">1</span>])</span><br><span class="line">            sr+=s1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(b0)==<span class="number">4</span>:</span><br><span class="line">                s0=<span class="built_in">str</span>(b0[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s0=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">str</span>(b0[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(b1)==<span class="number">4</span>:</span><br><span class="line">                s1=<span class="built_in">str</span>(b1[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s1=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">str</span>(b1[<span class="number">2</span>])</span><br><span class="line">            s=s0+s1</span><br><span class="line">            result=<span class="string">b&#x27;\x5c\x75&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">                bb=ss.encode()</span><br><span class="line">                result+=bb</span><br><span class="line">            sr+=result.decode(<span class="string">&quot;unicode_escape&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> sr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_lyrics</span>():</span><br><span class="line">    <span class="keyword">global</span> last_lyrics</span><br><span class="line">    raw_bytes=Game.read_bytes(lyrics_addr,lyrics_len)</span><br><span class="line">    use_bytes=raw_bytes.split(<span class="string">b&#x27;\x00\x00&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(use_bytes)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        use_bytes+=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    lyrics_bytes=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,lyrics_len,<span class="number">2</span>):  <span class="comment">#构建bytes 这里高低位需要调换一下顺序</span></span><br><span class="line">        b1=use_bytes[i:i+<span class="number">1</span>]</span><br><span class="line">        b2=use_bytes[i+<span class="number">1</span>:i+<span class="number">2</span>]</span><br><span class="line">        lyrics_bytes+=b2+b1</span><br><span class="line">    <span class="keyword">if</span> last_lyrics!=lyrics_bytes:   <span class="comment">#检查看词是否变化</span></span><br><span class="line">        last_lyrics=lyrics_bytes</span><br><span class="line">        <span class="keyword">return</span> b2u(lyrics_bytes)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendto</span>(<span class="params">lyric</span>):</span><br><span class="line">    quan=stringB2Q(lyric)</span><br><span class="line">    data=quan.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="comment"># tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span><br><span class="line"><span class="comment"># tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span></span><br><span class="line"><span class="comment"># tcp_server.bind((&quot;&quot;, 30960))</span></span><br><span class="line"><span class="comment"># tcp_server.listen(5)</span></span><br><span class="line"><span class="comment"># tcp_client, tcp_client_address= tcp_server.accept()</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    lyrics=get_lyrics()</span><br><span class="line">    <span class="keyword">if</span> lyrics!=<span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(lyrics)</span><br><span class="line">        data_send=sendto(lyrics)</span><br><span class="line">        <span class="comment">#tcp_client.send(data_send)</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>这次真的是爽爆了，完全实时同步，随便切歌，拉进度，歌词永远同步。<br>不过没有彻底完善，比如遇到日文韩文等显示不了，英文强行被我转GBK，很占地方，这个看心情再说吧哈哈哈，懂原理了什么时候解决都不急。</p><h2 id="方案-3：大道至简"><a href="#方案-3：大道至简" class="headerlink" title="方案 3：大道至简"></a>方案 3：大道至简</h2><p>原视频：<a href="https://www.bilibili.com/video/BV1Lm4y1F7h9/?mid=iECBg+o3DW4sut1yMFfFjw==&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【主播必看】OBS捕捉QQ音乐滚动歌词超简单教程！</a></p><p>省流：捕捉播放器窗口，扣掉背景颜色，裁剪一下就行了（</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【永夜Minus/岸晓】最后一页（Cover： 姚晓棠/王赫野）【Synthesizer V Cover】</title>
      <link href="/p/36b252a1/"/>
      <url>/p/36b252a1/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/最后一页_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【永夜Minus、岸晓】最后一页_blg.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《最后一页》</p><p>翻唱：永夜Minus、岸晓</p><p>扒谱：Rean__</p><p>调校：Rean__</p><p>混音：Rean__</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>原唱 : 江语晨</p><p>作词 : 宋健彰</p><p>作曲 : 詹宇豪</p><p>编曲 : David 王大卫&#x2F;王赫野</p><p>制作人 : 王赫野</p><p>合音编写 : 石行@维伴音乐</p><p>音乐总监 : 刘卓@维伴音乐</p><p>音响总监 : 何飚</p><p>音乐混音 : 林梦洋</p><p>人声编辑 : 顾雄</p><p>鼓 : 卢炜@维伴音乐</p><p>打击乐 : 刘效松@维伴音乐</p><p>贝斯 : 李九君@维伴音乐</p><p>吉他 : 崔万平@维伴音乐&#x2F;金天@维伴音乐</p><p>钢琴 : 傅一峥@维伴音乐</p><p>键盘 : 李海郡@维伴音乐</p><p>Program : 郎梓朔@维伴音乐</p><p>合音 : 石行@维伴音乐&#x2F;马思莹@维伴音乐&#x2F;邢晏侨@维伴音乐</p><p>录音 : 黄可爱@维伴音乐</p><p>乐队统筹 : 张伊然@维伴音乐</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>雨停滞天空之间</p><p>像泪在眼眶盘旋</p><p>这也许是最后一次见面</p> <br><p>沿途经过的从前</p><p>还来不及再重演</p><p>拥抱早已悄悄冷却</p> <br><p>海潮声淹没了离别时的黄昏</p><p>只留下不舍的体温</p><p>星空下拥抱着快凋零的温存</p><p>爱只能在回忆里完整</p> <br><p>想把你抱进身体里面</p><p>不敢让你看见</p><p>嘴角那颗没落下的泪</p> <br><p>如果这是最后的一页</p><p>在你离开之前</p><p>能否让我把故事重写</p> <br><p>雨停滞天空之间</p><p>像泪在眼眶盘旋</p><p>这也许是最后一次见面</p> <br><p>沿途经过的从前</p><p>还来不及再重演</p><p>拥抱早已悄悄冷却</p> <br><p>海潮声淹没了离别时的黄昏</p><p>只留下不舍的体温</p><p>星空下拥抱着快凋零的温存</p><p>爱只能在回忆里完整</p> <br><p>想把你抱进身体里面</p><p>不敢让你看见</p><p>嘴角那颗没落下的泪</p> <br><p>如果这是最后的一页</p><p>在你离开之前</p><p>能否让我把故事重写</p> <br><p>想把你抱进身体里面</p><p>不敢让你看见</p><p>嘴角那颗没落下的泪</p> <br><p>如果这是最后的一页</p><p>在你离开之前</p><p>能否让我把故事重写</p> <br><p>能否让我把故事重写</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 永夜Minus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【周深】心同此愿 (live | 典藏)【自修音】【2024金鹰节颁奖晚会】</title>
      <link href="/p/bbd98f0d/"/>
      <url>/p/bbd98f0d/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/周深金鹰节演唱《心同此愿》.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%e3%80%90%e5%91%a8%e6%b7%b1%e3%80%91%e5%bf%83%e5%90%8c%e6%ad%a4%e6%84%bf+(live_%e5%85%b8%e8%97%8f)%e3%80%90%e8%87%aa%e4%bf%ae%e9%9f%b3%e3%80%9150P.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《心同此愿》</p><p>演唱：周深</p><p>词：毕磊</p><p>曲：宋阳</p><p>制作人：宋阳</p><p>编曲：宋阳</p><p>监制：钱雷</p><p>人声编辑：Rean__</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>听 风在轻拂</p><p>金色的稻田 崭新的故土</p><p>伴 云的脚步</p><p>翻越山海的路 等一场奔赴</p><p>生命中的书签 汇聚成了画卷</p><p>将思念沉淀 渐渐温暖</p><p>梦 扬起了帆</p><p>看星光璀璨流水潺潺</p><br><p>是谁轻叹过 又在期盼着</p><p>将温柔瞬间绘成诗歌</p><p>岁月把人间烟火色</p><p>染得平凡又炙热</p><br><p>有一段时光 终此一生不能忘</p><p>不懈地 朝着前进的方向</p><p>一次次用赤诚铸就勋章</p><p>来将这山河点亮</p><br><p>让信仰凝成 一往无前的力量</p><p>带梦想 乘风破浪去翱翔</p><p>愿共你 越千山一路勇往</p><p>愿成为 你的荣光</p><br><p>听 雨在低诉</p><p>芬芳了泥土 遥望的祝福</p><p>伴 雾的追逐</p><p>出发时的山谷 平安等归途</p><p>生命中的书签 汇聚成了画卷</p><p>将思念沉淀 渐渐温暖</p><p>梦 扬起了帆</p><p>看星光璀璨流水潺潺</p><br><p>是谁轻叹过 又在期盼着</p><p>将温柔瞬间绘成诗歌</p><p>岁月把人间烟火色</p><p>染得平凡又炙热</p><br><p>有一段时光 终此一生不能忘</p><p>不懈地 朝着前进的方向</p><p>一次次用赤诚铸就勋章</p><p>来将这山河点亮</p><br><p>让信仰凝成 一往无前的力量</p><p>带梦想 乘风破浪去翱翔</p><p>愿共你 越千山一路勇往</p><p>愿成为 你的荣光</p><br><p>山高水长</p><p>从容四方</p><p>来见证阳光下</p><p>如期的盛况</p><p>不枉</p><p>相聚一场</p><p>再奔向每一个</p><p>滚烫的愿望</p><br><p>有一段时光 终此一生不能忘</p><p>不懈地 朝着前进的方向</p><p>一次次用赤诚铸就勋章</p><p>来将这山河点亮</p><br><p>让信仰凝成一往无前的力量</p><p>带梦想乘风破浪去翱翔</p><p>愿共你 越千山一路勇往</p><p>愿成为 你的荣光</p><br><p>愿你 绿水青山 岁月绵长</p><p>愿你 蓬勃地盛放</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是负载均衡？负载均衡算法有哪些？</title>
      <link href="/p/1b320550/"/>
      <url>/p/1b320550/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h2><p>负载均衡是一种将<strong>网络流量分摊到多台服务器</strong>上的技术，从而提高网站、应用或服务的性能和可靠性。它主要用来<strong>避免单台服务器过载</strong>，提供高可用性和高扩展性。</p><h2 id="为什么需要负载均衡？"><a href="#为什么需要负载均衡？" class="headerlink" title="为什么需要负载均衡？"></a>为什么需要负载均衡？</h2><p>在分布式系统中，服务通常会采用多节点部署的方式，每个节点收到的请求不一样，负载也不相同。如果某个节点的请求过多，就可能导致节点负载过大，从而影响服务的性能和响应速度，而负载均衡就是为了解决这个问题。</p><p>负载均衡可以将请求<strong>平均的分发到多个节点上</strong>，使得每个节点的负载在其可以处理的范围内，从而提高服务的性能和响应速度。</p><h2 id="常见的负载均衡算法"><a href="#常见的负载均衡算法" class="headerlink" title="常见的负载均衡算法"></a>常见的负载均衡算法</h2><ol><li>轮询（Round Robin）：依次将请求分配给每个服务器。</li><li>加权轮询（Weighted Round Robin）：给每台服务器分配一个权重，权重大则分配的请求多。</li><li>最少连接数（Least Connections）：分配请求给当前连接数最少的服务器。</li><li>加权最少连接数（Weighted Least Connections）：综合考虑服务器权重和当前连接数。</li><li>源地址哈希（Source Address Hash）：根据请求的源地址进行哈希计算，将请求分配给固定的服务器，以保证相同源地址的请求被分配到同一台服务器。</li><li>随机算法（Random）：随机选择一台服务器来处理请求。</li></ol><p>我们详细看看一些负载均衡算法的优缺点：</p><ol><li>轮询：它实现非常简单，但是没有考虑服务器的性能差异。适用于性能差异不大的服务器集群。 </li><li>加权轮询：相比单纯的轮询算法，加权轮询能更好地处理性能不均的服务器，通过给更高性能的服务器更多的请求来优化资源利用。</li><li>最少连接数：适用于<strong>长连接</strong>的负载均衡场景，因为它能公平地分摊负载。这种算法考虑了服务器当前的负载情况，更加智能。</li><li>加权最少连接数：结合了加权轮询和最少连接数的优点，适用于性能差异较大的长连接场景。</li><li>源地址哈希：主要优点是可以保证来自同一个客户端的请求总是被分配到同一台服务器，这对于一些需要保持会话状态的应用十分有用。不过，它可能导致负载分布不均，特别是在源地址分布不均的情况下。</li><li>随机算法：简单易实现，适用于服务器性能差异不明显且负载均衡器本身性能较弱时。</li></ol><p>为了实现高性能负载均衡，除了算法的选择，硬件和软件的选择也是关键。常见的负载均衡器有硬件（例如F5、Radware）和软件（例如Nginx、HAProxy、LVS）。每种负载均衡器都有其特定的应用场景和配置方式，选择时需要根据实际业务需求进行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SpringBoot】基础</title>
      <link href="/p/30cd73ca/"/>
      <url>/p/30cd73ca/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h2><p>Spring Boot 是一个简化 Spring 应用程序开发的框架。它的主要目标是减少 Spring 应用程序的配置和开发复杂性，使我们能够更快地构建、测试和部署 Spring 应用。</p><p>简单来说它通过<strong>提供默认配置</strong>、<strong>自动化配置</strong>和<strong>嵌入式服务器</strong>等功能，简化了传统 Spring 应用的繁琐配置过程。</p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>1）自动配置（Auto-Configuration）：</p><p>Spring Boot 会根据项目中的依赖和配置自动配置 Spring 应用程序，无需手动编写大量的配置代码。可以通过 @EnableAutoConfiguration 注解和自动配置类（@Configuration）即可实现。</p><p>2）内嵌 web 服务器：</p><p>Spring Boot 支持嵌入式的 Web 服务器，如 Tomcat、Jetty 和 Undertow，使应用程序无需外部部署服务器，简化了开发和部署流程。</p><p>3）简化的依赖管理：</p><p>Spring Boot 提供了非常多的 starter 依赖，用于简化常见功能的依赖管理。例如 spring-boot-starter-web 包含了开发 Web 应用所需的常见依赖。</p><p>4）Spring Boot CLI：</p><p>Spring Boot CLI 是一个命令行工具，用于快速创建和运行 Spring Boot 应用程序。</p><p>5）Spring Boot Actuator：</p><p>提供了应用程序的监控和管理功能。包括健康检查、度量信息、环境信息等，方便对应用进行监控和管理。</p><p>6）Spring Boot DevTools：</p><p>是一个开发工具，提供热重启、LiveReload 和其他开发环境下的便利功能，可提升开发效率。</p><h2 id="Spring-Boot-的核心特性有哪些？"><a href="#Spring-Boot-的核心特性有哪些？" class="headerlink" title="Spring Boot 的核心特性有哪些？"></a>Spring Boot 的核心特性有哪些？</h2><p>1）开箱即用，内嵌服务器。这个特点是程序员最直观的感受，相较于原本的开发，spring boot 可以省略以前繁琐的 tomcat 配置，快速创建一个 web 容器。</p><p>2）自动化配置。在 spring boot 中我们可以按照自动配置的规定（将自动加载的 bean 写在自己 jar 包当中的 <strong>meta&#x2F;info&#x2F;spring.factories</strong> 文件中或者通过的注解 <strong>@Import</strong> 导入时加载指定的类）这样我们的配置类就会被 springboot 自动加载到容器当中。 <strong>同时还支持通过改写yaml 和 propreties来覆盖默认配置</strong></p><p>3）支持 jar 包运行。传统部署web 容器都是打成 war 包放在 tomcat 中。spring boot 可以打成 jar 包只要有 java 运行环境即可运行 web 容器。</p><p>4）完整的生态支持。springboot 可以随意整合 spring 全家桶的支持。像 Actuator 健康检查模块，Spring Data JPA 数据库模块，Spring Test 测试模块。这些都可以很优雅的集成在 springboot 当中</p><h3 id="扩展知识-1"><a href="#扩展知识-1" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>面试时可以跟面试官说说自己是如何实现一个 spring boot starter 来帮助项目简化某些通用的业务的。</p><p>比如现在项目中有很多列表接口需要导出 excel。我利用自动化配置写了一个 excel 导出模块。</p><p>实现思路如下：</p><p>1)写一个 @ExcelExport 注解，放在列表接口上。利用切面来切列表的返回结果，拿到列表结果后写入 excel 当中。</p><p>2)然后写一个配置类放在 meta&#x2F;info&#x2F;spring.factories 文件下。这样让 spring boot 自动装配我们这个写 excel 文件的处理类。</p><p>3)在整个项目中有需要列表导出 excel 的地方，仅需把注解写在列表接口上即可。</p><p>通过这个例子让面试官相信你有实际使用自动化装配的经验。</p><h2 id="Spring-Boot-是如何通过-main-方法启动-web-项目的？"><a href="#Spring-Boot-是如何通过-main-方法启动-web-项目的？" class="headerlink" title="Spring Boot 是如何通过 main 方法启动 web 项目的？"></a>Spring Boot 是如何通过 main 方法启动 web 项目的？</h2><p>Spring Boot 应用的启动流程都封装在 SpringApplication.run 方法中，它的大部分逻辑都是复用 Spring 启动的流程，只不过在它的基础上做了大量的扩展。</p><p>在启动的过程中有一个刷新上下文的动作，这个方法内会触发 webServer 的创建，此时就会创建并启动内嵌的 web 服务，默认的 web 服务就是 tomcat。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>SpringApplication.run 方法实际上会触发 refreshContext 方法</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/hsfd74h6_image_mianshiya.png"></p><p>最终会调用到 ServletWebServerApplicationContext.onRefresh 方法，这个方法内会调用 createWebServer</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/NE0ZW9sk_image_mianshiya.png"></p><p>createWebServer 从名字就能理解这个方法是干嘛的，可以看到内部通过一个 ServletWebServerFactory 获取 webServer</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/pmINMGHa_image_mianshiya.png"></p><p>默认的 WebServer 是 tomcat，可以看到源码里就是直接 new 了一个 Tomcat，且包装成一个 WebServer：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/GMqmU3iT_image_mianshiya.png"></p><p>实际上这个 getTomcatWebServer 会 new 一个 WebServer：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/g7agvmrK_image_mianshiya.png"></p><p>而 new WebServer 会触发 initialize 方法，这个方法内就会触发 tomcat.start:</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/9yyYVp2I_image_mianshiya.png"></p><p>这个时候 tomcat 就被启动了，web 服务就起来了！</p><p>这里再扩展下，实际上有 5 种 webServer，默认用的是 TomcatWebServer，还有 jetty、undertow 等。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/BMBTGAoY_image_mianshiya.png"></p><h2 id="Spring-Boot-中-application-properties-和-application-yml-的区别是什么？"><a href="#Spring-Boot-中-application-properties-和-application-yml-的区别是什么？" class="headerlink" title="Spring Boot 中 application.properties 和 application.yml 的区别是什么？"></a>Spring Boot 中 application.properties 和 application.yml 的区别是什么？</h2><p>它们两者的区别就在于书写格式，对配置而言效果是一样的，就是个人偏好问题。</p><p>application.properties 使用键值对配置，键和值之间用等号或冒号分隔</p><p>application.yml 使用 YAML （YAML Ain’t Markup Language）格式，具有层级结构，使用缩进表示嵌套关系。适合复杂配置，阅读性更佳。</p><h2 id="SpringBoot-是如何实现自动配置的？"><a href="#SpringBoot-是如何实现自动配置的？" class="headerlink" title="SpringBoot 是如何实现自动配置的？"></a>SpringBoot 是如何实现自动配置的？</h2><p>Spring Boot 的自动配置是通过 <strong><code>@EnableAutoConfiguration</code></strong> 注解实现（<code>@SpringBootApplication</code> 实际上包含了 **<code>@EnableAutoConfiguration</code>**，从而启用了自动配置功能），这个注解包含<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解，导入的这个类会去扫描 classpath 下所有的 <strong><code>META-INF/spring.factories</code></strong> 中的文件，根据文件中指定的配置类加载相应的 Bean 的自动配置。</p><p>这些 Bean 通常会使用 <strong><code>@ConditionalOnClass</code><strong>、</strong><code>@ConditionalOnMissingBean</code><strong>、</strong><code>@ConditionalOnProperty</code></strong> 等条件注解。来控制自动配置的加载条件，例如仅在类路径中存在某个类时，才加载某些配置。</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>1）**<code>@EnableAutoConfiguration</code> 注解**：</p><p>Spring Boot 的自动配置是通过 <strong><code>@EnableAutoConfiguration</code></strong> 注解实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解位于 <code>@SpringBootApplication</code> 中，它导入的 <code>AutoConfigurationImportSelector</code> 会通过扫描类路径中的依赖，根据应用的上下文自动加载配置类，并为应用自动注入合适的 Bean。</p><p>2）**<code>spring.factories</code> 文件**：</p><p>Spring Boot 的自动配置依赖于 <strong><code>META-INF/spring.factories</code></strong> 文件，该文件中列出了所有自动配置类。当 Spring Boot 启动时，它会根据 <code>spring.factories</code> 文件中指定的配置类加载相应的自动配置。</p><p><strong>示例</strong>（<code>spring.factories</code> 文件片段）：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><code>spring.factories</code> 文件的内容是 <code>EnableAutoConfiguration</code> 注解扫描的目标。Spring Boot 会根据应用的环境条件，选择性地加载这些配置类。</p><p>3）<strong>条件注解（Conditional）</strong>：</p><p>自动配置类通常使用 <strong><code>@ConditionalOnClass</code><strong>、</strong><code>@ConditionalOnMissingBean</code><strong>、</strong><code>@ConditionalOnProperty</code></strong> 等条件注解。它们控制自动配置的加载条件，例如仅在类路径中存在某个类时，才加载某些配置。</p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span>  <span class="comment">// 只有类路径中存在 DataSource 时才生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 如果没有自定义 DataSource，则使用默认配置</span></span><br><span class="line">   <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的优先级"><a href="#自动配置的优先级" class="headerlink" title="自动配置的优先级"></a>自动配置的优先级</h3><p>Spring Boot 提供了控制自动配置顺序的机制。可以通过 <strong><code>@AutoConfigureBefore</code></strong> 和 <strong><code>@AutoConfigureAfter</code></strong> 注解，来指定自动配置类的加载顺序。</p><ul><li>**<code>@AutoConfigureBefore</code>**：让当前配置类在指定的配置类之前加载。</li><li>**<code>@AutoConfigureAfter</code>**：让当前配置类在指定的配置类之后加载。</li></ul><h3 id="禁用特定的自动配置"><a href="#禁用特定的自动配置" class="headerlink" title="禁用特定的自动配置"></a>禁用特定的自动配置</h3><p>在某些情况下，Spring Boot 的默认自动配置可能与业务需求不符，可以通过以下方式禁用不需要的自动配置类：</p><p>1）<strong>在 <code>application.properties</code> 中禁用</strong>：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.autoconfigure.exclude</span>=<span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>2）<strong>使用 <code>@SpringBootApplication</code> 注解的 <code>exclude</code> 属性</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       SpringApplication.run(MyApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在-Spring-Boot-中定义和读取自定义配置？"><a href="#如何在-Spring-Boot-中定义和读取自定义配置？" class="headerlink" title="如何在 Spring Boot 中定义和读取自定义配置？"></a>如何在 Spring Boot 中定义和读取自定义配置？</h2><p>简单来看可以有三种:</p><p>1）使用 @Value 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;my.custom.property&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String myProperty;</span><br></pre></td></tr></table></figure><p>2）使用 @ConfigurationProperties 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用 Environment 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;my.custom.property&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-配置文件加载优先级你知道吗？"><a href="#Spring-Boot-配置文件加载优先级你知道吗？" class="headerlink" title="Spring Boot 配置文件加载优先级你知道吗？"></a>Spring Boot 配置文件加载优先级你知道吗？</h2><p>简单优先级：</p><p>命令行参数 &gt; JAR包外面的 <code>application-&#123;profile&#125;.properties</code> &gt; JAR包内的 <code>application-&#123;profile&#125;.properties</code> &gt; JAR包外的 <code>application.properties</code> &gt; JAR包内的 <code>application.properties</code></p><p>注意：</p><p>当 <code>application.properties</code> 和 <code>application.yml</code> 同时存在，同样的参数，<strong>最终生效的是 <code>application.properties</code> 中的配置。</strong></p><h3 id="扩展-bootstrap-和-application-配置文件知识："><a href="#扩展-bootstrap-和-application-配置文件知识：" class="headerlink" title="扩展 bootstrap 和 application 配置文件知识："></a>扩展 bootstrap 和 application 配置文件知识：</h3><p>boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载，且它里面的内容不会被覆盖！</p><p>比如一些配置中心的配置，需要填写在 boostrap 中，父上下文先去配置中心获取额外的一些配置，然后再启动 SpringBoot 上下文。</p><h2 id="SpringBoot-的启动流程？"><a href="#SpringBoot-的启动流程？" class="headerlink" title="SpringBoot 的启动流程？"></a>SpringBoot 的启动流程？</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/435581c288345cb63e23c3e6ca5cbc2f.png"></p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBoot</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringBoot.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure><p>这些注解虽然看起来很多，但是除去元注解，真正起作用的注解只有以下三个注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br></pre></td></tr></table></figure><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br></pre></td></tr></table></figure><p><strong>@SpringBootConfiguration继承自@Configuration，二者功能也一致</strong>，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>@ComponentScan 的作用就是扫描当前包以及子包，将有@Component，@Controller，@Service，@Repository等注解的类注册到容器中，以便调用。</p><p>注：如果@ComponentScan不指定basePackages，那么默认扫描当前包以及其子包，而@SpringBootApplication里的@ComponentScan就是默认扫描，所以我们一般都是把springboot启动类放在最外层，以便扫描所有的类。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>这里先总结下<code>@EnableAutoConfiguration</code>的工作原理，大家后面看的应该会更清晰： 它主要就是通过内部的方法，扫描classpath的META-INF&#x2F;spring.factories配置文件（key-value），将其中的 org.springframework.boot.autoconfigure.EnableAutoConfiguration 对应的配置项实例化并且注册到spring容器。</p><p>ok，我们同样打开@EnableAutoConfiguration源码，可以发现他是由以下几个注解组成的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br></pre></td></tr></table></figure><p>除去元注解，主要注解就是<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code>。我们springboot项目为什么可以自动载入应用程序所需的bean？就是因为这个神奇的注解@Import。那么这个@Import怎么这么牛皮？没关系！我们一步一步的看下去！</p><p>首先我们先进入AutoConfigurationImportSelector类，可以看到他有一个方法selectImports()</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/b111ca10ac896777d9242e7b360439e2.png"></p><p>继续跟踪，进入getAutoConfigurationEntry()方法，可以看到这里有个List集合，那这个List集合又是干嘛的？没事，我们继续跟踪getCandidateConfigurations()方法！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1f5f2ed7e763d8d38de44a3a46f1c7b2.png"></p><p>可以看到这里有个方法，这个方法的作用就是读取classpath下的META-INF&#x2F;spring.factories文件的配置，将key为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 对应的配置项读取出来，通过反射机制实例化为配置文件，然后注入spring容器。</p><p>注：假如你想要实例化一堆bean，可以通过配置文件先将这些bean实例化到容器，等其他项目调用时，在spring.factories中写入这个配置文件的路径即可！</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-85c8d9dbbc27fc649b3a7c1d32f9152d_1440w.webp"></p><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication.run()"></a>SpringApplication.run()</h3><h4 id="SpringApplication创建"><a href="#SpringApplication创建" class="headerlink" title="SpringApplication创建"></a>SpringApplication创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="comment">//获取应用类型</span></span><br><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"><span class="comment">//获取所有初始化器</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">//获取所有监听器</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="comment">//定位main方法</span></span><br><span class="line"><span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取应用类型"><a href="#获取应用类型" class="headerlink" title="获取应用类型"></a>获取应用类型</h4><p>跟踪deduceFromClasspath方法：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1970379914c789f3ed35d5713622055f.png"></p><p> 从返回结果我们可以看出应用类型一共有三种，分别是</p><ul><li>NONE： 非web应用，即不会启动服务器</li><li>SERVLET： 基于servlet的web应用</li><li>REACTIVE： 响应式web应用（暂未接触过）</li></ul><p>判断一共涉及四个常量：</p><ul><li>WEBFLUX_INDICATOR_CLASS</li><li>WEBMVC_INDICATOR_CLASS</li><li>JERSEY_INDICATOR_CLASS</li><li>SERVLET_INDICATOR_CLASSES</li></ul><p>springboot在初始化容器的时候，会对以上四个常量所对应的class进行判断，看看他们是否存在，从而返回应用类型！</p><h4 id="获取初始化器"><a href="#获取初始化器" class="headerlink" title="获取初始化器"></a>获取初始化器</h4><p>跟踪进入getSpringFactoriesInstances方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line"><span class="comment">//获取所有初始化器的名称集合</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line"><span class="comment">//根据名称集合实例化这些初始化器</span></span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出是在META-INF&#x2F;spring.factories配置文件里获取初始化器，然后实例化、排序后再设置到initializers属性中</p><h4 id="获取初监听器"><a href="#获取初监听器" class="headerlink" title="获取初监听器"></a>获取初监听器</h4><p>监听器和初始化的操作是基本一样的</p><h4 id="定位main方法"><a href="#定位main方法" class="headerlink" title="定位main方法"></a>定位main方法</h4><p>跟踪源码进入deduceMainApplicationClass方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//通过创建运行时异常的方式获取栈</span></span><br><span class="line">StackTraceElement[] stackTrace = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>().getStackTrace();</span><br><span class="line"><span class="comment">//遍历获取main方法所在的类并且返回</span></span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line"><span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="comment">// Swallow and continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建小结"><a href="#创建小结" class="headerlink" title="创建小结"></a>创建小结</h4><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-4924a4480ae4b6b01a7e7157640c26e5_1440w.webp"></p><p>创建了SpringApplication实例之后，就完成了SpringApplication类的初始化工作，这个实例里包括监听器、初始化器，项目应用类型，启动类集合，类加载器。如图所示。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-26f8cb6b01474529d370b8c150657f81_1440w.webp"></p><h4 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、创建并启动计时监控类</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">//2、初始化应用上下文和异常报告集合</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//3、设置系统属性“java.awt.headless”的值，默认为true，用于运行headless服务器，进行简单的图像处理，多用于在缺少显示屏、键盘或者鼠标时的系统配置，很多监控工具如jconsole 需要将该值设置为true</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//4、创建所有spring运行监听器并发布应用启动事件，简单说的话就是获取SpringApplicationRunListener类型的实例（EventPublishingRunListener对象），并封装进SpringApplicationRunListeners对象，然后返回这个SpringApplicationRunListeners对象。说的再简单点，getRunListeners就是准备好了运行时监听器EventPublishingRunListener。</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5、初始化默认应用参数类</span></span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">        <span class="comment">//6、根据运行监听器和应用参数来准备spring环境</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="comment">//将要忽略的bean的参数打开</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">//7、创建banner打印类</span></span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">        <span class="comment">//8、创建应用上下文，可以理解为创建一个容器</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">//9、准备异常报告器，用来支持报告关于启动的错误</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        <span class="comment">//10、准备应用上下文，该步骤包含一个非常关键的操作，将启动类注入容器，为后续开启自动化提供基础</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//11、刷新应用上下文</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">//12、应用上下文刷新后置处理，做一些扩展功能</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">//13、停止计时监控类</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">//14、输出日志记录执行主类名、时间信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//15、发布应用上下文启动监听事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">//16、执行所有的Runner运行器</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//17、发布应用上下文就绪事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//18、返回应用上下文</span></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-e6e9f5cc5affbee1748e72788c9db978_1440w.webp"></p><h2 id="如何在-SpringBoot-启动时执行特定代码？有哪些方式？"><a href="#如何在-SpringBoot-启动时执行特定代码？有哪些方式？" class="headerlink" title="如何在 SpringBoot 启动时执行特定代码？有哪些方式？"></a>如何在 SpringBoot 启动时执行特定代码？有哪些方式？</h2><p>常见一共有六种方式：</p><h4 id="1、实现-CommandLineRunner-接口"><a href="#1、实现-CommandLineRunner-接口" class="headerlink" title="1、实现 CommandLineRunner 接口"></a>1、实现 CommandLineRunner 接口</h4><p>CommandLineRunner 接口用于在 Spring Boot 应用启动完成后，执行特定的代码逻辑。可以有多个实现类，按照 @Order 注解的顺序执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Application started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实现-ApplicationRunner-接口"><a href="#2、实现-ApplicationRunner-接口" class="headerlink" title="2、实现 ApplicationRunner 接口"></a>2、实现 ApplicationRunner 接口</h4><p>ApplicationRunner 接口与 CommandLineRunner 类似，但可以接受和处理 ApplicationArguments 对象。</p><p>ApplicationArguments 其实就是获取应用程序启动参数。</p><p>例如 idea 可以在这里配置启动参数：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/4Q1C7crO_image_mianshiya.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner: started with arguments: &quot;</span> + args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、使用-PostConstruct-注解"><a href="#3、使用-PostConstruct-注解" class="headerlink" title="3、使用 @PostConstruct 注解"></a>3、使用 @PostConstruct 注解</h4><p>Spring 容器初始化 bean 后，会执行初始化方法。这个注解适用于需要在 bean 初始化后立即执行的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostConstructBean</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PostConstruct: Bean initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、使用-InitializingBean-接口"><a href="#4、使用-InitializingBean-接口" class="headerlink" title="4、使用 InitializingBean 接口"></a>4、使用 InitializingBean 接口</h4><p>InitializingBean 接口提供了 afterPropertiesSet 方法，用于在 Spring 容器初始化 bean 的属性后，执行特定的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInitializingBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBean: Properties set!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、使用-Spring-事件监听器"><a href="#5、使用-Spring-事件监听器" class="headerlink" title="5、使用 Spring 事件监听器"></a>5、使用 Spring 事件监听器</h4><p>可以通过监听 Spring 的 ContextRefreshedEvent 期事件，在应用启动时执行特定代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EventListener: Context refreshed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、自定义-BeanFactoryPostProcessor-和-BeanPostProcessor"><a href="#6、自定义-BeanFactoryPostProcessor-和-BeanPostProcessor" class="headerlink" title="6、自定义 BeanFactoryPostProcessor 和 BeanPostProcessor"></a>6、自定义 BeanFactoryPostProcessor 和 BeanPostProcessor</h4><p>它们都是 Spring 容器启动给的扩展点，可以在 Spring 容器初始化 bean 之前或之后执行特定逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="comment">// bean 初始化前</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: Before initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="comment">// bean 初始化后</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: After initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h2><p>Spring Boot 打成的 JAR 包不仅包含了应用程序的源代码和依赖库，还包含了程序运行需要的<strong>配置、脚本和服务依赖</strong>（内嵌的服务器如 Tomcat、Jetty、Undertow），可以直接部署运行。</p><p>普通的 JAR 包只有源代码和一些依赖，通常需要外部服务器或容器来运行。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/450295684#:~:text=SpringBoot">SpringBoot启动都做了什么？看完就懂了！ - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/2402940">Spring Boot：最全SpringBoot启动流程原理分析(全网最全最完善)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【曹杨】如果你也听说 (live | 典藏)【自修音】【下一战歌手】</title>
      <link href="/p/332adb42/"/>
      <url>/p/332adb42/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/202409272158556472419.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%e3%80%90%e6%9b%b9%e6%9d%a8%e3%80%91%e5%a6%82%e6%9e%9c%e4%bd%a0%e4%b9%9f%e5%90%ac%e8%af%b4+(live+_+%e5%85%b8%e8%97%8f)%e3%80%90%e8%87%aa%e4%bf%ae%e9%9f%b3%e3%80%91.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《如果你也听说》</p><p>演唱：曹杨</p><p>作词 : 李焯雄</p><p>作曲 : 周杰伦</p><p>原唱 : 张惠妹</p><p>音乐总监 : 梁翘柏</p><p>音响总监 : 何飚</p><p>制作人 : 梁翘柏</p><p>改编编曲 : Johnny Yim</p><p>人声编辑：Rean__</p><p>混音 : 林梦洋</p><p>乐队队长&#x2F;键盘 : 达日丹</p><p>键盘 : 叶霖</p><p>吉他 : 黄仲贤&#x2F;劳国贤</p><p>贝斯 : Sylvain Gagnon</p><p>鼓 : Chris Trzcinski</p><p>打击乐 : 王宏涛</p><p>长号 : Ben</p><p>次中音萨克斯 &#x2F; 长笛 : Charlie</p><p>小号 : Ray</p><p>弦乐 : 靳海音®弦乐团</p><p>声乐指导&#x2F;和音 : 刘芳</p><p>和音 : 胡维纳&#x2F;付垚&#x2F;李郡洲</p><p>PGM : 杨阳</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>突然发现站了好久</p><p>不知道要往哪走</p><p>还不想回家的我</p><p>再多人陪 只会更寂寞</p><br> <p>许多话题 关于我</p><p>就连我 也有听过</p><p>我的快乐 要被认可</p><p>委屈却没有人诉说</p><br><p>夜把心洋葱般剥落</p><p>拿掉防卫 剩下什么</p><p>为什么脆弱时候 想你更多</p><br><p>如果你也听说 有没有想过我</p><p>像普通旧朋友</p><p>还是你依然会心疼我</p><p>好多好多的话想对你说</p><p>悬着一颗心没着落</p><p>要怎么附和 舍不得 又无可奈何</p><br><p>如果你也听说 会不会相信我</p><p>对流言会附和</p><p>还是你知道我还是我</p><p>跌跌撞撞才明白了许多</p><p>懂我的人就你一个</p><p>想到你想起我 胸口依然温热</p><br><p>许多话题 关于我</p><p>就连我 也有听过</p><p>我想我宁可都沉默</p><p>解释反而 显得做作</p><br><p>夜把心洋葱般剥落</p><p>拿掉防卫 剩下什么</p><p>为什么脆弱时候 想你更多</p><br><p>如果你也听说 有没有想过我</p><p>像普通旧朋友</p><p>还是你依然会心疼我</p><p>好多好多的话想对你说</p><p>悬着一颗心没着落</p><p>要怎么附和 舍不得 又无可奈何</p><br><p>如果你也听说 会不会相信我</p><p>对流言会附和</p><p>还是你知道我还是我</p><p>跌跌撞撞 才明白了许多</p><p>懂我的人就你一个</p><p>想到你想起我 胸口依然温热</p><br><p>如果你也听说 有没有想过我</p><p>像普通旧朋友 还是你依然会心疼我</p><p>跌跌撞撞才明白了许多</p><p>懂我的人就你一个</p><p>想到你想起我 胸口依然温热</p><br><p>如果你想起我 你会想到什么</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曹杨 </tag>
            
            <tag> 下一战歌手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】集合（三） | 集合类源码</title>
      <link href="/p/4f877c1e/"/>
      <url>/p/4f877c1e/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><ul><li><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</li><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h2 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h2><h3 id="先从-ArrayList-的构造函数说起"><a href="#先从-ArrayList-的构造函数说起" class="headerlink" title="先从 ArrayList 的构造函数说起"></a>先从 ArrayList 的构造函数说起</h3><p>ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">        <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一步一步分析-ArrayList-扩容机制"><a href="#一步一步分析-ArrayList-扩容机制" class="headerlink" title="一步一步分析 ArrayList 扩容机制"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 <code>ArrayList</code> 为例分析。</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p><p><code>ensureCapacityInternal</code> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保内部容量达到指定的最小容量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 <code>add</code> 进第 1 个元素到 <code>ArrayList</code> 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 <code>add</code> 第 2 个元素时，<code>minCapacity</code> 为 2，此时 <code>elementData.length</code>(容量)在添加第一个元素后扩容成 <code>10</code> 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a>grow 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法：</strong></p><ul><li>当 <code>add</code> 第 1 个元素时，<code>oldCapacity</code> 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>(为 10)。但是第二个 if 判断不会成立，即 <code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code> 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，<code>add</code> 方法中 return true，size 增为 1。</li><li>当 <code>add</code> 第 11 个元素进入 <code>grow</code> 方法时，<code>newCapacity</code> 为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 <code>hugeCapacity</code> 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a>hugeCapacity() 方法</h4><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3><p>阅读源码的话，我们就会发现 <code>ArrayList</code> 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h4 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><a href="#system-arraycopy-%E6%96%B9%E6%B3%95"><code>System.arraycopy()</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><h4 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="comment">// 申请一个新的数组</span></span><br><span class="line">      <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">      System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                       Math.min(original.length, newLength));</span><br><span class="line">      <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h4><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="LinkedList-简介"><a href="#LinkedList-简介" class="headerlink" title="LinkedList 简介"></a>LinkedList 简介</h2><p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p>另外，不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code>LinkedList</code> 仅仅在<strong>头尾</strong>插入或者删除元素的时候时间复杂度近似 O(1)，<strong>其他情况增删元素的平均时间复杂度都是 O(n)</strong> 。</p><h2 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h2><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有<strong>双端队列</strong>的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 “deck” [dɛk]，这个大部分人都会读错。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p><p>我们这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p><p><code>add()</code> 方法有两个版本：</p><ul><li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li><li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表指定位置插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 index 是不是链表尾部位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素节点插入到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 将最后一个元素赋值（引用传递）给节点 l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将 last 引用指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空</span></span><br><span class="line">    <span class="comment">// 如果 l 是null 意味着这是第一次添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定元素之前插入元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;断言 succ不为 null</span></span><br><span class="line">    <span class="comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化节点，并指明前驱和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将 succ 节点前驱引用 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断前驱节点是否为空，为空表示 succ 是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 新节点成为第一个节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// succ 节点前驱的后继引用指向新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p><ol><li><code>getFirst()</code>：获取链表的第一个元素。</li><li><code>getLast()</code>：获取链表的最后一个元素。</li><li><code>get(int index)</code>：获取链表指定位置的元素。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="comment">// 返回链表中对应下标的元素</span></span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心在于 <code>node(int index)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定下标的非空节点</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言下标未越界</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之从后向前查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 遍历，循环向后查找，直至 i == index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p><p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p><ol><li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除并返回链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除并返回链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为 null ,遍历链表找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言 x 不为 null</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 获取当前节点（也就是待删除节点）的元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点为空，则说明当前节点是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表头指向当前节点的下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个节点为空，则说明当前节点是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表尾指向当前节点的前一个节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果下一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点元素置为 null，方便 GC 回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unlink()</code> 方法的逻辑如下：</p><ol><li>首先获取待删除节点 x 的前驱和后继节点；</li><li>判断待删除节点是否为头节点或尾节点： <ul><li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li><li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li><li>如果 x 不是头节点也不是尾节点，执行下一步操作</li></ul></li><li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li><li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li><li>将待删除节点 x 的元素置空，修改链表长度。</li></ol><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。<code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">    <span class="comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p><p>我们先来看下从头到尾方向的迭代：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span></span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取下一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查在迭代过程中链表是否被修改过</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 指向当前节点</span></span><br><span class="line">    lastReturned = next;</span><br><span class="line">    <span class="comment">// 将 next 指向下一个节点</span></span><br><span class="line">    next = next.next;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下从尾到头方向的迭代：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有前一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否在迭代过程中链表被修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 如果没有前一个节点，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 和 next 指针指向上一个节点</span></span><br><span class="line">    lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器对应的移除元素的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从列表中删除上次被返回的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否在迭代过程中链表被修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 如果上次返回的节点为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">    <span class="comment">// 从链表中删除上次返回的节点</span></span><br><span class="line">    unlink(lastReturned);</span><br><span class="line">    <span class="comment">// 修改指针</span></span><br><span class="line">    <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">        next = lastNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextIndex--;</span><br><span class="line">    <span class="comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span></span><br><span class="line">    lastReturned = <span class="literal">null</span>;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note  flat"><p>值得注意的是上述四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor 将其扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</p></div><p><strong>putMapEntries 方法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 未初始化，s为m的实际元素个数，ft=s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span></span><br><span class="line"><span class="comment">             * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span></span><br><span class="line"><span class="comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span></span><br><span class="line"><span class="comment">             * 注意这里不是初始化阈值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并<strong>没有提供给用户使用</strong>。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/put.png" alt="putVal方法"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h4><p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">ArrayList 源码分析 | JavaGuide</a></p><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html#jdk1-8-%E4%B9%8B%E5%90%8E">HashMap 源码分析 | JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【曹杨】多远都要在一起 (live | 典藏)【自修音】【下一战歌手】</title>
      <link href="/p/677c7789/"/>
      <url>/p/677c7789/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/202409202055008277180.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%e3%80%90%e6%9b%b9%e6%9d%a8%e3%80%91%e5%a4%9a%e8%bf%9c%e9%83%bd%e8%a6%81%e5%9c%a8%e4%b8%80%e8%b5%b7+(live+%e5%85%b8%e8%97%8f)%e3%80%90%e8%87%aa%e4%bf%ae%e9%9f%b3%e3%80%91+.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《多远都要在一起》</p><p>演唱：曹杨</p><p>作词 : G.E.M.邓紫棋</p><p>作曲 : G.E.M.邓紫棋</p><p>原唱 : G.E.M.邓紫棋</p><p>音乐总监 : 梁翘柏</p><p>音响总监 : 何飚</p><p>制作人 : 梁翘柏</p><p>改编编曲 : Johnny Yim</p><p>人声编辑：Rean__</p><p>混音 : 林梦洋</p><p>乐队队长&#x2F;键盘 : 达日丹</p><p>键盘 : 白宇轩</p><p>吉他 : 金冬昱&#x2F;许德治</p><p>贝斯 : Sylvain Gagnon</p><p>鼓 : Chris Trzcinski</p><p>打击乐 : 王宏涛</p><p>长号 : Ben</p><p>次中音萨克斯&#x2F; 长笛 : Charlie</p><p>小号 : Ray</p><p>弦乐 : 靳海音®弦乐团</p><p>声乐指导&#x2F;和音 : 刘芳</p><p>和音 : 林灵&#x2F;付垚&#x2F;鱼椒盐</p><p>PGM : 杨阳</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>想听你听过的音乐</p><p>想看你看过的小说</p><p>我想收集每一刻</p><p>我想看到你眼里的世界</p><br><p>想到你到过的地方</p><p>和你曾渡过的时光</p><p>不想错过每一刻</p><p>多希望我一直在你身旁</p><br><p>未来何从何去</p><p>你快乐我也就没关系</p><p>对你我最熟悉</p><p>你爱自由我却更爱你</p><br><p>我能习惯远距离</p><p>爱总是身不由己</p><p>宁愿换个方式至少还能</p><p>遥远爱着你</p><br><p>爱能克服远距离</p><p>多远都要在一起</p><p>你已经不再存在我世界里</p><p>请不要离开我的回忆</p><br><p>想你说爱我的语气</p><p>想你望着我的眼睛</p><p>不想忘记每一刻</p><p>用思念让我们一直前进</p><br><p>想像你失落的唇印</p><p>想像你失约的旅行</p><p>想像你离开的一刻</p><p>如果我有留下你的勇气</p><br><p>我能习惯远距离</p><p>爱总是身不由己</p><p>宁愿换个方式至少还能</p><p>遥远爱着你</p><br><p>爱能克服远距离</p><p>多远都要在一起</p><p>我已经不再存在你的心里</p><p>就让我独自守着回忆</p><p>如果阳光永远都炽热</p><p>如果彩虹不会掉颜色</p><p>你能不能不离开呢</p><br><p>我能习惯远距离</p><p>爱总是身不由己</p><p>宁愿换个方式至少还能</p><p>遥远爱着你</p><br><p>爱能克服远距离</p><p>多远都要在一起</p><p>你已经不再存在我世界里</p><p>请不要离开我的回忆</p><p>请不要离开</p><p>不要离开我的回忆</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> 曹杨 </tag>
            
            <tag> 下一战歌手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证接口幂等性？</title>
      <link href="/p/f7f0a5f3/"/>
      <url>/p/f7f0a5f3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是接口幂等性？"><a href="#什么是接口幂等性？" class="headerlink" title="什么是接口幂等性？"></a>什么是接口幂等性？</h2><p>幂等性原本是数学上的概念，用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次。调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。</p><p>比如下面这些情况，如果没有实现接口幂等性会有很严重的后果：支付接口，重复支付会导致多次扣钱 ；订单接口，同一个订单可能会多次创建。</p><h2 id="什么情况下会产生接口幂等性的问题？"><a href="#什么情况下会产生接口幂等性的问题？" class="headerlink" title="什么情况下会产生接口幂等性的问题？"></a>什么情况下会产生接口幂等性的问题？</h2><ul><li><p>网络波动, 可能会引起重复请求</p></li><li><p>用户重复操作,用户在操作时候可能会无意触发多次下单交易,甚至没有响应而有意触发多次交易应用</p></li><li><p>使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等)</p></li><li><p>页面重复刷新</p></li><li><p>使用浏览器后退按钮重复之前的操作,导致重复提交表单</p></li><li><p>使用浏览器历史记录重复提交表单</p></li><li><p>浏览器重复的HTTP请求</p></li><li><p>定时任务重复执行</p></li><li><p>用户双击提交按钮</p></li><li><p>……</p></li></ul><h2 id="如何保证接口幂等性？"><a href="#如何保证接口幂等性？" class="headerlink" title="如何保证接口幂等性？"></a>如何保证接口幂等性？</h2><p>解决办法分为两个方向，一个方向是<a href="https://so.csdn.net/so/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&spm=1001.2101.3001.7020">客户端</a>防止重复调用，一个是服务端进行校验。当然，客户端防止重复提交并不是绝对可靠的，优点是实现起来比较简单。</p><h3 id="按钮只可操作一次"><a href="#按钮只可操作一次" class="headerlink" title="按钮只可操作一次"></a>按钮只可操作一次</h3><p>一般是提交后把按钮置灰或 loading 状态，消除用户因为重复点击而产生的重复记录，比如添加操作，由于点击两次而产生两条记录。</p><h3 id="Token-机制"><a href="#Token-机制" class="headerlink" title="Token 机制"></a>Token 机制</h3><p>功能上允许重复提交，但要保证重复提交不产生副作用，比如点击 n 次只产生一条记录。</p><p>具体实现就是进入页面时申请一个 Token，然后后面所有的请求都带上这个 Token，后端根据Token来避免重复请求。</p><h3 id="使用Post-Redirect-Get模式"><a href="#使用Post-Redirect-Get模式" class="headerlink" title="使用Post&#x2F;Redirect&#x2F;Get模式"></a>使用Post&#x2F;Redirect&#x2F;Get模式</h3><p>在提交后执行页面重定向，这就是所谓的<code>Post-Redirect-Get (PRG)</code>模式。</p><p>简单来说就是当用户提交表单后，跳转到一个重定向的信息页面，这样就避免用户按F5刷新导致的重复提交，而且也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退导致同样重复提交的问题。</p><h3 id="在-Session-存放特殊标志"><a href="#在-Session-存放特殊标志" class="headerlink" title="在 Session 存放特殊标志"></a>在 Session 存放特殊标志</h3><p>在服务端，生成一个唯一的标识符，将它存入session，同时前端获取这个标识符的值将它写入表单的隐藏中，用于用户输入信息后点击一起提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除，不相等则表示是重复提交，不再做处理。</p><h3 id="使用唯一索引防止新增脏数据"><a href="#使用唯一索引防止新增脏数据" class="headerlink" title="使用唯一索引防止新增脏数据"></a>使用唯一索引防止新增脏数据</h3><p>利用数据库唯一索引机制，当数据重复时，插入数据库会抛出异常，保证不会出现脏数据。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>如果更新已有数据，可以进行加锁更新，也可以设计表结构时使用乐观锁，通过version来做乐观锁，这样既能保证执行效率，又能保证幂等，乐观锁的version版本在更新业务数据要自增。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set version = version + 1 where id = #&#123;id&#125; and version = #&#123;version&#125;</span><br></pre></td></tr></table></figure><p>示例：当有重复请求的时候，第一个请求会获取当前商品的version版本号，得到的version为1，紧接着由于第一个请求还没更新商品的version，第二个请求获取的version依然也是1，这时候第一个请求操作更新的时候带上version并作为条件并且自增更新，这时候商品的version就会变成2，当第二个请求去操作更新的时候明显version不一致导致更新失败。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select + insert or update or delete</span><br></pre></td></tr></table></figure><p>该方案就是操作之前先查询一下，符合要求再插入，该方案在没有并发的系统中可以解决幂等问题，在单JVM有并发的时候可以用JVM加锁来保证幂等性，在分布式环境它是无法保证幂等性，可以使用分布式来保证。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统（redis 或 zookeeper），在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志（用户ID+后缀等）获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁（分布式锁要第三方系统提供）。</p><h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机（状态变更图），就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助 。</p><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>以支付为例：使用唯一主键去做防重表的唯一索引，比如使用订单号作为防重表的唯一索引，每一次请求都根据订单号向防重表中插入一条数据，插入成功说明可以处理后面的业务，当处理完业务逻辑之后删除防重表中的订单号数据，后续如果有重复请求，则会因为防重表唯一索引原因导致插入失败，直接返回操作失败，直到第一次请求返回结果，可以看出防重表作用就是加锁的功能。<br>注：最好结合状态机幂等先判断一下</p><h3 id="缓冲队列"><a href="#缓冲队列" class="headerlink" title="缓冲队列"></a>缓冲队列</h3><p>将请求都快速地接收下来后放入缓冲队列中，后续使用异步任务处理队列中的数据，过滤掉重复的请求，该解决方案优点是同步处理改成异步处理、高吞吐量，缺点则是不能及时地返回请求结果，需要后续轮询得处理结果。</p><h3 id="全局唯一号"><a href="#全局唯一号" class="headerlink" title="全局唯一号"></a>全局唯一号</h3><p>比如通过source来源 + 唯一序列号传入给后端，后端来判断请求是否重复，在并发时只能处理一个请求，其他相同并发请求要么返回请求重复，要么等待前面请求执行完成后再执行。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/zy_dreamer/article/details/139910885">面试官：如何保证接口幂等性？一口气说了12种方法！-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【应用服务器】Tomcat</title>
      <link href="/p/9b5a538c/"/>
      <url>/p/9b5a538c/</url>
      
        <content type="html"><![CDATA[<h2 id="描述-Tomcat-服务器的架构及其工作原理。"><a href="#描述-Tomcat-服务器的架构及其工作原理。" class="headerlink" title="描述 Tomcat 服务器的架构及其工作原理。"></a>描述 Tomcat 服务器的架构及其工作原理。</h2><p>Tomcat 是一个开源的 Java Servlet 容器，适用于在生产环境中部署和执行 Java Web 应用。它是由 Apache 软件基金会开发和维护的。Tomcat 服务器的架构分为几个核心组件，其中包括 Catalina、Coyote 和 Jasper。</p><ol><li>Catalina: 这是 Tomcat 的 Servlet 容器，它实现了 Servlet 和 JSP 规范。Catalina 负责管理 Servlet 的生命周期，处理 HTTP 请求。</li><li>Coyote: 这是 Tomcat 的 HTTP 连接器，它所承担的任务是从客户端接收请求并将其交给 Catalina 进行处理，然后将响应返回给客户端。</li><li>Jasper: 这是 Tomcat 的 JSP 引擎，用于将 JSP 转换为 Servlet 并进行编译和执行。</li></ol><p>请求处理流程：</p><ol><li>请求到达 Coyote HTTP 连接器。</li><li>Coyote 创建一个合适的 Request 和 Response 对象，然后将其传递给 Catalina 进行处理。</li><li>Catalina 根据请求 URL，找到相对应的 Servlet，通过包括生命周期管理来处理请求，生成响应。 </li><li>最后，响应通过 Coyote 返回到客户端。</li></ol><h2 id="描述在-Tomcat-中如何配置数据源连接池。"><a href="#描述在-Tomcat-中如何配置数据源连接池。" class="headerlink" title="描述在 Tomcat 中如何配置数据源连接池。"></a>描述在 Tomcat 中如何配置数据源连接池。</h2><p>在 Tomcat 中配置数据源连接池是一项常见的任务，它能够提高数据库连接的管理效率，提升应用性能。具体步骤如下：</p><p>1）首先，你需要将 JDBC 驱动包放置到 Tomcat 服务器的 <code>lib</code> 目录下。比如，如果你使用的是 MySQL 数据库，那么你需要下载 MySQL Connector&#x2F;J 并将其放入 <code>TOMCAT_HOME/lib</code> 目录。</p><p>2）接着，编辑 Tomcat 的全局配置文件 <code>context.xml</code> 或者是具体应用的 <code>context.xml</code> 文件。在这里配置你的数据源。以下是一个配置示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;jdbc/MyDB&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxTotal</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxIdle</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxWaitMillis</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">username</span>=<span class="string">&quot;yourUsername&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">password</span>=<span class="string">&quot;yourPassword&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">driverClassName</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/yourDatabase&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个配置中：</p><ul><li><code>name</code> 是数据源的名称。</li><li><code>auth</code> 通常为 “Container”。</li><li><code>type</code> 表示这是一个数据源（<code>javax.sql.DataSource</code>）。</li><li><code>maxTotal</code> 是连接池的最大连接数。</li><li><code>maxIdle</code> 是连接池中最大空闲连接数。</li><li><code>maxWaitMillis</code> 是获取连接的最大等待时间。</li><li><code>username</code> 和 <code>password</code> 是数据库的用户名和密码。</li><li><code>driverClassName</code> 是 JDBC 驱动的类名。</li><li><code>url</code> 是数据库的连接 URL。</li></ul><p>3）在你的 Java 应用程序中，通过 JNDI 查找数据源。如下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">initContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">Context</span> <span class="variable">envContext</span>  <span class="operator">=</span> (Context)initContext.lookup(<span class="string">&quot;java:/comp/env&quot;</span>);</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)envContext.lookup(<span class="string">&quot;jdbc/MyDB&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line"><span class="comment">// ... use this connection to interact with your database</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Boot中内置Tomcat最大连接数、线程数与等待数"><a href="#Spring-Boot中内置Tomcat最大连接数、线程数与等待数" class="headerlink" title="Spring Boot中内置Tomcat最大连接数、线程数与等待数"></a>Spring Boot中内置Tomcat最大连接数、线程数与等待数</h2><h3 id="Spring-Boot应用中Tomcat建议配置"><a href="#Spring-Boot应用中Tomcat建议配置" class="headerlink" title="Spring Boot应用中Tomcat建议配置"></a>Spring Boot应用中Tomcat建议配置</h3><p>Spring Boot 能支持的最大并发量主要看其对Tomcat的设置，可以在配置文件中对其进行更改。要了解具体参数的默认值，一个<strong>简单的方法是</strong>在application.properties 配置文件中输入配置项，默认值就会显示出来。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">最大工作线程数，默认200。</span></span><br><span class="line"><span class="string">server.tomcat.max-threads=200</span></span><br><span class="line"> </span><br><span class="line"><span class="string">最大连接数默认是10000</span></span><br><span class="line"><span class="string">server.tomcat.max-connections=10000</span></span><br><span class="line"> </span><br><span class="line"><span class="string">等待队列长度，默认100。</span></span><br><span class="line"><span class="string">server.tomcat.accept-count=100</span></span><br><span class="line"> </span><br><span class="line"><span class="string">最小工作空闲线程数，默认10。</span></span><br><span class="line"><span class="string">server.tomcat.min-spare-threads=100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是限流？限流算法有哪些？</title>
      <link href="/p/37360bc0/"/>
      <url>/p/37360bc0/</url>
      
        <content type="html"><![CDATA[<h2 id="限流是什么？"><a href="#限流是什么？" class="headerlink" title="限流是什么？"></a>限流是什么？</h2><p>在不同场景下「流」的定义不同，可以是每秒请求数、每秒事务处理数、网络流量等等。</p><p>而通常我们说的限流指代的是 <strong>限制到达系统的并发请求数</strong>，使得系统能够正常的处理 <strong>部分</strong> 用户的请求，来保证系统的稳定性。</p><p>限流不可避免的会造成用户的请求变慢或者被拒的情况，从而会影响用户体验。</p><p>因此限流是需要在用户体验和系统稳定性之间做平衡的，即我们常说的 <code>trade off</code>。</p><p>对了，限流也称流控（流量控制）。</p><h2 id="为什么要限流？"><a href="#为什么要限流？" class="headerlink" title="为什么要限流？"></a>为什么要限流？</h2><p>前面，我们提到限流是为了保证系统的稳定性。</p><p>日常的业务上有类似<strong>秒杀活动、双十一大促或者突发新闻</strong>等场景，用户的流量突增，<strong>后端服务的处理能力是有限的</strong>，如果不能处理好突发流量，后端服务很容易就被打垮。</p><p>亦或是爬虫等<strong>不正常流量</strong>，我们对外暴露的服务都要以<strong>最大恶意去防备</strong>调用者。</p><p>我们不清楚调用者会如何调用我们的服务，假设某个调用者开几十个线程一天二十四小时疯狂调用你的服务，如果不做啥处理咱服务也算完了，更胜的还有DDos攻击。</p><p>还有对于很多第三方开放平台来说，不仅仅要防备不正常流量，还要保证资源的公平利用，一些接口都免费给你用了，资源都不可能一直都被你占着吧，别人也得调的。</p><p>所以，限流的本质是因为后端处理能力有限，需要截掉超过处理能力之外的请求，亦或是为了均衡客户端对服务端资源的公平调用，防止一些客户端饿死。</p><h2 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h2><h3 id="计数限流"><a href="#计数限流" class="headerlink" title="计数限流"></a>计数限流</h3><p>例如系统能同时处理 100 个请求，保存一个计数器，处理了一个请求，计数器就加一，一个请求处理完毕之后计数器减一。</p><p>每次请求来的时候看看计数器的值，如果超过阈值就拒绝。</p><p>非常简单粗暴，计数器的值要是存内存中就算单机限流算法。</p><p>如果放在第三方存储里，例如 Redis 中，集群机器访问就算分布式限流算法。</p><p>优点就是：简单粗暴，单机在 Java 中可用 Atomic 等原子类、分布式就 Redis incr。</p><p>缺点就是：假设我们允许的阈值是1万，此时计数器的值为 0， 当 1 万个请求在前 1 秒内一股脑儿的都涌进来，这突发的流量可是顶不住的。</p><p>缓缓地增加流量处理和一下子涌入对于程序来说是不一样的。</p><p>而且一般的限流都是为了限制在指定时间间隔内的访问量，因此还有个算法叫固定窗口。</p><h3 id="固定窗口限流"><a href="#固定窗口限流" class="headerlink" title="固定窗口限流"></a>固定窗口限流</h3><p>它相比于计数限流主要是多了个时间窗口的概念，计数器每过一个时间窗口就重置。 规则如下：</p><ul><li>请求次数小于阈值，允许访问并且计数器 +1；</li><li>请求次数大于阈值，拒绝访问；</li><li>这个时间窗口过了之后，计数器清零；</li></ul><p>看起来好像很完美，实际上还是有缺陷的。</p><h4 id="固定窗口临界问题"><a href="#固定窗口临界问题" class="headerlink" title="固定窗口临界问题"></a>固定窗口临界问题</h4><p>假设系统每秒允许 100 个请求，假设第一个时间窗口是 0-1s，在第 0.55s 处一下次涌入 100 个请求，过了 1 秒的时间窗口后计数清零，此时在 1.05 s 的时候又一下次涌入100个请求。</p><p>虽然窗口内的计数没超过阈值，但是全局来看在 0.55s-1.05s 这 0.5 秒内涌入了 200 个请求，这其实对于阈值是 100&#x2F;s 的系统来说是无法接受的。</p><p>为了解决这个问题引入了滑动窗口限流。</p><h3 id="滑动窗口限流"><a href="#滑动窗口限流" class="headerlink" title="滑动窗口限流"></a>滑动窗口限流</h3><p>滑动窗口限流解决固定窗口临界值的问题，可以保证在任意时间窗口内都不会超过阈值。</p><p>相对于固定窗口，滑动窗口除了需要引入计数器之外还需要记录时间窗口内每个请求到达的时间点，因此<strong>对内存的占用会比较多</strong>。</p><p>规则如下，假设时间窗口为 1 秒：</p><ul><li>记录每次请求的时间</li><li>统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。</li><li>统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。</li></ul><p>但是滑动窗口和固定窗口都<strong>无法解决短时间之内集中流量的突击</strong>。</p><p>我们所想的限流场景是：</p><p>每秒限制 100 个请求。希望请求每 10ms 来一个，这样我们的流量处理就很平滑，但是真实场景很难控制请求的频率，因此可能存在 5ms 内就打满了阈值的情况。</p><p>当然对于这种情况还是有变型处理的，例如设置多条限流规则。不仅限制每秒 100 个请求，再设置每 10ms 不超过 2 个。</p><p>再多说一句，这个<strong>滑动窗口可与TCP的滑动窗口不一样</strong>。</p><p>TCP的滑动窗口是接收方告知发送方自己能接多少“货”，然后发送方控制发送的速率。</p><p>接下来再说说漏桶，它可以解决时间窗口类的痛点，使得流量更加平滑。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>如下图所示，水滴持续滴入漏桶中，底部定速流出。</p><p>如果水滴滴入的速率大于流出的速率，当存水超过桶的大小的时候就会溢出。</p><p>规则如下：</p><ul><li>请求来了放入桶中</li><li>桶内请求量满了拒绝请求</li><li>服务定速从桶内拿请求处理</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/lrTevRiH_058fd464-1f25-42a6-a015-94c1094c8f04_mianshiya.png"></p><p>可以看到水滴对应的就是请求。</p><p>它的特点就是<strong>宽进严出</strong>，无论请求多少，请求的速率有多大，都按照固定的速率流出，对应的就是服务按照固定的速率处理请求。</p><p>看到这想到啥，是不是和消息队列思想有点像，削峰填谷。</p><p>一般而言漏桶也是由队列来实现的，处理不过来的请求就排队，队列满了就开始拒绝请求。</p><p>看到这又想到啥，<strong>线程池</strong>不就是这样实现的嘛？</p><p>经过漏洞这么一过滤，请求就能平滑的流出，看起来很像很挺完美的？实际上它的优点也即缺点。</p><p>面对突发请求，服务的处理速度和平时是一样的，这其实不是我们想要的。</p><p>在面对突发流量我们希望在系统平稳的同时，提升用户体验即能更快的处理请求，而不是和正常流量一样，循规蹈矩的处理（看看，之前滑动窗口说流量不够平滑，现在太平滑了又不行，难搞啊）。</p><p>而令牌桶在应对突击流量的时候，可以更加的“激进”。</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶其实和漏桶的原理类似，只不过漏桶是<strong>定速地流出</strong>，而令牌桶是<strong>定速地往桶里塞入令牌</strong>，然后请求只有拿到了令牌才能通过，之后再被服务器处理。</p><p>当然令牌桶的大小也是有限制的，假设桶里的令牌满了之后，定速生成的令牌会丢弃。</p><p>规则：</p><ul><li>定速的往桶内放入令牌</li><li>令牌数量超过桶的限制，丢弃</li><li>请求来了先向桶内索要令牌，索要成功则通过被处理，反之拒绝</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/uomus52U_c30112aa-ed3d-40c1-a529-71367208560e_mianshiya.png"></p><p>看到这又想到什么？<strong>Semaphore 信号量啊</strong>，信号量可控制某个资源被同时访问的个数，其实和咱们拿令牌思想一样，一个是拿信号量，一个是拿令牌。</p><p>只不过信号量用完了返还，而咱们令牌用了不归还，因为令牌会定时再填充。</p><p>再来看看令牌桶的伪代码实现，可以看出和漏桶的区别就在于一个是加法，一个是减法。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/BHdlF5sY_0d3faa35-e04f-492e-9f70-a9f33450aafe_mianshiya.png"></p><p>可以看出令牌桶在应对突发流量的时候，桶内假如有 100 个令牌，那么这 100 个令牌可以马上被取走，而不像漏桶那样匀速的消费。所以在<strong>应对突发流量的时候令牌桶表现的更佳</strong>。</p><p>漏桶和令牌桶其实比较适合<strong>阻塞式限流</strong>场景，即没令牌我就等着，这样就不会误杀了，而漏桶本就是等着，比较适合后台任务类的限流。</p><p>而基于时间窗口的限流比较适合<strong>对时间敏感</strong>的场景，请求过不了您就快点儿告诉我，等的花儿都谢了。</p><h2 id="单机限流和分布式限流"><a href="#单机限流和分布式限流" class="headerlink" title="单机限流和分布式限流"></a>单机限流和分布式限流</h2><p>本质上单机限流和分布式限流的区别其实就在于 “阈值” 存放的位置。</p><p>单机限流就上面所说的算法直接在单台服务器上实现就好了，而往往我们的服务是集群部署的。</p><p>因此需要多台机器协同提供限流功能。</p><p>像上述的计数器或者时间窗口的算法，可以将计数器存放至 Redis 等分布式 K-V 存储中。</p><p>例如滑动窗口的每个请求的时间记录可以利用 Redis 的 <code>zset</code> 存储，利用<code>ZREMRANGEBYSCORE </code> 删除时间窗口之外的数据，再用 <code>ZCARD</code>计数。</p><p>像令牌桶也可以将令牌数量放到 Redis 中。</p><p>不过这样的方式等于每一个请求我们都需要去<code>Redis</code>判断一下能不能通过，在性能上有一定的损耗。</p><p>所以有个优化点就是 「<strong>批量获取</strong>」，每次取令牌不是一个一取，而是取一批，不够了再去取一批，这样可以减少对 Redis 的请求。</p><p>不过要注意一点，<strong>批量获取会导致一定范围内的限流误差</strong>。比如你取了 10 个此时不用，等下一秒再用，那同一时刻集群机器总处理量可能会超过阈值。</p><p>其实「批量」这个优化点太常见了，不论是 MySQL 的批量刷盘，还是 Kafka 消息的批量发送还是分布式 ID 的高性能发号，都包含了「批量」的思想。</p><p>当然，分布式限流还有一种思想是平分，假设之前单机限流 500，现在集群部署了 5 台，那就让每台继续限流 500 呗，即在总的入口做总的限流限制，然后每台机子再自己实现限流。</p><h2 id="限流的难点"><a href="#限流的难点" class="headerlink" title="限流的难点"></a>限流的难点</h2><p>可以看到，每个限流都有个阈值，这个阈值如何定是个难点。</p><p>定大了服务器可能顶不住，定小了就“误杀”了，没有资源利用最大化，对用户体验不好。</p><p>我能想到的就是限流上线之后先预估个大概的阈值，然后不执行真正的限流操作，而是采取日志记录方式，对日志进行分析查看限流的效果，然后调整阈值，推算出集群总的处理能力，和每台机子的处理能力(方便扩缩容)。</p><p>然后将线上的流量进行重放，测试真正的限流效果，最终阈值确定，然后上线。</p><p>我之前还看过一篇耗子叔的文章，讲述了在自动化伸缩的情况下，我们要动态地调整限流的阈值很难。</p><p>于是基于TCP拥塞控制的思想，根据请求响应在一个时间段的响应时间P90或者P99值来确定此时服务器的健康状况，来进行动态限流。在他的 Ease Gateway 产品中实现了这套算法，有兴趣的同学可以自行搜索。</p><p>其实真实的业务场景很复杂，<strong>需要限流的条件和资源很多</strong>，每个资源限流要求还不一样。</p><h2 id="限流组件"><a href="#限流组件" class="headerlink" title="限流组件"></a>限流组件</h2><p>一般而言，我们不需要自己实现限流算法来达到限流的目的，不管是接入层限流还是细粒度的接口限流，都有现成的轮子使用，其实现也是用了上述我们所说的限流算法。</p><p>比如<code>Google Guava</code> 提供的限流工具类 <code>RateLimiter</code>，是基于令牌桶实现的，并且扩展了算法，支持预热功能。</p><p>阿里开源的限流框架<code> Sentinel</code> 中的匀速排队限流策略，就采用了漏桶算法。</p><p>Nginx 中的限流模块 <code>limit_req_zone</code>，采用了漏桶算法，还有 OpenResty 中的 <code>resty.limit.req</code>库等等。</p><p>具体的使用还是很简单的，有兴趣的同学可以自行搜索，对内部实现感兴趣的同学可以下个源码看看，学习下生产级别的限流是如何实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TransFormer】简介</title>
      <link href="/p/bb996d5/"/>
      <url>/p/bb996d5/</url>
      
        <content type="html"><![CDATA[<h2 id="起源与发展"><a href="#起源与发展" class="headerlink" title="起源与发展"></a>起源与发展</h2><p>Transformer 源自于AI自然语言处理任务NLP；在计算机视觉领域CV，近年来Transformer逐渐替代CNN成为一个热门的研究方向。此外，Transformer在文本、语音、视频等多模态领域也在崭露头角，可见Transformer模型的重要之处。</p><p>2017 年 Google 在<a href="https://arxiv.org/abs/1706.03762">《Attention Is All You Need》</a>中提出了 Transformer 结构用于序列标注，在翻译任务上超过了之前最优秀的循环神经网络模型；与此同时，Fast AI 在<a href="https://arxiv.org/abs/1801.06146">《Universal Language Model Fine-tuning for Text Classification》</a>中提出了一种名为 ULMFiT 的迁移学习方法，将在大规模数据上预训练好的 LSTM 模型迁移用于文本分类，只用很少的标注数据就达到了最佳性能。</p><p>这些具有开创性的工作促成了两个著名 Transformer 模型的出现：</p><ul><li><a href="https://openai.com/blog/language-unsupervised/"><strong>GPT</strong></a> (the Generative Pretrained Transformer)；</li><li><a href="https://arxiv.org/abs/1810.04805"><strong>BERT</strong></a> (Bidirectional Encoder Representations from Transformers)。</li></ul><p>通过将 Transformer 结构与无监督学习相结合，我们不再需要对每一个任务都从头开始训练模型，并且几乎在所有 NLP 任务上都远远超过先前的最强基准。</p><p>  Transformer和LSTM的最大区别，就是LSTM的训练是迭代的、串行的，必须要等当前字处理完，才可以处理下一个字。而Transformer的训练时<strong>并行</strong>的，即所有字是同时训练的，这样就大大增加了计算效率。Transformer使用了位置嵌入(Positional Encoding)来理解语言的顺序，使用自注意力机制（Self Attention Mechanism）和前馈全连接层进行计算，这是Transformer的创新点。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/d3e2a9ca5dbb5c621067b4cc65e0df30.png">模型的左半边Encoder部分可以看作是一个编码器，右半边Decoder部分可以看作是一个解码器，其中<strong>编码器是双向</strong>的，<strong>解码器是单向</strong>的需要循环迭代输出。</p><p>虽然新的 Transformer 模型层出不穷，它们采用不同的预训练目标在不同的数据集上进行训练，但是依然可以按模型结构将它们大致分为三类：</p><ul><li><strong>纯 Encoder 模型</strong>（例如 BERT），又称自编码 (auto-encoding) Transformer 模型；</li><li><strong>纯 Decoder 模型</strong>（例如 GPT），又称自回归 (auto-regressive) Transformer 模型；</li><li><strong>Encoder-Decoder 模型</strong>（例如 BART、T5），又称 Seq2Seq (sequence-to-sequence) Transformer 模型。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>自注意力机制（Self-Attention）：这是Transformer的核心概念之一，它使模型能够同时考虑输入序列中的所有位置，而不是像循环神经网络（RNN）或卷积神经网络（CNN）一样逐步处理。自注意力机制允许模型根据输入序列中的不同部分来赋予不同的注意权重，从而更好地捕捉语义关系。</li><li>多头注意力（Multi-Head Attention）：Transformer中的<strong>自注意力机制被扩展为多个注意力头</strong>，每个头可以学习不同的注意权重，以更好地捕捉不同类型的关系。多头注意力允许模型并行处理不同的信息子空间。</li><li>堆叠层（Stacked Layers）：Transformer通常由多个相同的编码器和解码器层堆叠而成。这些堆叠的层有助于模型学习复杂的特征表示和语义。</li><li>位置编码（Positional Encoding）：由于Transformer没有内置的序列位置信息，它需要额外的位置编码来表达输入序列中单词的位置顺序。</li><li>残差连接和层归一化（Residual Connections and Layer Normalization）：这些技术有助于减轻训练过程中的梯度消失和爆炸问题，使模型更容易训练。</li><li>编码器和解码器：Transformer通常包括一个编码器用于处理输入序列和一个解码器用于生成输出序列，这使其适用于序列到序列的任务，如机器翻译。</li></ul><h3 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h3><p>当人类的视觉机制察觉到一个物体时，通常不会从头到尾地扫视整个场景；一般会根据个人的需求集中关注特定的部分。</p><p>比如下面这张图，我们第一眼应该是看到一只动物，然后，眼睛会先注意到动物的脸，然后得出初步结论，这应该是一只狼；就像右边注意力图所示，颜色更深的部分表示一般是我们人类最先看见（注意）的。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/v2-cb297c4d9f082e49fc3835b85a778930_1440w.webp"></p><p>注意力最早应用在机器视觉领域（CV，Computer Vision），后来才应用到NLP和LLM领域。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/v2-360d84d03007d9182d51a62db58d4f9b_1440w.webp"></p><p>在Transformer架构中，有3种不同的注意力层：</p><ul><li><strong>编码器中的全局自注意力层</strong>（Global self attention layer）</li><li><strong>解码器中的交叉注意力层</strong>（Cross attention layer）</li><li><strong>解码器中的因果自注意力层</strong>（Causal attention layer）</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/v2-65dcc3fe507b8ac8e7bdbb030006f38b_1440w.webp"></p><h4 id="注意力机制基础"><a href="#注意力机制基础" class="headerlink" title="注意力机制基础"></a>注意力机制基础</h4><p>注意力机制的数学表示如下：<br>$$<br>Attention(Q,K,V)&#x3D;softmax(\frac{QK^T}{\sqrt{d_k}})V<br>$$<br>其中，Q，K和V分别指的是查询（<strong>Q</strong>uery），键（<strong>K</strong>ey）以及值（<strong>V</strong>alue）矩阵。</p><p>简单来说，查询矩阵Q里的数据代表了我们关注的词，键矩阵K里的数据用来帮我们计算这些词之间的相似度（<strong>即注意力分数：attention score，<a href="https://zhida.zhihu.com/search?q=%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98&zhida_source=entity&is_preview=1">向量点乘</a>可以计算相似度</strong>），而值矩阵V里的数据则用来根据这些相似度计算出最终的输出结果</p><p>为了确保计算过程中的数据不会因为维度（即键的大小）太大而爆炸，或者太小而消失，注意力分数会通过键的维度的平方根来进行调整；接着，通过softmax函数把这些分数转化成权重，最后这些权重会和值矩阵相乘，得到最后的输出（<strong>注意力向量</strong>）。</p><h4 id="理解Q、K、V"><a href="#理解Q、K、V" class="headerlink" title="理解Q、K、V"></a>理解Q、K、V</h4><p>注意力机制中有两个输入：</p><ul><li><strong>查询序列</strong>（Q）：正在处理的序列（在底部）。</li><li><strong>上下文序列</strong>（K，V）：被关注的序列（在左侧）。</li></ul><p>输出序列的维度与查询序列相同。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/v2-247b42302a219805ce5acfa2a4d43638_1440w.webp"></p><p>这个操作常常被比作字典查找，但是，是一个<strong>模糊的，可微分的，向量化的</strong>字典查找。</p><p>举个例子，假设有一个普通的Python字典，有 3 个键和 3 个值，被传递了一个单独的查询：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;pickup&#x27;</span>&#125;</span><br><span class="line">result = d[<span class="string">&#x27;color&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里，查询（Q）是你要找的内容，键（K）表示字典里有什么样的信息，而值（V）则是对应的信息；在普通的字典查找中，字典会找到匹配的键，并返回其对应的值；如果查询找不到完全匹配的键，也许你会期望返回最接近的值，比如在上面的例子中，如果你查找 <code>d[&quot;species&quot;]</code>，你可能会期望返回 “pickup”，因为它是<strong>最接近查询的匹配</strong>。</p><p>一个注意力层就像是这样的一个<strong>模糊查找</strong>，但它不仅仅是寻找最佳键；它结合了查询（Q）和键（K）向量，来确定它们匹配的程度，也就是“注意力分数”。然后，根据“注意力分数”对所有值进行加权平均；在注意力层中，每个位置的查询（Q）序列都提供一个查询向量，而上下文序列则充当了一个字典，每个位置提供一个键和值向量；在使用这些向量之前，注意力层会用一个<a href="https://zhida.zhihu.com/search?q=%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82&zhida_source=entity&is_preview=1">全连接层</a>对输入向量进行投影。</p><h3 id="编码器-Encoder"><a href="#编码器-Encoder" class="headerlink" title="编码器 Encoder"></a>编码器 Encoder</h3><h4 id="自注意力-Self-Attention"><a href="#自注意力-Self-Attention" class="headerlink" title="自注意力 Self-Attention"></a>自注意力 Self-Attention</h4><p>随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。在处理过程中，自注意力机制会将对所有相关单词的理解融入到我们正在处理的单词中。更具体的功能如下：</p><ul><li>序列建模：自注意力可以用于序列数据（例如文本、时间序列、音频等）的建模。它可以捕捉序列中不同位置的依赖关系，从而更好地理解上下文。这对于机器翻译、文本生成、情感分析等任务非常有用。</li><li>并行计算：自注意力可以并行计算，这意味着可以有效地在现代硬件上进行加速。相比于RNN和CNN等序列模型，它更容易在GPU和TPU等硬件上进行高效的训练和推理。（因为在自注意力中可以并行的计算得分）</li><li>长距离依赖捕捉：传统的循环神经网络（RNN）在处理长序列时可能面临梯度消失或梯度爆炸的问题。自注意力可以更好地处理长距离依赖关系，因为它不需要按顺序处理输入序列。</li></ul><p>自注意力结构如下：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/49c88545fae57dbf255c8ab9fd279110.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://transformers.run/">Hello! · Transformers快速入门</a></p><p><a href="https://blog.csdn.net/m0_63669388/article/details/131362133">史上最详细Transformer讲解以及transformer实现中文版完形填空（掩蔽字训练MASK） 内容详细易懂且附有全部代码_transformer mask-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_42475060/article/details/121101749">【超详细】【原理篇&amp;实战篇】一文读懂Transformer-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/687832172">第四篇：一文搞懂Transformer架构的三种注意力机制 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/p/364ea8cc/"/>
      <url>/p/364ea8cc/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是设计模式？请简述其作用。"><a href="#什么是设计模式？请简述其作用。" class="headerlink" title="什么是设计模式？请简述其作用。"></a>什么是设计模式？请简述其作用。</h2><p>设计模式其实是在软件开发过程中经过经验积累和验证总结得出的一套通用代码设计方案，它们帮助开发者避免重复发明轮子，确保设计的一致性和可维护性，提高代码的可读性和可扩展性。</p><p>如果熟悉了设计模式，当遇到类似的场景，我们可以快速地参考设计模式实现代码。不仅可以加速我们的编码速度，也提升了代码的可扩展性、可重用性与可维护性！</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>帮助我们快速解决常见问题：设计模式提供了解决特定软件设计问题的通用方法，拿来套上即用，例如单例模式、代理模式、责任链模式等等。</li><li>提升代码可扩展性：设计模式通常考虑了软件的扩展性，将不同的功能和功能变化分离开来实现，使得未来添加新功能更加容易。</li><li>提高代码可重用性：设计模式本身就是经验的总结，按照设计模式的思路，很多代码封装的很好，便于复用，减少重复工作。</li><li>提升代码可维护性：通过使用设计模式，使得代码结构更加清晰，易于理解和维护。</li><li>简化沟通成本：如果大家都熟悉设计模式，其实设计模式就是一种通用语言，通过设计就能明白其实现含义，有助于开发者之间更有效地沟通设计意图。</li><li>提供最佳实践：它们是经验的总结，可以指导开发者避免常见陷阱，采用最佳实践。</li></ol><h2 id="请解释什么是单例模式，并给出一个使用场景"><a href="#请解释什么是单例模式，并给出一个使用场景" class="headerlink" title="请解释什么是单例模式，并给出一个使用场景"></a>请解释什么是单例模式，并给出一个使用场景</h2><p>单例模式（Singleton Pattern）在很多人眼里是最简单的一种设计模式，一个类只能有一个实例，这个类就是单例类，这就是单例模式。</p><p>它主要用于资源管理（避免资源冲突）、保证全局唯一的场景。</p><h3 id="具体使用场景"><a href="#具体使用场景" class="headerlink" title="具体使用场景"></a>具体使用场景</h3><p>1）配置管理：</p><p>基本上应用都会有一个全局配置，这个配置从理论上来说需要保证唯一性，确保读取到的配置是同一份，是一致的，所以天然适合单例实现。</p><p>2）连接池、线程池：</p><p>池化资源需要保证唯一性，不然就没有池化的意义了，总不能每次访问池化资源都新建一个吧？需要保持单例，控制具体池化资源的数量，便于管理和监控。</p><p>还有日志、缓存等需要全局唯一避免资源冲突的场景。</p><h2 id="单例模式有哪几种实现？如何保证线程安全？"><a href="#单例模式有哪几种实现？如何保证线程安全？" class="headerlink" title="单例模式有哪几种实现？如何保证线程安全？"></a>单例模式有哪几种实现？如何保证线程安全？</h2><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>单例有很多种实现方式，最简单的可能就是<strong>懒汉式单例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的优点就是延迟加载，但是线程不安全，多线程并发访问的情况下可能会产生多个实例。</p><p>最简单的改进方法就是加个锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样一来，每次访问单例的时候，都需要有锁的竞争，可能会有性能问题。</p><p>因此又改进得到一个<strong>双重检查锁定版本</strong>的单例实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现利用 volatile 关键字保证了可见性，利用双重检查机制减少了同步带来的性能损耗。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>除了懒汉式的单例实现，还有个<strong>饿汉式</strong>单例实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式是线程安全的，硬要说它的缺点就是不使用的情况下，也因为静态属性的原因，导致类在加载的时候单例就创建了，即没有延迟加载。</p><p>如果要改进这个实现，可以采用静态内部类的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅线程安全，也实现了延迟加载。</p><p>以上就是常见的单例实现方式。</p><h2 id="工厂模式和抽象工厂模式有什么区别？"><a href="#工厂模式和抽象工厂模式有什么区别？" class="headerlink" title="工厂模式和抽象工厂模式有什么区别？"></a>工厂模式和抽象工厂模式有什么区别？</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂方法模式定义了一个创建对象的接口，一个具体的工厂类负责生产一种产品，如果需要添加新的产品，<strong>仅需新增对应的具体工厂类</strong>而不需要修改原有的代码实现。</p><p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品。工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p><p>我们来看个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IPhone</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best IPhone &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Samsung</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best Samsung &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huawei</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best Huawei &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">gotoPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(phone.equal(<span class="string">&quot;Iphone&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IPhone</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(phone.equal(<span class="string">&quot;Samsung&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Samsung</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Huawei</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">PhoneFactory</span> <span class="variable">factory</span> <span class="operator">=</span> Factory.gotoPhone(<span class="string">&quot;Iphone&quot;</span>);</span><br><span class="line">factory.makePhone();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到简单的工厂模式就是根据if判断语句进行区分的，这样客户端免除了直接创建产品对象的责任，而仅仅负责“消费”产品（正如手机厂老板所为）。加入现在需要加入中兴手机呢，下面我们从开闭原则（对扩展开放；对修改封闭）上来分析下简单工厂模式。如果需要加入中兴手机，那么就需要修改Factory中的gotoPhone(String)，加入一个if分支，这样明显就是修改了，违背了开闭原则中的对修改封闭，同时也是因为程序中使用if判断语句进行分类导致的对扩展不够。所以现在我们使用工厂方法模式，直接去掉中间的Factory。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IPhoneFactory</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best IPhone &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungFactory</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best Samsung &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> implement PhoneFactory&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePhone</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Make a best Huawei &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">PhoneFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IPhoneFactory</span>();</span><br><span class="line">factory.makePhone();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以看出，还要增加中兴手机就不要修改代码了，直接就是可以实现一个中兴手机的PhoneFactory就可以了。刚好没有修改任何代码，直接就是增加一个实现类。如果哪天中兴手机代工厂关闭了，那么就有直接删掉中兴代工厂的类就好了，也不至于修改其它类。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>而抽象工厂提供一个<strong>创建一系列相关或相互依赖对象的接口</strong>，简单来说不是仅生产一个产品，而是一个系列产品。听起来可能有点抽象，我们还是看一下例子。</p><p>假设我们有两个产品 ProductA 和 ProductB，以及它们的具体实现 ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2，我们使用抽象工厂模式来创建这些相关的产品：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using ConcreteProductA1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using ConcreteProductA2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating ConcreteProductB1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating ConcreteProductB2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    ProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    ProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用抽象工厂创建产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        productA1.use();</span><br><span class="line">        productB1.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line">        productA2.use();</span><br><span class="line">        productB2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码虽然很多，但是看下来应该很清晰，抽象工厂就是打包式的创建系列对象，等于帮我们搭配好了，屏蔽关联对象的一些创建细节。</p><p>总结一下。</p><p>工厂模式：</p><ul><li>关注创建单一产品对象。</li><li>使用子类来决定创建哪个具体产品。</li><li>扩展性较好，新增产品时只需增加新的工厂子类。</li><li>包含一个抽象产品接口，多个具体产品实现这个接口。</li><li>有一个抽象工厂接口和多个具体工厂实现类，每个具体工厂负责创建一种具体产品。</li></ul><p>抽象工厂模式：</p><ul><li>关注创建一系列相关或相互依赖的产品对象。</li><li>提供一个接口，用于创建多个产品族的对象。</li><li>增加新的产品族较为容易，但增加新产品类型较为困难。（比如要加个 createProductC，所有实现具体工厂的代码都得改）</li><li>包含多个抽象产品接口，每个接口代表一类相关的产品。</li><li>有一个抽象工厂接口，这个接口中包含多个创建不同抽象产品的方法。</li><li>多个具体工厂实现类，每个具体工厂实现类负责创建一整套相关的具体产品，即实现抽象工厂接口中的所有创建方法，以提供一个完整的产品系列。</li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li><p>两种模式都通过封装对象的创建过程，将客户端代码与具体的实现类分离。</p></li><li><p>都使用工厂方法来创建对象，而不是直接使用new关键字。（将对象的创建过程封装起来）</p></li><li><p>都遵循”开闭原则”，增加新的产品时，两种模式均可以在不修改客户端代码的情况下，通过增加新的产品类来扩展系统。</p></li><li><p>都遵循”单一职责原则”，即工厂类负责对象的创建，客户端负责对象的使用。</p></li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>工厂模式是创建单一的产品对象，即一个工厂负责创建一类产品。<br>抽象工厂模式是创建产品族，即一个工厂负责创建一系列相关的产品对象。</li><li>工厂模式更加灵活，可以很容易地增加新的产品类型，但不能轻易地切换产品族。<br>抽象工厂模式可以很容易地切换不同的产品族，但不能轻易地增加新的产品类型（因为这需要修改抽象工厂接口。）</li><li>工厂模式的客户端代码依赖于具体的工厂实现类。<br>抽象工厂模式的客户端代码依赖于抽象工厂接口，而不依赖于具体的工厂实现类。</li><li>工厂模式通常只有一个抽象工厂接口和多个具体工厂实现类。<br>抽象工厂模式通常有一个抽象工厂接口，以及多个具体工厂实现类，每个实现类创建一个产品族。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当你需要创建一个对象，但不关心它的具体类型时，可以使用工厂模式。如果需要产品切换族，适合使用抽象工厂模式。</p><p>工厂模式适用于创建单一产品的场景，而抽象工厂模式适用于创建产品族的场景。</p><h2 id="什么是模板方法模式？一般用在什么场景？"><a href="#什么是模板方法模式？一般用在什么场景？" class="headerlink" title="什么是模板方法模式？一般用在什么场景？"></a>什么是模板方法模式？一般用在什么场景？</h2><p>模板方法模式，它在一个抽象类中定义了一个算法（业务逻辑）的骨架，具体步骤的实现由子类提供，它通过将算法的不变部分放在抽象类中，可变部分放在子类中，达到代码复用和扩展的目的。</p><p>复用：所有子类可以直接复用父类提供的模板方法，即上面提到的不变的部分。 扩展：子类可以通过模板定义的一些扩展点就行不同的定制化实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line">        hook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本操作（抽象方法）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法（可选的操作，提供默认实现）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClassA: primitiveOperation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClassA: primitiveOperation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClassB: primitiveOperation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClassB: primitiveOperation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClassB: hook&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了模板方法 templateMethod，内部定义了业务处理的逻辑，按序执行 primitiveOperation1()、primitiveOperation2() 和 hook()。</p><p>子类只需要关心几个方法的内部实现，不需要关心模板方法的内部执行顺序，这就是我们所说的将通用的算法步骤放在抽象类中，不同的实现细节放在子类中，在多个子类中共享相同的代码，而不需要在每个子类中重复实现相同的逻辑。</p><p>在 Java 中有很多应用场景，例如 JdbcTemplate 就是使用了模板方法来处理数据库的操作。</p><p>再比如 HttpServlet 类的 service 方法也用了模板方法，doGet、doPost 等方法都是需要子类实现的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>提高复用性</li><li>提高扩展性</li><li>符合开闭原则</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>类数目增加</li><li>增加了系统实现的复杂度</li><li>继承关系自身的缺点，如果父类添加新的抽象方法，所有子类都要改一遍。</li></ol><h2 id="什么是策略模式？一般用在什么场景？"><a href="#什么是策略模式？一般用在什么场景？" class="headerlink" title="什么是策略模式？一般用在什么场景？"></a>什么是策略模式？一般用在什么场景？</h2><p>策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，让算法独立于使用它的客户端（调用方）而变化。</p><p>很多情况下，我们代码里有大量的 if else、switch 等，可以通过使用策略模式，避免大量条件语句的使用，实现算法的分离和独立变化。</p><p>它的主要目的是为了解耦多个策略，并方便调用方在针对不同场景灵活切换不同的策略。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(User user)</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;Executing Strategy A &quot;</span> + user.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(User user)</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;Executing Strategy B &quot;</span> + user.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">AStrategy</span>());</span><br><span class="line">    strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">BStrategy</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> user.getType();</span><br><span class="line">    <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> StrategyFactory.getStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> strategy.execute(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述的代码通过使用策略模式，可以将不同的算法策略封装起来，并根据 user 的类型在运行时动态选择具体的算法策略，从而提高系统的灵活性和可扩展性。</p><p>可以用在例如多种支付方式的切换、不同排序算法的切换等多策略实现的场景。</p><h2 id="什么是责任链模式？一般用在什么场景？"><a href="#什么是责任链模式？一般用在什么场景？" class="headerlink" title="什么是责任链模式？一般用在什么场景？"></a>什么是责任链模式？一般用在什么场景？</h2><p>责任链模式允许将多个对象连接成一条链，并且沿着这条链传递请求，让多个对象都有机会处理这个请求，请求会顺着链传递，直到某个对象处理它为止。</p><p>它主要避免了请求发送者和接受者之间的耦合，增强了系统的灵活性和可扩展性。</p><p>在很多场景都能看到责任链模式，比如日志的处理，不同级别不同输出。在Spring框架中，责任链设计模式通常被用于<strong>过滤器链、拦截器链</strong>等场景。</p><p>下面是一个简单的日志处理示例代码。日志处理器有三种类型：控制台日志处理器（ConsoleLogger）、文件日志处理器（FileLogger）和错误日志处理器（ErrorLogger）。日志处理器按照优先级进行处理，如果当前处理器不能处理，则将请求传递给下一个处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 责任链模式的抽象处理器类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ERROR</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">protected</span> Logger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextLogger</span><span class="params">(Logger nextLogger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMessage</span><span class="params">(<span class="type">int</span> level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.level &lt;= level) &#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理器类：控制台日志处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsoleLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Standard Console::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理器类：文件日志处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理器类：错误日志处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorLogger</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Error Console::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="title function_">getChainOfLoggers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">errorLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorLogger</span>(Logger.ERROR);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">fileLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(Logger.DEBUG);</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">consoleLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>(Logger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">loggerChain</span> <span class="operator">=</span> getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(Logger.INFO, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        loggerChain.logMessage(Logger.DEBUG, <span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        loggerChain.logMessage(Logger.ERROR, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是观察者模式？一般用在什么场景？"><a href="#什么是观察者模式？一般用在什么场景？" class="headerlink" title="什么是观察者模式？一般用在什么场景？"></a>什么是观察者模式？一般用在什么场景？</h2><p>观察者模式其实也称为<strong>发布订阅模式</strong>，它定义了对象之间的一种<strong>一对多</strong>的依赖关系，让<strong>多个观察者对象同时监听某一个主题对象</strong>。当主题对象状态发生变化时，它会通知所有观察者对象。</p><p>它的目的就是将观察者和被观察者代码解耦，使得一个对象或者说事件的变更，让不同观察者可以有不同的处理，非常灵活，扩展性很强，是事件驱动编程的基础。</p><p>观察者模式的组成部分</p><ul><li>Subject（主题&#x2F;被观察者）：状态发生变化时，通知所有注册的观察者。</li><li>Observer（观察者）：接收来自主题的更新通知，并进行相应的操作。</li><li>ConcreteSubject（具体主题）：实现具体的主题对象，保存需要被观察的状态。</li><li>ConcreteObserver（具体观察者）：实现具体的观察者对象，更新自己以与主题的状态同步。</li></ul><h2 id="什么是装饰器模式？一般用在什么场景？"><a href="#什么是装饰器模式？一般用在什么场景？" class="headerlink" title="什么是装饰器模式？一般用在什么场景？"></a>什么是装饰器模式？一般用在什么场景？</h2><p>装饰器模式是一种结构型设计模式，<strong>用于在不改变现有类的情况下动态地为其增加新功能</strong>。通过将对象嵌套在装饰器中，可以实现功能扩展，同时保留原始对象的行为。</p><p>主要作用是<strong>给原始类增强功能</strong>，一般使用组合形式对原始类进行一定的扩展，并且可以将多个装饰器组合在一起，实现多个功能的叠加（多个装饰器组合需要装饰类需要和原始类实现同样接口或继承同样的抽象类）。</p><p><strong>装饰器模式的特点</strong>：</p><ol><li><strong>动态扩展</strong>：无需修改原始类的代码即可添加新功能。</li><li><strong>遵循开闭原则</strong>：对扩展开放，对修改关闭。</li><li><strong>灵活组合</strong>：装饰器可以嵌套组合，形成复杂的功能。</li></ol><h3 id="一般用在什么场景？"><a href="#一般用在什么场景？" class="headerlink" title="一般用在什么场景？"></a>一般用在什么场景？</h3><ol><li><strong>需要动态扩展功能</strong>： 对现有对象添加功能，但不希望通过继承方式。</li><li><strong>不同组合的功能需求</strong>：功能可以按需组合，而不需要创建大量子类。</li><li><strong>透明扩展</strong>：客户端无需了解对象是否被装饰过。</li></ol><p><strong>典型场景</strong>：</p><ul><li><strong>日志系统</strong>：在日志记录中动态添加时间戳、日志级别等信息。</li><li><strong>网络编程</strong>：为网络流添加缓存、压缩、加密功能。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>最典型的装饰器实现就是 Java 中的 I&#x2F;O 类库，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (dis.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(dis.readLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileInputStream</code> 用来读取文件流，然后被 <code>BufferedInputStream</code> 装饰，<strong>提供了缓存的功能</strong>。</p><p>然后再被 <code>DataInputStream</code> 装饰，<strong>提供了按数据类型读取的功能</strong>。</p><p>可以看到，多个装饰器叠加在一起，实现了多个功能的增强，且不会增加类的实现复杂度，每个装饰器仅需关注自己的加强功能即可，提高代码的灵活性和可维护性。</p><h2 id="什么是享元模式？一般用在什么场景？"><a href="#什么是享元模式？一般用在什么场景？" class="headerlink" title="什么是享元模式？一般用在什么场景？"></a>什么是享元模式？一般用在什么场景？</h2><p>享元模式是一种结构型设计模式，用于减少程序中对象的数量，节约内存资源。通过<strong>共享具有相同状态的对象，来减少内存占用，提高内存效率</strong>。</p><p>例如一个系统中可能会存在大量的重复对象，并且这些对象实际是不可变的，在设计上我们就可以仅在内存中保留一份实例，然后多处引用即可，这样就能节省内存的开销。</p><p><strong>享元模式的特点</strong>：</p><p>1）<strong>对象共享</strong>：通过共享对象来减少内存消耗。</p><p>2）<strong>状态分离</strong>：</p><ul><li><strong>内部状态</strong>：可以共享的状态，不随环境变化。</li><li><strong>外部状态</strong>：不能共享的状态，由客户端负责传递。</li></ul><p>3）<strong>高效性</strong>：适合大量细粒度对象的场景，通过对象复用提升性能。</p><h3 id="一般用在什么场景？-1"><a href="#一般用在什么场景？-1" class="headerlink" title="一般用在什么场景？"></a>一般用在什么场景？</h3><ol><li><strong>大量重复对象</strong>：系统中需要创建大量相似对象，而这些对象的状态大部分是可共享的。</li><li><strong>内存优化</strong>：对象数量过多会导致内存开销过大，享元模式通过共享对象减少内存占用。</li><li><strong>状态稳定</strong>：共享的对象需要具有较为稳定的内部状态。</li></ol><p><strong>典型场景</strong>：</p><ul><li>文本编辑器中字符对象的复用。</li><li>图形应用中重复绘制的形状或图元（如树、建筑）。</li><li>数字常量缓冲池。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在 Integer 中就采用了享元模式，即 Integer 中缓冲池。</p><p>很多人都遇到过一个面试题，即 Integer -128 到 127 之内的相等，而超过这个范围用 &#x3D;&#x3D; 就不对了，<strong>因为这个范围内采用了享元模式，本质就是同一个对象，所以用 &#x3D;&#x3D; 判断当然一致</strong>。</p><p>原理就是 <code>Integer</code> 内部有个 <code>IntegerCache</code> ，在静态块中会初始化好缓存值：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20210228112757226_mianshiya.png"></p><p>在相关 Integer 操作的时候，会判断它的值是否在 <code>IntegerCache</code> 内，如果是则直接范围 <code>IntegerCache</code> 内已经初始化好的值，比如 <code>valueOf</code> 接口：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20210228112742081_mianshiya.png"></p><p>jdk 之所以要这样实现，是因为根据实践发现大部分的数据操作都集中在值比较小的范围，所以采用了享元模式，给 Integer 搞了个缓存池，默认范围是 -128 到 127。延伸下，可根据设置 <code>JVM-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来修改缓存的最大值，最小值改不了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/dreamInTheWorld/article/details/42928079">人人都能看懂的工厂方法模式和抽象工厂模式的区别-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【徵羽摩柯】只字不提（Cover：周深）【音乐缘计划】【ACE Cover】</title>
      <link href="/p/a027699d/"/>
      <url>/p/a027699d/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/只字不提.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【徵羽摩柯】只字不提_small.mov" type="video/mp4" >      </video></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《只字不提》</p><p>翻唱：徵羽摩柯（ACE Studio）</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><br><p>感谢小墨帮忙导出！</p><p>选了130首歌之后终于找到新赛道 思路打开（</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>词：赵楠&#x2F;包安全<br>曲：周月&#x2F;包安全<br>OP：北京拾陆文化传播有限公司<br>SP：北京千亩稻田文化传播有限公司<br>音乐总监：刘卓<br>音响总监：张小年<br>制作人：刘卓&#x2F;周深<br>音乐统筹：郎梓朔<br>编曲：朱麦文<br>现场乐队：VBand<br>钢琴：傅一峥<br>键盘：孙维峰<br>吉他：董珂铭&#x2F;王海洋<br>鼓：邓华龙<br>贝斯：杨琪<br>合音：关晓林&#x2F;石行&#x2F;邢晏侨<br>和声：周深<br>电脑工程：岳义<br>音频编辑：石行<br>混音：赵靖</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>街边 偶遇熟悉陌生的你<br>擦肩 你头也没回便远去<br>风吹得肆意<br>冻结了记忆<br>却始终没法忘记</p><br><p>房间 时钟声音模糊清晰<br>消息 对话框没任何回应<br>你已销声匿迹<br>对我避之不及<br>只是我还不甘心</p><br><p>后来的你<br>关于我 已只字不提<br>仿佛和你<br>从未有 热烈的经历<br>熟练地 将这一切规避</p><br><p>此刻的你<br>还是否会想起曾经<br>那些过往<br>还是否苟活在你回忆<br>曾触手可及的你 在哪里<br>在哪里</p><br><p>房间 时钟声音模糊清晰<br>消息 对话框没任何回应<br>你已销声匿迹<br>对我避之不及<br>只是我还不甘心</p><br><p>后来的你<br>关于我 已只字不提<br>仿佛和你<br>从未有 热烈的经历<br>熟练地 将这一切规避</p><br><p>此刻的你<br>还是否 会想起曾经<br>那些过往<br>还是否苟活在你回忆<br>曾触手可及的你<br>在哪里</p><br><p>后来的你 关于我 已只字不提<br>仿佛和你 从未有 热烈的经历<br>熟练地 将这一切规避<br>此刻的你 还是否 会想起曾经<br>那些过往 还是否苟活在你回忆<br>曾触手可及的你 在哪里<br>在哪里<br>你在哪里<br>曾触手可及的你 在哪里</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
            <tag> 徵羽摩柯 </tag>
            
            <tag> 音乐缘计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Spring】MVC &amp; 事务</title>
      <link href="/p/21cdaec5/"/>
      <url>/p/21cdaec5/</url>
      
        <content type="html"><![CDATA[<h2 id="说下对-Spring-MVC-的理解？"><a href="#说下对-Spring-MVC-的理解？" class="headerlink" title="说下对 Spring MVC 的理解？"></a>说下对 Spring MVC 的理解？</h2><p>Spring MVC 是基于 Servlet API 构建的，可以说核心就是 DispatcherServlet，即一个前端控制器。</p><p>还有几个重要的组件：处理器映射、控制器、视图解析器等。</p><p>由这几个组件让我们与 Servlet 解耦，不需要写一个个 Servlet ，基于 Spring 的管理就可以很好的实现 web 应用，简单，方便。</p><p>可以简单解释下 MVC 的 Model，View，Controller。</p><p>Model：模型表示应用程序的数据状态。它负责处理应用程序的数据，并将数据传递给视图层。</p><p>View：视图负责呈现数据给用户。它主要是用户界面的表示层，可以是 JSP、Thymeleaf、FreeMarker 等。视图是从模型中获取数据并进行展示。</p><p>Controller：控制器处理用户请求，负责将请求分发到相应的服务层或业务逻辑层，并将处理结果传递给视图层。它是连接模型和视图的桥梁。</p><h2 id="Spring-MVC-具体的工作原理？"><a href="#Spring-MVC-具体的工作原理？" class="headerlink" title="Spring MVC 具体的工作原理？"></a>Spring MVC 具体的工作原理？</h2><p>当一个请求过来的时候，由 DispatcherServlet 接待，它会根据处理器映射（HandlerMapping）找到对应的 HandlerExecutionChain（这里面包含了很多定义的 HandlerInterceptor，拦截器）。</p><p>然后通过 HandlerAdapter 适配器的适配（适配器模式了解一下）后，执行 handler，即通过 controller 的调用，返回 ModelAndView。</p><p>然后 DispatcherServlet 解析得到 ViewName，将其传给 ViewResoler 视图解析器，解析后获得 View 视图。</p><p>然后 DispatcherServlet 将 model 数据填充到 view ，得到最终的 Responose 返回给用户。</p><h2 id="能简单说说请求是如何找到对应的-controller-吗？"><a href="#能简单说说请求是如何找到对应的-controller-吗？" class="headerlink" title="能简单说说请求是如何找到对应的 controller 吗？"></a>能简单说说请求是如何找到对应的 controller 吗？</h2><p>当请求打到 Spring MVC 应用程序时，请求首先会到达一个叫做 DispatcherServlet 的核心控制器，它是所有请求的入口点。</p><p>然后请求会利用 HandlerMapping 找到具体的 handle，实际就是通过请求的 URL 查找对应的映射配置，得到对应的 controller 。</p><p>不过再具体一些，HandlerMapping 找到的其实是 HandlerExecutionChain ，它包含了拦截器和 handler，请求需要先进过拦截器的处理才会到最后的handler（也就是controller内的方法）。</p><h2 id="介绍下-Spring-MVC-的核心组件？"><a href="#介绍下-Spring-MVC-的核心组件？" class="headerlink" title="介绍下 Spring MVC 的核心组件？"></a>介绍下 Spring MVC 的核心组件？</h2><p>Spring MVC 的核心组件主要包括以下几个：</p><ol><li>DispatcherServlet：前端控制器，是 Spring MVC 的核心。负责接收 HTTP 请求，将其分派到相应的处理器（Controller）进行处理。</li><li>HandlerMapping：根据请求 URL、请求方法、请求参数等，映射请求到具体的处理器（Controller）方法。</li><li>Controller：处理用户请求，执行业务逻辑，返回视图名称和模型数据</li><li>ModelAndView：将数据传递给视图层，渲染响应。</li><li>ViewResolver：将逻辑视图名称解析为实际视图对象，找到具体的视图文件，如 JSP、Thymeleaf 模板。</li><li>View：负责渲染模型数据的视图对象。</li><li>Model：用于在 Controller 和 View 之间传递数据，包含需要在视图中展示的属性和对象。</li></ol><h2 id="什么是-Restful-风格的接口？"><a href="#什么是-Restful-风格的接口？" class="headerlink" title="什么是 Restful 风格的接口？"></a>什么是 Restful 风格的接口？</h2><p>实际上 RESTful 就是要求我们不要在 URL 上表现出动作，而是用 HTTP 动词代表动作，URL 上只做资源。</p><p>比如获取一个 user。</p><p>非 RESTful ：GET &#x2F;getUserById?userId&#x3D;1</p><p>RESTful ：GET &#x2F;users&#x2F;1</p><p>对应到 SpringMVC 代码就是 url 不写什么 get 之类的动词，而是通过 HTTP 请求（如 GET、POST、PUT、DELETE）访问服务端资源。</p><h3 id="扩展-REST"><a href="#扩展-REST" class="headerlink" title="扩展 REST"></a>扩展 REST</h3><p>REST 不是一个单词，是 <strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer 的缩写。</p><p>直译过来就是表述性状态转移，其实它还有个主语 Resource，所以是<strong>资源的表述性状态转移</strong>。</p><p>知道 REST 之后 RESTful 就不难解释了，加 ful 就是变形容词了。</p><p>核心就是资源，<strong>用 URL 定位资源，用 HTTP 动词来描述所要做的操作</strong>，这就是 REST 的核心</p><p>HTTP的提供了很多动词：GET、PUT、POST、DELETE……</p><p>这些动词都是有含义的。</p><p>比如 GET 就是获取资源，是查询请求。</p><p>PUT 指的是修改资源，是幂等的。</p><p>POST 也是修改(新增也是一种修改)，指的是不幂等的操作。</p><p>所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下：</p><p>比如获取一个 user。</p><p>错误姿势：<code>GET /getUserById?userId=1</code>。</p><p>正确姿势：<code>GET /users/1</code>。</p><p>再比如新增 user。</p><p>错误姿势：<code>POST /addUser （省略body）</code>。</p><p>正确姿势：<code>POST /users （省略body）</code>。</p><p>可以看到 <strong>HTTP 的动词其实就能指代你要对资源做的操作</strong>，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。</p><p>这里注意要<strong>用对 HTTP 动词</strong>，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。</p><p>其实更深一步的理解是 <strong>HTTP 是一个协议</strong>。</p><p>协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。</p><p>可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。</p><p>这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。</p><p>当然理想很丰满，现实很骨感，还是有很多人就 getUserById。</p><p>不过我个人觉得问题不大，公司统一就行。</p><h2 id="Spring-MVC中的Controller是什么？如何定义一个Controller？"><a href="#Spring-MVC中的Controller是什么？如何定义一个Controller？" class="headerlink" title="Spring MVC中的Controller是什么？如何定义一个Controller？"></a>Spring MVC中的Controller是什么？如何定义一个Controller？</h2><p>在 Spring MVC 中，Controller 是一个用于处理用户请求和返回响应的组件。它作为模型-视图-控制器（MVC）设计模式中的控制器部分，负责接收用户的输入，调用业务逻辑，并返回响应结果。</p><p>@Controller 用于标记传统 MVC 控制器，它们返回视图和模型数据。</p><p>@RestController 是 @Controller 和 @ResponseBody 的组合，用于标记 RESTful 控制器，它们直接返回响应体。</p><h3 id="参数接受"><a href="#参数接受" class="headerlink" title="参数接受"></a>参数接受</h3><p>使用 @RequestParam 注解来接收查询参数或表单数据。</p><p>使用 @PathVariable 注解来提取 URL 路径中的变量。</p><p>使用 @RequestBody 注解来接收请求正文中的 JSON 或 XML 数据。</p><h2 id="Spring-MVC-中的国际化支持是如何实现的？"><a href="#Spring-MVC-中的国际化支持是如何实现的？" class="headerlink" title="Spring MVC 中的国际化支持是如何实现的？"></a>Spring MVC 中的国际化支持是如何实现的？</h2><p>国际化（i18n）是指在应用程序中提供多种语言和区域设置的支持，使得不同语言的用户都能使用该应用程序。（例如一些航空公司的网页或软件，都需要提供国际化的支持）</p><p>Spring 中国际化的主要组件：</p><ul><li>MessageSource：用于加载和管理国际化消息资源。</li><li>LocaleResolver：用于解析和确定用户的区域设置（Locale）。</li></ul><p>具体实现步骤：</p><p>1）配置 MessageSource：</p><p>定义消息资源文件（如 messages.properties、messages_en.properties）。</p><p>2）注册 MessageSource bean，用于加载这些消息资源文件。</p><p>4）配置 LocaleResolver：</p><p>配置 LocaleResolver bean，用于确定用户的区域设置或通过 HandlerInterceptor 拦截器获取前端传的 <code>lang</code> 参数。</p><p>4）控制器中的使用：</p><p>在控制器中使用 Locale 和 MessageSource 获取国际化消息。</p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><p>1）定义消息资源文件：</p><p>messages.properties：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greeting=你好</span><br></pre></td></tr></table></figure><p>messages_en.properties：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greeting=Hello</span><br></pre></td></tr></table></figure><p>2）注入配置 MessageSource bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ResourceBundleMessageSource <span class="title function_">messageSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundleMessageSource</span> <span class="variable">messageSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">        messageSource.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">        messageSource.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）配置 LocaleResolver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LocaleResolver <span class="title function_">localeResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SessionLocaleResolver</span> <span class="variable">localeResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SessionLocaleResolver</span>();</span><br><span class="line">    localeResolver.setDefaultLocale(Locale.ENGLISH);</span><br><span class="line">    <span class="keyword">return</span> localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）控制器中的使用</p><p>通过 MessageSource 和 Locale 获取国际化信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greet&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(Locale locale, Model model)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> messageSource.getMessage(<span class="string">&quot;greeting&quot;</span>, <span class="literal">null</span>, locale);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, greeting);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;greet&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-MVC-父子容器是什么知道吗？"><a href="#Spring-MVC-父子容器是什么知道吗？" class="headerlink" title="Spring MVC 父子容器是什么知道吗？"></a>Spring MVC 父子容器是什么知道吗？</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/x8WPdZry_92fadbb4-ec32-4efa-9427-d1bf4103e477.png"></p><p>可以看到，services 和 repositories 是属于父容器的，而 Controllers 等是属于子容器的。</p><p>那为什么会有父子之分？</p><p>其实 Spring 容器在启动的时候，不会有 Spring MVC 这个概念，只会扫描文件然后创建一个 context ，此时就是父容器。</p><p>然后发现是 web 服务需要生成 DispatcherServlet ，此时就会调用 DispatcherServlet#init，这个方法里面最会生成一个新的 context，并把之前的 context 置为自己的 Parent。</p><p>这样就有了父子之分，这样指责就更加清晰，子容器就负责 web 部分，父容器则是通用的一些 bean。</p><p>也正是有了父子之分，如果有些人没把 controller 扫包的配置写在 spring-servlet.xml ，而写到了 service.xml 里，那就会把 controller 添加到父容器里，这样子容器里面就找不到了，<strong>请求就 404 了</strong>。</p><p>当然，如果你把 services 和 repositories 添加到子容器是没影响的，不过没必要，分层还是比较好的方式。</p><p>对了，子容器可以用父容器的 Bean，父容器不能用子容器的 Bean。</p><h2 id="你了解的-Spring-都用到哪些设计模式？"><a href="#你了解的-Spring-都用到哪些设计模式？" class="headerlink" title="你了解的 Spring 都用到哪些设计模式？"></a>你了解的 Spring 都用到哪些设计模式？</h2><ul><li>工厂模式，从名字就看出来了 BeanFacotry，整个 Spring IOC 就是一个工厂。</li><li>模板方法，例如 JdbcTemplate、RestTemplate 名字是 xxxTemplate 的都是模板。</li><li>代理模式，AOP 整的都是代理。</li><li>单例，默认 bean 都是单例的。</li><li>责任链模式，比如 Spring MVC 中的拦截器，多个拦截器串联起来就是责任链。</li><li>观察者模式，Spring 里的监听器。</li><li>适配器模式，SpringMVC 提到的 handlerApdaper 其实就是适配器。</li></ul><h2 id="Spring-事务有几个隔离级别？"><a href="#Spring-事务有几个隔离级别？" class="headerlink" title="Spring 事务有几个隔离级别？"></a>Spring 事务有几个隔离级别？</h2><p>从源码定义我们可以看到，一共有 5 种隔离级别，而 DEFAULT 就是使用数据库定义的隔离级别。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/7jc0MbTS_8bb08ab2-81c8-47a5-a3a6-3847f872358c.png"></p><p>其他几种分别是：读未提交、读已提交、可重复读、序列化。</p><p>1）读未提交，READ UNCOMMITED，简称 RU，最宽松的限制，即一个事务的修改还未提交，另一个事务就能看到修改的结果，会产生脏读现象。</p><p>2）读已提交，READ COMMITED，简称 RC，即一个事务只能读到另一个事务已经提交的修改，所以在一个事务里面的多次查询可能会得到不同的结果，因为第一次查询的时候，另一个事务还未提交，所以看不到修改的结果，第二次查询的时候，另一个事务提交了，因此读到了修改后的结果，所以两次查询结果不一致，称之为：不可重复读。</p><p>3）可重复读，REPEATABLE READ，简称 RR，它比 RC 更严格，即一个事务开始的时候读不到，那之后也读不到，也就是一个事务内的多次读结果是一致的，但是有幻读情况，即第一次读拿到了四行数据，第二次读拿到了五行数据，因为有新插入的行，不过 InnoDB 利用 MVCC 解决了大部分幻读的情况，利用 update当前读再 select 的幻读无法解决，之前文章已经提到，这里不再赘述。</p><p>4）串行化，SERIALIZABLE，最严格的模式，即这个隔离级别的读写访问会把需要遍历到的记录上锁，这样另一个事务要访问对应的记录时候就被阻塞了，需要等待上一个事务提交之后，才能继续执行，所以叫串行。在 InnoDB 中，非自动提交时，会隐式地将所有普通的 SELECT 语句转换为 SELECT..LOCK IN SHARE MODE来满足这个隔离级别。</p><h2 id="Spring-有哪几种事务传播行为"><a href="#Spring-有哪几种事务传播行为" class="headerlink" title="Spring 有哪几种事务传播行为?"></a>Spring 有哪几种事务传播行为?</h2><p>从源码来看，一共有 7 种事务传播行为：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/eJ7NcxDe_09fe5de4-a6ca-4b14-9cd4-8d4d06759157.png"></p><ul><li>PROPAGATION_REQUIRED（默认）：如果当前存在事务，则用当前事务，如果没有事务则新起一个事务</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果不存在，则以非事务方式执行</li><li>PROPAGATION_MANDATORY：支持当前事务，如果不存在，则抛出异常</li><li>PROPAGATION_REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起当前事务</li><li>PROPAGATION_NOT_SUPPORTED：不支持当前事务，始终以非事务方式执行</li><li>PROPAGATION_NEVER：不支持当前事务，如果当前存在事务，则抛出异常</li><li>PROPAGATION_NESTED：如果当前事务存在，则在嵌套事务中执行，内层事务依赖外层事务，如果外层失败，则会回滚内层，内层失败不影响外层。</li></ul><h2 id="Spring-事务传播行为有什么用"><a href="#Spring-事务传播行为有什么用" class="headerlink" title="Spring 事务传播行为有什么用?"></a>Spring 事务传播行为有什么用?</h2><p>其实答案就几个字：<strong>控制事务的边界</strong>。</p><p>拿 PROPAGATION_NESTED 来举例。<strong>如果外层事务失败，则会回滚内层事务，内层事务失败不影响外层事务</strong>。</p><p>可以发现，外层事务失败会影响到内层事务，这说明从事务角度来看，外层到内层之间是没有边界的，因为外层会影响到内层的事务。</p><p>而内层失败则不影响外层，说明内层往外层之间事务是有边界的，使得影响无法传播出去。</p><p>再比如 PROPAGATION_REQUIRED（默认）。如果当前存在事务，则用当前事务，如果没有事务则新起一个事务。</p><p>说明这个配置下，多个方法之间不想要有边界，它们想在一个事务中，这样但凡有一个方法出错都会回滚，就能保证它们是“一体”的，它们想要相互影响。</p><p>因此，每种事务传播行为都有其独特的使用场景和作用，能够灵活控制事务的边界，确保事务的一致性和隔离性。</p><h2 id="Spring-事务在什么情况下会失效？"><a href="#Spring-事务在什么情况下会失效？" class="headerlink" title="Spring 事务在什么情况下会失效？"></a>Spring 事务在什么情况下会失效？</h2><p>一般而言失效的情况都是用了声明式事务即 @Transactional 注解，如果使用了这个注解那么在以下几个情况下会导致事务失效：</p><p>1）rollbackFor 没设置对，比如默认没有任何设置（RuntimeException 或者 Error 才能捕获），则方法内抛出 IOException 则不会回滚，需要配置 <code>@Transactional(rollbackFor = Exception.class)</code>。</p><p>2）异常被捕获了，比如代码抛错，但是被 catch 了，仅打了 log 没有抛出异常，这样事务无法正常获取到错误，因此不会回滚。</p><p>3）同一个类中方法调用，因此事务是基于动态代理实现的，同类的方法调用不会走代理方法，因此事务自然就失效了。</p><p>4）@Transactional 应用在非 public 修饰的方法上，Spring 事务管理器判断非公共方法则不应用事务。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/CQfM5yy7_image.png"></p><p>5）@Transactional 应用在 final 和 static 方法上，因为 aop （Spring Boot2.x版本默认是 cglib，Spring 自身默认是 jdk，一般现在用的都是 SpringBoot）默认是 cglib 代理，无法对 final 方法子类化。static 是静态方法，属于类，不属于实例对象，无法被代理！</p><p>6）propagation 传播机制配置错误，例如以下的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserAndAddress</span><span class="params">(User user,Address address)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    userMapper.save(user);</span><br><span class="line">    addAddress(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">    addressMapper.save(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为配置了 Propagation.REQUIRES_NEW，是新起了一个事务，即 addAddress 的事务和 addUserAndAddress 其实不是一个事务，因此两个事务之间当然就无法保证数据的一致性了。</p><p>7）多线程环境，因为 @Transactional 是基于 ThreadLocal 存储上下文的，多线程情况下每个线程都有自己的上下文，那么之间如何保持事务同步？保持不了，因此事务失效。</p><p>8）用的是 MyISAM，这个引擎本身不支持事务！</p><h2 id="Spring、SpringMVC、SpringBoot-三者之间是什么关系？"><a href="#Spring、SpringMVC、SpringBoot-三者之间是什么关系？" class="headerlink" title="Spring、SpringMVC、SpringBoot 三者之间是什么关系？"></a>Spring、SpringMVC、SpringBoot 三者之间是什么关系？</h2><p>Spring、SpringMVC、SpringBoot 是三个独立的框架，它们之间的关系是：</p><ol><li>Spring 是一个 Java 的<strong>轻量级应用框架</strong>，提供了基于 <strong>IoC</strong> 和 <strong>AOP</strong> 的支持，用于构建企业级应用。Spring 有多个模块，包括 <strong>Spring Core、Spring Context、Spring JDBC、Spring Web</strong> 等，每个模块提供了不同的功能。</li><li>Spring MVC 是 Spring 框架的一部分，是<strong>基于 MVC 设计模式的 Web 框架</strong>，用于构建 Web 应用程序。它提供了<strong>控制器、视图解析器、数据绑定、异常处理</strong>等功能，使得开发 Web 应用变得更加简单。SpringMVC 还支持 RESTful 架构。</li><li>SpringBoot 是<strong>基于 Spring 框架的一个开发框架</strong>，用于快速构建独立的、生产级别的 Spring 应用程序。它通过<strong>自动配置</strong>和<strong>约定优于配置</strong>的方式，简化了 Spring 应用程序的配置和开发过程。SpringBoot 集成了很多常用的第三方库和工具，例如 Spring Data、Spring Security、Thymeleaf、Logback 等，可以极大地提高开发效率。</li></ol><p>因此，SpringBoot 可以看作是<strong>在 Spring 的基础上，通过自动配置和约定优于配置的方式</strong>，提供了更加简单、快速的开发体验。而 <strong>SpringMVC 则是 Spring 框架中用于构建 Web 应用程序的模块</strong>。</p><div class="note  flat info"><p>这题可以提一下 Spring Boot 内置了 Tomcat、Undertow 等服务器，不用像传统 SSM 一样自己去搭 Tomcat 等环境了，简化了开发</p></div>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Spring】Bean/IoC/AOP/启动流程</title>
      <link href="/p/37c37880/"/>
      <url>/p/37c37880/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h2><p>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。bean 是由Spring IoC 容器实例化、组装和管理的对象。</p><h2 id="什么是-Spring-IoC？"><a href="#什么是-Spring-IoC？" class="headerlink" title="什么是 Spring IoC？"></a>什么是 Spring IoC？</h2><p>IoC，即 Inversion of Control，控制反转。<strong>控制反转通过依赖注入（DI）方式实现对象之间的松耦合关系</strong>。</p><p>首先要明确 IOC 是一种思想，而<strong>不是一个具体的技术</strong>，其次 IOC 这个思想也不是 Spring 创造的。</p><p>然后我们要理解到底<strong>控制</strong>的是什么，其实就是<strong>控制对象的创建</strong>，IOC 容器根据配置文件来创建对象，在对象的生命周期内，在<strong>不同时期</strong>根据不同配置进行对象的创建和改造。</p><p>那什么被<strong>反转</strong>了？其实就是关于创建对象且注入依赖对象的这个动作，本来这个动作是由我们程序员在代码里面指定的，例如对象 A 依赖对象 B，在创建对象 A 代码里，我们需要写好如何创建对象 B，这样才能构造出一个完整的 A。</p><p>而反转之后，这个动作就由 IOC 容器触发，IOC 容器在创建对象 A 的时候，发现依赖对象 B ，根据配置文件，它会创建 B，并将对象 B 注入 A 中。</p><p>这里要注意，注入的不一定非得是一个对象，也可以注入配置文件里面的一个值给对象 A 等等。</p><p>在 Spring 中，类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制，而不是用 new 方式实例化对象、通过非构造函数方法传入依赖等常规方式。实质的控制权已经交由程序管理，而不是程序员管理，所以叫控制反转。</p><h2 id="Spring-中的-DI-是什么？"><a href="#Spring-中的-DI-是什么？" class="headerlink" title="Spring 中的 DI 是什么？"></a>Spring 中的 DI 是什么？</h2><p>DI，Dependency Injection，依赖注入。</p><p>普遍的答案是 DI 是 IOC 的一种实现。</p><p>其实它跟 IOC 的概念一致，只是从不同角度来描述罢了。</p><p>大致理解为容器在运行的时候，可以找到被依赖的对象，然后将其注入，通过这样的方式，使得各对象之间的关系可由运行期决定，而不用在编码时候明确。</p><h2 id="Spring-IOC-有什么好处？"><a href="#Spring-IOC-有什么好处？" class="headerlink" title="Spring IOC 有什么好处？"></a>Spring IOC 有什么好处？</h2><p>对象的创建都由 IOC 容器来控制之后，对象之间就不会有很明确的依赖关系，使得非常容易设计出松耦合的程序。</p><p>例如，对象 A 需要依赖一个实现 B，但是对象都由 IOC 控制之后，我们不需要明确地在对象 A 的代码里写死依赖的实现 B，只需要写明依赖一个接口，这样我们的代码就能顺序的编写下去。</p><p>然后，我们可以在配置文件里定义 A 依赖的具体的实现 B，根据配置文件，在创建 A 的时候，IOC 容器就知晓 A 依赖的 B，这时候注入这个依赖即可。</p><p>如果之后你有新的实现需要替换，那 A 的代码不需要任何改动，你只需要将配置文件 A 依赖 B 改成 B1，这样重启之后，IOC 容器会为 A 注入 B1。</p><p>并且也因为创建对象由 IOC 全权把控，那么我们就能很方便的让 IOC 基于扩展点来“加工”对象，例如我们要代理一个对象，IOC 在对象创建完毕，直接判断下这个对象是否需要代理，如果要代理，则直接包装返回代理对象。</p><p>这等于我们只要告诉 IOC 我们要什么，IOC 就能基于我们提供的配置文件，创建符合我们需求的对象。</p><h2 id="Spring-中的-FactoryBean-是什么？"><a href="#Spring-中的-FactoryBean-是什么？" class="headerlink" title="Spring 中的 FactoryBean 是什么？"></a>Spring 中的 FactoryBean 是什么？</h2><p>从命名角度来看，我们可以得知它就是一个 Bean，而不是一个工厂。</p><p>那为什么名字如此奇怪，它其实是一个接口，并且有以下几个方法：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/CISrnraB_4b5433fd-c3d9-4606-af51-c988ab8f9285.png" alt="img"></p><p>如果一个对象实现了这接口，那它就成为一种特殊的 Bean，注册到 IOC 容器之后，如果调用 getBean 获取得到的其实是 FactoryBean.getObject() 方法返回的结果。</p><p>为什么要这样做？</p><p>假设你依赖一个第三方的类 A，而我们又不能修改第三方的类，并且这个对象创建比较复杂，那么你就可以创建一个 bean 来封装它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.setXXX</span><br><span class="line">        ....</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    &#125;</span><br><span class="line">    ....省略一些实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们 getBean(“A”) 会得到 AFactoryBean.getObject 的结果，如果单纯只想要 AFactoryBean， 那么加个 “&amp;” 即可，即 getBean(“&amp;A”)</p><h2 id="Spring-Bean-一共有几种作用域？"><a href="#Spring-Bean-一共有几种作用域？" class="headerlink" title="Spring Bean 一共有几种作用域？"></a>Spring Bean 一共有几种作用域？</h2><p>从官网，我们很容易可以得知，最新版本一共有六种作用域：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/qwlMoKUc_673e289c-a559-4966-9d3c-845ab8043e24.png"></p><ul><li>singleton：默认是单例，含义不用解释了吧，一个 IOC 容器内部仅此一个</li><li>prototype：原型，多实例</li><li>request：每个请求都会新建一个属于自己的 Bean 实例，这种作用域仅存在 Spring Web 应用中</li><li>session：一个 http session 中有一个 bean 的实例，这种作用域仅存在 Spring Web 应用中</li><li>application：整个 ServletContext 生命周期里，只有一个 bean，这种作用域仅存在 Spring Web 应用中</li><li>websocket：一个 WebSocket 生命周期内一个 bean 实例，这种作用域仅存在 Spring Web 应用中</li></ul><h2 id="说下-Spring-Bean-的生命周期？"><a href="#说下-Spring-Bean-的生命周期？" class="headerlink" title="说下 Spring Bean 的生命周期？"></a>说下 Spring Bean 的生命周期？</h2><p>在说具体的生命周期前，我们需要先知晓之所以 Bean 容易被添加一些属性，或者能在运行时被改造就是因为在生成 Bean 的时候，Spring对外暴露出很多扩展点。</p><p>基于这些点我们可以设置一些逻辑，Spring 会在 Bean 创建的某些阶段根据这些扩展点，基于此进行 Bean 的改造。</p><p>有了上面的认识，我们再来看 Spring Bean 的生命周期，我用一幅图先总结一下：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/zNxXrxM1_60913d46-9305-41c6-adc6-7787e078b188.png"></p><p>大致了解生命周期之后，我们再来看详细的操作，可以看到有好多扩展点：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/coeRfvs5_4ebac0e4-813d-4fc5-93c7-141e309d57e9.png"></p><h2 id="PostConstruct-和-PreDestroy-注解的作用是什么？"><a href="#PostConstruct-和-PreDestroy-注解的作用是什么？" class="headerlink" title="@PostConstruct 和 @PreDestroy 注解的作用是什么？"></a>@PostConstruct 和 @PreDestroy 注解的作用是什么？</h2><p>Spring 通过它们来管理 Bean 的生命周期。</p><ul><li><p>**<code>@PostConstruct</code>**：用于标记方法，当依赖注入完成后，在 Bean 初始化完成后调用，这个方法会自动被调用。常用于进行初始化逻辑，例如设置默认值、检查依赖等。</p><ul><li><p><strong>使用场景</strong>：</p><ul><li><strong>依赖注入后做额外的初始化工作</strong>：例如，某个服务需要在依赖注入后连接外部系统。</li><li><strong>进行状态检查</strong>：在 Bean 初始化后验证某些关键属性是否正确配置。</li></ul></li><li><p><strong>执行时机</strong>：</p><ul><li><code>@PostConstruct</code> 方法在依赖注入完成后立即执行，但在 Bean 可以被其他对象使用之前调用（即在 Bean 完成初始化前调用，Bean 处于准备状态）。</li></ul></li></ul></li><li><p>**<code>@PreDestroy</code>**：用于标记方法，在 Bean 即将被销毁时调用。常用于进行资源的释放、清理工作。</p><ul><li><p><strong>使用场景</strong>：</p><ul><li><p><strong>资源清理</strong>：例如关闭数据库连接、文件句柄、线程池等。</p></li><li><p><strong>会话管理</strong>：例如在 Web 应用中，清理用户会话或缓存。</p></li></ul></li><li><p><strong>执行时机</strong>：</p><ul><li><code>@PreDestroy</code> 方法在 Bean 即将被销毁时调用，一般是在 Spring 容器关闭时执行。对于单例（<code>singleton</code>）作用域的 Bean，会在容器关闭时调用；对于原型（<code>prototype</code>）作用域的 Bean，不会调用销毁方法，因为容器不管理其生命周期。</li></ul></li></ul></li></ul><h2 id="Spring-的启动过程？"><a href="#Spring-的启动过程？" class="headerlink" title="Spring 的启动过程？"></a>Spring 的启动过程？</h2><p>Bean的一生从总体上来说可以分为两个阶段：</p><ul><li>容器启动阶段</li><li>Bean实例化阶段</li></ul><ol><li><p>加载配置文件，初始化容器：Spring 启动时首先会读取配置文件（如 XML 配置文件、Java Config 类等），包括配置数据库连接、事务管理、AOP 配置等。</p></li><li><p>实例化容器：Spring 根据配置文件中的信息创建容器 ApplicationContext，在容器启动阶段实例化 BeanFactory，会扫描所有的 Bean 定义。对于基于注解的配置，Spring 会扫描指定包下的所有带有 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code> 等注解的类，并加载它们的定义到容器中。对于 XML 配置，Spring 会解析 <code>&lt;bean&gt;</code> 元素并加载定义，得到 BeanDefinitions。</p></li><li><p>解析 BeanDefinitions：Spring 容器会解析配置文件中的 BeanDefinitions，即声明的 Bean 元数据，包括 Bean 的作用域、依赖关系等信息。</p></li><li><p>实例化 Bean：Spring 根据 BeanDefinitions 实例化 Bean 对象，将其放入容器管理，但不会立即注入依赖。这个过程类似于类的构造函数调用。</p></li><li><p>注入依赖：Spring 进行依赖注入，将 Bean 之间的依赖关系进行注入，包括构造函数注入、属性注入等。</p><ul><li><p><strong>构造函数注入</strong>：通过构造函数来注入依赖。</p></li><li><p><strong>Setter 注入</strong>：通过 Setter 方法注入依赖。</p></li><li><p><strong>字段注入</strong>：通过 <code>@Autowired</code> 注解直接注入字段。</p></li></ul></li><li><p>处理 Bean 生命周期初始化方法：</p><ul><li><p>Spring 调用 Bean 初始化方法（如果有定义的话），对 Bean 进行初始化。</p></li><li><p>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 会调用其 <code>afterPropertiesSet</code> 方法。</p></li></ul></li><li><p>处理 BeanPostProcessors：容器定义了很多 BeanPostProcessor，处理其中的自定义逻辑，例如 postProcessBeforeInitialization 会在 Bean 初始化前调用， postProcessAfterInitialization 则在之后调用。</p><p>Spring AOP 代理也在这个阶段生成。</p></li><li><p>发布事件：Spring 可能会在启动过程中发布一些事件，比如容器启动事件。</p></li><li><p>完成启动：当所有 Bean 初始化完毕、依赖注入完成、AOP 配置生效等都准备就绪时，Spring 容器启动完成。</p></li></ol><p>需要指出，容器启动阶段与Bean实例化阶段存在多少时间差。</p><p>如果我们选择懒加载的方式，那么直到我们伸手向Spring要依赖对象实例之前，其都是以BeanDefinationRegistry中的一个个的BeanDefination的形式存在，也就是Spring只有在我们需要依赖对象的时候才开启相应对象的实例化阶段。</p><p>而如果我们不是选择懒加载的方式，容器启动阶段完成之后，将立即启动Bean实例化阶段，通过隐式的调用所有依赖对象的getBean方法来实例化所有配置的Bean并保存起来。</p><h2 id="Spring-Bean-注册到容器有哪些方式？"><a href="#Spring-Bean-注册到容器有哪些方式？" class="headerlink" title="Spring Bean 注册到容器有哪些方式？"></a>Spring Bean 注册到容器有哪些方式？</h2><p>Spring Bean 注册到容器的方式主要包括以下几种：</p><p>1）基于 XML 的配置</p><p>使用 XML 文件配置 Bean，并定义 Bean 的依赖关系。</p><p>2）基于 <code>@Component</code> 注解及其衍生注解</p><p>使用注解如 <code>@Component</code>、<code>@Service</code> 、<code>@Controller</code>、<code>@Repository</code> 等进行配置。</p><table><thead><tr><th>声明</th><th>含义</th></tr></thead><tbody><tr><td><code>@Component</code></td><td>当前类是组件，没有明确的意思，可以用于任何类，标记该类为 Spring 管理的 Bean。</td></tr><tr><td><code>@Service</code></td><td>当前类在业务逻辑层使用，用于标记服务类，以便于识别和管理业务逻辑组件。</td></tr><tr><td><code>@Repository</code></td><td>当前类在数据访问层</td></tr><tr><td><code>@Controller</code></td><td>当前类在展示层（MVC）使用，用于处理 HTTP 请求和响应。</td></tr></tbody></table><p> 以上四种声明方式效果完全一致，使用不同的关键词是为了给阅读的人能够快速了解该类属于哪一层。</p><p>3）基于 <code>@Configuration</code> 和 <code>@Bean</code> 注解</p><p>使用 <code>@Configuration</code> 注解声明配置类，并使用 <code>@Bean</code> 注解定义 Bean。</p><p>4）基于 <code>@Import</code> 注解</p><p><code>@Import</code> 可以将普通类导入到 Spring 容器中，这些类会自动被注册为 Bean。</p><h2 id="Bean-和-Component有什么区别？"><a href="#Bean-和-Component有什么区别？" class="headerlink" title="@Bean 和 @Component有什么区别？"></a>@Bean 和 @Component有什么区别？</h2><p>@Bean 和 @Component 都是用于定义 Spring 容器中的 Bean 的注解，但它们的使用场景和方式有所不同：</p><ul><li>@Bean 注解通常用于 Java 配置类的方法上，以声明一个 Bean 并将其添加到 Spring 容器中。</li><li>@Component 注解用于类级别，将该类标记为 Spring 容器中的一个组件，自动检测并注册为 Bean（需要扫对应的包）。</li></ul><h2 id="Spring-的单例-Bean-是否有并发安全问题？"><a href="#Spring-的单例-Bean-是否有并发安全问题？" class="headerlink" title="Spring 的单例 Bean 是否有并发安全问题？"></a>Spring 的单例 Bean 是否有并发安全问题？</h2><p>Spring 的单例 Bean 默认是非线程安全的，但是只要我们避免在多个 Bean 之间共享一些数据，就不用害怕并发问题。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>1）单例 Bean 的生命周期：Spring 容器在初始化时会创建并管理单例 Bean，这些 Bean 在整个应用程序生命周期内只会被创建一次，并且被多个线程共享使用。</p><p>2）多线程访问：如果单例 Bean 中包含共享的可变状态（如实例变量），多个线程同时访问并修改这些共享状态时，可能会导致并发安全问题，如数据不一致、脏读、死锁等。</p><h2 id="Spring-Bean如何保证并发安全？"><a href="#Spring-Bean如何保证并发安全？" class="headerlink" title="Spring Bean如何保证并发安全？"></a>Spring Bean如何保证并发安全？</h2><p>大致可以分三种方式：</p><p>1）无状态 Bean：如果单例 Bean 不包含可变状态，或者仅包含只读状态，通常不会有并发安全问题。例如，所有方法都是无状态的纯函数，或者使用的是本地变量。</p><p>2）线程安全设计：确保单例 Bean 中的方法是线程安全的。可以通过同步方法、使用线程安全的数据结构（如 ConcurrentHashMap）、或使用 java.util.concurrent 包中的其他并发工具类。</p><p>3）@Scope(“prototype”)：对于需要状态的 Bean，可以将其作用域设置为原型（prototype），这样每次请求该 Bean 时，Spring 容器都会返回一个新的实例。</p><h2 id="什么是循环依赖（常问）？"><a href="#什么是循环依赖（常问）？" class="headerlink" title="什么是循环依赖（常问）？"></a>什么是循环依赖（常问）？</h2><p>例如 A 要依赖 B，发现 B 还没创建，于是开始创建 B ，创建的过程发现 B 要依赖 A， 而 A 还没创建好呀，因为它要等 B 创建好，就这样<strong>它们俩就搁这卡 bug 了</strong>。</p><h2 id="Spring-如何解决循环依赖？"><a href="#Spring-如何解决循环依赖？" class="headerlink" title="Spring 如何解决循环依赖？"></a>Spring 如何解决循环依赖？</h2><p>关键就是<strong>提前暴露未完全创建完毕的 Bean</strong>。</p><p>在 Spring 中，只有同时满足以下两点才能解决循环依赖的问题：</p><ol><li>依赖的 Bean 必须都是单例</li><li>依赖注入的方式，必须<strong>不全是</strong>构造器注入，且 beanName 字母序在前的不能是构造器注入</li></ol><h3 id="为什么必须都是单例"><a href="#为什么必须都是单例" class="headerlink" title="为什么必须都是单例"></a>为什么必须都是单例</h3><p>因为原型模式都需要创建新的对象，不能用以前的对象。如果是单例的话，创建 A 需要创建 B，而创建的 B 需要的是之前的 A， 不然就不叫单例了，对吧？</p><p>也是基于这点， Spring 就能操作操作了。</p><p>具体做法就是：先创建 A，此时的 A 是不完整的（没有注入 B），用个 map 保存这个不完整的 A，再创建 B ，B 需要 A，所以从那个 map 得到“不完整”的 A，此时的 B 就完整了，然后 A 就可以注入 B，然后 A 就完整了，B 也完整了，且它们是相互依赖的。</p><h3 id="为什么不能全是构造器注入"><a href="#为什么不能全是构造器注入" class="headerlink" title="为什么不能全是构造器注入"></a>为什么不能全是构造器注入</h3><p>在 Spring 中创建 Bean 分三步:</p><ol><li>实例化，createBeanInstance，就是 new 了个对象</li><li>属性注入，populateBean， 就是 set 一些属性值</li><li>初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等</li></ol><p>明确了上面这三点，再结合我上面说的“不完整的”，我们来理一下。</p><p>如果全是构造器注入，比如<code>A(B b)</code>，那表明在 new 的时候，就需要得到 B，此时需要 new B ，但是 B 也是要在构造的时候注入 A ，即<code>B(A a)</code>，这时候 B 需要在一个 map 中找到不完整的 A ，发现找不到。</p><p>为什么找不到？因为 A 还没 new 完呢，所以找不到完整的 A，<strong>因此如果全是构造器注入的话，那么 Spring 无法处理循环依赖</strong>。</p><p>如果循环依赖不完全是构造器注入，则可能成功，可能失败，具体跟BeanName的字母序有关系。</p><h3 id="Spring-解决循环依赖全流程"><a href="#Spring-解决循环依赖全流程" class="headerlink" title="Spring 解决循环依赖全流程"></a>Spring 解决循环依赖全流程</h3><p>明确了 Spring 创建 Bean 的三步骤之后，我们再来看看它为单例搞的三个 map：</p><ol><li>一级缓存，singletonObjects，存储所有已创建完毕的单例 Bean （完整的 Bean）</li><li>二级缓存，earlySingletonObjects，存储所有仅完成实例化，但还未进行属性注入和初始化的 Bean</li><li>三级缓存，singletonFactories，存储能建立这个 Bean 的一个工厂，通过工厂能获取这个 Bean，延迟化 Bean 的生成，工厂生成的 Bean 会塞入二级缓存</li></ol><p>这三个 map 是如何配合的呢？</p><ol><li>首先，获取单例 Bean 的时候会通过 BeanName 先去 singletonObjects（一级缓存） 查找完整的 Bean，如果找到则直接返回，否则进行步骤 2。</li><li>看对应的 Bean 是否在创建中，如果不在直接返回找不到，如果是，则会去 earlySingletonObjects （二级缓存）查找 Bean，如果找到则返回，否则进行步骤 3</li><li>去 singletonFactories （三级缓存）通过 BeanName 查找到对应的工厂，如果存着工厂则通过工厂创建 Bean ，并且放置到 earlySingletonObjects 中。</li><li>如果三个缓存都没找到，则返回 null。</li></ol><p>从上面的步骤我们可以得知，如果查询发现 Bean 还未创建，到第二步就直接返回 null，不会继续查二级和三级缓存。</p><p>返回 null 之后，说明这个 Bean 还未创建，这个时候会标记这个 Bean 正在创建中，然后再调用 createBean 来创建 Bean，而实际创建是调用方法 doCreateBean。</p><p>doCreateBean 这个方法就会执行上面我们说的三步骤：</p><ol><li>实例化</li><li>属性注入</li><li>初始化</li></ol><p>在实例化 Bean 之后，<strong>会往 singletonFactories 塞入一个工厂，而调用这个工厂的 getObject 方法，就能得到这个 Bean</strong>。</p><h3 id="为什么-Spring-循环依赖需要三级缓存，二级不够吗？"><a href="#为什么-Spring-循环依赖需要三级缓存，二级不够吗？" class="headerlink" title="为什么 Spring 循环依赖需要三级缓存，二级不够吗？"></a>为什么 Spring 循环依赖需要三级缓存，二级不够吗？</h3><p>我们思考下，解决循环依赖需要三级缓存吗？</p><p>很明显，如果仅仅只是为了破解循环依赖，二级缓存够了，压根就不必要三级。</p><p>你思考一下，在实例化 Bean A 之后，我在二级 map 里面塞入这个 A，然后继续属性注入，发现 A 依赖 B 所以要创建 Bean B，这时候 B 就能从二级 map 得到 A ，完成 B 的建立之后， A 自然而然能完成。</p><p>所以<strong>为什么要搞个三级缓存，且里面存的是创建 Bean 的工厂呢</strong>？</p><p><strong>问题就出在时机</strong>，这跟 Bean 的生命周期有关系。</p><p>正常代理对象的生成是基于后置处理器，是<strong>在被代理的对象初始化后期调用生成的</strong>，<strong>所以如果你提早代理了其实是违背了 Bean 定义的生命周期</strong>。</p><p>所以 Spring 先在一个三级缓存放置一个工厂，如果产生循环依赖，那么就调用这个工厂提早得到代理对象，如果没产生依赖，这个工厂根本不会被调用，所以 Bean 的生命周期就是对的。</p><h2 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h2><p>AOP，Aspect Oriented Programming，面向切面编程。</p><p>将一些通用的逻辑集中实现，然后通过 AOP 进行逻辑的切入，减少了零散的碎片化代码，提高了系统的可维护性。</p><p>面向切面编程是一种通过将横切关注点（如日志记录、事务管理、安全检查等）与业务逻辑分离的技术。在传统的编程中，这些横切关注点通常会分散在各个业务逻辑模块中，导致代码的重复和难以维护。而在 Spring 中，通过 AOP 可以将这些横切关注点封装成切面，然后在需要的时候将切面织入到业务逻辑中，从而提高代码的可维护性和可扩展性。</p><p>实现上代理大体上可以分为：<strong>动态代理</strong>和<strong>静态代理</strong>。</p><ul><li>动态代理，即<strong>在运行时</strong>将切面的逻辑进去，按照上面的逻辑就是你实现 A 类，然后定义要代理的切入点和切面的实现，程序会自动在运行时生成类似上面的代理类。</li><li>静态代理，<strong>在编译时或者类加载时</strong>进行切面的织入，典型的 AspectJ 就是静态代理。</li></ul><h2 id="Spring-AOP-相关术语都有哪些？"><a href="#Spring-AOP-相关术语都有哪些？" class="headerlink" title="Spring AOP 相关术语都有哪些？"></a>Spring AOP 相关术语都有哪些？</h2><p>1）切面（Aspect）：其实就是定义了一个 java 类，里面包含了通知（advice）和切点（pointcut），定义了在何处以及何时执行通知，将切面的一些东西模块化了。</p><p>2）通知（Advice）</p><ul><li>前置通知（Before advice）：在目标方法执行前执行。</li><li>后置通知（After returning advice）：在目标方法成功执行后执行。</li><li>后置异常通知（After throwing advice）：在目标方法抛出异常后执行。</li><li>后置最终通知（After (finally) advice）：无论目标方法如何结束（正常返回或抛出异常），都会执行。</li><li>环绕通知（Around advice）：在目标方法执行前后都执行，并且可以控制目标方法的执行过程，环绕通知可以用作日志打印或者权限校验。</li></ul><p>3）切点（Pointcut）：切点是一个表达式，用于定义在哪些连接点上执行通知，简单理解就是通过这个表达式可以找到想要织入的哪些方法。</p><p>4）连接点（Join point）：连接点是程序执行过程中可以应用切面的点，例如方法的调用、方法的执行、异常的抛出等，可以拿到切入方法名等诸多属性。</p><h2 id="Spring-一共有几种注入方式？"><a href="#Spring-一共有几种注入方式？" class="headerlink" title="Spring 一共有几种注入方式？"></a>Spring 一共有几种注入方式？</h2><ul><li>构造器注入，<strong>Spring 倡导构造函数注入</strong>，因为构造器注入返回给客户端使用的时候一定是完整的。</li><li>setter 注入，可选的注入方式，好处是在有变更的情况下，可以重新注入。</li><li>字段注入，就是平日我们用 @Autowired <strong>标记字段</strong></li><li>方法注入，就是平日我们用 @Autowired <strong>标记方法</strong></li><li>接口回调注入，就是实现 Spring 定义的一些内建接口，例如 BeanFactoryAware，会进行 BeanFactory 的注入</li></ul><p>像字段注入其实官方是不推荐的使用的，因为依赖注解，后没有控制注入顺序且无法注入静态字段。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】优化</title>
      <link href="/p/a02febe4/"/>
      <url>/p/a02febe4/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-中如何进行-SQL-调优？"><a href="#MySQL-中如何进行-SQL-调优？" class="headerlink" title="MySQL 中如何进行 SQL 调优？"></a>MySQL 中如何进行 SQL 调优？</h2><p>平时进行 SQL 调优，主要是通过观察慢 SQL，然后利用 explain 分析查询语句的执行计划，识别性能瓶颈，优化查询语句。</p><p>1）合理设计索引，利用<strong>联合索引</strong>进行覆盖索引的优化，避免回表的发生，减少一次查询和随机 I&#x2F;O</p><p>2）避免 SELECT * ，只查询必要的字段</p><p>3）避免在 SQL 中进行函数计算等操作，使得无法命中索引</p><p>4）避免使用 %LIKE，导致全表扫描</p><p>5）注意联合索引需满足<strong>最左匹配原则</strong></p><p>6）不要对无索引字段进行排序操作</p><p>7）连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描</p><p>除此之外，还可以<strong>利用缓存</strong>来优化，一些变化少或者访问频繁的数据设置到缓存中，减轻数据库的压力，提升查询的效率。</p><p>还可以<strong>通过业务</strong>来优化，例如少展示一些不必要的字段，减少多表查询的情况，将列表查询替换成分页分批查询等等。</p><h2 id="如何在-MySQL-中监控和优化慢-SQL？"><a href="#如何在-MySQL-中监控和优化慢-SQL？" class="headerlink" title="如何在 MySQL 中监控和优化慢 SQL？"></a>如何在 MySQL 中监控和优化慢 SQL？</h2><p>可以利用 MySQL 自带的 slow_query_log 来监控慢 SQL，它是 MySQL 提供的一个日志功能，用于记录执行时间超过特定阈值的 SQL 语句。</p><p>在 MySQL 配置文件（通常是 my.cnf 或 my.ini）中添加或修改以下配置项：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span>                    <span class="comment"># 启用慢查询日志</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log  <span class="comment"># 指定慢查询日志文件路径</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">2.0</span>                 <span class="comment"># 设置慢查询的阈值时间（单位：秒）</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span>     <span class="comment"># 记录未使用索引的查询</span></span><br></pre></td></tr></table></figure><p>也可以通过 SQL 命令动态设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL slow_query_log = &#x27;ON&#x27;;</span><br><span class="line">SET GLOBAL slow_query_log_file = &#x27;/var/log/mysql/mysql-slow.log&#x27;;</span><br><span class="line">SET GLOBAL long_query_time = 2.0;</span><br><span class="line">SET GLOBAL log_queries_not_using_indexes = &#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><h2 id="如何使用-MySQL-的-EXPLAIN-语句进行查询分析？"><a href="#如何使用-MySQL-的-EXPLAIN-语句进行查询分析？" class="headerlink" title="如何使用 MySQL 的 EXPLAIN 语句进行查询分析？"></a>如何使用 MySQL 的 EXPLAIN 语句进行查询分析？</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923212054.png"></p><p>参数有：</p><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数。</li><li><strong>type</strong> 表示数据扫描类型，我们需要重点看这个。</li></ul><p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p><ul><li>All（全表扫描）；</li><li>index（全索引扫描）；</li><li>range（索引范围扫描）；</li><li>ref（非唯一索引扫描）；</li><li>eq_ref（唯一索引扫描）；</li><li>const（结果只有一条的主键或唯一索引扫描）。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1）创建 employees 表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    hire_date <span class="type">DATE</span>,</span><br><span class="line">    INDEX (department_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们要执行以下查询来查找部门 ID 为 5 且薪水在 50000 到 100000 之间的员工，并按薪水降序排序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> salary <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>2）我们先使用 explain 分析计划进行分析：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> employee_id, first_name, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> salary <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>employees</td><td>NULL</td><td>ref</td><td>department_id</td><td>department_id</td><td>4</td><td>const</td><td>5000</td><td>20.00</td><td>Using where; Using filesort</td></tr></tbody></table><p>3）分析执行计划</p><p>从执行计划中看出，<code>type</code> 为 <code>ref</code>，表示使用了 <code>department_id</code> 索引，这是个非唯一索引。<code>key </code> 为 <code>department_id</code> 这个索引，而且 <code>rows</code> 为 5000，表示扫描了 5000 行匹配的 <code>department_id = 5</code> 的条件。从 <code>Extra</code> 看出在应用 <code>WHERE</code> 条件后，还需要进行文件排序来满足 <code>ORDER BY</code> 子句。</p><p>4）找出问题</p><p>尽管查询使用了索引，但由于索引不完全覆盖查询的条件和排序，查询需要进行额外的文件排序。这可能会导致性能瓶颈，特别是在结果集较大时。</p><p>5）优化解决它！</p><p><strong>创建复合索引</strong></p><p>创建一个包含 <code>department_id</code> 和 <code>salary</code> 的复合索引，这样可以覆盖查询的 <code>WHERE</code> 和 <code>ORDER BY</code> 条件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_department_salary <span class="keyword">ON</span> employees (department_id, salary);</span><br></pre></td></tr></table></figure><p>复合索引可以使查询在扫描 <code>department_id</code> 列时，同时按 <code>salary</code> 列排序，避免额外的文件排序。</p><h2 id="如何处理-MySQL-的主从同步延迟？"><a href="#如何处理-MySQL-的主从同步延迟？" class="headerlink" title="如何处理 MySQL 的主从同步延迟？"></a>如何处理 MySQL 的主从同步延迟？</h2><p>首先需要明确一个点<strong>延迟是必然存在的</strong>，无论怎么优化都无法避免延迟的存在。</p><p>如果主从延迟过大，可能出现一个用户刚注册，然后登陆报该用户不存在的，这个体验对用户而言就太差了。</p><p>之所以会产生这个原因是因为数据是写到主库中的，而查询走从库，因为延迟原因使得数据还未同步完毕，导致查不到这个用户。</p><p>常见解决方式有以下几种：</p><ul><li>二次查询。如果从库查不到数据，则再去主库查一遍，由 API 封装这个逻辑即可，算是一个兜底策略，比较简单。不过等于读的压力又转移到主库身上了，如果有不法分子故意查询必定查不到的查询，这就对主库产生冲击了。</li><li>强制将写之后立马读的操作转移到主库上。这种属于代码写死了，比如一些写入之后立马查询的操作，就绑定在一起，写死都走主库。不推荐，比较死板。</li><li>关键业务读写都走主库，非关键还是读写分离。比如上面我举例的用户注册这种，可以读写主库，这样就不会有登陆报该用户不存在的问题，这种访问量频次应该也不会很多，所以看业务适当调整此类接口。</li><li>使用缓存，主库写入后同步到缓存中，这样查询时可以先查询缓存，避免了延迟的问题，不过又引入了缓存数据一致性的问题。</li></ul><h2 id="什么是分库分表？分库分表有哪些类型（或策略）？"><a href="#什么是分库分表？分库分表有哪些类型（或策略）？" class="headerlink" title="什么是分库分表？分库分表有哪些类型（或策略）？"></a>什么是分库分表？分库分表有哪些类型（或策略）？</h2><p>随着用户量的激增和时间的堆砌，存在数据库里面的数据越来越多，此时的数据库就会产生瓶颈，出现资源报警、查询慢等场景。</p><p>首先单机数据库所能承载的连接数、I&#x2F;O及网络的吞吐等都是有限的，所以当并发量上来了之后，数据库就渐渐顶不住了。</p><p>再则，如果单表的数据量过大，查询的性能也会下降。因为数据越多 B+ 树就越高，树越高则查询 I&#x2F;O 的次数就越多，那么性能也就越差。</p><p>因为上述的原因，不得已就得上分库分表了。</p><p>把以前存在一个数据库实例里的数据拆分成多个数据库实例，部署在不同的服务器中，这是分库。</p><p>把以前存在一张表里面的数据拆分成多张表，这是分表。</p><p>一般而言：</p><ul><li>分表：是为了解决由于单张表数据量多大，而导致查询慢的问题。大致三、四千万行数据就得拆分，不过具体还是得看每一行的数据量大小，有些字段都很小的可能支持更多行数，有些字段大的可能一千万就顶不住了。</li><li>分库：是为了解决服务器资源受单机限制，顶不住高并发访问的问题，把请求分配到多台服务器上，降低服务器压力。</li></ul><p>在我的理解中分库分表分为四个类型，垂直分表、垂直分库、水平分表、水平分库。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>1）简单来说就是将原本的一张表切割成多张表。举个例子：有张 <code>student</code> 表存储着学生家庭背景、学生入学宣言（500字）、学生信息，现在将其进行垂直分表，可以分为 学生基本信息表、学生入学宣言表、学生家庭背景表，将其进行切割。</p><p>2）垂直分表一般是将不常用的字段单独放在一张表、将大字段分一张表、把经常需要同时查出来的信息放一张表。这样做可以冷数据和热数据分开提高查询效率。</p><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>1）按我个人理解就是把一个数据库里面的多个表，按照功能，分成多个数据库存放。举个例子：一个数据库有很多张表，用户表、商品表、订单表等，那么可以根据功能属性进行垂直分库，将用户表等信息放到存放用户信息的数据库，将商品表、订单表存放到与商品订单有关的商品订单库。</p><p>2）这样做的好处就是将数据负载分散到不同的数据库上，从而提高系统的性能和扩展性、降低单一数据库的复杂度。</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>1）我个人的理解就是在同一个数据库中，有几个相同表，里面的数据是不一样的，但<strong>表结构是一样的</strong>，数据按照固定的规则选择数据表存放，如：商品表1、商品表2。</p><p>2）提高了读写性能，减少了单表的压力、可弹性增加存储容量只需要增加一个表就行。</p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>1）按我的理解来说就是相同的表结构复制一份分到另一个库中，每个库的表结构是一样的，但是数据是不一样的。</p><p>2）这样做能在大数量的情况下提高读写性能，因为减少了单一数据库的读写压力。</p><p>3）能提高存储容量。可以通过增加或减少数据库进行弹性伸缩。</p><p>4）提高容错性。当一个数据库故障了，别的数据库还能正常运行，只影响小部分数据查询。</p><h2 id="对数据库进行分库分表可能会引发哪些问题？"><a href="#对数据库进行分库分表可能会引发哪些问题？" class="headerlink" title="对数据库进行分库分表可能会引发哪些问题？"></a>对数据库进行分库分表可能会引发哪些问题？</h2><p>1）首先是事务的问题。</p><p>我们使用关系型数据库，有很大一点在于它<strong>保证事务的完整性</strong>。</p><p>而分库之后单机事务就用不上了，必须使用分布式事务来解决，而分布式事务相对而言就比较重了，而且大部分的分布式事务只能保证最终一致性，所以<strong>业务上会存在数据不一致的场景</strong>。</p><p>2）连表 JOIN 问题</p><p>在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。</p><p>此时的解决方案就是在业务代码中进行关联，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。</p><p>这种方式实现起来稍微比较复杂，不过也是可以接受的。</p><p>还有可以适当的冗余一些字段。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。</p><p>或者通过宽表的形式查询，比如将数据全量存储至 ES 中，利用 ES 来查询数据。</p><p>3）全局 ID 唯一性问题</p><p>以前单库单表直接使用数据库的自增 ID 即可，但是分库分表之后，使用自增 ID 会导致重复主键的情况，此时需要利用<strong>雪花算法</strong>或者其他全局唯一 ID 发号器来生成唯一主键。</p><div class="note  flat info"><p>什么是雪花算法？</p></div><p>雪花算法（Snowflake Algorithm）是由 Twitter 开发的一种用来生成<strong>分布式</strong>系统中<strong>全局唯一</strong>的 ID 的算法。</p><p>雪花算法生成的唯一 ID 通常是一个 64 位的整数，按照以下结构组成：</p><ul><li>首位符号位（固定为 0）: 符号位始终为 0，保证生成的是正整数。</li><li>41 位时间戳（毫秒级）: 表示生成 ID 的时间戳，可以支持约 69 年的时间范围。</li><li>10 位机器标识（分布式部署时的机器 ID）: 可以支持 1024 台不同的机器。</li><li>12 位序列号（同一机器同一毫秒内的自增序列）: 表示同一台机器同一毫秒内生成的不同 ID 的序列号。</li></ul><p>雪花算法原理图如下：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1716811643355-3a79b857-600e-4432-81e7-e03b755f6957.jpeg"></p><p>雪花算法能生成分布式全局唯一 ID 的原因：</p><ul><li>雪花算法允许在同一毫秒内生成多个不同的 ID，通过序列号的自增保证在高并发情况下生成的 ID 唯一性。</li><li>通过机器部分的标识符保证了在不同的机器上生成 ID 时不会发生冲突。</li><li>利用时间戳部分的信息，确保生成的 ID 按时间递增，可以方便地对 ID 进行排序和分析。</li></ul><p>雪花算法在同一毫秒内最多可以生成多少个全局唯一ID呢：同一毫秒的ID数量 &#x3D; 1024 * 4096 &#x3D; 4194304</p><p>雪花算法的缺点：</p><ol><li>依赖服务器时间，服务器时间回拨时可能会生成重复 id。<ul><li>人为原因，把系统环境的时间改了；</li><li>有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。</li><li>解决方案：算法中可通过记录最后一个生成 id 时的时间戳来解决，每次生成 id 之前比较当前服务器时钟是否被回拨，避免生成重复 id。</li></ul></li><li>在单机上，生成的ID是递增的，但在多台机器上，只能大致保持递增趋势，并不能严格保证递增。这是因为多台机器之间的时钟不一定完全同步。</li></ol><p>4）排序问题</p><p>单表直接通过 order by 进行排序即可，分库分表后直接利用数据库是无法实现排序的。要么利用分库分表中间件的能力进行汇总排序，要么自己在业务代码中排序，要么利用 ES 存储全量数据排序查询。</p><p>5）count 问题</p><p>其实和排序问题类似，单表可以直接 count，分库分表后无法支持，只能多表 count 然后业务代码中累加，或者单独搞一个地方来维护总数，要么还是利用 ES。</p><h2 id="分库分表的中间件有哪些？"><a href="#分库分表的中间件有哪些？" class="headerlink" title="分库分表的中间件有哪些？"></a>分库分表的中间件有哪些？</h2><h3 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a>ShardingSphere</h3><ul><li>ShardingSphere是一款开源的分布式数据库中间件，提供了分库分表、读写分离、分布式事务等功能。</li><li>它支持多种数据库，如MySQL、PostgreSQL、Oracle、SQL Server等，并且可以与现有的数据库系统无缝集成。</li></ul><h4 id="架构与原理"><a href="#架构与原理" class="headerlink" title="架构与原理"></a>架构与原理</h4><p>ShardingSphere由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar三个主要组件组成。</p><ul><li>Sharding-JDBC：用于实现分库分表功能的模块，它可以在应用层通过简单的配置实现透明的分库分表操作。</li><li>Sharding-Proxy：用于实现数据库代理功能的模块，它可以将数据库请求路由到不同的数据库节点上，实现读写分离和负载均衡。</li><li>Sharding-Sidecar（规划中）：定位为Kubernetes的云原生数据库代理，以Sidecar的形式代理所有对数据库的访问。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/167509-20240727115652944-82462320.png"></p><p>其原理是通过数据分片和路由来实现分库分表。数据分片是将数据划分为多个片段，每个片段存储在不同的数据库实例或数据表中；路由则是根据数据的分片规则将请求路由到对应的数据库实例或数据表上。</p><h4 id="优势与适用场景"><a href="#优势与适用场景" class="headerlink" title="优势与适用场景"></a>优势与适用场景</h4><ul><li>灵活的扩展性：支持水平扩展和垂直扩展，可以根据业务需求灵活调整数据库的规模和性能。</li><li>高可用性：支持主从复制和多活架构，提供高可用的数据库访问和数据保护。</li><li>简化开发和维护：提供了简单易用的接口和配置，可以减少开发人员的工作量和维护成本。</li><li>适用于高并发访问、大数据量存储、跨地域部署等场景。</li></ul><h3 id="MyCAT"><a href="#MyCAT" class="headerlink" title="MyCAT"></a>MyCAT</h3><ul><li>MyCAT是一个开源的分布式数据库中间件，基于Java编写，支持MySQL协议，可以作为MySQL的代理服务器使用。</li><li>它支持分库分表、读写分离、全局序列号等功能，并且具有跨语言、跨平台、跨数据库的通用性。</li></ul><h4 id="架构与原理-1"><a href="#架构与原理-1" class="headerlink" title="架构与原理"></a>架构与原理</h4><ul><li>MyCAT采用代理模式来实现数据库的路由和分片。</li><li>它包括MyCAT-Server和MyCAT-DataNode两个主要部分。MyCAT-Server用于接收客户端的数据库请求，并将请求路由到不同的数据库节点上；MyCAT-DataNode则用于实际存储数据的数据库节点。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/167509-20240727121533110-1588061359.png"></p><h4 id="优势与使用场景"><a href="#优势与使用场景" class="headerlink" title="优势与使用场景"></a>优势与使用场景</h4><ul><li>易于部署和使用：对于项目来说是透明的，如果遇到升级之类的操作，只需要在中间件层面进行即可。</li><li>适用于大规模MySQL集群的管理和扩展问题。</li><li>但是，MyCAT的SQL支持相对较弱，可能需要对SQL语句进行一定的改写和优化。</li></ul><h2 id="MySQL-中如何解决深度分页的问题？"><a href="#MySQL-中如何解决深度分页的问题？" class="headerlink" title="MySQL 中如何解决深度分页的问题？"></a>MySQL 中如何解决深度分页的问题？</h2><p>所谓的深度分页是指数据量很大的时候，按照分页访问后面的数据，例如 <code>limit 99999990，10</code>，这会使得数据库扫描前面的 99999990 条数据，才能得到最终的 10 条数据，大批量的扫描数据会增加数据库的负载，影响性能。</p><p>优化方式可以有三种：</p><p>1）子查询</p><p>比如 <code>select * from table where name = &#39;111&#39; limit 99999990，10；</code> 这样的一条查询语句，可以优化成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where </span><br><span class="line">name = &#x27;111&#x27; </span><br><span class="line">and id &gt; </span><br><span class="line">(select id from table where name = &#x27;111&#x27; order by id limit 99999990，1)</span><br><span class="line">order by id limit 10;</span><br></pre></td></tr></table></figure><p>name 有索引的情况下，这样的查询直接扫描 name 的二级索引，<strong>二级索引的数据量少</strong>，且在子查询中能直接得到 id 不需要回表。将子查询得到的 id 再去主键索引查询，速度很快，数据量也小。</p><p>如果直接扫描主键索引的话，数据量就比较大，因为主键索引包含全部的数据。</p><p>当然上面的 SQL 改成 Join 也行，本质上是一样的。</p><p>2）记录 id</p><p>每次分页都返回当前的最大 id ，然后下次查询的时候，带上这个 id，就可以利用 id &gt; maxid 过滤了。</p><p>这种查询仅适合连续查询的情况，如果跳页的话就不生效了。</p><p>3）elasticsearch</p><p>可以考虑用搜索引擎来解决这个问题，不过 es 也会有深度分页的问题，所以如果对 es 不熟，面试就不要这样答了，防止面试官问 es 的深度分页如何解决。</p><h2 id="如何实现数据库的不停服迁移？"><a href="#如何实现数据库的不停服迁移？" class="headerlink" title="如何实现数据库的不停服迁移？"></a>如何实现数据库的不停服迁移？</h2><p>迁移想着很简单，不就是把一个库的数据迁移到另一个库吗？</p><p>但是实际上有很多细节：</p><ul><li>首先关注量级，如果是几十万的数据其实直接用代码迁移，简单核对下就结束了。如果数据量大那么才需要好好设计方案。</li><li>不停服数据迁移需要考虑<strong>在线数据的插入和修改</strong>，保证数据的一致性。</li><li>迁移还需要注意回滚，因为一旦发生问题需要及时切换回老库，防止对业务产生影响。</li></ul><h3 id="双写"><a href="#双写" class="headerlink" title="双写"></a>双写</h3><p>大部分数据库迁移都会采用双写方案，例如自建的数据库要迁移到云上的数据库这个场景，双写就是同时写入自建的数据库和云上的数据库。</p><p>我们来过一遍迁移流程：</p><p>1）将云上数据库（新库）作为自建数据库（旧库）的从库，进行数据同步（或者可以利用云上的能力，比如阿里云的 DTS）。</p><p>2）改造业务代码，数据写入修改不仅要写入旧库，同时也要写入新库，这就是所谓的双写，注意这个<strong>双写需要加开关</strong>，即通过修改配置实时打开双写和关闭双写。</p><p>3）<strong>在业务低峰期</strong>，确保数据同步完全一致的时候（即主从不延迟，这个都是有对应的监控的），关闭同步，同时打开双写开关，此时业务代码读取的还是旧数据库。</p><p>4）进行数据核对，数据量很大的场景只能<strong>抽样调查</strong>（可以利用定时任务写代码进行抽样核对，一旦不一致就告警和记录。）</p><p>5）如果确认数据一致，此时可以进行<strong>灰度切流</strong>，比如 1% 的用户切到读新的数据库（比如今天访问前 1% 的用户或者根据用户 ID 或其他业务字段），如果发现没问题，则可以逐步增加开放的比例，比如 5%-&gt;20%-&gt;50%-&gt;100%</p><p>6）继续保留双写，跑个几天(或者更久)，确保新库确实没问题了，此时关闭双写，只写新库，这时候迁移就完成了。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>除了主从同步，代码双写的方案，也可以采用第三方工具。例如 flink-cdc 等工具来进行数据的同步，它的优点方便，且支持<strong>异构</strong>（比如 mysql 同步到 pg、es 等等）的数据源。</p><h2 id="什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？"><a href="#什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？" class="headerlink" title="什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？"></a>什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？</h2><p>逻辑删除是一种将数据标记为已删除但实际不会从数据库中移除的删除方式。一般是在表中添加一个表示删除状态的字段，如 is_deleted ，默认是 0 表示未删除，1 表示已删除。</p><p>物理删除则是直接从数据库中删除记录。</p><p>一般业务上都是使用逻辑删除，便于后续的数据分析、追溯等。</p><h3 id="逻辑删除与唯一性问题"><a href="#逻辑删除与唯一性问题" class="headerlink" title="逻辑删除与唯一性问题"></a>逻辑删除与唯一性问题</h3><p>很多时候表需要设置唯一索引来保证数据的唯一性。</p><p>例如用户参加店铺活动，我们有个活动记录表以 <code>userId+shopId</code> 作为唯一索引，防止用户重复参加一个店铺活动也用于后续活动记录。</p><p>后续如果用户反悔了，他说不想参加了，此时一个方式就是直接物理删除这条记录，但是为了审计和后续的追溯，我们用的都是逻辑删除，因此使用 is_deleted 字段，标记为 1 表明已删除。</p><p>但是用户又反悔了，他又报名参加了，这时候由于我们将 <code>userId+shopId</code> 作为唯一索引，且这条字段仅仅是逻辑删除，表中还存在这条记录，所以此时就产生了唯一索引冲突，业务无法正常执行下去。</p><p>这就是<strong>逻辑删除与唯一性问题</strong>。</p><p>怎么处理？把 <code>userId+shopId+is_deleted</code> 一起作为唯一索引？</p><p>也不行，is_deleted 只有 0 和 1，如果用户多次反复横跳，这个设计无法满足。</p><p>常见有三种简单的解决方式：</p><p>1）is_deleted 改为 deleted_at ，deleted_at 存储的是<strong>时间戳</strong>，默认为空。</p><p>把 <code>userId+shopId+deleted_at</code> 作为唯一索引，通过 deleted_at 是否为空来判断是否被逻辑删除，然后每次删除把当前时间设置到 deleted_at 字段上，这样唯一索引就能继续生效了。</p><p>由于时间戳的随机性，不会产生唯一索引冲突</p><p>2）is_deleted 改为 bigint，存储的是主键，默认为 0 。</p><p>每次删除，把当前记录的 id 设置到 is_deleted 字段，例如 id 是 2222 ，那么 is_deleted 就变为 2222。这时候将 <code>userId+shopId+is_deleted</code> 作为唯一索引，就可以解决用户反复退出再加入的问题。</p><p>判断已经被删除的逻辑从 <code>is_deleted = 1</code> 变成 <code>is_deleted &gt; 0</code>。</p><p>3）复用一条记录+日志表（流水表）</p><p>所谓的日志或者流水指的是机械地记录用户的操作记录，不会做修改和删除，只有新增。</p><p>用户某时某刻参加了活动，则记录。</p><p>用户退出了活动，则记录。</p><p>审计和追溯可以使用流水表。这时候活动表仅需设置 <code>userId+shopId</code> 为唯一索引即可，用户参加活动 is_deleted 为 0 ，退出活动改为 1，再次参加继续改为 0 ，仅需在一条记录上修改记录。</p><h2 id="什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？"><a href="#什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？" class="headerlink" title="什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？"></a>什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？</h2><p>逻辑外键是一种在<strong>应用程序层面上</strong>管理和维护数据完整性的方法，而<strong>不是通过数据库本身的外键约束</strong>。主要是利用应用程序代码来保证引用的完整性。</p><h3 id="逻辑外键实现例子"><a href="#逻辑外键实现例子" class="headerlink" title="逻辑外键实现例子"></a>逻辑外键实现例子</h3><p>比如插入一笔订单的时候，先判断这个用户是否存在：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查引用完整性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!customerExists(order.getCustomerId())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入订单</span></span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">customerExists</span><span class="params">(Long customerId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> customerRepository.existsById(customerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是复杂的业务，例如还需要判断用户是否是已注销、是否被冻结等等，此时仅需修改 <code>customerExists</code> 就能实现，而物理外键就没办法实现这么灵活的需求了。</p><h3 id="为什么不推荐使用数据库的外键？"><a href="#为什么不推荐使用数据库的外键？" class="headerlink" title="为什么不推荐使用数据库的外键？"></a>为什么不推荐使用数据库的外键？</h3><p>阿里巴巴 Java 开发手册写到了：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/rX9duFQC_image.png"></p><p>可以看到，主要是因为数据库的外键会产生级联更新从而导致性能问题。</p><p>因为现在很多互联网公司都是高并发大流量场景，所以一般互联网公司不推荐使用外键。</p><h4 id="数据库外键性能问题盘点"><a href="#数据库外键性能问题盘点" class="headerlink" title="数据库外键性能问题盘点"></a>数据库外键性能问题盘点</h4><p>1）级联更新</p><p>按照手册举例，如果学生表的 ID 被修改，数据库同时需要改成绩表中的对应的学生 ID，如果还有其他关联表则都需要被修改。</p><p>在高并发数据量大的情况下，一次修改会产生意料之外的级联更新使得数据库压力过大，导致系统其他操作数据库的请求阻塞，很可能导致系统全面崩盘。</p><p>2）检查维护</p><p>还是拿学生成绩举例，因为设置了外键，插入成绩表对应的学生 ID 时，数据库需要去检查这个学生 ID 在对应的学生表是否存在，来保证数据外键完整性约束。</p><p>除了插入，删除、更新相关外键，<strong>数据库都需要去检查数据的完整性</strong>，这就产生了性能开销。</p><p>3）锁问题</p><p>如果多个事务并发修改学生表，那么对应锁定的数据涉及的成绩表也需要被锁定，同理并发修改成绩表，那么对应的学生的表的数据也需要被锁定。</p><p>关联外键越多锁定的数据也就越多。锁的数据多除了性能问题，还可能会带来死锁的问题。</p><h4 id="数据库外键业务问题盘点"><a href="#数据库外键业务问题盘点" class="headerlink" title="数据库外键业务问题盘点"></a>数据库外键业务问题盘点</h4><p>1）无法支持复杂的业务控制</p><p>不说其他复杂的情况，就拿删除数据使用逻辑删除的情况，数据库的外键就无法满足级联修改，还是需要开发人员编写业务代码手动控制。</p><p>2）分库分表</p><p>数据库的外键约束只能控制一个数据库实例，跨实例的情况下无法满足。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/wzh2010/p/18031229">数据库系列: 主流分库分表中间件介绍(图文总结) - Hello-Brand - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】日志 &amp; 内存</title>
      <link href="/p/d1ec0e4e/"/>
      <url>/p/d1ec0e4e/</url>
      
        <content type="html"><![CDATA[<h1 id="undo-log、redo-log、binlog-有什么用？"><a href="#undo-log、redo-log、binlog-有什么用？" class="headerlink" title="undo log、redo log、binlog 有什么用？"></a>undo log、redo log、binlog 有什么用？</h1><p><strong>执行一条 update 语句，期间发生了什么？</strong></p><p>查询语句的那一套流程，更新语句也是同样会走一遍：</p><ul><li>客户端先通过连接器建立连接，连接器自会判断用户身份；</li><li>因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；</li><li>解析器会通过<strong>词法分析</strong>识别出关键字 update，表名等等，构建出语法树，接着还会做<strong>语法分析</strong>，判断输入的语句是否符合 MySQL 语法；</li><li><strong>预处理器</strong>会判断表和字段是否存在；</li><li><strong>优化器</strong>确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；</li><li><strong>执行器</strong>负责具体执行，找到这一行，然后更新。</li></ul><p>不过，更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog（归档日志）这三种日志：</p><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog（归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h2 id="为什么需要-undo-log？"><a href="#为什么需要-undo-log？" class="headerlink" title="为什么需要 undo log？"></a>为什么需要 undo log？</h2><p>我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。</p><p>执行一条语句是否自动提交事务，是由 <code>autocommit</code> 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。</p><p>那么，考虑一个问题。一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？</p><p>如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p><p>实现这一机制就是 <strong>undo log（回滚日志），它保证了事务的 <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID 特性</a>中的原子性（Atomicity）</strong>。</p><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p><p><img src="https://camo.githubusercontent.com/6a3b5d93aa5b1dbc582640c590664c829396e2976e3d1d80e53b6f8f8f1b5bf0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f2545352539422539452545362542422539412545342542412538422545352538412541312e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30" alt="回滚事务"></p><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p><p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查。</p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务 id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p><img src="https://camo.githubusercontent.com/7a5959f006bdca0b9991b06b43941f935abb824b385feff7158a860124b3d729/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f2545372538392538382545362539432541432545392539332542452e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30" alt="版本链"></p><p>另外，<strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</p><p>因此，undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h2 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h2><p>MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？</p><p>当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>有了 Buffer Pool 后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><h3 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h3><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页，Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><h4 id="Undo-页是记录什么？"><a href="#Undo-页是记录什么？" class="headerlink" title="Undo 页是记录什么？"></a>Undo 页是记录什么？</h4><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p><h4 id="查询一条记录，就只需要缓冲一条记录吗？"><a href="#查询一条记录，就只需要缓冲一条记录吗？" class="headerlink" title="查询一条记录，就只需要缓冲一条记录吗？"></a>查询一条记录，就只需要缓冲一条记录吗？</h4><p>不是的。</p><p>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p><p>关于页结构长什么样和索引怎么查询数据的问题可以在这篇找到答案：<a href="https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw">换一个角度看 B+ 树</a></p><h4 id="什么是预读失效？"><a href="#什么是预读失效？" class="headerlink" title="什么是预读失效？"></a>什么是预读失效？</h4><p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p><p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p><p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p><p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool 空间不够的时候，还需要把末尾的页淘汰掉。</p><p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p><h4 id="怎么解决预读失效而导致缓存命中率降低的问题？"><a href="#怎么解决预读失效而导致缓存命中率降低的问题？" class="headerlink" title="怎么解决预读失效而导致缓存命中率降低的问题？"></a>怎么解决预读失效而导致缓存命中率降低的问题？</h4><p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p><p>那到底怎么才能避免呢？</p><p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p><p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p><p><img src="https://camo.githubusercontent.com/8eae8ab437aada3acb8f3ba00c6337b302ee72dccfdedd8012ea9a0482e2fb54/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f696e6e6f64622f796f756e672532426f6c642e706e67"></p><p>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><h4 id="什么是-Buffer-Pool-污染？"><a href="#什么是-Buffer-Pool-污染？" class="headerlink" title="什么是 Buffer Pool 污染？"></a>什么是 Buffer Pool 污染？</h4><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><p>注意，Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p><h4 id="怎么解决出现-Buffer-Pool-污染而导致缓存命中率下降的问题？"><a href="#怎么解决出现-Buffer-Pool-污染而导致缓存命中率下降的问题？" class="headerlink" title="怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？"></a>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</h4><p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p><p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p><p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题。</p><p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4 被访问了才会。</p><h3 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h3><p>InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p><p>下面几种情况会触发脏页的刷新：</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul><p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p><p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p><h2 id="为什么需要-redo-log？"><a href="#为什么需要-redo-log？" class="headerlink" title="为什么需要 redo log？"></a>为什么需要 redo log？</h2><p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL（Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是，MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>过程如下图：</p><p><img src="https://camo.githubusercontent.com/081c69a8d128b32710579157d34d52517b4c86c3663a20136fdc761edb663ff9/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f77616c2e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30"></p><h3 id="什么是-redo-log？"><a href="#什么是-redo-log？" class="headerlink" title="什么是 redo log？"></a>什么是 redo log？</h3><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了 AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><h3 id="被修改-Undo-页面，需要记录对应-redo-log-吗？"><a href="#被修改-Undo-页面，需要记录对应-redo-log-吗？" class="headerlink" title="被修改 Undo 页面，需要记录对应 redo log 吗？"></a>被修改 Undo 页面，需要记录对应 redo log 吗？</h3><p>需要的。</p><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p><p>不过，<strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p><h3 id="redo-log-和-undo-log-区别在哪？"><a href="#redo-log-和-undo-log-区别在哪？" class="headerlink" title="redo log 和 undo log 区别在哪？"></a>redo log 和 undo log 区别在哪？</h3><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务。所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p><h3 id="redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h3><p>写入 redo log 的方式使用了追加操作，所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写」比「随机写」高效的多，因此 redo log 写入磁盘的开销更小。</p><p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上。</p><p>至此，针对为什么需要 redo log 这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h3 id="产生的-redo-log-是直接写入磁盘的吗？"><a href="#产生的-redo-log-是直接写入磁盘的吗？" class="headerlink" title="产生的 redo log 是直接写入磁盘的吗？"></a>产生的 redo log 是直接写入磁盘的吗？</h3><p>不是的。</p><p>实际上，执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘，如下图：</p><p><img src="https://camo.githubusercontent.com/a1204cd8c05f4b76a924309d96961bc3576bf9c661b1ba96eebb39cba1f19564/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f7265646f6c6f676275662e77656270" alt="事务恢复"></p><p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」时不必写入磁盘，进而提升写 I&#x2F;O 性能。</p><h3 id="redo-log-什么时候刷盘？"><a href="#redo-log-什么时候刷盘？" class="headerlink" title="redo log 什么时候刷盘？"></a>redo log 什么时候刷盘？</h3><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）。</li></ul><p>InnoDB 还提供了另外两种策略，由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong></li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇</a> ），Page Cache 是专门用来缓存文件数据的，所以写入「redo log 文件」意味着写入到了操作系统的文件缓存。</li></ul><h3 id="redo-log-文件写满了怎么办？"><a href="#redo-log-文件写满了怎么办？" class="headerlink" title="redo log 文件写满了怎么办？"></a>redo log 文件写满了怎么办？</h3><p>默认情况下，InnoDB 存储引擎有一个重做日志文件组 (redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p><p>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p><p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><p>我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p><p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 check point 表示当前要擦除的位置，如下图：</p><p><img src="https://camo.githubusercontent.com/978d649744b823c1242d04a81ec641ca38fdfdf22f27dbc8608b926559f47dd0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f636865636b706f696e742e706e67"></p><p>如果 write pos 追上了 check point，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，check point 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><p>所以，一次 check point 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p><h2 id="为什么需要-binlog？"><a href="#为什么需要-binlog？" class="headerlink" title="为什么需要 binlog？"></a>为什么需要 binlog？</h2><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><h3 id="为什么有了-binlog，还要有-redo-log？"><a href="#为什么有了-binlog，还要有-redo-log？" class="headerlink" title="为什么有了 binlog，还要有 redo log？"></a>为什么有了 binlog，还要有 redo log？</h3><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p><p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p><h3 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h3><p>这两个日志有四个区别。</p><p><em>1、适用对象不同：</em></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul><p><em>2、文件格式不同：</em></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT、ROW、MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式，binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了 AAA 更新；</li></ul><p><em>3、写入方式不同：</em></p><ul><li>binlog 是<strong>追加写</strong>，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是<strong>循环写</strong>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><p><em>4、用途不同：</em></p><ul><li>binlog 用于<strong>备份恢复、主从复制</strong>；</li><li>redo log 用于掉电等故障恢复。</li></ul><h3 id="主从复制是怎么实现？"><a href="#主从复制是怎么实现？" class="headerlink" title="主从复制是怎么实现？"></a>主从复制是怎么实现？</h3><p>MySQL 的主从复制依赖于 binlog，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><p><img src="https://camo.githubusercontent.com/df36b597388010996b1d0485de0218e0e1d95a40fbf6ff200195ca91be6a73ff/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f2545342542382542422545342542422538452545352541342538442545352538382542362545382542462538372545372541382538422e64726177696f2e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30" alt="MySQL 主从复制过程"></p><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体详细过程如下：</p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><h3 id="binlog-什么时候刷盘？"><a href="#binlog-什么时候刷盘？" class="headerlink" title="binlog 什么时候刷盘？"></a>binlog 什么时候刷盘？</h3><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>MySQL 给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。</p><p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下：</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。</li></ol><h2 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>举个例子，假设 id &#x3D; 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后，MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li><li><strong>如果在将 binlog 刷入到磁盘之后，MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul><p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p><h3 id="两阶段提交的过程是怎样的？"><a href="#两阶段提交的过程是怎样的？" class="headerlink" title="两阶段提交的过程是怎样的？"></a>两阶段提交的过程是怎样的？</h3><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p><p><img src="https://camo.githubusercontent.com/3ff88c95a7009ddd07b8a4a1efb7e5e2a94532e9822026c4f5b40a2ee955863e/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f2545342542382541342545392539382542362545362541452542352545362538462539302545342542412541342e64726177696f2e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30" alt="两阶段提交"></p><p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入 binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID）写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件，所以 commit 状态也是会刷盘的）；</li></ul><h3 id="异常重启会出现什么现象？"><a href="#异常重启会出现什么现象？" class="headerlink" title="异常重启会出现什么现象？"></a>异常重启会出现什么现象？</h3><p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：</p><p><img src="https://camo.githubusercontent.com/8942911bb4f4a71c0112de76aad92eec1901c64559cb7126a38d451836e66c3d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f686f775f7570646174652f2545342542382541342545392539382542362545362541452542352545362538462539302545342542412541342545352542342541392545362542412538332545372538322542392e64726177696f2e706e673f696d6167655f70726f636573733d77617465726d61726b2c746578745f35595773354c795835592d333737796135624350357036585932396b6157356e2c747970655f5a6e70736448706f61772c785f31302c795f31302c675f73652c73697a655f32302c636f6c6f725f3030303043442c745f37302c66696c6c5f30" alt="时刻 A 与时刻 B"></p><p>不管是时刻 A（已经 redo log，还没写入 binlog），还是时刻 B（已经写入 redo log 和 binlog，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li></ul><p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p><p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p><h4 id="事务没提交的时候，redo-log-会被持久化到磁盘吗？"><a href="#事务没提交的时候，redo-log-会被持久化到磁盘吗？" class="headerlink" title="事务没提交的时候，redo log 会被持久化到磁盘吗？"></a>事务没提交的时候，redo log 会被持久化到磁盘吗？</h4><p>会的。</p><p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p><p>也就是说，事务没提交的时候，redo log 也是可能被持久化到磁盘的。</p><p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p><p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p><p>所以，redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p><h3 id="两阶段提交有什么问题？"><a href="#两阶段提交有什么问题？" class="headerlink" title="两阶段提交有什么问题？"></a>两阶段提交有什么问题？</h3><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双 1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p><p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader 领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。</p><br><br><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log">MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html">揭开 Buffer Pool 的面纱 | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】锁</title>
      <link href="/p/25d2b878/"/>
      <url>/p/25d2b878/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-中有哪些锁类型？"><a href="#MySQL-中有哪些锁类型？" class="headerlink" title="MySQL 中有哪些锁类型？"></a>MySQL 中有哪些锁类型？</h2><p>这个答案比较长，也是从演进的角度来讲解 MySQL 中比较关键的几个锁，这样记忆和理解会更深刻，减少出现看过没多久就忘了的情况。</p><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>在 MySQL 中锁可以分为两大类，分别是 shared (S) locks 和 exclusive (X) locks。</p><ul><li>S锁，称为共享锁，事务在读取记录的时候获取 S 锁，它允许多个事务同时获取 S 锁，互相之间不会冲突。</li><li>X锁，称为独占锁（排他锁），事务在修改记录的时候获取 X 锁，且只允许一个事务获取 X 锁，其它事务需要阻塞等待。</li></ul><p>S 锁之间不冲突，X 锁则为独占锁，所以 X 之间会冲突， X 和 S 也会冲突。</p><table><thead><tr><th>冲突</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>不冲突</td><td>冲突</td></tr><tr><td>X</td><td>冲突</td><td>冲突</td></tr></tbody></table><p><code>SELECT ... LOCK IN SHARE MODE;</code> 这种读取需要对记录上 S 锁。</p><p><code>SELECT ... FOR UPDATE;</code> 需要对记录上 X 锁。</p><p>MyISAM 引擎仅支持表锁，而 Innodb 即支持表锁也支持行锁。</p><ul><li><code>LOCK TABLES yes READ</code> 是对 yes 这个表上 S 锁。</li><li><code>LOCK TABLES yes WRITE</code> 是对 yes 这个表上 X 锁。</li></ul><p>不过一般情况下，我们不会使用表锁，因为平日的 UPDATE 、SELECT 要用也是用行锁了，不可能用粒度粗的表锁，不然性能太低。</p><p>唯一能想到用上表锁的就是 DDL 语句了，比如 ALTER TABLE 的时候，应该锁定整个表，防止查询和修改，但是这个 server 已经提供了一个叫 MDL 的锁，即 <code>Metadata Locks</code>（元数据锁）。</p><h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><p>元数据锁也分为读锁和写锁：</p><p>1）读锁 (MDL_SHARED)：</p><p>当一个事务需要读取表的元数据时（如执行 SELECT 操作），会获取读锁。 多个事务可以同时持有读锁，不会互相阻塞。</p><p>2）写锁 (MDL_EXCLUSIVE)：</p><p>当一个事务需要修改表的元数据时（如执行 ALTER TABLE 操作），会获取写锁。 写锁会阻塞其他任何读锁和写锁，确保独占访问。</p><p>元数据锁的主要作用如下：</p><p>1）防止并发的 DDL 操作和 DML 操作冲突：</p><ul><li>当一个事务对表进行结构性更改（如 ALTER TABLE），元数据锁（写锁）会阻止其他事务对该表进行操作，直到结构更改完成。</li><li>当一个事务对表进行数据操作（如 SELECT、INSERT、UPDATE、DELETE），元数据锁（读锁）会阻止其他事务对该表进行结构性更改。</li></ul><p>2）保护元数据一致性：</p><ul><li>确保在执行 DDL 操作（如 CREATE TABLE、DROP TABLE、ALTER TABLE）时，元数据不会被其他事务同时修改。</li></ul><p>假设业务上真用到了表锁，那么表锁和行锁之间肯定会冲突，当 InnoDB 加表锁的时候，如何判断表里面是否已经有行锁？难道得一条记录一条记录遍历过去找吗？</p><p>显然这样的效率太低了！</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>所以有了个叫意向锁（Intention Locks）的东西。</p><ul><li>IS（Intention Shared Lock），共享意向锁。</li><li>IX（Intention Exclusive Lock），独占意向锁。</li></ul><p>这两个锁是表级别的锁，当需要对表中的某条记录上 S 锁的时候，先在表上加个 IS 锁，表明此时表内有 S 锁。当需要对表中的某条记录上 X 锁的时候，先在表上加个 IX 锁，表明此时表内有 X 锁。</p><p>这样操作之后，如果要加表锁，就不需要遍历所有记录去找了，直接看看表上面有没有 IS 和 IX 锁。</p><p>比如，此时要上表级别的 S 锁，如果表上没有 IX ，说明表中没有记录有独占锁，其实就可以直接上表级 S 锁。</p><p>如果此时要上表级别的 X 锁，如果表上没有 IX 和 IS ，说明表中的所有记录都没加锁，其实就可以直接上表级 X 锁。</p><p><strong>因此 IS 和 IX 的作用就是在上表级锁的时候，可以快速判断是否可以上锁，而不需要遍历表中的所有记录</strong>。</p><p>所以 IS 和 IX 互相之间是不会冲突的，因为它们的作用只是打个标记，来丰富一下上面的表格：</p><table><thead><tr><th>冲突</th><th>S</th><th>X</th><th>IS</th><th>IX</th></tr></thead><tbody><tr><td>S</td><td>不冲突</td><td>冲突</td><td>不冲突</td><td>冲突</td></tr><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IS</td><td>不冲突</td><td>冲突</td><td>不冲突</td><td>不冲突</td></tr><tr><td>IX</td><td>冲突</td><td>冲突</td><td>不冲突</td><td>不冲突</td></tr></tbody></table><h3 id="Auto-Inc-Lock"><a href="#Auto-Inc-Lock" class="headerlink" title="Auto-Inc Lock"></a>Auto-Inc Lock</h3><p>Auto-Inc Lock 是一个特殊的<strong>表级锁</strong>，用于自增列插入数据时使用。 在插入一条数据的时候，需要在表上加个 Auto-Inc Lock，然后为自增列分配递增的值，在语句插入结束之后，再释放 Auto-Inc Lock。</p><p>在 MySQL 5.1.22 版本之后，又弄了个互斥量来进行自增减的累加。互斥量的性能高于 Auto-Inc Lock，因为 Auto-Inc Lock是语句插入完毕之后才释放锁，而互斥量是在语句插入的时候，<strong>获得递增值之后，就可以释放锁</strong>，所以性能更好。</p><p>但是我们还需要考虑主从的情况，由于<strong>并发插入</strong>的情况，基于 statement -based binlog 复制时，自增的值顺序无法把控，可能会导致主从数据不一致。</p><p>所以 MySQL 有个 innodb_autoinc_lock_mode 配置，一共有三个值：</p><ul><li>0，只用 Auto-Inc Lock。</li><li>1，<strong>默认值</strong>，对于插入前已知插入行数的插入，用互斥量，对于插入前不知道具体插入数的插入，用 Auto-Inc Lock，这样即使基于 statement -based binlog 复制也是安全的。</li><li>2，只用互斥量。</li></ul><p>至此，已经理解了共享锁、独占锁、表锁相关的知识，接下来再来看看 MySQL 中的行锁有哪几种。</p><p>主要有三种：</p><ul><li>记录锁（Record Locks）</li><li>间隙锁（Gap Locks）</li><li>临键锁（Next-Key Locks）</li></ul><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁顾名思义就是锁住当前的记录，它是<strong>作用到索引上</strong>的。我们都知道 innodb 是肯定有索引的，即使没有主键也会创建隐藏的聚簇索引，所以<strong>记录锁总是锁定索引记录</strong>。</p><p>比如，此时一个事务 A 执行 <code>SELECT * FROM yes WHERE name = &#39;xx&#39; FOR UPDATE;</code> 那么 name &#x3D; xx 这条记录就被锁定了，其他事务无法插入、删除、修改 name &#x3D; xx 的记录。</p><p>此时事务 A 还未提交，另一个事务 B 要执行 <code>insert into yes (name) values (&#39;xx&#39;)</code>，此时会被阻塞，这个很好理解。</p><p>但是，如果另一个事务 C 执行了 <code>insert into yes (name) values (&#39;aa&#39;)</code>，这个语句会被阻塞吗？</p><p><strong>看情况</strong>。</p><p><strong>如果 name 没有索引</strong>。前面提到记录锁是加到索引上的，但是 name 没索引啊，那只能去找聚簇索引，但聚簇索引上面只有主键啊，它哪知道各自的 name 是什么，所以咋办？都锁了呗！</p><p>因此，<strong>如果 name 没有索引，那么事务 C 会被阻塞，如果有索引，则不会被阻塞</strong>！</p><p>所以这里要注意，没索引的列不要轻易的锁，不要以为有行锁就可以为所欲为，并不是这样的。</p><h3 id="间隙锁和临键锁"><a href="#间隙锁和临键锁" class="headerlink" title="间隙锁和临键锁"></a>间隙锁和临键锁</h3><p>前面说了，记录锁需要加到记录上，但是如果<strong>要给此时还未存在的记录加锁怎么办</strong>？也就是要预防幻读的出现！</p><p>这时候间隙锁就派上用场了，它是给间隙加上锁。</p><p>比如此时有 1、3、5、10 这四条记录，之前的文章分析过，数据页中还有两条虚拟的记录，分别是 <code>Infimum</code> 和 <code>Supremum</code>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/TJoGOsWO_image.png"></p><p>可以看到，记录之前都有间隙，<strong>那间隙锁呢，锁的就是这个间隙</strong>！</p><p>比如我把 3 和 5 之间的间隙锁了，此时要插入 id &#x3D; 4 的记录，就会被这个间隙锁给阻塞了，这样就避免了幻读的产生！也就实现了锁定未插入的记录的需求！</p><p>还有个 <code>Next-Key Locks</code> 就是记录锁+间隙锁，像上面间隙锁的举例，只能锁定(3,5) 这个区间，而 <code>Next-Key Locks</code> 是一个前开后闭的区间(3,5]，这样能防止查询 id&#x3D;5 的这个幻读。</p><p>间隙锁之间不会冲突，<strong>间隙锁的唯一目的就是防止其他事务插入数据到间隙中</strong> ，所以即使两个间隙锁要锁住相同的间隙也没有关系，因为它们的目的是一致的。</p><p>间隙锁可以显式禁用，它是在事务隔离级别为可重复读的时候生效的，如果将事务隔离级别更改为 READ COMMITTED，就会禁用了，此时，间隙锁对于搜索和索引扫描是禁用的，仅用于外键约束检查和重复键检查。</p><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁，即 Insert Intention Locks，<strong>它也是一类间隙锁</strong>，但是它<strong>不是锁定间隙，而是等待某个间隙</strong>。比如上面举例的 id &#x3D; 4 的那个事务 C ，由于被间隙锁给阻塞了，所以事务 C 会生成一个插入意向锁，表明等待这个间隙锁的释放。</p><p>并且插入意向锁之间不会阻塞，因为它们的目的也是只等待这个间隙被释放，所以插入意向锁之间没有冲突。</p><p>它的目的不在于锁定资源防止别人访问，我个人觉得更像是为了遵循 MySQL 的锁代码实现而为之。</p><p><strong>锁其实就是内存里面的一个结构</strong>，每个事务为某个记录或者间隙上锁就是创建一个锁对象来争抢资源。</p><p>如果某个事务没有抢到资源，那也会生成一个锁对象，只是状态是等待的，而当拥有资源的事务释放锁之后，就会寻找正在等待当前资源的锁结构，然后选一个让它获得资源并唤醒对应的事务使之得以执行。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/W99AP5cD_image.png"></p><p>所以按照这么个逻辑，<strong>那些在等待间隙锁的插入事务，也需要对应的建立一个锁结构，然后锁类型是插入意向锁</strong>。</p><p>这样一来，间隙锁的事务在释放间隙锁的时候，才能得以找到那些等待插入的事务，然后进行唤醒，而由锁的类型也可以得知是插入意向锁，之间不需要阻塞，所以可以一起执行插入。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/VwKY3SBK_image.png"></p><h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p>大概就是，在线上执行一条 update 语句修改数据库数据的时候，where 条件没有带上索引，导致业务直接崩了</p><p>这次我们就来看看：</p><ul><li>为什么会发生这种的事故？</li><li>又该如何避免这种事故的发生？</li></ul><p>说个前提，接下来说的案例都是基于 InnoDB 存储引擎，且事务的隔离级别是可重复读。</p><h3 id="为什么会发生这种的事故？"><a href="#为什么会发生这种的事故？" class="headerlink" title="为什么会发生这种的事故？"></a>为什么会发生这种的事故？</h3><p>InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</p><p>因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p><p>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p><p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p><p>这里举个例子，这里有一张数据库表，其中 id 为主键索引。</p><p><img src="https://camo.githubusercontent.com/31051da723dc122a903085bff0d8dd7639eb168bff38b533d10ad5acb8730064/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f33633361663136653761393438383333636362363430396538623531646166382e706e67"></p><p>假设有两个事务的执行顺序如下：</p><p><img src="https://camo.githubusercontent.com/951e8b366ad166a8f6e6f71df709883e51d78003875dbda2022ae65730b6782f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64323332366639386362623334666330396361343031333730333235313530312e706e67"></p><p>可以看到，事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id &#x3D; 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。</p><p>但是，<strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。</p><p>假设两个事务变一下：</p><p><img src="https://camo.githubusercontent.com/074593f4a554e8176cec2141dbbed7328d5133129fc3e4adf97c628fe1f00b6a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f31616138383666653935653762633739316332393665326433343266613433352e706e67"></p><p>可以看到，这次事务 B 的 update 语句被阻塞了。</p><p>这是因为事务 A 的 update 语句中 where 条件没有索引列，触发了<strong>全表扫描</strong>，在扫描过程中会对索引加锁，所以全表扫描的场景下，<strong>所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表</strong>。</p><p>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</p><p>并不是。</p><p><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p><div class="note  flat info"><p>网上很多资料说，update 没加锁索引会加表锁，这是不对的。</p><p>Innodb 源码里面在扫描记录的时候，都是针对索引项这个单位去加锁的，update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，所以大家误以为加了表锁。</p></div><h3 id="如何避免这种事故的发生？"><a href="#如何避免这种事故的发生？" class="headerlink" title="如何避免这种事故的发生？"></a>如何避免这种事故的发生？</h3><p>我们可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</p><p>当 sql_safe_updates 设置为 1 时，update 语句必须满足如下条件之一才能执行成功：</p><ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>delete 语句必须满足以下条件能执行成功：</p><ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p><h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p><img src="https://camo.githubusercontent.com/c2fcb30d3e75edd855300164199b152a74377ca04257be16796a1e5937fbf902/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f34633438666538613032333734373534623163663932353931616538643362342e706e67"></p><p>面试官反问的大概意思是，<strong>MySQL 记录锁 + 间隙锁可以防止删除操作而导致的幻读吗？</strong></p><p>答案是可以的。</p><p>首先回顾一下：</p><h3 id="什么是幻读？"><a href="#什么是幻读？" class="headerlink" title="什么是幻读？"></a>什么是幻读？</h3><p>当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。</p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章</a>），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁 + 间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>现在有一张用户表（t_user），表里<strong>只有一个主键索引</strong>，表里有以下行数据：</p><p><img src="https://camo.githubusercontent.com/286278a3dabc584a3f6d800ba92b78041bdfc087ef00cfa6ea77f48c086d03fa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37356335633530336437646634616430393162666333353730386463653663342e706e67"></p><p>现在有一个 A 事务执行了一条查询语句，查询到年龄大于 20 岁的用户共有 6 条行记录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_user where age &gt; 20 for update;</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/651156ee0be8150ab256d767079dc4b781956085369479e8a40132fa3479b5e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36386464383966633935616134326366396230633432353164346539323236632e706e67"></p><p>然后，B 事务执行了一条删除 id &#x3D; 2 的语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from t_user where id=2;</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/c8ce42e72cc3caafffa1e0ef0cd9f5dc99b3f0d52c621b7b667ac568709b96d7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32333332666164353862633534386563393137626137656134346430396433302e706e67"></p><p>此时，B 事务的删除语句就陷入了<strong>等待状态</strong>，说明是无法进行删除的。</p><p>因此，MySQL 记录锁 + 间隙锁<strong>可以防止</strong>删除操作而导致的幻读问题。</p><h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><p>参考上一个问题，事务 A 的这条查询语句，where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了，<strong>锁是在遍历索引的时候加上的，并不是针对输出的结果加锁</strong>。</p><div class="note  flat info"><p>如果对 age 建立索引，事务 A 这条查询会加什么锁呢？</p></div><p><strong>因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。</strong></p><p>主键索引会加如下的锁：</p><ul><li>X 型的记录锁，锁住 id &#x3D; 2 的记录；</li><li>X 型的记录锁，锁住 id &#x3D; 3 的记录；</li><li>X 型的记录锁，锁住 id &#x3D; 5 的记录；</li><li>X 型的记录锁，锁住 id &#x3D; 6 的记录；</li><li>X 型的记录锁，锁住 id &#x3D; 7 的记录；</li><li>X 型的记录锁，锁住 id &#x3D; 8 的记录；</li></ul><p>分析 age 索引加锁的范围时，要先对 age 字段进行排序。</p><p>age 索引加的锁：</p><ul><li>X 型的 next-key lock，锁住 age 范围 (19, 21] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (21, 21] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (21, 23] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (23, 23] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (23, 39] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (39, 43] 的记录；</li><li>X 型的 next-key lock，锁住 age 范围 (43, +∞] 的记录；</li></ul><p>化简一下，<strong>age 索引 next-key 锁的范围是 (19, +∞]。</strong></p><p>总结一下，在对 age 字段建立索引后，事务 A 在执行下面这条查询语句后，主键索引和 age 索引会加下图中的锁。</p><p><img src="https://camo.githubusercontent.com/81258bbb313c966ee49dcd2c8a9d40b52a406ba671acfd0486daee32099959ca/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f35623961326437613263643234306665613437623933383336346630623736612e706e67"></p><p>事务 A 加上锁后，事务 B、C、D、E 在执行以下语句都会被阻塞。</p><p><img src="https://camo.githubusercontent.com/04883c10d01e09e3aa03391f60b93f2e83abc704ee37afaba8d29459fb20b3ce/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f34366339623434313432663134323137623339626439373338363865373332652e706e67"></p><h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><p>出现 MySQL 死锁的主要原因是<strong>资源的循环依赖</strong>。</p><p>像 MyISAM 引擎只有表锁，基本上不会产生死锁，而 InnoDB 有行锁，锁的粒度比较低，因此可能会产生死锁。</p><p>不过 MySQL InnoDB 有一个自动检测的功能（innodb_deadlock_detect），如果发生死锁会回退事务从而释放锁，也有锁等待超时的参数（innodb_lock_wait_timeout），当获取锁的等待时间超过阈值时，就释放锁进行回滚。</p><p>如果线上遇到死锁的情况，可以通过 <code>SHOW ENGINE INNODB STATUS</code> 来获取死锁的日志信息，从而定位到死锁发生的原因。</p><h3 id="死锁的发生"><a href="#死锁的发生" class="headerlink" title="死锁的发生"></a>死锁的发生</h3><p>本次案例使用存储引擎 Innodb，隔离级别为可重复读（RR）。</p><p>这里建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引。然后， <code>t_order</code> 表里现在已经有了 6 条记录：</p><p><img src="https://camo.githubusercontent.com/dbbb8871b7d55fc97102598c6ee22001ccd2f02d4b649be84f3a9e286aa0cc98/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f35346663303066396638376136306162376235626139326438323461383932642e706e67"></p><p>假设这时有两事务，一个事务要插入订单 1007，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：</p><p><img src="https://camo.githubusercontent.com/ce4e6f1cf60cba002f3a68086e6ce808e11504f38eefbfea36932188d4f6856f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f39306331653031643033343564653633396533343236636561303339306538302e706e67"></p><p>可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。</p><p>这里在查询记录是否存在的时候，使用了 <code>select ... for update</code> 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。</p><p>如果没有使用 <code>select ... for update</code> 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：</p><p><img src="https://camo.githubusercontent.com/d467f366e50c71ce5ed110ea3de126e75686c081767185e1acf0f91e4b22404d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f38616531386631306631613839616163356539336630653937393465343639652e706e67"></p><h3 id="为什么会产生死锁？"><a href="#为什么会产生死锁？" class="headerlink" title="为什么会产生死锁？"></a>为什么会产生死锁？</h3><p>可重复读隔离级别下，是存在幻读的问题。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p><ul><li>Record Lock，记录锁，锁的是记录本身；</li><li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li></ul><p>行锁的释放时机是在<strong>事务提交（commit）后</strong>，锁就会被释放，并不是一条语句执行完就释放行锁。</p><p>回到上面的例子，**此时事务 A 在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是<code>(1006, +∞]</code>**。当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id &#x3D; 1008 的记录就会被锁住。</p><div class="note  flat info"><p>next-key 锁的范围 (1006, +∞]，是怎么确定的？</p></div><p>根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。</p><div class="note  flat info"><p>为什么上面事务 A 的 next-key lock 并没有退化为间隙锁？</p></div><p>如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no &#x3D; 1006（不存在），就是 next key lock，如上面事务 A 的情况。</p><p>如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no &#x3D; 1006（不存在），就是间隙锁。</p><p>再回到两个事务当中，当我们执行插入语句时，会在插入间隙上获取插入意向锁，<strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 <code>select ... for update</code> 语句并不会相互影响</strong>。</p><p>案例中的事务 A 和事务 B 在执行完后 <code>select ... for update</code> 语句后都持有范围为<code>(1006,+∞]</code>的 next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p><p>有一点要注意，<strong>next-key lock 是包含间隙锁 + 记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p><p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系。X 型的记录锁与 X 型的记录锁是冲突的，比如一个事务执行了 select … where id &#x3D; 1 for update，后一个事务在执行这条语句的时候，就会被阻塞的。</p><p>但是还要注意！对于这种范围为 (1006, +∞] 的 next-key lock，<strong>两个事务是可以同时持有的，不会冲突</strong>。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。</p><h3 id="Insert-语句是怎么加行级锁的？"><a href="#Insert-语句是怎么加行级锁的？" class="headerlink" title="Insert 语句是怎么加行级锁的？"></a>Insert 语句是怎么加行级锁的？</h3><p>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。</p><div class="note  flat info"><p>什么是隐式锁？</p></div><p>当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB 会跳过加锁环节，这种机制称为隐式锁。隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</p><p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显式锁，这里我们列举两个场景。</p><ul><li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；</li><li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；</li></ul><h4 id="记录之间加有间隙锁"><a href="#记录之间加有间隙锁" class="headerlink" title="记录之间加有间隙锁"></a>记录之间加有间隙锁</h4><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</p><h4 id="遇到唯一键冲突"><a href="#遇到唯一键冲突" class="headerlink" title="遇到唯一键冲突"></a>遇到唯一键冲突</h4><p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为 NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p><p>至于是行级锁的类型是记录锁，还是 next-key 锁，跟是「主键冲突」还是「唯一二级索引冲突」有关系。</p><p>如果主键索引重复：</p><ul><li>当隔离级别为<strong>读已提交</strong>时，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li><li>当隔离级别是<strong>可重复读</strong>（默认隔离级别），插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li></ul><p>如果唯一二级索引列重复：</p><ul><li><strong>不论是哪个隔离级别</strong>，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。对的，没错，即使是读已提交隔离级别也是加 next-key 锁，这是读已提交隔离级别中为数不多的给记录添加间隙锁的场景。至于为什么要加 next-key 锁，我也没找到合理的解释。</li></ul><p><img src="https://camo.githubusercontent.com/b1cad449c5ffae7c583b7e879088acc5e881d3b6e2f897ad9880c06952a41962/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f2545352539342541462545342542382538302545372542342541322545352542432539352545352538412541302545392539342538312e64726177696f2e706e67"></p><p>两个事务的加锁过程：</p><ul><li>事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；</li><li>接着，事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，<strong>事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态</strong>。</li></ul><p>如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。</p><p><img src="https://camo.githubusercontent.com/d467f366e50c71ce5ed110ea3de126e75686c081767185e1acf0f91e4b22404d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f38616531386631306631613839616163356539336630653937393465343639652e706e67"></p><h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li><li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p><h2 id="字节面试：加了什么锁，导致死锁的？"><a href="#字节面试：加了什么锁，导致死锁的？" class="headerlink" title="字节面试：加了什么锁，导致死锁的？"></a>字节面试：加了什么锁，导致死锁的？</h2><p><img src="https://camo.githubusercontent.com/cfb4352d24094f97415f2ca7994498a43177a436e0835f2dd872652abf57a86a/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f2545352541442539372545382538412538326d7973716c2545392539442541322545382541462539352545392541322539382e706e67"></p><p>如果对 MySQL 加锁机制比较熟悉的同学，应该一眼就能看出<strong>会发生死锁</strong>，但是具体加了什么锁而导致死锁，是需要我们具体分析的。</p><p>（其实看完上一个问题，这里是多看两眼就能看出来了）</p><h3 id="为什么会发生死锁？"><a href="#为什么会发生死锁？" class="headerlink" title="为什么会发生死锁？"></a>为什么会发生死锁？</h3><h4 id="Time-1-阶段加锁分析"><a href="#Time-1-阶段加锁分析" class="headerlink" title="Time 1 阶段加锁分析"></a>Time 1 阶段加锁分析</h4><p>Time 1 阶段，事务 A 执行语句后，执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务 A 此时加了什么锁。</p><p><img src="https://camo.githubusercontent.com/07f47dda4724b33847d7a8fb285071af9a8fad2664f081c074ad5e0776815a6a/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f254534254241253842254535253841254131612545372539412538342545392539342538312e706e67"></p><p>**因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加的是间隙锁，锁范围是<code>(20, 30)</code>**。</p><h4 id="Time-2-阶段加锁分析"><a href="#Time-2-阶段加锁分析" class="headerlink" title="Time 2 阶段加锁分析"></a>Time 2 阶段加锁分析</h4><p><img src="https://camo.githubusercontent.com/96011c19567e52c55651831d0c6b9002187c627cb36e4fcbe529919fc0e0008a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f34343237376366656662643634343664623836316266623831613165346135392e706e67"></p><p>从上图可以看到，行锁是 X 类型的间隙锁，间隙锁的范围是<code>(20, 30)</code>。</p><div class="note  flat info"><p>事务 A 和 事务 B 的间隙锁范围都是一样的，为什么不会冲突？</p></div><p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。<strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享（S 型）和排他（X 型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。</p><h4 id="Time-3-阶段加锁分析"><a href="#Time-3-阶段加锁分析" class="headerlink" title="Time 3 阶段加锁分析"></a>Time 3 阶段加锁分析</h4><p><img src="https://camo.githubusercontent.com/7e472218a59e291d46d1a449eca1b6d8d7cb67a97ac3d4d89c3ea2b252aeeced/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f254534254241253842254535253841254131612545372541442538392545352542452538352545342542382541442e706e67"></p><p>可以看到，事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 <code>(20, 30)</code>）中插入了一条记录，所以事务 A 的插入操作生成了一个插入意向锁（<code>LOCK_MODE:INSERT_INTENTION</code>）。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：<strong>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的</strong>。</p><h4 id="Time-4-阶段加锁分析"><a href="#Time-4-阶段加锁分析" class="headerlink" title="Time 4 阶段加锁分析"></a>Time 4 阶段加锁分析</h4><p>同理，事务 B 在生成插入意向锁时而导致被阻塞，这是因为事务 B 向事务 A 生成的范围为 (20, 30) 的间隙锁插入了一条记录，而插入意向锁和间隙锁是冲突的，所以事务 B 在获取插入意向锁时就陷入了等待状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次案例中，事务 A 和事务 B 在执行完后 update 语句后都持有范围为<code>(20, 30）</code>的间隙锁，而接下来的插入操作为了获取到<strong>插入意向锁</strong>，都在等待对方事务的间隙锁释放，于是就造成了<strong>循环等待</strong>，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81">MySQL 有哪些锁？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/lock/update_index.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E7%9A%84%E4%BA%8B%E6%95%85">update 没加索引会锁全表？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/lock/lock_phantom.html">MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/lock/deadlock.html">MySQL 死锁了，怎么办？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/lock/show_lock.html">字节面试：加了什么锁，导致死锁的？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】事务</title>
      <link href="/p/8324e4bc/"/>
      <url>/p/8324e4bc/</url>
      
        <content type="html"><![CDATA[<h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性（即ACID），分别如下：</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log（重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志）来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制）或锁机制来保证的；</li><li>一致性则是通过持久性 + 原子性 + 隔离性来保证；</li></ul><p>这次将<strong>重点介绍事务的隔离性</strong>，这也是面试时最常问的知识的点。</p><p>为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</p><h2 id="MySQL-是如何实现事务的？"><a href="#MySQL-是如何实现事务的？" class="headerlink" title="MySQL 是如何实现事务的？"></a>MySQL 是如何实现事务的？</h2><p>MySQL 主要是通过：<strong>锁、Redo Log 、Undo Log、MVCC</strong> 来实现事务。</p><p>MySQL 利用锁（行锁、间隙锁等等）机制，使用数据并发修改的控制，满足事务的<strong>隔离性</strong>。</p><p>Redo Log（重做日志），它会记录事务对数据库的所有修改，在崩溃时恢复未提交的更改，用来满足事务的<strong>持久性</strong>。</p><p>Undo Log（回滚日志），它会记录事务的反向操作，简单地说就是保存数据的历史版本，用于事务的回滚，使得事务执行失败之后可以恢复之前的样子。实现<strong>原子性和隔离性</strong></p><p>MVCC（多版本并发控制），满足了非锁定读的需求，提高了并发度，实现了读已提交和可重复读两种隔离级别，实现了事务的<strong>隔离性</strong>。</p><p>事务主要是为了实现一致性，具体是通过 AID，即原子性、隔离性和持久性来达到一致性的目的。</p><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p><p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p><h3 id="脏读（针对于未提交的数据）"><a href="#脏读（针对于未提交的数据）" class="headerlink" title="脏读（针对于未提交的数据）"></a>脏读（针对于未提交的数据）</h3><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p><p><img src="https://camo.githubusercontent.com/1b0c4e74de27d6b8dd19f1dfb0a7b6097f6901c08698bbb488f55b66c0fe1401/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f31306235313330303865613335656538383063353932613838616463623132662e706e67"></p><p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p><h3 id="不可重复读（针对于数据的内容）"><a href="#不可重复读（针对于数据的内容）" class="headerlink" title="不可重复读（针对于数据的内容）"></a>不可重复读（针对于数据的内容）</h3><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><p><img src="https://camo.githubusercontent.com/4e1df87bb5ae151243593d5dd3968abb26a131c3edc7d6e642fbf51e3e4488cf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f66356234663866306330616463663034346233346331663330306139356162662e706e67"></p><h3 id="幻读（针对于数据的数量）"><a href="#幻读（针对于数据的数量）" class="headerlink" title="幻读（针对于数据的数量）"></a>幻读（针对于数据的数量）</h3><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p><p><img src="https://camo.githubusercontent.com/810790b78484be293f61a7054246c1e54e7d8986dc3468ed0ddc742ecf0f14a7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64313961313031396463333564666538636665376662666638636439376533312e706e67"></p><p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p><p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p><h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程度的影响。</p><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的<strong>数据</strong>不一致；</li><li>幻读：前后读取的记录<strong>数量</strong>不一致。</li></ul><p>这三个现象的严重性排序如下：</p><p><img src="https://camo.githubusercontent.com/f6bc9ce6abf28d354b9233ef66cc1007fb1e187691f7375e1c8310d17b9d2c52/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64333762666131363738656237316165376533336463386632313164316563312e706e67"></p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>按隔离水平高低排序如下：</p><p><img src="https://camo.githubusercontent.com/02345733bcb91bbc63f5b32f67dd8afec04d03b43187b1d8118b5d74848e1553/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f63636537363661363964656137323563643866313962393064623264303433302e706e67"></p><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p><p><img src="https://camo.githubusercontent.com/0acf8a568ea4b35b3f596dfb67129b142f091f80e51f75c397df4d5566b4814d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f34653938656132653630393233623936393739303839383536356234643634332e706e67"></p><p>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</p><p>不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，<strong>我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与 SQL 标准中规定的各级隔离级别允许发生的现象却有些出入</strong>。</p><p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章</a>）</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁 + 间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p><p><img src="https://camo.githubusercontent.com/ff0a4c980d5b3f4716b1035dfed77139b40737061d6aea77a94ccb8f19d5b37b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64356465343530653930316564393236643062353237386338623635623966652e706e67"></p><p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p><ul><li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li><li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li><li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li><li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200 万。</li></ul><p>这四种隔离级别具体是如何实现的呢？</p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul><h2 id="MySQL-中的-MVCC-是什么？"><a href="#MySQL-中的-MVCC-是什么？" class="headerlink" title="MySQL 中的 MVCC 是什么？"></a>MySQL 中的 MVCC 是什么？</h2><p>MVCC（Multi-Version Concurrency Control）多版本并发控制。</p><p>所谓多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本。</p><p>多版本之间串联起来就形成了一条版本链，这样不同时刻启动的事务可以<strong>无锁</strong>地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞，写操作可以继续写，无非就是多加了一个版本，历史版本记录可供已经启动的事务读取。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/yLAbrqaa_image.png"></p><p>（为保持简短，简化了SQL语句，下面的内容也同样简化）</p><p>实际上 InnoDB 不会真的存储了多个版本的数据，只是借助 undolog 记录每次写操作的反向操作，所以索引上对应的记录只会有一个版本，即最新版本。只不过可以根据 undolog 中的记录反向操作得到数据的历史版本，所以看起来是多个版本。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/bH5m2PJ7_image.png"></p><p>拿上面的<code> insert （1，XX）</code>这条语句举例，成功插入之后数据页的记录上不仅存储 ID 1，name XX，还有 trx_id 和 roll_pointer 这两个隐藏字段：</p><ul><li>trx_id：当前事务ID。</li><li>roll_pointer：指向 undo log 的指针。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/cWCeOxKe_image.png"></p><p>从图中可以得知此时插入的事务 ID 是 1，此时插入会生成一条 undolog ，并且记录上的 roll_pointer 会指向这条 undolog ，而这条 undolog 是一个类型为<code>TRX_UNDO_INSERT_REC</code>的 log，代表是 insert 生成的，里面存储了主键的长度和值(还有其他值，不提)，所以 InnoDB 可以根据 undolog 里的主键的值，找到这条记录，然后把它删除来实现回滚(复原)的效果。因此可以简单地理解 undolog 里面存储的就是当前操作的反向操作，所以认为里面存了个<code> delete 1</code> 就行。</p><p>此时<strong>事务1提交</strong>，然后另一个 ID 为 5 的事务再执行 <code>update NO where id 1</code> 这个语句，此时的记录和 undolog 就如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/4DPGWFzz_image.png"></p><p>没错，之前 insert 产生的 undolog 没了，insert 的事务提交了之后对应的 undolog 就回收了，因为不可能有别的事务会访问比这还要早的版本了，访问插入之前的版本？访问个寂寞吗？</p><p>而 update 产生的 undolog 不一样，它的类型为 <code>TRX_UNDO_UPD_EXIST_REC</code>。</p><p>此时<strong>事务 5 提交</strong>，然后另一个 ID 为 11 的事务执行<code>update Yes where id 1</code> 这个语句，此时的记录和 undolog 就如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/nI8f9S2A_image.png"></p><p>没错，update 产生的 undolog 不会马上删除，因为可能有别的事务需要访问之前的版本，所以不能删。这样就串成了一个版本链，可以看到记录本身加上两条 undolog，这条 id 为 1 的记录共有三个版本。</p><h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><p>版本链搞清楚了，这时候还需要知道一个概念 readView，这个 readView 就是用来判断哪个版本对当前事务可见的，这里有四个概念：</p><ul><li>creator_trx_id：<strong>创建该 Read View 的事务的事务 id</strong>。</li><li>m_ids：生成 readView 时还活跃的事务ID集合，也就是<strong>已经启动但是还未提交</strong>的事务ID列表。</li><li>min_trx_id：当前活跃ID之中的最小值。</li><li>max_trx_id：生成 readView 时 InnoDB 将分配给下一个事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务ID越大）</li></ul><p><img src="https://camo.githubusercontent.com/81cf4a72128544f6d770c4b7cb1abb47c5d337409233a2dbfe34240f52ad9005/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f72656164766965772545372542422539332545362539452538342e64726177696f2e706e67"></p><p><strong>对于可见版本的判断是从最新版本开始沿着版本链逐渐寻找老的版本，如果遇到符合条件的版本就返回</strong>。</p><p>判断条件如下：</p><ul><li>如果当前数据版本的 trx_id &#x3D;&#x3D; creator_trx_id 说明修改这条数据的事务就是当前事务，所以可见。</li><li>如果当前数据版本的 trx_id &lt; min_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候已提交，所以可见。</li><li>如果当前数据版本的 trx_id 大小在 min_trx_id 和 max_trx_id 之间，此时 trx_id 若在 m_ids 中，说明修改这条数据的事务此时还未提交，所以不可见，若不在 m_ids 中，表明事务已经提交，可见。</li><li>如果当前数据版本的 trx_id &gt;&#x3D; max_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候还未启动，所以不可见(结合事务ID递增来看)。</li></ul><p><img src="https://camo.githubusercontent.com/294ef29ce17eed909fdb498f6f0f862ef72a88c84f02187e9f26b5bb2880f8e6/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f52656164566965772e64726177696f2e706e67"></p><h2 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A（事务 id 为 51）启动后，紧接着事务 B（事务 id 为 52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img src="https://camo.githubusercontent.com/4d6d83e2e15e4e9c34f70dc98a8d394d6aebdb6adb0f3643d9835555407c8967/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f25453425424125384225453525384125413161622545372539412538342545382541372538362545352539422542452d6e65772e706e67"></p><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>接下来，跟大家具体分析下。</p><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="https://camo.githubusercontent.com/e896afd86527d2f4f70f797bc4790060fc5ec4a6cecb4fb209fe61fc199f45e5/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f2545342542412538422545352538412541316162254537253941253834254538254137253836254535253942254245322e706e67"></p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 可见的第一条记录（trx_id「小于」事务 B 的 Read View 中的 min_trx_id 值，或者 trx_id 在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，但是不在 m_ids 范围内）</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务，事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p><h2 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A（事务 id 为 51）启动后，紧接着事务 B（事务 id 为 52）也启动了，接着按顺序执行了以下操作：</p><ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul><p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：</p><p><img src="https://camo.githubusercontent.com/53c78c9fded71bd0fb6c2ff7b1df968ecbf91b91cf1d4ba0459b2f74a1a98484/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f2545382541462542422545362538462539302545342542412541342545342542412538422545352538412541312e706e67"></p><p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A（还未提交事务）修改的数据？</p><p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<strong>这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录</strong>。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 可见的第一条记录（trx_id「小于」事务 B 的 Read View 中的 min_trx_id 值，或者 trx_id 在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，但是不在 m_ids 范围内），所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？</p><p>在事务 A 提交后，<strong>由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View</strong>，此时事务 B 第三次读取数据时创建的 Read View 如下：</p><p><img src="https://camo.githubusercontent.com/30c81c50a30116347fd2e9e319b93d0ebd95f3d528bbdb3006d84eae1475822e/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f254538254146254242254536253846253930254534254241254134254534254241253842254535253841254131322e64726177696f2e706e67"></p><p>事务 B 在找到小林这条记录时，<strong>会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的</strong>。</p><p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><h2 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>上面提到，MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁 + 间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。</p><h3 id="快照读是如何避免幻读的？"><a href="#快照读是如何避免幻读的？" class="headerlink" title="快照读是如何避免幻读的？"></a>快照读是如何避免幻读的？</h3><p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p><h3 id="当前读是如何避免幻读的？"><a href="#当前读是如何避免幻读的？" class="headerlink" title="当前读是如何避免幻读的？"></a>当前读是如何避免幻读的？</h3><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p><img src="https://camo.githubusercontent.com/510dc2d1020bb3936becee84e4d8ff401dec82de60bed71b326236f0d2cf5bde/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f6761702545392539342538312e64726177696f2e706e67"></p><h3 id="幻读被完全解决了吗？"><a href="#幻读被完全解决了吗？" class="headerlink" title="幻读被完全解决了吗？"></a>幻读被完全解决了吗？</h3><h4 id="第一个发生幻读现象的场景"><a href="#第一个发生幻读现象的场景" class="headerlink" title="第一个发生幻读现象的场景"></a>第一个发生幻读现象的场景</h4><p>以这张表作为例子：</p><p><img src="https://camo.githubusercontent.com/eb4e1663127ef47dcb41c2294e6b650d8f3a7cbd1951da518bb65e9828366737/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37663964663134326233353934646165616163613439356162623731333366352e706e67" alt="img"></p><p>事务 A 执行查询 id &#x3D; 5 的记录，此时表中是没有该记录的，所以查询不出来。</p><p>然后事务 B 插入一条 id &#x3D; 5 的记录，并且提交了事务。</p><p>此时，<strong>事务 A 更新 id &#x3D; 5 这条记录，对没错，事务 A 看不到 id &#x3D; 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id &#x3D; 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。整个发生幻读的时序图如下：</p><p><img src="https://camo.githubusercontent.com/f478ab3ff785c7022d3f0667535ab6e4358db3839feecfb21f55dffa4e70495f/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545392539342538312f2545352542392542422545382541462542422545352538462539312545372539342539462e64726177696f2e706e67"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h4 id="第二个发生幻读现象的场景"><a href="#第二个发生幻读现象的场景" class="headerlink" title="第二个发生幻读现象的场景"></a>第二个发生幻读现象的场景</h4><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往<code>t_test</code>表中插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><h2 id="MySQL-中长事务可能会导致哪些问题？"><a href="#MySQL-中长事务可能会导致哪些问题？" class="headerlink" title="MySQL 中长事务可能会导致哪些问题？"></a>MySQL 中长事务可能会导致哪些问题？</h2><p>比如，你现在需要删除一张一共有 5 亿数据的表里面的 2021 年数据，假设这张表叫 yes。</p><p>我相信你脑子在 1s 内肯定会蹦出这条 SQL：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from yes where create_date &gt; &quot; 2020-12-31&quot; and create_date &lt; &quot;2022-01-01&quot;;</span><br></pre></td></tr></table></figure><p>如果直接执行这条 SQL 会发生什么问题呢？</p><p>那便是<strong>长事务</strong>，我们需要关注到一个前提：这张表有 5 亿的数据，所以它是一张超大表，因此这个 where 条件可能涉及非常多的数据，所以我们可以从离线数仓或者备库查下数据量，然后我们发现这条 SQL 会删除 3 亿左右的数据。</p><p>那么一次性 delete 完的方案是不行的，因为这会涉及到<strong>长事务的问题</strong>。</p><p>长事务涉及到加锁，只会在事务执行完毕后才会释放锁，由于长事务锁了很多数据，如果期间有频繁的 DML 想要操作这些数据，那么就会造成阻塞。</p><p>连接都阻塞住了，业务线程自然就阻塞了，也就是说你的服务线程都在等待数据库的响应，然后可能还会影响到别的服务，可能产生雪崩，导致非常严重的线上事故。</p><p>长事务还可能会造成主从延迟，你想想主库执行了好久，才执行完给从库，从库又要重放好久，期间可能有很长一段时间数据是不同步的。</p><p>还有一种情况，业务都有个特殊停机窗口，你觉得你可以为所欲为，然后开始执行长事务了，然后执行了 5 小时之后，不知道啥情况抛错了，事务回滚了，于是浪费了 5 个小时，还得重新开始。</p><h3 id="长事务的-SQL-如何处理？"><a href="#长事务的-SQL-如何处理？" class="headerlink" title="长事务的 SQL 如何处理？"></a>长事务的 SQL 如何处理？</h3><p>答案就是<strong>拆</strong>！怎么拆呢？以上面的 delete 操作来说我们来看下如何解决：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from yes where create_date &gt; &quot;2020-12-31&quot; and create_date &lt; &quot;2022-01-01&quot;;</span><br></pre></td></tr></table></figure><p>看到这条 SQL，如果要拆分，想必很多小伙伴会觉得很简单，按日期拆不就完事了？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from yes where create_date &gt; &quot;2020-12-31&quot; and create_date &lt; &quot;2021-02-01&quot;;</span><br></pre></td></tr></table></figure><p><code>delete from yes where create_date &gt;= &quot;2021-02-01&quot; and create_date &lt; &quot;2021-03-01&quot;;</code> ……</p><p>这当然可以，恭喜你，你已经拆分成功了，没错就这么简单。</p><p>但是，<strong>如果 create_date 没有索引怎么办？</strong></p><p>没索引的话，上面这就全表扫描了啊？</p><p>影响不大，没有索引我们就给他创造索引条件，这个条件就是主键。</p><p>我们直接一个 select min(id)… 和 select max(id)…. 得到这张表的主键最小值和最大值，假设答案是233333333 和 666666666。</p><p>然后我们就可以开始操作了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from yes where (id &gt;= 233333333 and id &lt; 233433333) and create_date &gt; &quot;2020-12-31&quot; and create_date &lt; &quot;2022-01-01&quot;;</span><br><span class="line">delete from yes where (id &gt;= 233433333 and id &lt;233533333) and create_date &gt; &quot;2020-12-31&quot; and create_date &lt; &quot;2022-01-01&quot;;</span><br></pre></td></tr></table></figure><p>……</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from yes where (id &gt;= 666566666 and id &lt;=666666666) and create_date &gt; &quot;2020-12-31&quot; and create_date &lt; &quot;2022-01-01&quot;;</span><br></pre></td></tr></table></figure><p>当然你也可以再精确些，通过日期筛选来得到 maxId，这影响不大（不满足条件的 SQL 执行很快，不会耗费很多时间）。</p><p>这样一来 SQL 就满足了分批的操作，且用得上索引。</p><p>如果哪条语句执行出错，只会回滚小部分数据，我们重新排查下就好了，影响不大。</p><p>而且拆分 SQL 之后还可以<strong>并行提高执行效率</strong>。</p><p>当然并行可能有锁竞争的情况，导致个别语句等待超时。不过影响不大，只要机器状态好，执行的快，因为锁竞争导致的等待并不一定会超时，如果个别 SQL 超时的话，重新执行就好了。</p><h3 id="删除的思路转换"><a href="#删除的思路转换" class="headerlink" title="删除的思路转换"></a>删除的思路转换</h3><p>关于大表删除有时候要转换思路，<strong>把删除转成插入</strong>。</p><p>假设还是有一张 5 亿的数据表，此时你需要删除里面 4.8 亿的数据，那这时候就不要想着删除了，要想着插入。</p><p>道理很简单，删除 4.8 亿的数据，不如把要的 2000W 插入到新表中，我们后面业务直接用新表就好了。</p><p>这两个数据量对比，时间效率差异不言而喻了吧？</p><p>具体操作也简单：</p><ol><li>创建一张新表，名为 yes_temp</li><li>将 yes 表的 2000W 数据 select into 到 yes_temp 中</li><li>将 yes 表 rename 成 yes_233</li><li>将 yes_temp 表 rename 成 yes</li></ol><p>狸猫换太子，大功告成啦！</p><p>之前有个记录表我们就是这样操作的，就 select into 近一个月的数据到新表中，以前老数据就不管了，然后 rename 一下，执行的非常快，1 分钟内就搞定了。</p><p>这种类似的操作是有工具的，比如 pt-online-schema-change 等，不过我没用过，有兴趣的小伙伴可以自己去看看，道理是一样的，多了几个触发器，这里不多赘述了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离级别是怎么实现的？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB">MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑神话：悟空》100%全流程全成就全要素收集指南</title>
      <link href="/p/6021f67a/"/>
      <url>/p/6021f67a/</url>
      
        <content type="html"><![CDATA[<div class="note  simple"><p>搬运自：<a href="https://steamcommunity.com/sharedfiles/filedetails/?id=3313910106">Steam 社区 :: 指南 :: 《黑神话：悟空》100%全流程全成就全要素收集指南！</a><br>原文更新时间：8 月 26 日 下午 8:34<br>个人补充内容时间：见文章标题下</p></div><div class="note  simple info"><p>地图：<a href="https://www.gamersky.com/tools/map/wukong/">黑神话悟空全收集互动地图</a><br>实时地图：<a href="https://chat.top/home/index">黑盒语音，玩家开黑大本营</a></p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本指南的正确食用方法是：</p><p>想一周目就无脑照做的，看全流程要素</p><p>不想一周目就无脑照做，也至少请看下面的易错过合集</p><p>想查漏补缺，后面许许多多的篇章供您参考</p><br><p>游戏中的几样重要永久强化素材：</p><p>落伽香藤：强化葫芦等级<br>三冬虫：强化葫芦回血量<br>碧藕金丹：永久提升生命值上限<br>太乙紫金丹：永久提升法术值上限<br>九转金丹：永久提升气力值上限<br>虚空结：强化高级别精魄关键材料<br>玲珑内丹：仙炉炼药关键材料，用于提升角色各项基本性能数值——许多精英怪、宝箱都有掉落，本指南不作尽数列举。</p><p><strong>一个重要的小技巧是跳跃+重攻击，可以视为二段跳效果跳到高处、快速近身。</strong></p><p>存档位置：X:\Steam\steamapps\common\BlackMythWukong\b1\Saved\SaveGames</p><h3 id="常见Q-A"><a href="#常见Q-A" class="headerlink" title="常见Q&amp;A"></a>常见Q&amp;A</h3><ul><li>全成就约50-70小时，概率掉落收集类较为耗时，部分实测掉率大概在1%~3%，据说可携带金鱼鲤等珍玩增加掉率，但感觉只掉材料，，，</li><li>一周目无法达成全成就，除防具全配方解锁但需两周目收集大力铁角、龙珠等道具外，其余收集为二周目新增配方</li><li>游戏仅有一条主线路线击败大圣残躯，和唯一影响要素隐藏分支二郎神战（需1245章节隐藏图击败最终boss以及3章节瓜田支线完成）。先打隐藏分支结局动画会有所区别，所以也是两种不同结局故事。无网络传言结局3、结局5等</li></ul><h2 id="【-重点先看–易错过合集-】（欢迎留言扩充）"><a href="#【-重点先看–易错过合集-】（欢迎留言扩充）" class="headerlink" title="【 重点先看–易错过合集 】（欢迎留言扩充）"></a><strong>【 重点先看–易错过合集 】</strong>（欢迎留言扩充）</h2><p>据说，必须单存档内达成其它所有成就，所以备份存档对全成就的帮助不大，而主要是为了防止错过某些要素而进行的保险措施。</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul><li>开局就会碰到的大头怪boss——幽魂，在进入第一章隐藏地图后就会消失。该boss掉落 幽魂-精魄，这个精魄技能还可用来打开第二章的隐藏道具门。</li><li>NPC马天霸，一只马头NPC，之后每一章均会出现一次，请务必提前找到，再去挑战最终boss，传闻第五章某剧情后就不可补了。第二章可补，后续未验证</li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li>沙国王BOSS战先击杀沙二郎会直接导致BOSS战结束，并少获得 沙二郎-精魄，但会多一段沙国王召唤沙大朗的过场动画。（有全精魄成就！）</li><li>先击杀石母会少拿石双双精魄。</li><li>马天霸NPC，村口刚进院的位置，详情参考流程篇，通关后若涉及该NPC的成就我会补充到这里和成就篇。</li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ul><li>浮屠界打boss魔将妙音前，击杀九个掌灯怪会得到一个珍玩吉祥灯，提前击杀则将错过</li><li>BOSS无量蝠，位置在龟岛下来到达苦海北岸处，面对岛最左边的大蛇骨架处。（在拜完四佛，八戒离队后无法触发）</li><li>马天霸NPC，最后的小雷音寺左边偏殿二楼的走廊，详情参考流程篇，通关后若涉及该NPC的成就我会补充到这里和成就篇。</li><li>四将信物交给小张太子之前，确保摸它旁边尸体获取法术“灰蛰”</li></ul><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ul><li>隐藏地图前置boss黑手道人，可通过偷袭背部的手掉落额外装备——毒手，第一次见就能掉，由于判定有问题，各位可以用定身法定住后打他屁股位置，怕失误可以提前备份。</li><li>四妹支线-揭紫符，在挑战完第四章最终boss百目魔君后会消失。<strong>涉及 第四十七难 成就</strong></li><li>隐藏地图-紫云山 boss毒敌大王，在触发完隐藏地图boss晦月魔君后会消失。<strong>涉及 第四十五难 成就</strong></li><li>隐藏地图-紫云山 糜道人支线，需要击杀地图上的黄袍怪掉落任务道具，在触发完隐藏地图boss晦月魔君后会消失。（但传送点上仍未消失，推测可能是bug）<strong>涉及 第四十六难 成就</strong></li><li>马天霸NPC，到达 盘丝洞-绝想崖 传送点前，属于主线必经之路，详情参考流程篇，通关后若涉及该NPC的成就我会补充到这里和成就篇。</li></ul><h2 id="【【-回档方法及补救措施-】】"><a href="#【【-回档方法及补救措施-】】" class="headerlink" title="【【 回档方法及补救措施 】】"></a><strong>【【 回档方法及补救措施 】】</strong></h2><ul><li>当前游戏带自动存档，位置在 <code>X:\Steam\steamapps\common\BlackMythWukong\b1\Saved\SaveGamesBackup</code>（X是你存游戏的盘符）</li><li>打开后会有三个文件夹，三个文件夹仅保存周期规则不同，无其余区别<ul><li>01RealtimeBackup（最近存档，根据游戏内时间节点自动保存，会被新时间覆盖，最多六个）</li><li>02HourlyBackup（小时存档，按照登录游戏后每整点自动保存，会被新时间覆盖，最多十二小时）</li><li>03DailyBackup（天数存档，按照现实时间日期每天自动保存一次，或无上限）</li></ul></li><li>根据自己错过的成就节点，可根据steam成就完成时间进行参考，选择最近的时间存档替换掉<code>X:\Steam\steamapps\common\BlackMythWukong\b1\Saved\SaveGames</code>内的即可</li></ul><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2405571925790514878/44248BEF8DDB9AB7D6B1763B5636293D604DF929/"></p><h2 id="无脑照做流程全要素收录"><a href="#无脑照做流程全要素收录" class="headerlink" title="无脑照做流程全要素收录"></a><strong>无脑照做流程全要素收录</strong></h2><h3 id="第一话：黑风山（对应成就1-10）"><a href="#第一话：黑风山（对应成就1-10）" class="headerlink" title="第一话：黑风山（对应成就1-10）"></a>第一话：黑风山（对应成就1-10）</h3><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><p>BOSS-二郎显圣真君：必经流程</p><div class="note  flat success"><p>▶成就01：击败教程BOSS二郎显圣真君后过场动画结束</p></div><h4 id="苍狼林-土地庙：前山"><a href="#苍狼林-土地庙：前山" class="headerlink" title="苍狼林-土地庙：前山"></a>苍狼林-土地庙：前山</h4><div class="note  flat info"><p>豪华版预购玩家记得在土地庙领取豪华版预购奖励（豪华版奖励不纳入相关全收集类成就统计）</p><ul><li>珍玩-风铎：豪华版预购奖励（不纳入全珍玩收集成就统计）</li><li>防具-百戏套装：豪华版预购奖励</li><li>葫芦-争先红葫芦：豪华版预购奖励，后面也能获得</li></ul></div><p>抵达该土地庙触发过场后获得可无限次使用的“缩地青符”，可立即返回上一次互动过的土地庙&#x2F;区域起点</p><p>泡酒物-青山骨：流程中许多地方都有的甘草采摘概率获得<br>泡酒物-铁骨银参：流程中许多地方都有的人参采摘概率获得<br>要紧物事-色蕴：牯护院BOSS战场地之前，可以看到一个鬼鬼祟祟逃窜的妖怪之位置的石佛头</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240908154139219.png"></p><p>BOSS-牯护院：必经流程<br>1号位法术-定身法：牯护院BOSS战期间学到<br>打坐蒲团：牯护院BOSS战场地后沿路上山路右侧亭中</p><h4 id="苍狼林-土地庙：林外"><a href="#苍狼林-土地庙：林外" class="headerlink" title="苍狼林-土地庙：林外"></a>苍狼林-土地庙：林外</h4><p>泡酒物-嫩碧藕：全游戏许多场景都有的水上莲藕采集概率获得<br>BOSS-广智：从土地庙“林外”出发后朝左前方前进，有火炬的路口内<br>4号位法术-赤潮：广智BOSS战奖励<br>敲钟1&#x2F;3：BOSS广智所在场地<br>BOSS-幽魂：必经流程（从土地庙“林外”出发后朝右前方前进）<br>珍玩-猫睛宝串：幽魂BOSS战奖励<br>精魄-幽魂：<strong>现在还无法获取</strong>请忽略，很快就可补获得</p><h4 id="苍狼林-土地庙：观音禅院"><a href="#苍狼林-土地庙：观音禅院" class="headerlink" title="苍狼林-土地庙：观音禅院"></a>苍狼林-土地庙：观音禅院</h4><div class="note  flat success"><p>▶成就02：穿一件披挂，抵达土地庙“观音禅院”后解锁铸造功能</p></div><p>防具-行者套装：抵达土地庙“观音禅院”后解锁防具铸造功能的同时解锁配方<br>BOSS-灵虚子：必经流程</p><div class="note  flat success"><p>▶成就03：击败BOSS灵虚子</p></div><p>头冠-白脸子：灵虚子BOSS战奖励<br>碧藕金丹：灵虚子BOSS战场地继续前进进入下一个建筑时的左侧香炉内</p><h4 id="翠竹林-土地庙：后山"><a href="#翠竹林-土地庙：后山" class="headerlink" title="翠竹林-土地庙：后山"></a>翠竹林-土地庙：后山</h4><p>NPC-午马：从土地庙“后山”继续出发抵达水池时，走向左掉头的岔路进洞，对话至重复<br>打坐蒲团：从土地庙“后山”继续出发抵达水池时，走向左掉头的岔路进入洞内</p><h4 id="翠竹林-土地庙：蛇径"><a href="#翠竹林-土地庙：蛇径" class="headerlink" title="翠竹林-土地庙：蛇径"></a>翠竹林-土地庙：蛇径</h4><p>NPC-葫芦仙人：从土地庙“蛇径”出发上楼梯后岔路右拐（前面的精魄-幽魂，土地庙点击“拾遗”补齐）<br>BOSS-波里个浪：从土地庙“蛇径”出发上楼梯后岔路左拐是正确路线，抵达河边时向右下河掉头直行<br>精魄-波里个浪：波里个浪BOSS战奖励</p><div class="note  flat success"><p>▶成就04：初次用葫芦吸收精魄，按顺序最早接触的便是波里个浪的精魄</p></div><p>BOSS-广谋：必经流程<br>精魄-广谋：广谋BOSS战奖励<br>敲钟2&#x2F;3：广谋BOSS战场地一处向上的路口尽头，易错过</p><h4 id="翠竹林-土地庙：白雾泽"><a href="#翠竹林-土地庙：白雾泽" class="headerlink" title="翠竹林-土地庙：白雾泽"></a>翠竹林-土地庙：白雾泽</h4><p>落伽香藤：就在土地庙“白雾泽”不远处<br>泡酒物-胆中珠：从土地庙“白雾泽”出发，击杀栈桥上的蛇妖救出申猴获得<br>NPC-申猴：从土地庙“白雾泽”出发，击杀栈桥上的蛇妖将其救出，至此作为商人NPC呆在旁边洞内（除了交易商品外，该NPC还提供消耗落伽香藤、三冬虫强化葫芦等级和恢复量的功能）</p><div class="note  flat success"><p>▶成就05：为葫芦装配泡酒物，按顺序最早接触的便是解救NPC申猴时获得的胆中珠</p></div><p>泡酒物-瑶池莲子：NPC申猴出售<br>BOSS-白衣秀士：必经流程（有两管血条对应二阶段）<br>防具-锦鳞套装：击败BOSS白衣秀士后解锁配方</p><div class="note  flat success"><p>▶成就06：击败BOSS白衣秀士<br>▶成就07：初次强化武器（击败白衣秀士后解锁兵器铸造功能，比如初始的柳木棍）</p></div><p>敲钟3&#x2F;3：白衣秀士BOSS战场地，面向继续前进的门拱，左侧岔路的尽头</p><div class="note  flat success"><p>▶成就08：在第一话中敲响三处钟（三处钟均被敲过后，立即自动跳转至旧观音禅院场景）</p></div><h4 id="隐-土地庙：旧观音禅院"><a href="#隐-土地庙：旧观音禅院" class="headerlink" title="隐-土地庙：旧观音禅院"></a>隐-土地庙：旧观音禅院</h4><p>臂甲-南海念珠：就在土地庙“旧观音禅院”所在院内开箱获得<br>BOSS-金池长老：土地庙“旧观音禅院”继续前进（攻略后自动离开该场景）</p><div class="note  flat success"><p>▶成就09：击败BOSS金池长老</p></div><p>防具-青铜套装：击败BOSS金池长老后解锁配方<br>法宝-辟火罩：金池长老BOSS战后自动返回的位置，旁边悬挂的妖尸处<br>打坐蒲团：从白衣秀士BOSS战场地继续出发进洞，出洞后左侧平台<br>太乙紫金丹：从白衣秀士BOSS战场地继续出发进洞，出洞后左侧平台</p><h4 id="黑风洞-土地庙：洞内"><a href="#黑风洞-土地庙：洞内" class="headerlink" title="黑风洞-土地庙：洞内"></a>黑风洞-土地庙：洞内</h4><p>BOSS-黑风大王：必经流程<br>2号位法术-聚形散气：黑风大王BOSS战奖励<br>三冬虫：黑风大王BOSS战场地角落一个发光的罐子内，打破它以获得<br>珍玩-玛瑙罐：黑风大王BOSS战场地继续往前走一点距离，左侧香炉内</p><h4 id="黑风洞-土地庙：洞外"><a href="#黑风洞-土地庙：洞外" class="headerlink" title="黑风洞-土地庙：洞外"></a>黑风洞-土地庙：洞外</h4><p>精魄-狼刺客：从土地庙“洞外”出发沿木桥走，向观察可看到低处一个有宝箱的平台，击杀该处的狼妖<br>九转金丹：从土地庙“洞外”出发的必经之路上</p><h4 id="黑风洞-土地庙：见谛峰"><a href="#黑风洞-土地庙：见谛峰" class="headerlink" title="黑风洞-土地庙：见谛峰"></a>黑风洞-土地庙：见谛峰</h4><p>BOSS-黑熊精：必经流程</p><div class="note  flat success"><p>▶成就10：击败BOSS黑熊精</p></div><p>防具-乌金套装：击败BOSS黑熊精解锁配方<br>武器-兽棍•熊罴：击败BOSS黑熊精解锁配方<br>珍玩-不求人：完成第一话后，在第一话的土地庙中购买<br>根器-眼看喜：第一话完成奖励</p><h3 id="第二话：黄风岭（对应成就11-23）"><a href="#第二话：黄风岭（对应成就11-23）" class="headerlink" title="第二话：黄风岭（对应成就11-23）"></a>第二话：黄风岭（对应成就11-23）</h3><h4 id="沙门村-土地庙：村口"><a href="#沙门村-土地庙：村口" class="headerlink" title="沙门村-土地庙：村口"></a>沙门村-土地庙：村口</h4><p>酒-羔儿酿：从土地庙“村口”原路返回最开始的区域，水域中木桥处沿路上山至尽头<br>NPC-戌狗：从土地庙“村口”出发的木桥跳到下侧的路，下行进洞（击败浪里个波后与它再对话）<br>打坐蒲团：从土地庙“村口”出发的木桥跳到下侧的路，下坡直行出洞后不跳下而是左拐亭子处<br>BOSS-浪里个波：从土地庙“村口”出发的木桥跳到下侧的路，下坡直行出洞后跳到底层<br>丹方-避凶药：击败BOSS浪里个波后再回头与NPC戌狗对话获得（同时解锁炼丹功能）</p><div class="note  flat success"><p>▶成就11：初次炼丹</p></div><div class="note  flat warning"><p><em>从土地庙“村口”出发过木桥后面前大门锁着，向右走绕到右后方有几个紫色大鼠妖的场地，该场地的右侧门是正确路线——<strong>建议最后打开</strong></em></p></div><p>泡酒物-梭罗琼芽：抵达有几个紫色大鼠妖的场地，右侧佛像处<br>BOSS-地狼：有几个紫色大鼠妖的场地，向左绕，进入一个有池塘的大院（或登上房顶后跳下）<br>NPC-无名氏：有几个紫色大鼠妖的场地直行上山坡往左侧走，后方一处房屋，对话至重复</p><div class="note  flat info"><p>这里建议先打地狼再去跟鼠国国民对话，触发三王子相关对话，对话至重复（涉及到第三回）</p></div><p>精魄-地狼：地狼BOSS战奖励<br>NPC-午马：地狼BOSS战场地一角的亭子处，对话至重复<br>精魄-鼠弩手：地狼BOSS战场地，打开通往土地庙“村口”的捷径木门后出现的鼠弩手（冒蓝光的）<br>BOSS-沙国王父子：必经流程，<strong>击杀小体型的父亲与否对剧情只有细微影响，建议尝试击杀父亲再击杀儿子——如果让父亲逃跑就少拿一个精魄“沙二郎”</strong><br>精魄-沙二郎：先杀了小体型的父亲才有，沙国王父子BOSS战奖励<br>要紧物事-一块血肉：先杀了小体型的父亲才有，沙国王父子BOSS战奖励</p><div class="note  flat warning"><p><em>沙国王父子BOSS战后是分支地图，有一个打不开的大门（缺石之厉、虎之锋），左侧是土地庙“不济谷”<strong>可以先开一下</strong>，右侧过桥是挟魂崖区域——<strong>本指南建议先走挟魂崖！</strong></em></p></div><h4 id="挟魂崖-土地庙：藏风山凹"><a href="#挟魂崖-土地庙：藏风山凹" class="headerlink" title="挟魂崖-土地庙：藏风山凹"></a>挟魂崖-土地庙：藏风山凹</h4><p>要紧物事-佛目珠1&#x2F;6：土地庙“藏风山凹”原路返回没多远的佛头处（冒黄光）<br>要紧物事-佛目珠2&#x2F;6：面对土地庙“藏风山凹”，右侧区域贴左侧前进找到<br>要紧物事-佛目珠3&#x2F;6：面对土地庙“藏风山凹”，右侧区域对面木楼梯沿路上去尽头找到<br>NPC-石中人：面对土地庙“藏风山凹”，右侧区域中央低沟尽头（击败石母后与它再对话）<br>要紧物事-佛目珠4&#x2F;6：面对土地庙“藏风山凹”，左转直行通过小型拱门后，直走到底左转找到<br><strong>精魄-石双双：面对土地庙“藏风山凹”，左转直行通过小型拱门后，直走到底右转，不出洞（出洞就是下一个土地庙）而向左上去，击杀冒蓝光的石妖（如果先行继续前进击杀BOSS石母则将错过！）</strong><br>BOSS-石母：面对土地庙“藏风山凹”，左转直行通过小型拱门后，直走到底右转，不出洞（出洞就是下一个土地庙）而向左上去<br>要紧物事-石之精魄：石母BOSS战奖励（带去给NPC石中妖）<br>要紧物事-佛目珠5&#x2F;6：石母BOSS战场地继续走到尽头<br>4号位法术-碧尘：将石之精魄带给NPC石中人后，攻击并击败它后再与之对话获得（坐火刷新后它将作为一个商人NPC呆在这里）</p><div class="note  flat success"><p>▶成就14：击败BOSS石中人</p></div><p>泡酒物-铁弹：NPC石中人出售<br>珍玩-金花玉萼：NPC石中人出售<br>要紧物事-醒酒石：NPC石中人出售 <strong>（必买）</strong></p><h4 id="挟魂崖-土地庙：枕石坪"><a href="#挟魂崖-土地庙：枕石坪" class="headerlink" title="挟魂崖-土地庙：枕石坪"></a>挟魂崖-土地庙：枕石坪</h4><p>精魄-骨悚然：面对土地庙“枕石坪”，向右上楼梯击败骨悚然（继续走有流沙阻拦）<br>NPC-黄袍员外：土地庙“枕石坪”所在区域向前直行抵达下一个开阔地带，给它醒酒石并对话至重复</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827231803493.png"></p><p>打坐蒲团：土地庙“枕石坪”所在区域向前直行抵达下一个开阔地带悬崖边树下<br>要紧物事-佛目珠6&#x2F;6：土地庙“枕石坪”所在区域贴左侧前进可看到<br>BOSS-石敢当&amp;石先锋：集齐6颗佛目珠后，土地庙“枕石坪”所在区域贴左侧前进，穿过左侧大拱门并对面前的深色大石头互动，触发BOSS对打（没这么做的话则是单挑石先锋）</p><div class="note  flat success"><p>▶成就16：击败石先锋<br>▶成就17：击败石敢当</p></div><p>要紧物事-石之厉：石先锋BOSS战奖励<br>要紧物事-受蕴：石敢当BOSS战奖励<br>武器-出云棍：击败BOSS石先锋解锁配方<br>防具-藏风套装：击败BOSS石先锋解锁配方</p><h4 id="挟魂崖-土地庙：碎石台"><a href="#挟魂崖-土地庙：碎石台" class="headerlink" title="挟魂崖-土地庙：碎石台"></a>挟魂崖-土地庙：碎石台</h4><p>太乙紫金丹：从土地庙“碎石台”出发，右侧有火盆的路口，右侧香炉内<br>精魄-鼠司空：从土地庙“碎石台”出发直走到底击杀鼠司空<br>打坐蒲团：从土地庙“碎石台”出发直走到底<br>3号位法术-身外身法：滑坡到底接近下一个土地庙时触发过场获得</p><h4 id="黄风阵-土地庙：镇风门"><a href="#黄风阵-土地庙：镇风门" class="headerlink" title="黄风阵-土地庙：镇风门"></a>黄风阵-土地庙：镇风门</h4><div class="note  flat warning"><p><em>该土地庙旁的门就是本话BOSS门，最后开</em></p></div><p>BOSS-百目真人：从土地庙“镇风门”继续出发没多远，左侧角落，正看着落伽香藤<br>精魄-百目真人：从土地庙“镇风门”继续出发没多远，击杀左侧看着落伽香藤的BOSS百目真人<br>落伽香藤：从土地庙“镇风门”继续出发没多远，击杀左侧看着落伽香藤的BOSS百目真人后获得</p><div class="note  flat warning"><p><em>从土地庙“镇风门”继续出发直走的门，就是先前要石之厉、虎之锋而打不开的大门；过桥后向右有个岔路可以进去，进门通往沙大郎BOSS战斗场地，但进门先往左拐就能看到先前开过的土地庙“不济谷”。</em></p></div><h4 id="沙门村-土地庙：不济谷"><a href="#沙门村-土地庙：不济谷" class="headerlink" title="沙门村-土地庙：不济谷"></a>沙门村-土地庙：不济谷</h4><p>三冬虫：在沙大郎BOSS战场地高处可看到被木板隔断的发光罐子，跳到低处掉头进路口到尽头获得（使用戳棍可以直接打碎缸获得三冬虫 立棍重击也可以）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240826194950.png"></p><p>要紧物事-飞龙鳞片：在沙大郎BOSS战场地有一面深色佛像墙，勾引BOSS沙大郎去破坏它可出现裂缝（用精魄“幽魂”、石粼粼变身消失时的后倒、四段棍势的劈棍也可以破坏），裂缝后开宝箱获得</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240826195939093.png"></p><p>BOSS-沙大郎：必经流程（先前与沙国王父子BOSS战期间杀死了父亲，就是用“一块血肉”吸引出）</p><div class="note  flat success"><p>▶成就12：击杀沙大郎</p></div><p>要紧物事-阿罗金片：沙大郎BOSS战奖励</p><br><p>BOSS-赤髯龙：获得飞龙鳞片后，从 <strong>黑风山 - “林外”</strong> 出发贴左侧前进到尽头，穿过瀑布</p><div class="note  flat success"><p>▶成就13：击杀赤髯龙</p></div><p>珍玩-博山炉：赤髯龙BOSS战场地开宝箱获得<br>BOSS-小骊龙：获得飞龙鳞片后，从 <strong>黄风岭 - 挟魂崖“枕石坪”</strong> 出发向右上楼梯穿过流沙</p><div class="note  flat success"><p>▶成就15：击杀小骊龙</p></div><p>珍玩-砗磲佩：小骊龙BOSS战场地右侧上楼梯，高处宝箱内</p><p>武器-鳞棍•蟠龙：击败BOSS小骊龙、赤髯龙任意一只即可解锁配方（但本武器要将小骊龙和赤髯龙都击败才能制作)</p><br><p>回到沙门村“不济谷”</p><p>精魄-疾蝠：从沙大郎BOSS战场地走另一条通往狭缝的路（去卧虎寺），穿过狭缝后击败疾蝠<br>九转金丹：从沙大郎BOSS战场穿过去卧虎寺的狭缝后，直行（破坏障碍）进去的尽头香炉内</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240826195638781.png" alt="狭缝"></p><h4 id="卧虎寺-土地庙：寺门"><a href="#卧虎寺-土地庙：寺门" class="headerlink" title="卧虎寺-土地庙：寺门"></a>卧虎寺-土地庙：寺门</h4><p>打坐蒲团：从土地庙“寺门”出发上楼梯不进门，门前左拐<br>NPC-黄袍员外：从土地庙“寺门”出发上楼梯不进门，门前右拐，交付碧藕，对话至重复</p><div class="note  simple"><p>后续流程是在第一次遇到它的位置触发战斗，并开启隐藏地图“斯哈哩国”，这里先打BOSS</p></div><p>BOSS-虎先锋：必经流程<br>2号位法术-铜头铁臂：虎先锋BOSS战奖励<br>头冠-白脸子：虎先锋BOSS战奖励<br><em>与虎先锋BOSS战场地无头雕像下方机关互动，打开血池中的地窖入口</em><br>碧藕金丹：跳入地窖入口后的前进路上，左侧香炉<br>精魄-狸侍长：跳入地窖入口后的前进路上，击败冒蓝光的狸侍长（5个怪打我1个这河里吗。。。。）<br>泡酒物-虎舍利：跳入地窖入口后前进，向下滑行的位置，可看到前方平台的香炉，滑到一半借助跳跃+重攻击登上</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240826234401410.png"></p><h4 id="卧虎寺-土地庙：地窖"><a href="#卧虎寺-土地庙：地窖" class="headerlink" title="卧虎寺-土地庙：地窖"></a>卧虎寺-土地庙：地窖</h4><p>NPC-戌狗：土地庙“地窖”旁，与之对话，解锁仙炉功能（可以炼一些永久强化角色各种性能的药；之后它会作为商人一直呆在这里）</p><div class="note  flat success"><p>▶成就22：解锁仙炉功能</p></div><p>丹方-延寿膏：NPC戌狗出售</p><h4 id="黄风阵-土地庙：定风桥"><a href="#黄风阵-土地庙：定风桥" class="headerlink" title="黄风阵-土地庙：定风桥"></a>黄风阵-土地庙：定风桥</h4><div class="note  flat info"><p><em>从虎先锋BOSS战场地向无头雕像后方是继续前进的路线</em>（tp至卧虎寺“寺门”）</p></div><p>泡酒物-铜丸：从虎先锋BOSS战场地向无头雕像后方往前走，有两个怪的地方</p><p>醒酒石&#x2F;登仙散：从土地庙“定风桥”继续前进，过桥后左前方院内发光罐子（如果之前在石中人买了醒酒石，这里会变成登仙散）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827221502588.png"></p><p>精魄-鼠禁卫：从土地庙“定风桥”继续前进，过桥后中间道路前进，击杀其中一只从高处跳下的冒蓝光的红袍鼠禁卫<br>落伽香藤：从土地庙“定风桥”继续前进，开门后右侧</p><h4 id="黄风阵-土地庙：定风庄"><a href="#黄风阵-土地庙：定风庄" class="headerlink" title="黄风阵-土地庙：定风庄"></a>黄风阵-土地庙：定风庄</h4><p>BOSS-虎伥：从土地庙“定风庄”继续前进的桥上<br>精魄-虎伥：虎伥BOSS战奖励<br>要紧物事-旧拨浪鼓：虎伥BOSS战奖励<br>珍玩-琉璃舍利瓶：虎伥BOSS战场地后走一段 洞内开箱</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827224831785.png"></p><h4 id="沙门村-土地庙：井底"><a href="#沙门村-土地庙：井底" class="headerlink" title="沙门村-土地庙：井底"></a>沙门村-土地庙：井底</h4><p>建议每个土地庙都看下商店和铸造有没有新货</p><p>BOSS-疯虎：获得旧拨浪鼓后可开启支线，①从土地庙“定风庄”往回走，进大门后左拐进院摇拨浪鼓；②传送至土地庙“镇风门”，过桥打个盾哥后，面对楼梯，左拐进院子摇拨浪鼓；③tp到沙门村“村口”，之前在沙门村大院遇到NPC午马的亭子后方角落摇拨浪鼓，最后跳入井里就可以触发该BOSS战</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827225411106.png" alt="摇拨浪鼓①"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827230102392.png" alt="摇拨浪鼓②"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827230514534.png" alt="摇拨浪鼓③"></p><div class="note  flat success"><p>▶成就18：击杀疯虎</p></div><p>精魄-疯虎：疯虎BOSS战奖励<br>葫芦-五鬼葫芦：疯虎BOSS战场地开箱获得</p><h4 id="隐-土地庙：沙门关"><a href="#隐-土地庙：沙门关" class="headerlink" title="隐-土地庙：沙门关"></a>隐-土地庙：沙门关</h4><p>BOSS-黄袍员外：从土地庙“枕石坪”出发回到第一次遇到NPC黄袍员外的位置的右手边触发</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240827232016115.png"></p><div class="note  flat success"><p>▶成就19：击败BOSS黄袍员外后，进入斯哈里国</p></div><p>BOSS-虎先锋：从土地庙“沙门关”继续前进，战斗后与之对话至重复<br>珍玩-虎头牌：斯哈哩国区域的虎先锋BOSS战奖励</p><div class="note  flat success"><p>▶成就20：击杀卧虎寺、沙门村井底、斯哈里国的三只虎先锋</p></div><h4 id="隐-土地庙：沙门界"><a href="#隐-土地庙：沙门界" class="headerlink" title="隐-土地庙：沙门界"></a>隐-土地庙：沙门界</h4><p>虚空结：虎先锋BOSS战场地继续前进后贴左侧前进，左侧一处建筑废墟内宝箱<br>打坐蒲团：虎先锋BOSS战场地继续前进后贴左侧抵达尽头<br>BOSS-蝜蝂：与场地中央高处的鼠妖对话触发</p><div class="note  flat success"><p>▶成就21：击杀蝜蝂</p></div><p>法宝-定风珠：蝜蝂BOSS战奖励<br>防具-昆蚑套装：击败BOSS蝜蝂解锁配方</p><h4 id="黄风阵-黄风大圣"><a href="#黄风阵-黄风大圣" class="headerlink" title="黄风阵-黄风大圣"></a>黄风阵-黄风大圣</h4><p>tp至黄风阵“镇风门”</p><p>打坐蒲团：打开土地庙“镇风门”旁边的门，下坡后左拐掉头到尽头<br>NPC-葫芦仙人：打开土地庙“镇风门”旁边的门，下坡后左拐掉头到尽头，对话至重复<br>BOSS-黄风大圣：必经流程</p><div class="note  flat success"><p>▶成就23：击败黄风大圣</p></div><p>武器-兽棍•貂鼠：击败BOSS黄风大圣解锁配方<br>防具-赭黄套装：击败BOSS黄风大圣解锁配方<br>根器-耳听怒：第二话完成奖励</p><h3 id="第三话：小西天（对应成就24-38）"><a href="#第三话：小西天（对应成就24-38）" class="headerlink" title="第三话：小西天（对应成就24-38）"></a>第三话：小西天（对应成就24-38）</h3><h4 id="雪山径-土地庙：披霜道"><a href="#雪山径-土地庙：披霜道" class="headerlink" title="雪山径-土地庙：披霜道"></a>雪山径-土地庙：披霜道</h4><p>珍玩-摩尼珠：本话中许多场景都有分布的假装雕像的敌怪概率掉掉，浮屠界也有<br>BOSS-赤尻马猴：必经流程（打掉大半血会逃跑，无法击杀，击杀也会出发逃跑特效）<br>精魄-巡山鬼：从土地庙“披霜道”出发沿路过门后立即左转上楼梯，直行到底击败冒蓝光的巡山鬼（大量装死小怪注意）</p><h4 id="雪山径-土地庙：照鉴湖"><a href="#雪山径-土地庙：照鉴湖" class="headerlink" title="雪山径-土地庙：照鉴湖"></a>雪山径-土地庙：照鉴湖</h4><p>打坐蒲团：土地庙“照鉴湖”左斜前方湖岸边树下<br>BOSS-亢金龙：必经流程（击败后自动前往浮屠界场景）<br>武器-鳞棍•亢金：击败BOSS亢金龙后解锁配方<br>酒食-困龙须：亢金龙BOSS战场地后方一处岸边的香炉</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240828213719.png"></p><h4 id="浮屠界-土地庙：下层"><a href="#浮屠界-土地庙：下层" class="headerlink" title="浮屠界-土地庙：下层"></a>浮屠界-土地庙：下层</h4><p><strong>珍玩-吉祥灯：浮屠界土地庙“下层”至“轮藏”前的路线，期间有9个掌灯御史（红眼状态下才可见，第一层四只（tp点前两只，tp点后两只），第三层四只且有一只在最尽头牢内，第九只参考土地庙“轮藏”的第一项），全部击杀获得（但是如果先行击杀BOSS魔将•妙音，剩余未被击杀的掌灯御史会消失！）</strong></p><p>珍玩-细磁茶盂：从土地庙“下层”出发沿路推进到尽头，继续前进是上楼梯，在楼梯下开箱获得</p><div class="note  flat info"><p><em>监狱里的独木桥尽量都隐身过以及小心别摔下去了，别问为什么（</em></p></div><h4 id="浮屠界-土地庙：上层"><a href="#浮屠界-土地庙：上层" class="headerlink" title="浮屠界-土地庙：上层"></a>浮屠界-土地庙：上层</h4><p>掌灯御史：第三层tp点后一只，过独木桥后两只，尽头一牢里面一只</p><p>精魄-菇男：从土地庙“上层”继续出发，过窄木桥后，采集左侧牢房内草药触发草药妖怪，将之击杀<br>BOSS-魔将•莲眼：在土地庙“上层”往回走一点点的坑内（击败后先前见过的紫色封印就能通行了）</p><div class="note  simple info"><p>参考攻略：<a href="https://www.bilibili.com/video/BV1MJWCepEAd/?t=231.910729&spm_id_from=333.1350.jump_directly&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">魔将莲眼定番逃课 无操作门槛的定番击杀 简单好学一看就懂 黑神话悟空_单机游戏热门视频 (bilibili.com)</a><br>可以等打完魔界•妙音再来打（</p></div><p>要紧物事-神魂•四将：魔将•莲眼BOSS战奖励<br>珍玩-耐雪枝：魔将•莲眼BOSS战奖励</p><p>精魄-夜叉奴：击败BOSS魔将•莲眼后，在其BOSS战场地离开（回到二层木桥边）后向左第一个牢门打开后击杀冒蓝光的夜叉奴（别忘了旁边的玲珑内丹）<br>NPC-小张太子：击败BOSS魔将•莲眼后，最初抵达浮屠界所在牢房的隔壁牢房内，对话至重复（在本话中击败四位魔将后再回来与其对话）<br>4号位法术-灰蛰：在黄风岭与NPC无名氏对话过才能触发，击败BOSS魔将•莲眼后，最初抵达浮屠界所在牢房的隔壁牢房内，与沙国三王子尸体互动拔刀（如果没有该尸体，可以去该牢房正上方的二楼牢房杀死一只双头鼠妖获得该法术，同样解锁对应的成就24）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240829232851147.png"></p><div class="note  flat info"><p>如果第二章和鼠国村民对过话触发了三王子任务的话，这个鼠督尉尸体会出现在一层三王子房间里（它来小西天找到了三王子并且保护三王子死掉了）<br>如果第二章没有对话，那房间里只有三王子，去完成收集任务再返回第二回的黄风岭和村民对话再回来，房间里三王子走了，会听到鼠督尉说没有找到三王子的声音，然后再去第二层角落<br>个人实测第二回先对话再打地狼（然后没再去对话），到这里没发现尸体，然后回去对话再回来就出现尸体，仅供参考</p></div><div class="note  flat success"><p>▶成就24：获得4号位法术“灰蛰”，见证三王子的结局</p></div><h4 id="浮屠界-土地庙：轮藏"><a href="#浮屠界-土地庙：轮藏" class="headerlink" title="浮屠界-土地庙：轮藏"></a>浮屠界-土地庙：轮藏</h4><p>小心第四层刚上去的这里↓（接近这里就自动跳下去摔死</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/origin_11591581_920136.jpg"></p><p>掌灯狱史、精魄-戒刀僧、三冬虫：从<strong>背对</strong>轮藏土地庙的左手边直走到头（从楼梯上来的右手边），跳下去地上有个圆形小坛会出现一只隼居士，从此处继续向右前方可下落至之前无法到达的区域，此区域有一只<strong>掌灯狱使</strong>，还有一直蓝火精英<strong>戒刀僧</strong>，附近还有一个<strong>三冬虫</strong>，在发光的罐子里</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240830231553.png"></p><p>BOSS-魔界•妙音：必经流程</p><div class="note  flat success"><p>▶成就25：击杀魔界•妙音</p></div><p>要紧物事-神魂•一将：魔将•妙音BOSS战奖励</p><h4 id="浮屠界-土地庙：经筒外"><a href="#浮屠界-土地庙：经筒外" class="headerlink" title="浮屠界-土地庙：经筒外"></a>浮屠界-土地庙：经筒外</h4><p>落伽香藤：土地庙“经筒外”继续出发的水池处<br>太乙紫金丹：土地庙“经筒外”继续前进路上右侧香炉内<br>打坐蒲团：土地庙“经筒外”继续前进路上看到右侧香炉桌（有太乙紫金丹），打破其后方栅栏抵达尽头</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240830235737662.png"></p><h4 id="浮屠界-土地庙：冲寒道"><a href="#浮屠界-土地庙：冲寒道" class="headerlink" title="浮屠界-土地庙：冲寒道"></a>浮屠界-土地庙：冲寒道</h4><div class="note  simple"><p><em>该土地庙出发下坡到尽头穿过雾门可抵达土地庙“浮屠塔”</em>，可以先去把土地庙开了</p></div><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/origin_10961999_902513.jpg"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240831001639128.png" alt="土地庙“浮屠塔”"></p><p>精魄-隼居士-从土地庙“冲寒道”出发上坡后朝左前方一路前进遇到的其中一只隼居士，将其击杀获得<br>虚空结-从土地庙“冲寒道”出发上坡后朝左前方一路前进，过桥后开箱</p><h4 id="浮屠界-土地庙：安身寺"><a href="#浮屠界-土地庙：安身寺" class="headerlink" title="浮屠界-土地庙：安身寺"></a>浮屠界-土地庙：安身寺</h4><p>BOSS-赤尻马猴：必经流程（这次打完依然会逃跑）<br>1号位法术-安身法：安身寺的赤尻马猴BOSS战奖励</p><h4 id="苦海-土地庙：龟岛"><a href="#苦海-土地庙：龟岛" class="headerlink" title="苦海-土地庙：龟岛"></a>苦海-土地庙：龟岛</h4><div class="note  flat warning"><p><em>该场地有特殊性，建议先确保激活该土地庙后再跟进主线剧情离开龟岛</em></p></div><p>BOSS-亢金星君：必经流程</p><div class="note  flat success"><p>▶成就26：击败亢金星君</p></div><p>防具-龙鳞套装：亢金星君BOSS战奖励</p><div class="note  simple"><p><em>在击败BOSS亢金星君后，可以回到土地庙“安身寺”，重新继续前进，滑下雪坡后解锁土地庙“苦海南岸”，但这个地方没什么可探索的内容</em></p></div><p>碧藕金丹：土地庙“龟岛”左后方低处香炉<br>BOSS-青背龙：土地庙“龟岛”后方低处（钓鱼者）</p><div class="note  flat success"><p>▶成就27：击败青背龙</p></div><p>武器-飞龙宝杖：击败BOSS青背龙、小黄龙任意一只即可解锁配方（但本武器要将青背龙和小黄龙都击败才能制作）</p><h4 id="苦海-土地庙：苦海北岸"><a href="#苦海-土地庙：苦海北岸" class="headerlink" title="苦海-土地庙：苦海北岸"></a>苦海-土地庙：苦海北岸</h4><p><em><strong>激活该土地庙后，强烈建议第一件事就是去打BOSS无量蝠，以防错过</strong></em><br>落伽香藤：面对土地庙“苦海北岸”朝右，朝远处蛇骨前进，走左侧岔路<br>BOSS-无量蝠：面对土地庙“苦海北岸”朝右，朝远处蛇骨前进，蛇骨的头骨处互动（据说必须要猪八戒跟随时才能触发BOSS战）<br>泡酒物-龟泪：与蛇骨的头骨互动后，再返回龟将正下方发绿光处拾取</p><div class="note  flat success"><p>▶成就28：了解蛇将的下落，获取泡酒物“龟泪”</p></div><p>BOSS-辰龙：背对土地庙“苦海北岸”向下出发，沿海边向右走没多远看到（先触发BOSS战，然后与之对话，再去黄风岭卧虎寺“地窖”旁与NPC戌狗对话选择“招呼”后获得药）<br>丹方-坚骨药：与NPC辰龙接到丹药需求后，去黄风岭的土地庙与NPC戌狗互动<br>NPC-寻宝小生：背对土地庙“苦海北岸”向下沿海边向右出发，第一个可以向右的路口走到一栋建筑下，杀怪帮其脱困<br>酒-蓝桥风月：背对土地庙“苦海北岸”向下沿海边向右出发，第一个可以向右的路口走到一栋建筑左后方池塘的小舟<br>NPC-辰龙：背对土地庙“苦海北岸”向下沿海边向右出发，沿海边走到尽头屋外，交付丹药解锁如意画轴</p><div class="note  flat success"><p>▶成就29：解锁如意画轴</p></div><h4 id="六六村-土地庙：村口"><a href="#六六村-土地庙：村口" class="headerlink" title="六六村-土地庙：村口"></a>六六村-土地庙：村口</h4><div class="note  simple"><p><em>“如意画轴-六六村”相当于“家园”系统，除了可以找到NPC戌狗（可以定期白嫖丹药）、申猴，还有交付种子就可定期收获草药的NPC辰龙，充当铁匠的寅虎（除了锻造外，还可以给防具升阶、增加可同时佩戴珍品数量）</em></p></div><p>丹方-益气膏：NPC戌狗出售<br>落伽香藤：NPC申猴出售<br>三冬虫：NPC申猴出售<br>葫芦-宝莲玉葫芦：NPC申猴出售<br>泡酒物-霹雳角：NPC申猴出售<br>法术-乌川：向NPC寅虎发起挑战获胜奖励（同时奖励一次珍玩槽上限提升，与之对话解锁）<br>防具-玄铁套装：向NPC寅虎发起挑战获胜解锁配方</p><div class="note  flat success"><p>▶成就30：初次使用NPC寅虎的防具升阶功能<br>▶成就31：向NPC寅虎发起挑战并获胜<br>▶成就32：初次在NPC辰龙处收获草药</p></div><h4 id="苦海-土地庙：戒语廊"><a href="#苦海-土地庙：戒语廊" class="headerlink" title="苦海-土地庙：戒语廊"></a>苦海-土地庙：戒语廊</h4><p>打坐蒲团：从土地庙“戒语廊”出发走一点点距离左侧<br>丹方-聚珍伏虎丸：从土地庙“戒语廊”出发直走到尽头的香炉<br>精魄-赤发鬼：从土地庙“戒语廊”出发，一路上楼梯后进院击杀赤发鬼<br><em>接下来的宽阔区域，先去中央亭子与NPC活佛对话，然后向左沿路拜四座佛后再与其对话，最后沿右侧上行楼梯继续前进</em></p><h4 id="极乐谷-土地庙：一念壁"><a href="#极乐谷-土地庙：一念壁" class="headerlink" title="极乐谷-土地庙：一念壁"></a>极乐谷-土地庙：一念壁</h4><p>葫芦-燃葫芦：土地庙“一念壁”右侧跳下，一处室内开箱<br>要紧物事-想蕴：土地庙“一念壁”右侧跳下，继续前进出到室外，可再次看到第一话见过的鬼鬼祟祟逃窜的妖怪，该位置佛头处<br>BOSS-不白：必经剧情，半血逃跑，沿路前进后第二次战斗即可击败<br>珍玩-未来珠：第一次不白BOSS战场地进洞继续前进，必经之路上左侧开箱<br>BOSS-不白：梅开二度，从满血开始打（）<br>精魄-不白：不白BOSS战奖励<br>打坐蒲团：第二次的不白BOSS战场地旁</p><h4 id="极乐谷-土地庙：快活林"><a href="#极乐谷-土地庙：快活林" class="headerlink" title="极乐谷-土地庙：快活林"></a>极乐谷-土地庙：快活林</h4><div class="note  flat warning"><p><em><strong>极乐谷是个很容易迷路的场景，建议按本指南顺序！！！</strong></em></p></div><p>珍玩-铜佛坠：极乐谷区域有分布的拿着圆刃的黄袍小妖概率掉落（如通往土地庙“极乐大道”的红色殿门处，会从上方突然袭击下来两只）<br>珍玩-兽与佛：极乐谷区域有分布的拿着拳刺的红袍小妖概率掉落（如土地庙“罪业塔林”旁石壁下有一只）<br>珍玩-金棕衣：极乐谷与小雷音寺区域有分布的巨妖概率掉落<br>BOSS-浪里个浪：从土地庙“快活林”出发走左后方洞内，出洞遇到<br>NPC-狐妖：土地庙“快活林”前方的小院门下尸体处（获得道具“白狐毫”）（提交后消失，可用于跑图，只能在第三回的地图使用，完成该区域后就交了吧）（目前先不用管，到小雷音寺再继续）</p><h4 id="极乐谷-土地庙：罪业塔林"><a href="#极乐谷-土地庙：罪业塔林" class="headerlink" title="极乐谷-土地庙：罪业塔林"></a>极乐谷-土地庙：罪业塔林</h4><div class="note  simple"><p><em>土地庙“快活林”前方的小院门，进门后左拐进洞后右拐下山到底后向右，激活土地庙“罪业塔林”</em></p></div><p>NPC-翠笠武师：土地庙“罪业塔林”往回走一点就能听到有个NPC坐在枯树处喊冷，对其释放安身法<br>胸甲-山珍蓑衣：土地庙“罪业塔林”往前走到一座方柱，附近的药草是药草妖怪，将其击杀获得<br>精魄-老人参精：土地庙“罪业塔林”往前走到一座方柱，附近的药草是药草妖怪，其中一株可掉落<br>酒-琼浆：土地庙“罪业塔林”往前走到一座方柱，在其背后</p><h4 id="极乐谷-土地庙：无忧涧"><a href="#极乐谷-土地庙：无忧涧" class="headerlink" title="极乐谷-土地庙：无忧涧"></a>极乐谷-土地庙：无忧涧</h4><div class="note  simple"><p><em>土地庙“快活林”前方的小院门，不进院门而是右侧沿路下山过桥，激活土地庙“无忧涧”</em></p></div><p>BOSS-不能：从土地庙“无忧涧”出发，两侧上行的路线都能抵达一座宝塔下的空地<br>精魄-不能：不能BOSS战奖励（注意有两个阶段）<br>精魄-鸦香客：土地庙“无忧涧”处，过石桥右转向下，掉头在池塘中击杀冒蓝光的鸦香客（也可以背对土地庙方向往前跳下）</p><h4 id="极乐谷-土地庙：瓜田"><a href="#极乐谷-土地庙：瓜田" class="headerlink" title="极乐谷-土地庙：瓜田"></a>极乐谷-土地庙：瓜田</h4><div class="note  simple"><p><em>土地庙“无忧涧”处，过石桥右转向下到尽头再一路跳下，可激活土地庙“瓜田”</em></p></div><p>BOSS-翠笠武师：土地庙“瓜田”旁</p><div class="note  flat success"><p>▶成就33：击败翠笠武师</p></div><p>1号位法术-禁字法：翠笠武师BOSS战奖励</p><h4 id="极乐谷-土地庙：长生大道"><a href="#极乐谷-土地庙：长生大道" class="headerlink" title="极乐谷-土地庙：长生大道"></a>极乐谷-土地庙：长生大道</h4><div class="note  simple"><p><em>土地庙“快活林”前方的小院门，进门后沿路上行可激活土地庙“长生大道”</em></p></div><p>珍玩 - 金棕衣：击败焦面魔王（超大巨人）一共2只即可获得<br>三冬虫：从土地庙“长生大道”进大拱门后，向左侧沿路穿过几个小拱门前进，右侧可看到发光罐子（旁边有一个鳖宝，概率会掉一个头冠增加杀敌材料掉落概率（搁这搁这呢））</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240831233715264.png"></p><p>落伽香藤：从土地庙“长生大道”进大拱门后，向左侧沿路一直走到尽头（小心附近的两个怪）<br>要紧物事-神魂•三将：面对土地庙“长生大道”，向正右方直走可在左侧看到其尸身<br>BOSS-魔将•劫波：必经流程，从土地庙“长生大道”出发，向右走去向小雷音寺<br>要紧物事-神魂•二将：魔将•劫波BOSS战奖励<br>武器-楮白枪：收集四位魔将的要紧物事物品后，返回NPC小张太子处对话获得配方</p><div class="note  flat success"><p>▶成就35：收集四位魔将的要紧物事物品并交还给NPC小张太子</p></div><h4 id="小雷音寺-土地庙：寺门"><a href="#小雷音寺-土地庙：寺门" class="headerlink" title="小雷音寺-土地庙：寺门"></a>小雷音寺-土地庙：寺门</h4><div class="note  simple"><p><em>走主路进殿一路直线前进上楼梯即是本话最终BOSS战场地</em></p></div><p>头冠-闭眼禅：小雷音寺许多地方有分布的红衣“盲僧”概率掉落<br>臂甲-金刚护臂：小雷音寺几处泥塑金刚概率掉落<br>珍玩-雷榍：从土地庙”寺门“出发走主路，穿过殿后，正前方高处第二座殿内开箱获得<br>精魄-泥塑金刚：从土地庙”寺门“出发走主路，穿过殿后上楼梯到正前方高处殿外击败泥塑金刚<br>焦面魔王×2：打完泥塑金刚往前走就能看到（顺便能开一下大殿的土地庙）</p><p>NPC-午马：从土地庙”寺门“出发走主路，穿过殿后向左走进殿，右侧楼梯上去遇到，对话至重复，给一个争先红葫芦（预购玩家已经有了，这里就不会送）<br>丹方-轻身散：从土地庙”寺门“出发走主路，穿过殿后向左走进殿，右侧楼梯上去到尽头<br>九转金丹：从土地庙”寺门“出发走主路，穿过殿后向左走进殿，左侧楼梯上去后出到外侧，左侧香炉<br>BOSS-不空：从土地庙”寺门“出发走主路，穿过殿后向左走进殿，右侧楼梯上去，翻到外侧院子后往左前方上坡进殿，要先对其使用道具“白狐毫”才可触发战斗<br>珍玩-白狐毫：击败BOSS不空后，传送至土地庙“快活林”，与院门下尸体处狐妖对话（可以等这块地图清完再回去送，跑图挺快的）</p><div class="note  flat success"><p>▶成就34：击败BOSS不空后，与狐妖对话</p></div><p>泡酒物-甜雪：从土地庙”寺门“出发走主路，穿过殿后向右走进右侧院门（中央一个泥塑金刚）后，右侧高处亭内</p><p>虚空结：从土地庙”寺门“出发，不进主路，<strong>直接右转直走到底进院</strong>，上楼梯后开龟雕像下宝箱<br>BOSS-海上僧：从土地庙”寺门“出发，不进主路，直接右转直走到底进院后，继续前进遇到<br>4号位法术-皓霜：海上僧BOSS战奖励（击败BOSS海上僧后，需要再与其互动）</p><h4 id="小雷音寺-土地庙：大殿"><a href="#小雷音寺-土地庙：大殿" class="headerlink" title="小雷音寺-土地庙：大殿"></a>小雷音寺-土地庙：大殿</h4><p>BOSS-不净：从土地庙“大殿”出发下楼梯左转<br>精魄-不净：不净BOSS战奖励</p><div class="note  flat success"><p>▶成就36：将不白、不能、不空、不净全都击杀</p></div><p>打坐蒲团：不净BOSS战场地</p><p>BOSS-黄眉：必经流程（黄眉BOSS战+赤尻马猴BOSS战+一路无双+二阶段黄眉BOSS战）<br>BOSS-赤尻马猴：必经流程（黄眉BOSS战期间）</p><div class="note  flat success"><p>▶成就37：击败第三话中的三只赤尻马猴<br>▶成就38：击败黄眉</p></div><p>精魄-无量蝠：黄眉BOSS战奖励<br>4号位法术-红眼：黄眉BOSS战奖励<br>防具-金身套装：击败BOSS黄眉后解锁配方<br>武器-狼牙棒：击败BOSS黄眉后解锁配方<br>根器-鼻嗅爱：第三话完成奖励</p><h3 id="第四话：盘丝岭（对应成就39-48）"><a href="#第四话：盘丝岭（对应成就39-48）" class="headerlink" title="第四话：盘丝岭（对应成就39-48）"></a>第四话：盘丝岭（对应成就39-48）</h3><h4 id="六六村-土地庙：村口-1"><a href="#六六村-土地庙：村口-1" class="headerlink" title="六六村-土地庙：村口"></a>六六村-土地庙：村口</h4><p>葫芦-妙仙葫芦：NPC申猴出售（现在还无法购买，需要基本打完第四话）<br>泡酒物-松醪：NPC申猴出售<br>三冬虫：NPC申猴出售<br>落伽香藤：NPC申猴出售<br>丹方-朝元膏：NPC戌狗出售</p><h4 id="兰喜村-土地庙：朱家大院"><a href="#兰喜村-土地庙：朱家大院" class="headerlink" title="兰喜村-土地庙：朱家大院"></a>兰喜村-土地庙：朱家大院</h4><p>虚空结：从土地庙“朱家大院”往回走，过了房桥后左拐走到底，右侧开箱<br>BOSS-二姐：必经流程<br>武器-几丁棍：击败BOSS二姐后解锁配方<br>三冬虫：二姐BOSS战场地右后方屋子里发光罐子<br>碧藕金丹：二姐BOSS战场地后一个院子内香炉</p><h4 id="盘丝洞-土地庙：上层"><a href="#盘丝洞-土地庙：上层" class="headerlink" title="盘丝洞-土地庙：上层"></a>盘丝洞-土地庙：上层</h4><div class="note  simple info"><p><em><strong>整个盘丝洞及后面的黄花观、紫云山区域，一共分布了4只蝎太子精英怪，均击杀涉及成就，它们都在主干道上，不难找<br>另外，盘丝洞场景中可以找到一些茧圆，获取方式是那些随处可见的卵球破坏获得</strong></em></p></div><div class="note  simple"><p><em><strong>正确路线</strong>是面对该土地庙，左侧上楼梯直走</em></p></div><p>珍品-卵中骨：盘丝洞区域大量分布的可破坏卵球概率掉落<br>头冠-长须头面：盘丝洞区域许多位置都有分布的青色虫妖概率掉落<br>珍品-错金银带钩：从土地庙“上层”往回走到尽头开箱<br>泡酒物-血杞子：从土地庙“上层”出发向左侧沿楼梯上行进屋的香炉<br>精魄 - 虫校尉：从土地庙“上层”按正确路线走，靠右直行到底然后左转，一个向右的岔路内冒蓝光的虫校尉</p><h4 id="盘丝洞-土地庙：碎玉池"><a href="#盘丝洞-土地庙：碎玉池" class="headerlink" title="盘丝洞-土地庙：碎玉池"></a>盘丝洞-土地庙：碎玉池</h4><div class="note  flat info"><p><em>先正常推进激活了土地庙“花间桥”后（从虫校尉打完洞口出来右手边走到尽头），再回头解锁这个易错过的土地庙：从土地庙“上层”按正确路线走，遇到岔路时直接从左侧缺口跳下，一路抵达</em></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240901231714621.png" alt="去花间桥"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240901233730772.png" alt="去碎玉池 对面有弓箭手的火盆"></p></div><p>蝎太子1&#x2F;4：前往土地庙“碎玉桥”路上就能遇到<br>打坐蒲团：土地庙“碎玉池”附近的池塘</p><div class="note  flat warning"><p><em>土地庙“碎玉池”附近的BOSS黑手道人有特殊条件下才会掉落的防具，为保险防错过，建议先备份</em></p></div><p>BOSS-黑手道人：土地庙“碎玉池”旁路口进去，打破巨大卵球，后面会再打一次<br>臂甲-下毒手：与BOSS黑手道人战斗期间<strong>打断其背上的手臂</strong>（建议配合法术“定身术”），成功砍断1次会触发其大幅度的趔趄，建议尽可能多砍断背上手臂几次（累计四次）（与第四话主线最终BOSS百眼魔君对应解锁的羽士套装匹配）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20240902000838.png"></p><h4 id="盘丝洞-土地庙：花间桥"><a href="#盘丝洞-土地庙：花间桥" class="headerlink" title="盘丝洞-土地庙：花间桥"></a>盘丝洞-土地庙：花间桥</h4><p>葫芦-湘妃葫芦：从土地庙“花间桥”继续出发，走左侧岔路后进右侧藏宝院开箱<br>加味参势丸：从土地庙“花间桥”继续出发，走左侧岔路后进右侧藏宝院开箱<br>泡酒物-紫纹缃核：从土地庙“花间桥”继续出发，走左侧岔路后进右侧藏宝院开箱<br>BOSS-琴螂仙：从土地庙“花间桥”继续出发，走左侧岔路后穿过右侧藏宝院<br>要紧物事-琴螂原体：琴螂仙BOSS战奖励<br>精魄-琴螂仙：获得琴螂原体后，将它交给NPC辰龙研究，提供收获草药功能的草药篮右后方会多一个装毛毛虫的篮子，后续累计喂养三次后获得，每次需要喂1份茧圆（可以攒齐茧圆后一次性反复坐火调息喂养）</p><div class="note  simple"><p><em>考虑到避免赘述，先介绍“院子”的位置，从土地庙“花间桥”继续出发，走左侧岔路后，不进右侧院门而走左侧路口下去，穿过吊袋蛛群后走左侧岔路可抵达这个院子；或者从土地庙“花间桥”继续出发，走右侧岔路尽头跳下去后靠左上坡（右侧路线通往土地庙“千红窟”），也能抵达这个院子。</em><br>从“院子”处上楼梯的路口沿路走，可抵达土地庙“中层”。</p></div><p>蝎太子2&#x2F;4：“院子”内，还是冒蓝光的<br>泡酒物-倒马刺钩：击杀“院子”内冒蓝光的蝎太子掉落<br>精魄-蝎太子：击杀“院子”内冒蓝光的蝎太子掉落<br>落伽香藤：“院子”内<br>丹方-镜中丹：“院子”处上楼梯路口，上去后右侧开箱<br>酒-无忧醑：“院子”处上楼梯路口，上去后一个左侧屋内<br>撕符1&#x2F;4：“院子”处上楼梯路口沿路前进，会触发过场<br>精魄-傀蛛士：从土地庙“花间桥”继续出发，走右侧岔路尽头跳下去后走右侧路线，在左侧有许多吊袋蛛的地方后面区域击杀傀蛛士</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/origin_202408241738484269.jpg"></p><h4 id="盘丝洞-土地庙：中层"><a href="#盘丝洞-土地庙：中层" class="headerlink" title="盘丝洞-土地庙：中层"></a>盘丝洞-土地庙：中层</h4><p>打坐蒲团：土地庙“中层”旁</p><div class="note  simple"><p><em>“千红窟”和“中层”两个土地庙没什么区别，继续前进都是百足虫BOSS战场地</em></p></div><p>BOSS-百足虫：土地庙“千红窟”或“中层”处继续前进并跳下<br>精魄-百足虫：百足虫BOSS战奖励<br>NPC-午马：百足虫BOSS战场地后继续前进看到一个巨大的卵球，击破以将其解救，对话至重复<br>撕符2&#x2F;4：从土地庙“千红窟”一路沿路前进，必经之路旁可看到</p><h4 id="盘丝洞-土地庙：绝想崖"><a href="#盘丝洞-土地庙：绝想崖" class="headerlink" title="盘丝洞-土地庙：绝想崖"></a>盘丝洞-土地庙：绝想崖</h4><p>BOSS-右手虫：必经流程</p><div class="note  flat success"><p>▶成就39：击杀右手虫</p></div><p>要紧物事-照骨镜：右手虫BOSS战奖励（同时获得“佛手（右）”）<br>太乙紫金丹：右手虫BOSS战后，右手虫尸身化成桥，过右手虫桥后左拐尽头</p><div class="note  simple"><p><em>从右手虫桥跳下来后，左侧跳下的窄绳桥通往土地庙“堕龙壁”（路上有个窄木桥很凶险，建议用能隐身的法术通过，或者变老鼠直接跟他们爆了）;有个远程妖怪的右侧路口通往土地庙“底层”</em></p></div><h4 id="盘丝洞-土地庙：堕龙壁"><a href="#盘丝洞-土地庙：堕龙壁" class="headerlink" title="盘丝洞-土地庙：堕龙壁"></a>盘丝洞-土地庙：堕龙壁</h4><p>落伽香藤：面对土地庙“堕龙壁”向左往来路方向直走，在左侧崖边一颗树上<br>蝎太子3&#x2F;4：面对土地庙“堕龙壁”向左往来路方向直走，可以看到在“面壁思过”<br>精魄-儡蜱士：面对土地庙“堕龙壁”，左前方上坡进洞，右侧路口尽头击杀冒蓝光的儡蜱士<br>虚空结：面对土地庙“堕龙壁”，左前方上坡进洞，左侧路口前进，右侧岔路内开箱<br>撕符3&#x2F;4：面对土地庙“堕龙壁”，左前方上坡进洞，左侧路口前进即可在右侧看到<br>BOSS-小黄龙：面对土地庙“堕龙壁”向右往亭子处走即可触发</p><div class="note  flat success"><p>▶成就42：击败小黄龙</p></div><p>珍玩-金色鲤：小黄龙BOSS战奖励（击败BOSS小黄龙后，需要再与其互动）<br>4号位法术-金岚：小黄龙BOSS战奖励（击败BOSS小黄龙后，需要再与其互动）</p><h4 id="盘丝洞-土地庙：底层"><a href="#盘丝洞-土地庙：底层" class="headerlink" title="盘丝洞-土地庙：底层"></a>盘丝洞-土地庙：底层</h4><div class="note  simple"><p><em>从右手虫桥跳下来后，有个远程妖怪的右侧路口通往土地庙“底层”</em></p></div><p>打坐蒲团：从土地庙“底层”处往回走（全是吊袋蛛的方向），左侧有光线渗出的石缝<br>BOSS-波里个波：从土地庙“底层”处往回走（全是吊袋蛛的方向），左侧有光线渗出的石缝，然后往左后方路口进去，会掉落“佛手（左）”</p><h4 id="盘丝洞-土地庙：若仙庵"><a href="#盘丝洞-土地庙：若仙庵" class="headerlink" title="盘丝洞-土地庙：若仙庵"></a>盘丝洞-土地庙：若仙庵</h4><p>BOSS-猪八戒：必经流程（先在若仙庵里打，再从土地庙“若仙庵”旁尽头新出现的石缝出去打）</p><div class="note  flat success"><p>▶成就40：击败猪八戒</p></div><p>要紧物事-染血绣针：猪八戒BOSS战奖励<br>珍玩-月玉兔：猪八戒BOSS战奖励<br>防具-不净套装：击败BOSS猪八戒后解锁</p><h4 id="盘丝洞-土地庙：濯垢泉"><a href="#盘丝洞-土地庙：濯垢泉" class="headerlink" title="盘丝洞-土地庙：濯垢泉"></a>盘丝洞-土地庙：濯垢泉</h4><p>要紧物事-行蕴：从土地庙“濯垢泉”继续前进来到开阔区域，中央池塘尽头可看到先前遇到过的鬼鬼祟祟逃窜的妖怪，佛头处<br>蝎太子4&#x2F;4：从土地庙“濯垢泉”继续前进上楼梯抵达第二个开阔区域，必经之路上<br>精魄-蜻蜓精：从土地庙“濯垢泉”继续前进，上楼梯抵达第二个开阔区域，击杀右侧崖边冒蓝光的蜻蜓精</p><h4 id="盘丝洞-土地庙：万慈窟"><a href="#盘丝洞-土地庙：万慈窟" class="headerlink" title="盘丝洞-土地庙：万慈窟"></a>盘丝洞-土地庙：万慈窟</h4><p>BOSS-紫蛛儿：必经流程（ps：眼睛发光时不要看boss）</p><div class="note  flat success"><p>▶成就41：击败紫蛛儿</p></div><p>武器-昆棍•蛛仙：击败BOSS紫蛛儿解锁配方</p><h4 id="黄花观-土地庙：山道"><a href="#黄花观-土地庙：山道" class="headerlink" title="黄花观-土地庙：山道"></a>黄花观-土地庙：山道</h4><p>落伽香藤：从土地庙“山道”往回走<br>珍玩-君子牌：黄花观场景许多地方都有分布的虫羽士概率掉落<br>泡酒物-蜂山石髓：土地庙“山道”继续前进可看到左前方高处石栏杆，该平台上的香炉</p><h4 id="黄花观-土地庙：虎蛇虫林"><a href="#黄花观-土地庙：虎蛇虫林" class="headerlink" title="黄花观-土地庙：虎蛇虫林"></a>黄花观-土地庙：虎蛇虫林</h4><p>打坐蒲团：从土地庙“虎蛇虫林”出发，向左到尽头<br>BOSS-虫总兵：从土地庙“虎蛇虫林”出发上楼梯可听到右侧练武声<br>精魄-虫总兵：虫总兵BOSS战奖励<br>虚空结：虫总兵BOSS战奖励<br>三清令：虫总兵BOSS战场地开箱</p><h4 id="黄花观-土地庙：观门"><a href="#黄花观-土地庙：观门" class="headerlink" title="黄花观-土地庙：观门"></a>黄花观-土地庙：观门</h4><div class="note  simple"><p><em>该土地庙的正确路线是上山进入院门后左侧径直前进到底后左拐激活土地庙“金光苑”</em></p></div><p>打坐蒲团：从土地庙“观门”出发进入院门，进入右侧院子找到<br>精魄-蛇捕头：从土地庙“观门”出发进入院门，进入右侧院子直走上楼梯击杀蛇捕头<br>NPC-葫芦仙人：从土地庙“观门”出发进入院门，进入右侧院子并抵达最靠里的院子找到，对话至重复<br>三冬虫：从土地庙“观门”出发进入院门，进入右侧院子并抵达最靠里的院子，发光罐子<br>BOSS-蘑女：从土地庙“观门”出发左侧直走到尽头右拐上山，下一个岔路右转到一个广场，拔起其上的一株草药触发<br>精魄-蘑女：蘑女BOSS战奖励<br>虚空结：蘑女BOSS战奖励<br>酒-九霞清醑：蘑女BOSS战场地<br>BOSS-黑手道人：从土地庙“观门”出发左侧直走到尽头右拐上山，下一个岔路左转下坡触发</p><div class="note  flat success"><p>▶成就43：在黄花观再一次击败黑手道人</p></div><div class="note  simple"><p><em>触摸黑手道人BOSS战场地新出现的壁画可解锁进入隐藏场景紫云山；但建议先顺手从场地对侧出去在尽头开箱拿个九转还魂丹</em></p></div><h4 id="隐•紫云山-土地庙：千花谷"><a href="#隐•紫云山-土地庙：千花谷" class="headerlink" title="隐•紫云山-土地庙：千花谷"></a>隐•紫云山-土地庙：千花谷</h4><div class="note  flat warning"><p>由于紫云山一些要素触发顺序会影响支线、收集要素，所以紫云山部分建议按本指南顺序<br>从该土地庙出发，过桥后左拐直行穿过拱门抵达土地庙“落花庄”；过桥后右拐沿路进右侧拱门抵达土地庙“绕仙居”</p></div><p>泡酒物-不老藤：在紫云山场景中许多地方都有分布的树妖“青冉冉”概率掉落<br>泡酒物-清虚道果：在紫云山场景中许多地方都有分布的黄袍道人概率掉落<br>NPC-红蛇妖：前往土地庙“千花谷”的路上，桥头遇到，对话至重复<br>精魄-蛇司药：从土地庙“千花谷”出发过桥左拐后直行，拱门前<br>珍玩-日金乌：从土地庙“千花谷”出发过桥左拐后走右侧岔路向上，走过树干后开箱<br>精魄-青冉冉：从土地庙“千花谷”出发过桥右拐后，右前方树林里击杀青冉冉<br>落伽香藤：从土地庙“千花谷”出发过桥右拐后，右前方树林里<br>珍玩-仙箓：从土地庙“千花谷”出发过桥右拐后沿路前进，左前方亭子内（土地庙“绕仙居”正对面）<br>打坐蒲团：从土地庙“千花谷”出发过桥右拐后沿路前进抵达右侧拱门前，爬拱门左侧山坡上去</p><h4 id="隐•紫云山-土地庙：绕仙居"><a href="#隐•紫云山-土地庙：绕仙居" class="headerlink" title="隐•紫云山-土地庙：绕仙居"></a>隐•紫云山-土地庙：绕仙居</h4><p>BOSS-毒敌大王：从土地庙“绕仙居”继续前进即可看到，需要打碎它面前的罐子触发战斗（如果先行继续探索至击败BOSS晦月魔君则将消失）</p><div class="note  flat success"><p>▶成就45：击败本话先前遇到过的四个蝎太子后，击败毒敌大王BOSS后获得；或者另一种不是很推荐的方法（保险防漏BOSS毒敌大王的奖励）击败本话先前遇到过的四个蝎太子后，不打BOSS毒敌大王而打BOSS晦月魔君，二阶段毒敌大王会助战，晦月魔君BOSS战后也能获得本成就</p></div><p>胸甲-昆蚑毒敌甲：击败BOSS毒敌大王后解锁配方（与第二话BOSS蝜蝂对应解锁的昆蚑套装匹配）<br>葫芦-彩玉葫芦：毒敌大王BOSS战奖励（先开宝箱给丹药，葫芦会从毒敌大王身上掉）</p><h4 id="隐•紫云山-土地庙：落花庄"><a href="#隐•紫云山-土地庙：落花庄" class="headerlink" title="隐•紫云山-土地庙：落花庄"></a>隐•紫云山-土地庙：落花庄</h4><p>NPC-糜道人：从土地庙“落花庄”继续前进上楼梯后，基本算必经流程，对话至重复接任务<br>三冬虫：从土地庙“落花庄”继续前进上楼梯后是NPC糜道人所在位置，继续直行上楼梯过门洞后立即转身跳到门洞上方，有发光罐子<br>保命丹：从土地庙“落花庄”继续前进上楼梯后是NPC糜道人所在位置，不上门洞楼梯而是朝右侧走到底，打破左侧木板往前走并开箱<br>要紧物品-藕雹：接取NPC糜道人的任务后，在紫云山区域许多区域都有分布的黄袍道人概率掉落<br>BOSS-糜道人：将要紧物品“藕雹”后交给NPC糜道人后触发战斗</p><div class="note  flat success"><p>▶成就44：击败糜道人</p></div><p>4号位法术-藕雹：糜道人BOSS战奖励</p><h4 id="隐•紫云山-土地庙：巢云顶"><a href="#隐•紫云山-土地庙：巢云顶" class="headerlink" title="隐•紫云山-土地庙：巢云顶"></a>隐•紫云山-土地庙：巢云顶</h4><p>BOSS-晦月魔君：土地庙“巢云顶”处继续上楼梯</p><div class="note  flat success"><p>▶成就46：击杀晦月魔君</p></div><p>4号位法术-藕雹：晦月魔君BOSS战奖励<br>法宝-绣花针：晦月魔君BOSS战奖励<br>泡酒物-双冠血：晦月魔君BOSS战奖励</p><h4 id="黄花观-土地庙：金光苑"><a href="#黄花观-土地庙：金光苑" class="headerlink" title="黄花观-土地庙：金光苑"></a>黄花观-土地庙：金光苑</h4><div class="note  flat warning"><p><em>请注意，跨过那个通往开阔场地的路口，会直接触发过场，进入本话最终BOSS战</em></p></div><p>撕符4&#x2F;4：往土地庙背面路口进院<br>BOSS-王灵官：在第四话撕完四处符后，在土地庙背面路口的院内触发（打一点点血就触发过场）</p><div class="note  flat success"><p>▶成就47：撕完四处符并完成与王灵官的战斗（如果先行打过BOSS百眼魔君，将无法获得）</p></div><p>九转金丹：王灵官BOSS战场地后方<br>BOSS-百眼魔君：必经流程（boss进入金色二阶段时用绣花针会变回一阶段，不要开局就给用了）</p><div class="note  flat success"><p>▶成就48：击杀百眼魔君</p></div><p>武器-昆棍•百眼：击杀BOSS百眼魔君后解锁配方<br>防具-羽士套装：击杀BOSS百眼魔君后解锁配方<br>根器-舌尝思：第四话完成奖励</p><h3 id="第五话：火焰山（对应成就49-63）"><a href="#第五话：火焰山（对应成就49-63）" class="headerlink" title="第五话：火焰山（对应成就49-63）"></a>第五话：火焰山（对应成就49-63）</h3><p>珍品-定颜珠：击杀BOSS百眼魔君后，去第二次黑手道人BOSS战场地尽头，大树斜后方石碑处开箱<br>精魄-幽灯鬼：完成第四话后，再回土地庙“朱家大院”，进入院内击杀冒蓝光的幽灯鬼</p><h4 id="六六村-土地庙：村口-2"><a href="#六六村-土地庙：村口-2" class="headerlink" title="六六村-土地庙：村口"></a>六六村-土地庙：村口</h4><p>丹方-龙光倍力丸：NPC戌狗出售<br>落伽香藤：NPC申猴出售<br>三冬虫：NPC申猴出售</p><div class="note  flat success"><p>▶成就52：获得所有15种草药种子（前五话内容即可遇到所有的种类）</p></div><p>泡酒物-蕙性兰：将全部15种草药种子都交付给NPC辰龙</p><h4 id="灰烬林-土地庙：火燎一关"><a href="#灰烬林-土地庙：火燎一关" class="headerlink" title="灰烬林-土地庙：火燎一关"></a>灰烬林-土地庙：火燎一关</h4><p>泡酒物-火焰丹头：本话中许多地方都有分布的火岩敌怪概率掉落<br>珍玩-白贝腰链：本话中许多地方都有分布的红皮敌怪概率掉落<br>BOSS-皓斧居士：必经流程，随后与之对话至重复，接任务（在本话击杀3处战车BOSS）<br>BOSS-褐铁战车：必经之路上</p><h4 id="灰烬林-土地庙：春秋寨"><a href="#灰烬林-土地庙：春秋寨" class="headerlink" title="灰烬林-土地庙：春秋寨"></a>灰烬林-土地庙：春秋寨</h4><p>打坐蒲团：从土地庙“春秋寨”继续出发的必经之路走过第二座桥后，右侧上楼梯<br>泡酒物-灵台药苗：必经之路上，第三座桥前的香炉</p><h4 id="灰烬林-土地庙：灰烬台"><a href="#灰烬林-土地庙：灰烬台" class="headerlink" title="灰烬林-土地庙：灰烬台"></a>灰烬林-土地庙：灰烬台</h4><p>BOSS-石父：必经流程<br>精魄-石父：石父BOSS战奖励<br>落伽香藤：击败BOSS石父后，不开门而是继续向前并走左边向下的楼梯，然后到外侧向右走到尽头<br>珍玩-琥珀念珠：从土地庙“灰台”出发进门下坡，到洞内后直接向右出去开箱<br>精魄-黑脸鬼：从土地庙“灰台”出发进门下坡，到洞内后向前直行到佛像处击杀黑脸鬼<br>BOSS-灰铜战车：必经流程<br>BOSS-急如火&amp;快如风：必经流程</p><h4 id="灰烬林-土地庙：火燎二关"><a href="#灰烬林-土地庙：火燎二关" class="headerlink" title="灰烬林-土地庙：火燎二关"></a>灰烬林-土地庙：火燎二关</h4><p>碧藕金丹：土地庙“火燎二关”对面香炉</p><h4 id="丹灶谷-土地庙：谷口"><a href="#丹灶谷-土地庙：谷口" class="headerlink" title="丹灶谷-土地庙：谷口"></a>丹灶谷-土地庙：谷口</h4><p>头冠-鳖宝头骨：丹灶谷和火光岭一些地方有分布的鳖宝概率掉落（比如土地庙“谷口”附近那只会出精魄的）<br>精魄-鳖宝：土地庙“谷口”继续前进下到熔岩池时，向右后方掉头走到底，击杀尽头处的鳖宝<br>NPC-午马：土地庙“谷口”继续前进下到熔岩池时向右走到底看到妖车，拉绳子对话接任务<br>BOSS-燧统领：土地庙“谷口”继续前进下到熔岩池时，走左侧熔岩池向前<br>精魄-燧统领：燧统领BOSS战奖励<br>精魄-地罗刹：土地庙“谷口”继续前进，过拱门后左拐尽头击杀冒蓝光的地罗刹<br>BOSS-雾里云&amp;云里雾：必经流程<br>精魄-雾里云•云里雾：雾里云&amp;云里雾BOSS战奖励<br>武器-业火杖：击杀BOSS雾里云&amp;云里雾后解锁配方</p><h4 id="丹灶谷-土地庙：罗刹宫"><a href="#丹灶谷-土地庙：罗刹宫" class="headerlink" title="丹灶谷-土地庙：罗刹宫"></a>丹灶谷-土地庙：罗刹宫</h4><div class="note  flat info"><p>建议开完这个土地庙后回去六六村把“药葫芦”升满</p></div><p>珍玩-雷火印：土地庙“罗刹宫”及“翠云殿”往后的路段有分布的持戟蓝袍法师概率掉落</p><div class="note  simple"><p><em>面对该土地庙向左上方看到的围栏，就是下一个土地庙的路线</em></p></div><p>太乙紫金丹：在土地庙“罗刹宫”侧后方不远处香炉<br>珍玩-金纽：从土地庙“罗刹宫”沿桥路继续前进，可看到两只大体型的火焰巨妖，其中一只掉落<br>三冬虫：从土地庙“罗刹宫”沿桥路继续前进，往左前方进入殿内找到发光罐子<br>NPC-葫芦仙人：从土地庙“罗刹宫”沿桥路继续前进，往左前方进入殿内找到，对话至重复<br>葫芦-上清宝葫芦：将初始葫芦强化满后，与NPC葫芦仙人对话后在该室内中央获取</p><div class="note  flat success"><p>▶成就49：在前五话都与NPC葫芦仙人对过话，最终获得上清宝葫芦</p></div><h4 id="丹灶谷-土地庙：翠云殿"><a href="#丹灶谷-土地庙：翠云殿" class="headerlink" title="丹灶谷-土地庙：翠云殿"></a>丹灶谷-土地庙：翠云殿</h4><p>BOSS-火焰山土地：必经流程（第一阶段打守炉道士，第二阶段打阴阳鱼）</p><div class="note  flat success"><p>▶成就50：击败守炉道士和阴阳鱼</p></div><p>胸甲-阴阳法衣：守炉道士&amp;阴阳鱼BOSS战奖励<br>NPC-午马：击败守炉道士&amp;阴阳鱼后，回到NPC午马所在的妖车处拉绳子</p><div class="note  flat success"><p>▶成就51：在前四话都与NPC午马对过话，并在第五话助其解脱</p></div><p>4号位法术-黯雷：击败守炉道士&amp;阴阳鱼后帮NPC午马拉绳解脱后获得<br>打坐蒲团：从土地庙“翠云殿”继续出发，贴左侧石栏杆向前走到尽头<br>泡酒物-瞌睡虫蜕：守炉道士&amp;阴阳鱼BOSS战场地，面对座位方向，左侧外围香炉<br>酒-龙膏：守炉道士&amp;阴阳鱼BOSS战场地座位处<br>NPC-皓斧居士：将两处战车BOSS击杀后，回土地庙“春秋寨”与其对话至重复；<br>BOSS-红银战车：必经之路上，如果与皓斧居士对话过，他会在此助战。<br>NPC-皓斧居士：再回到红银战车BOSS战场地，与其对话至重复</p><h4 id="火光岭-土地庙：火燎三关"><a href="#火光岭-土地庙：火燎三关" class="headerlink" title="火光岭-土地庙：火燎三关"></a>火光岭-土地庙：火燎三关</h4><div class="note  flat info"><p>建议检查一下身上有没有4个火灵砂，后面会用到，不够的话图省事可以直接在土地庙买，或者打虫子刷</p></div><p>BOSS-九叶灵芝精：面对土地庙“火燎三关”向右，采摘面前中间的九叶灵芝草触发<br>精魄-九叶灵芝精：九叶灵芝精BOSS战奖励<br>头冠-地灵伞盖：九叶灵芝精BOSS战奖励<br>打坐蒲团：面对土地庙“火燎三关”向右</p><p>剧情-灭火：土地庙继续前进，路上<font color="red">小 心 铁 球</font></p><div class="note  flat info"><p>建议先继续前进开一下土地庙“陨砖坑”，然后再回头去刚刚路上被火拦住的地方</p></div><p>精魄-兴烘掀•掀烘兴：灭火剧情后，传送至土地庙“翠云殿”并继续前进抵达一个外侧的空旷场地，可看到BOSS兴烘掀&amp;掀烘兴的尸身</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240907192944780.png"></p><p>BOSS-燧先锋：主线剧情用芭蕉扇灭火后，从土地庙“火燎三关”继续出发，进原先被火拦住的右侧岔路<br>精魄-燧先锋：燧先锋BOSS战奖励<br>落伽香藤：主线剧情用芭蕉扇灭火后，从土地庙“火燎三关”继续出发，进原先被火拦住的右侧岔路<br>BOSS-火灵元母：主线剧情用芭蕉扇灭火后，从土地庙“火燎三关”继续出发，进原先被火拦住的右侧岔路沿路前进，会看到地上有发光法阵，需要交4份火灵砂（直接在土地庙买&#x2F;打附近的虫子也会掉）以召唤<br>精魄-火灵元母：火灵元母BOSS战奖励</p><div class="note  flat success"><p>▶成就53：将老人参精（小西天）、磨女（盘丝洞）、琴螂仙（盘丝洞）、九叶灵芝精（火焰山）、火灵元母（火焰山）全部击杀</p></div><div class="note  simple"><p><em>继续往前走解锁土地庙“清凉坡”，该处连通着土地庙“火燎二关”；但正确路线是触发扇风过场的场地继续上坡前进，解锁土地庙“陨砖坑”</em></p></div><h4 id="火光岭-土地庙：清凉坡"><a href="#火光岭-土地庙：清凉坡" class="headerlink" title="火光岭-土地庙：清凉坡"></a>火光岭-土地庙：清凉坡</h4><p>BOSS-赤金战车：击败前面三处战车BOSS并完成NPC皓斧居士的一系列对话后，土地庙“清凉坡”旁门前开阔场地触发<br>珍玩-阳燧珠：赤金战车BOSS战奖励<br>NPC-皓斧居士：击杀BOSS赤金战车后，面对大门，左侧与其对话，再去开大门走到中央，解锁隐藏地图壁水洞</p><div class="note  flat success"><p>▶成就54：见证皓斧居士的结局，并进入大门解锁壁水洞</p></div><h4 id="隐•壁水洞-土地庙：炼魔坑"><a href="#隐•壁水洞-土地庙：炼魔坑" class="headerlink" title="隐•壁水洞-土地庙：炼魔坑"></a>隐•壁水洞-土地庙：炼魔坑</h4><p>丹方-七返火丹：从土地庙“炼魔坑”往回走开箱<br>打坐蒲团：面对土地庙“炼魔坑”向左走到底</p><div class="note  flat success"><p>▶成就55：与前五话每一处打坐蒲团都互动打坐过</p></div><p>BOSS-兴烘掀&amp;掀烘兴：土地庙“炼魔坑”继续前进</p><div class="note  flat success"><p>▶成就56：击败BOSS兴烘掀&amp;掀烘兴</p></div><p>九转金丹：兴烘掀&amp;掀烘兴BOSS战场地上楼梯继续前进一点距离后向左掉头的香炉</p><h4 id="隐•壁水洞-土地庙：洞天深处"><a href="#隐•壁水洞-土地庙：洞天深处" class="headerlink" title="隐•壁水洞-土地庙：洞天深处"></a>隐•壁水洞-土地庙：洞天深处</h4><p>精魄-牯都督：土地庙“洞天深处”继续前进必经之路上，击杀冒蓝光的牯都督</p><div class="note  flat warning"><p>它附近的箱子里有1个素材“大力铁角”，请确保拿到，否则单周目给的该素材总数不够，做不齐半套大力套装</p></div><div class="note  flat success"><p>▶成就57：收集全部种类的精魄，总共54种</p></div><h4 id="隐•壁水洞-土地庙：水火道"><a href="#隐•壁水洞-土地庙：水火道" class="headerlink" title="隐•壁水洞-土地庙：水火道"></a>隐•壁水洞-土地庙：水火道</h4><p>BOSS-壁水金睛兽：土地庙“水火道”继续前进</p><div class="note  flat success"><p>▶成就58：击杀壁水金睛兽</p></div><p>三冬虫：打BOSS过程中引导它撞场地里的一个冰门，撞出一条路后打，完BOSS进入走一段即可看到</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240907201900321.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240907201705191.png"></p><p>珍玩-水火篮：壁水金睛兽BOSS战奖励<br>武器-兽棍•金睛：击杀BOSS壁水金睛兽后解锁配方<br>防具-大力套装：击杀BOSS壁水金睛兽后解锁配方（单周目的素材只够做半套，BOSS壁水金睛兽会给3个“大力铁角”，然后上面介绍“精魄-牯都督”的位置有个宝箱要开，否则缺了1个“大力铁角”的情况下半套都做不出来并且还进下周目的话，将延长获取全防具成就的时间）</p><p>BOSS-波浪浪：击杀BOSS壁水金睛兽后自动返回大门内，就在该场景一侧</p><div class="note  flat success"><p>▶成就61：已将金池长老（黑风山）、蝜蝂（黄风岭）、翠笠武师（小西天）、晦月魔君（盘丝岭）、碧水金睛兽（火焰山）全部击败后，前往小西天的土地庙“浮屠塔”并走向高处尽头触发过场，解锁第三话的隐藏场景“梅山”</p></div><h4 id="隐•梅山-土地庙：梅见峰"><a href="#隐•梅山-土地庙：梅见峰" class="headerlink" title="隐•梅山-土地庙：梅见峰"></a>隐•梅山-土地庙：梅见峰</h4><div class="note  flat warning"><p><em>建议仅仅先解锁该土地庙，这里接下去的BOSS是否被击败会影响结局分支，可以晚点做决定；本指南建议一周目选择直接去打，该结局观感更好，不仅不影响成就获取，反而是尽早拿齐成就的选择<br>如果想一周目连续看双结局动画，则此处请不要继续前进打BOSS，而是直接继续推进到结局后；主菜单点击“继续游戏”后会回到结局BOSS战前，届时来本处打BOSS后再去触发结局BOSS战。</em></p></div><p>BOSS-二郎显圣真君&amp;四大天王&amp;二郎神：土地庙“梅见峰”继续向前（共三阶段）</p><div class="note  flat success"><p>▶成就62：击败四大天王与二郎神</p></div><p>武器-三尖两刃枪：二郎显圣真君&amp;四大天王&amp;二郎神BOSS战奖励<br>4号位法术-青穹：二郎显圣真君&amp;四大天王&amp;二郎神BOSS战奖励</p><div class="note  flat success"><p>▶成就63：集齐10种4号位法术（变身类）</p></div><div class="note  flat info"><p>轻松击败二郎神的思路</p></div><p>只讲一个简单思路，可大幅降低二郎神战难度，核心思路就是：<strong>没有韧性的二郎神不如哮天犬</strong></p><p>不过需要注意的是，由于二郎神机制为每掉25%的血，就会强制转阶段释放大招，每阶段强制恢复满韧性。<br>在前期等级和装备、操作不够的情况下，削韧成了主要思路</p><br><p><strong>准备工作：</strong><br>变身法术：石头——在第二章击败石母。<br>法宝：完成第五章主线获取<strong>芭蕉扇</strong><br>加点：优先点满神力相关的变身类后点满攻击向技能后，富余点数可投资防御类。<br>大圣套：有最好，没有也无所谓，只要不被秒就行<br>其余法术，推荐潜行，容错率更高，有自信也可以铜头铁臂。</p><br><p><strong>打法：</strong></p><p>一阶段：100%血量<br>开局快跑到二郎神位置直接使用芭蕉扇，强制中断对面开局跳脸且稳定打掉一管韧性<br>没有韧性的二郎神完全可以对A，适当闪避，利用一二段轻棍可以轻松打入硬直<br>如此复读打到75%强制转阶段</p><br><p>二阶段：75%血量<br>此阶段开始二郎神会用开山斧转第二圈时，劈下，利用闪避很好躲，没自信也可以用潜行<br>此阶段思路多利用潜行拖时间，等斧子落下后直接变身石头，正所谓早用早CD。<br>重点来了，你变成石头后，二郎神直接摆烂挂机开始语言嘲讽（233…)<br>一直贴脸用平A，一般情况下可以削弱一半左右韧性。之后利用潜行补血、拖时间、削韧<br>变身结束后多利用近身平A触发二郎神格挡反击，会把你踹飞，但是没伤害。<br>整体技能威胁不算很大，唯一注意就是飞天召唤很多把剑，最后一段蓄力只要不被秒慢慢拖到三阶段</p><br><p>三阶段：50%血量<br>此阶段开始二郎神会飞天召唤分身并用天眼发激光，比较好躲，瞎翻就可以<br>此阶段思路一个字——喝，先前两阶段应该存了不少酒，这阶段可以一股脑的狂饮，近身换血。<br>潜行好了就用，不过别立即攻击，补好状态后潜行快结束时再攻击。<br>只要不被秒，应该能拖到变身法术好，此时变身石头重复二阶段的操作。<br>先前换血和变身石头应该耗掉二郎神不少血，还是很容易压到25%血量</p><br><p>四阶段：25%血量<br>没啥说的，emm，芭蕉扇CD转好了，懂我意思吧~</p><h4 id="火光岭-土地庙：陨砖坑"><a href="#火光岭-土地庙：陨砖坑" class="headerlink" title="火光岭-土地庙：陨砖坑"></a>火光岭-土地庙：陨砖坑</h4><p>BOSS-红孩儿&amp;夜叉王：必经流程（第一阶段打红孩儿，第二阶段打夜叉王）</p><div class="note  flat success"><p>▶成就59：击败红孩儿及夜叉王</p></div><p>法宝-芭蕉扇：红孩儿&amp;夜叉王BOSS战奖励<br>防具-厌火套装：击败BOSS红孩儿&amp;夜叉王后解锁配方</p><div class="note  flat success"><p>▶成就60：集齐四样法宝</p></div><p>根器-身本忧：第五话完成奖励</p><h3 id="第六话：花果山（对应成就64-72）"><a href="#第六话：花果山（对应成就64-72）" class="headerlink" title="第六话：花果山（对应成就64-72）"></a>第六话：花果山（对应成就64-72）</h3><h4 id="六六村-土地庙：村口-3"><a href="#六六村-土地庙：村口-3" class="headerlink" title="六六村-土地庙：村口"></a>六六村-土地庙：村口</h4><p>葫芦-乾坤彩葫芦：NPC申猴出售<br>酒-千日醉：NPC申猴出售<br>泡酒物-百花蕤：NPC申猴出售</p><div class="note  flat success"><p>▶成就64：集齐9种酒</p></div><h4 id="山脚-土地庙：青嶂道"><a href="#山脚-土地庙：青嶂道" class="headerlink" title="山脚-土地庙：青嶂道"></a>山脚-土地庙：青嶂道</h4><p>BOSS-王灵官：必经流程</p><div class="note  flat success"><p>▶成就65：击杀王灵官，获得筋斗云（但只能在花果山场景里使用，战斗期间也不能用）</p></div><p>丹方-登仙散：王灵官BOSS战奖励<br>防具-大圣套装（凡品级别）：从王灵官BOSS战场地往回飞行，如下图箭头所指的粗斜树干下宝箱<br><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240908145431204.png"><br><strong>下面，打★号的项目为神珍级别的大圣五件套。</strong><br>BOSS-跳浪蛟：从王灵官BOSS战场地继续直线向前飞出至大河的悬崖边，悬崖下的水潭处<br>珍玩-辟水珠：跳浪蛟BOSS战奖励<br>BOSS-石子：从王灵官BOSS战场地继续直线向前飞出至大河，大河对面青蓝色巨石</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240908150431972.png"></p><p>BOSS-大石敢当：石子BOSS战场地，继续向内侧前进到尽头，向右穿过峡谷<br>要紧物事-识蕴：BOSS大石敢当被击败后，爬到它背上最高处触发过场</p><div class="note  flat success"><p>▶成就68：集齐要紧物事5件名字带“蕴”的物品，与NPC戌狗对话选择展示及交付五蕴炼制五蕴丹<br>▶成就69：前五话的碧藕金丹、太乙紫金丹、九转金丹全部获取（每话各一)，并且炼制出五蕴丹</p></div><h4 id="山脚-土地庙：望犀坡"><a href="#山脚-土地庙：望犀坡" class="headerlink" title="山脚-土地庙：望犀坡"></a>山脚-土地庙：望犀坡</h4><div class="note  simple"><p><em>从王灵官BOSS战场地继续直线向前飞出至大河后向右转，可看到右侧高处有打雷的场地（左侧的是见鹿林），即可找到该土地庙</em></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240908162102815.png"></p></div><p>BOSS-金甲犀：土地庙“望犀坡”处继续往前方空地处走<br>★胸甲-锁子黄金甲：金甲犀BOSS战战奖励<br>BOSS-毒统领①：从土地庙“望犀坡”处飞向大河，大河对面靠左林中空地</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/origin_202408261859409149.jpg"></p><p>BOSS-浪波波：从土地庙“望犀坡”处飞向大河，右转沿河前进到底（大河走向左拐），右下角岸边无草开阔平地上<br>珍玩-仙胞石片：浪波波BOSS战奖励</p><div class="note  flat success"><p>▶成就66：在单周目中，击败全流程所有6只青蛙BOSS<br>▶成就67：获得所有种类的珍玩（难点在于那些需要刷取概率掉落的珍玩）</p></div><h4 id="山脚-土地庙：见鹿林"><a href="#山脚-土地庙：见鹿林" class="headerlink" title="山脚-土地庙：见鹿林"></a>山脚-土地庙：见鹿林</h4><div class="note  simple"><p><em>从土地庙“望犀坡”处飞向大河，右前方红树下可找到该土地庙</em></p></div><p>BOSS-步云鹿：从土地庙“望犀坡”处飞向大河，右前方红树围着的空地<br>★腿甲-藕丝步云履：步云鹿BOSS战奖励</p><h4 id="山脚-土地庙：捕螂汀"><a href="#山脚-土地庙：捕螂汀" class="headerlink" title="山脚-土地庙：捕螂汀"></a>山脚-土地庙：捕螂汀</h4><div class="note  simple"><p><em>从王灵官BOSS战场地继续直线向前飞出至大河，左转沿河前进在一棵黄叶树下激活土地庙“捕螂汀”</em></p></div><p>头目-水木兽：从土地庙“捕螂汀”继续沿河到左侧尽头水域（水木兽有很多只，别的可以解锁图鉴，但这只有血条的关系到70难的成就！！！特别注意！！！）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240908222614777.png"></p><div class="note  flat success"><p>▶成就70：将跳浪蛟、石子、大石敢当、水木兽、毒统领（4个）、浪波波全都击杀（不限单周目）</p></div><p>BOSS-凤翅将军：花果山山脚场景的大河有一只“巨型蚂蚱”在以循环点位形式跳跃移动，去土地庙“捕螂汀”，面对该土地庙的方向飞到高空左侧可看到一个小型山顶平台，等到“巨型蚂蚱”跳到那上面后，落到它背上，走到其头部，出现提示后保持按住E即可（等它完成3次跳跃后使用辟火罩再去按E）<br>★头冠-凤翅紫金冠：凤翅将军BOSS战奖励<br>BOSS-碧臂螂：集齐大圣套装的头冠、胸甲、腿甲后，回到土地庙“捕螂汀”向阳光下走出一点距离触发<br>★臂甲-点翠飞龙釬：碧臂螂BOSS战奖励<br>★武器-如意金箍棒：集齐大圣套装防具四件套后，面对土地庙“捕螂汀”，飞往右方高处后立即左转进洞抵达水帘洞获得</p><div class="note  flat success"><p>▶成就71：集齐神珍级别的大圣套装五件套</p></div><div class="note  simple"><p><em>从获得如意金箍棒的位置继续前进就是正确路线</em></p></div><h4 id="水帘洞-土地庙：峰回路"><a href="#水帘洞-土地庙：峰回路" class="headerlink" title="水帘洞-土地庙：峰回路"></a>水帘洞-土地庙：峰回路</h4><p>无它，跑图</p><h4 id="水帘洞-土地庙：天真顶"><a href="#水帘洞-土地庙：天真顶" class="headerlink" title="水帘洞-土地庙：天真顶"></a>水帘洞-土地庙：天真顶</h4><p>无它，摸石头触发过场</p><h4 id="石卵-土地庙：石中境"><a href="#石卵-土地庙：石中境" class="headerlink" title="石卵-土地庙：石中境"></a>石卵-土地庙：石中境</h4><p>BOSS-石猿&amp;大圣残身：必经流程（一共四阶段），看完结局后解锁主菜单“再入轮回”选项<br>4号位法术-不坏身：石猿&amp;大圣残身BOSS战奖励<br>根器-意见欲：第六话完成奖励</p><div class="note  flat success"><p>▶成就72：看完结局（是否完成每一话的隐藏地图主线，过场动画将有区别，对应双结局）</p></div><h3 id="进多周目前须知"><a href="#进多周目前须知" class="headerlink" title="进多周目前须知"></a>进多周目前须知</h3><p><strong>跟随本指南一般不会有什么问题，但还是特意交代一下：</strong><br>1.除了要紧物事不会继承，行囊和披挂内的物品都会继承。影神图进度、药草种子的交付进度、重要稀有强化素材也可被继承，可以放心；按本指南每一项过，可确保影神图全齐（重点是葫芦仙人）。<br>2.碧藕金丹、太乙紫金丹、九转金丹，可以在下一周目补齐，但仍然必须是没收集过的点位；若是已收集过的点位则会开出一些丹药奖励。因为比较麻烦，所以建议在确保获得成就68、69后再开新周目。<br>3.成就66对应的6只青蛙BOSS，达成条件是限定在单周目内，所以建议在确保获得后再开新周目。<br>4.已收集过的精魄在新周目会转化为灵蕴，已打坐过的打坐蒲团在新周目不会重复获得灵光点。<br>5.每次新周目每话获得的根器可各自解锁额外的一项强化项。<br>6.如对应位置也有交代过的，确保单周目在火焰山的隐藏地图“壁水洞”内获得4份“大力铁角”（重点在于有1份是开宝箱获得的），足够做出半套大力套装后再进新周目，否则入手全防具&#x2F;武器的成就会被多拖延一个周目。击杀4只龙集齐单周目内能入手的最多的龙丹，也是同理。</p><h3 id="多周目（对应成就73-81）"><a href="#多周目（对应成就73-81）" class="headerlink" title="多周目（对应成就73-81）"></a>多周目（对应成就73-81）</h3><div class="note  flat success"><p>▶成就73：解锁全部影神图（单周目到结局可全解锁，这种情况下只有在进新周目时才会解锁）<br>▶成就74：在主菜单选择“再入轮回”开启新周目的游戏<br>▶成就75：获取全部法术（单周目到结局可解锁全法术，这种情况下只有在进新周目时才会解锁）</p></div><h4 id="第一话：黑风山"><a href="#第一话：黑风山" class="headerlink" title="第一话：黑风山"></a>第一话：黑风山</h4><p>武器-天龙棍：新周目解锁配方（龙珠会不够，记得拿飞龙鳞片去找四龙麻烦）<br>武器-混铁棍：新周目解锁配方<br>武器-昆棍•通天：新周目解锁配方<br>葫芦-青田葫芦：NPC申猴出售（据说只有前一周目打过梅山BOSS战、影神图全解锁才开放出售）<br>泡酒物-净瓶柳叶：NPC申猴出售</p><div class="note  flat success"><p>▶成就76：获取全部10种葫芦<br>▶成就78：获取全部27种泡酒物（难点在于那些需要概率刷取的泡酒物）</p></div><h4 id="第二话：黄风岭"><a href="#第二话：黄风岭" class="headerlink" title="第二话：黄风岭"></a>第二话：黄风岭</h4><p>丹方-九转还魂丹：NPC戌狗出售</p><div class="note  flat success"><p>▶成就77：获取全部14种丹方</p></div><h4 id="第五话：火焰山"><a href="#第五话：火焰山" class="headerlink" title="第五话：火焰山"></a>第五话：火焰山</h4><p><em>记得开隐藏地图“壁水洞”开箱+击杀BOSS壁水金睛兽，集齐当前周目的4份“大力铁角”，以做齐大力套装</em></p><div class="note  flat success"><p>▶成就79：铸造或获得每种防具<br>▶成就80：铸造或获得过每种武器<br>▶成就81：解锁所有其它成就（据说，必须单存档内达成其它所有成就，所以备份存档对全成就的帮助不大，而主要是为了防止错过某些要素而进行的保险措施）</p></div><h2 id="全收集附录"><a href="#全收集附录" class="headerlink" title="全收集附录"></a>全收集附录</h2><h3 id="附录1：全种子列表（52难）"><a href="#附录1：全种子列表（52难）" class="headerlink" title="附录1：全种子列表（52难）"></a>附录1：全种子列表（52难）</h3><p><strong>需要注意的是，一共有12种种子，对应15种药草，因为其中有几种是单种子对应多种药材的。</strong></p><table><thead><tr><th>名称</th><th>获得方式</th><th>推荐刷取地点（全流程采集对应植株都掉）</th><th>个人收集情况</th></tr></thead><tbody><tr><td>火铃草种子</td><td>采摘火铃草概率获得</td><td>挟魂崖-枕石坪 右侧山壁有一株，之后往洞里走</td><td>√</td></tr><tr><td>千年人参种子<br/>（千年人参+老山参）</td><td>击杀极乐谷-罪业塔林 boss 老人参精必定获得</td><td></td><td>√</td></tr><tr><td>龙胆种子</td><td>采摘龙胆概率获得</td><td>极乐谷-无忧涧，传送点旁就有一个，可同交梨碧藕一起刷</td><td>√</td></tr><tr><td>猴头菌种子<br/>（猴头菌+葛蕈）</td><td>击杀黄花观-金光苑 boss 蘑女获得</td><td></td><td>√</td></tr><tr><td>火枣种子</td><td>采摘火枣概率获得</td><td>丹灶谷-谷口下到熔浆底层后，从左侧熔浆进去，里面有几株</td><td></td></tr><tr><td>九叶灵芝草种子<br/>（九叶灵芝草+紫芝）</td><td>击杀火光地-火燎三关 传送点旁的 boss 九叶灵芝精必定获得</td><td></td><td>√</td></tr><tr><td>碧藕种子</td><td>采摘碧藕概率获得</td><td>极乐谷-无忧涧 从旁边河道上游跳下，一路沿着河道往下找</td><td>√</td></tr><tr><td>交梨种子</td><td>采摘交梨概率获得</td><td>极乐谷-无忧涧，河流旁有三株靠得很近</td><td></td></tr><tr><td>珠树种子</td><td>采摘树珍珠概率获得</td><td>紫云山-绕仙居 开头往房屋右侧悬崖边走有一株，之后朝有桥的方向走到岔路口左拐，在一个树藤精旁有一株，沿着旁边的山体往前不远处还有一株</td><td></td></tr><tr><td>漱玉花种子</td><td>采摘漱玉花概率获得</td><td>沙门村-村口 旁边的桥跳下左侧尽头有一株，可与甘草一起刷</td><td></td></tr><tr><td>地莲种子</td><td>击杀地莲精概率获得</td><td>苦海-龟岛 往前走，右侧有几株</td><td></td></tr><tr><td>甘草种子</td><td>采摘甘草概率获得</td><td>沙门村-村口 进院后向左走，里面的大树旁</td><td>√</td></tr></tbody></table><h3 id="附录4：全珍玩列表（67难）"><a href="#附录4：全珍玩列表（67难）" class="headerlink" title="附录4：全珍玩列表（67难）"></a>附录4：全珍玩列表（67难）</h3><p>共36+1个，1是豪华版奖励不计数</p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2404446025900468676/555683643BAF8EB97E6AFE134502B7746973860C/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th><th>最大获得数量</th></tr></thead><tbody><tr><td>仙胞石片</td><td>BOSS 战奖励</td><td>第六章从土地庙“望犀坡”处飞向大河，右转沿河前进到底（大河走向左拐），右下角岸边无草开阔平地上，浪波波 BOSS 战奖励</td><td>1</td></tr><tr><td>虎筋绦子</td><td>怪物概率掉落</td><td>第四章击杀蛇捕头(虎头妖)概率掉落，推荐金光院土地庙往回走出门左边水池有一只</td><td>1</td></tr><tr><td>金花玉萼</td><td>商店购买</td><td>第二章 NPC 石中人出售</td><td>3</td></tr><tr><td>仙箓</td><td>宝箱获取</td><td>第四章隐藏从土地庙“千花谷”出发过桥右拐后沿路前进，左前方亭子内（土地庙“绕仙居”正对面）</td><td>3</td></tr><tr><td>金色鲤</td><td>BOSS 战奖励</td><td>第四章小黄龙 BOSS 战奖励（击败 BOSS 小黄龙后，需要再与其互动）</td><td>3</td></tr><tr><td>未来珠</td><td>宝箱获取</td><td>第三章第一次不白 BOSS 战场地进洞继续前进，必经之路上左侧开箱</td><td>1</td></tr><tr><td>月玉兔</td><td>BOSS 战奖励</td><td>第四章猪八戒 BOSS 战奖励</td><td>1</td></tr><tr><td>日金乌</td><td>宝箱获取</td><td>第四章隐藏从土地庙“千花谷”出发过桥左拐后走右侧岔路向上，走过树干后开箱</td><td>1</td></tr><tr><td>定颜珠</td><td>宝箱获取</td><td>第四章击杀 BOSS 百眼魔君后，去第二次黑手道人 BOSS 战场地尽头，大树斜后方石碑处开箱</td><td>1</td></tr><tr><td>水火篮</td><td>BOSS 战奖励</td><td>第五章隐藏壁水金睛兽 BOSS 战奖励</td><td>3</td></tr><tr><td>辟水珠</td><td>BOSS 战奖励</td><td>第六章跳浪蛟 BOSS 战奖励</td><td>1</td></tr><tr><td>琥珀念珠</td><td>宝箱获取</td><td>第五章从土地庙“灰烬台”出发进门下坡，到洞内后直接向右出去开箱</td><td>1</td></tr><tr><td>金棕衣</td><td>怪物必定掉落</td><td>第三章击杀长生大道的焦面鬼王（巨妖）必定掉落（大殿的不行），一共两只，一只从长生大道土地庙回头的路上，一只往前走向左贴墙走到头</td><td>3</td></tr><tr><td>博山炉</td><td>宝箱获取</td><td>第一章赤髯龙 BOSS 战场地开宝箱获得</td><td>1</td></tr><tr><td>不求人</td><td>商店购买</td><td>完成第一章后，在第一章的土地庙中购买</td><td>3</td></tr><tr><td>吉祥灯</td><td>怪物必定掉落</td><td>第三章浮屠界土地庙“下层”至“轮藏”前的路线，期间有 9 个掌灯御史，全部击杀获得（但是如果先行击杀 BOSS 魔将•妙音，剩余未被击杀的掌灯御史会消失！）</td><td>1</td></tr><tr><td>兽与佛</td><td>怪物概率掉落</td><td>第三章击杀双刀僧概率掉落，推荐小雷音寺寺门进门门口一个</td><td>3</td></tr><tr><td>铜佛坠</td><td>怪物概率掉落</td><td>第三章击杀狼护法（圆刃的黄袍小妖）概率掉落，推荐从快活林土地庙出发，通往长生大道土地庙的红色殿门处，会从上方突然袭击下来的两只</td><td>3</td></tr><tr><td>雷火印</td><td>怪物概率掉落</td><td>第三章雷长老和第五章火长老概率掉落，推荐小雷音寺寺门进入刷，或者从翠云殿回头击杀，平台有 2 个，从走廊左侧岩浆穿过后有 2 个，共 4</td><td>3</td></tr><tr><td>君子牌</td><td>怪物概率掉落</td><td>第五章击杀虫羽士概率掉落，推荐黄花观观门土地庙上楼右侧进门院子，共 12 只</td><td>3</td></tr><tr><td>卵中骨</td><td>地图内概率掉落</td><td>第四章盘丝洞区域大量分布的可破坏卵球概率掉落</td><td>3</td></tr><tr><td>白贝腰链</td><td>怪物概率掉落</td><td>第五章许多地方都有分布的红皮敌怪（牛侍长，牛校尉，牛力士）概率掉落，推荐罗刹宫土地庙</td><td>3</td></tr><tr><td>细磁茶盂</td><td>宝箱获取</td><td>第三章从土地庙“下层”出发沿路推进到尽头，继续前进是上楼梯，在楼梯下开箱获得</td><td>3</td></tr><tr><td>猫睛宝串</td><td>BOSS 战奖励</td><td>第一章幽魂 BOSS 战奖励</td><td>3</td></tr><tr><td>玛瑙罐</td><td>宝箱获取</td><td>第一章黑风大王 BOSS 战场地继续往前走一点距离，左侧香炉内</td><td>3</td></tr><tr><td>虎头牌</td><td>BOSS 战奖励</td><td>第二章隐藏斯哈哩国区域的虎先锋 BOSS 战奖励</td><td>1</td></tr><tr><td>砗磲佩</td><td>宝箱获取</td><td>第二章小骊龙 BOSS 战场地右侧上楼梯，高处宝箱内</td><td>1</td></tr><tr><td>琉璃舍利瓶</td><td>宝箱获取</td><td>第二章虎伥 BOSS 战场地后洞内开箱</td><td>3</td></tr><tr><td>风铎</td><td>预购奖励</td><td>豪华版预购奖励（不纳入全珍玩收集成就统计）</td><td>1</td></tr><tr><td>白狐毫</td><td>任务获得</td><td>第三章完成 NPC 狐妖的任务获得</td><td>3</td></tr><tr><td>三清令</td><td>宝箱获取</td><td>虫总兵 BOSS 战场地开箱</td><td>1</td></tr><tr><td>金钮</td><td>怪物概率掉落</td><td>第五章击杀海罗刹（罗刹宫的火焰巨妖）掉落 ，多周目不会重复掉落</td><td>1</td></tr><tr><td>耐雪枝</td><td>BOSS 战奖励</td><td>第三章魔将•莲眼 BOSS 战奖励</td><td>3</td></tr><tr><td>阳燧珠</td><td>BOSS 战奖励</td><td>第五章赤金战车 BOSS 战奖励</td><td>3</td></tr><tr><td>错金银带钩</td><td>宝箱获取</td><td>第四章从土地庙“上层”往回走到尽头开箱</td><td>3</td></tr><tr><td>雷榍</td><td>宝箱获取</td><td>从土地庙”寺门“出发走主路，穿过殿后，正前方高处第二座殿内开箱获得</td><td>3</td></tr><tr><td>摩尼珠</td><td>怪物概率掉落</td><td>第三章中小西天和浮屠界分布的假装雕像的敌怪概率掉落</td><td>1</td></tr></tbody></table><h4 id="概率掉落整理"><a href="#概率掉落整理" class="headerlink" title="概率掉落整理"></a>概率掉落整理</h4><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th><th>最大获得数量</th><th>个人收集情况</th></tr></thead><tbody><tr><td>虎筋绦子</td><td>怪物概率掉落</td><td>第四章击杀蛇捕头(虎头妖)概率掉落，推荐金光院土地庙往回走出门左边水池有一只</td><td>1</td><td></td></tr><tr><td>兽与佛</td><td>怪物概率掉落</td><td>第三章击杀双刀僧概率掉落，推荐小雷音寺寺门进门门口一个</td><td>3</td><td></td></tr><tr><td>铜佛坠</td><td>怪物概率掉落</td><td>第三章击杀狼护法（圆刃的黄袍小妖）概率掉落，推荐从快活林土地庙出发，通往长生大道土地庙的红色殿门处，会从上方突然袭击下来的两只</td><td>3</td><td></td></tr><tr><td>雷火印</td><td>怪物概率掉落</td><td>第三章雷长老和第五章火长老概率掉落，推荐小雷音寺寺门进入刷，或者从翠云殿回头击杀，平台有 2 个，从走廊左侧岩浆穿过后有 2 个，共 4</td><td>3</td><td>2</td></tr><tr><td>君子牌</td><td>怪物概率掉落</td><td>第五章击杀虫羽士概率掉落，推荐黄花观观门土地庙上楼右侧进门院子，共 12 只</td><td>3</td><td></td></tr><tr><td>卵中骨</td><td>地图内概率掉落</td><td>第四章盘丝洞区域大量分布的可破坏卵球概率掉落</td><td>3</td><td>3</td></tr><tr><td>白贝腰链</td><td>怪物概率掉落</td><td>第五章许多地方都有分布的红皮敌怪（牛侍长，牛校尉，牛力士）概率掉落，推荐罗刹宫土地庙</td><td>3</td><td></td></tr><tr><td>金钮</td><td>怪物概率掉落</td><td>第五章击杀海罗刹（罗刹宫的火焰巨妖）掉落 ，多周目不会重复掉落</td><td>1</td><td>1</td></tr><tr><td>摩尼珠</td><td>怪物概率掉落</td><td>第三章中小西天和浮屠界分布的假装雕像的敌怪概率掉落</td><td>1</td><td>1</td></tr></tbody></table><h3 id="附录8：全泡酒物列表（78难）"><a href="#附录8：全泡酒物列表（78难）" class="headerlink" title="附录8：全泡酒物列表（78难）"></a>附录8：全泡酒物列表（78难）</h3><p>共27个</p><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2404446025901796259/75375E25563435C1C3550D8FE39E9B98098DA5DD/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th><th>最大获取数量</th></tr></thead><tbody><tr><td>百花蕤</td><td>商店购买</td><td>第六章 NPC 申猴出售</td><td>1</td></tr><tr><td>净瓶<br>柳叶</td><td>商店购买</td><td>二周目 NPC 申猴出售</td><td>1</td></tr><tr><td>龟泪</td><td>任务获得</td><td>与蛇骨的头骨互动后，再返回龟将正下方发绿光处拾取</td><td>1</td></tr><tr><td>困龙须</td><td>宝箱获取</td><td>第三章亢金龙 BOSS 战场地右后方跨湖，一处岸边枯树下的香炉</td><td>1</td></tr><tr><td>血杞子</td><td>宝箱获取</td><td>第四章从土地庙“上层”出发向左侧沿楼梯上行进屋的香炉</td><td>1</td></tr><tr><td>十二重楼胶</td><td>宝箱获取</td><td>第三章青背龙 BOSS 战场地旁边宝箱内</td><td>1</td></tr><tr><td>铜丸</td><td>宝箱获取</td><td>第二章从虎先锋 BOSS 战场地向无头雕像后方继续前进，到定风桥土地庙途中的香炉内</td><td>1</td></tr><tr><td>灵台<br>药苗</td><td>宝箱获取</td><td>第五章春秋寨土地庙继续前进的必经之路上，第三座桥前的香炉</td><td>1</td></tr><tr><td>瞌睡<br>虫蜕</td><td>宝箱获取</td><td>第五章守炉道士&amp;阴阳鱼 BOSS 战场地，面对座位方向，左侧外围香炉</td><td>1</td></tr><tr><td>蕙性兰</td><td>任务获取</td><td>如意画卷中将全部 15 种草药种子都交付给 NPC 辰龙</td><td>1</td></tr><tr><td>瑶池<br>莲子</td><td>商店购买</td><td>第一章 NPC 申猴出售</td><td>3</td></tr><tr><td>不老藤</td><td>怪物随机掉落</td><td>第四章隐藏击杀青冉冉（树人）概率掉落，推荐落花庄土地庙回头出门，岔路两侧一边一个</td><td>3</td></tr><tr><td>虎舍利</td><td>宝箱获取</td><td>第二章从寺门土地庙跳入地窖入口后前进，向下滑行的位置，可看到前方平台的香炉，滑到一半高跳（跳跃+重攻击）登上</td><td>3</td></tr><tr><td>梭罗<br>琼芽</td><td>宝箱获取</td><td>第二章从村口土地庙抵达有几个紫色大鼠妖的场地，右侧佛像处（沙国王父子 Boss 战大门前右侧</td><td>3</td></tr><tr><td>倒马<br>毒钩</td><td>怪物必定掉落</td><td>第四章从土地庙“花间桥”继续出发，走左侧岔路后，不进右侧院门而走左侧路口下去，穿过吊袋蛛群后走左侧岔路可抵达一个院子，击杀“院子”内冒蓝光的蝎太子掉落</td><td>1</td></tr><tr><td>紫纹<br>缃核</td><td>宝箱获取</td><td>第四章从土地庙“花间桥”继续出发，走左侧岔路后进右侧藏宝院开箱</td><td>1</td></tr><tr><td>峰山<br>石髓</td><td>宝箱获取</td><td>第四章土地庙“山道”继续前进可看到左前方高处石栏杆，该平台上的香炉</td><td>1</td></tr><tr><td>铁弹</td><td>商店购买</td><td>第二章 NPC 石中人出售</td><td>1</td></tr><tr><td>清虚<br>道果</td><td>怪物随机掉落</td><td>第四章在黄花观和紫云山场景中许多地方都有分布的拿拂尘的黄袍道人概率掉落</td><td>1</td></tr><tr><td>双冠血</td><td>BOSS 战奖励</td><td>第四章隐藏晦月魔君 BOSS 战奖励</td><td>1</td></tr><tr><td>嫩玉藕</td><td>采集随机掉落</td><td>全游戏许多场景都有的水上莲藕采集概率获得</td><td>3</td></tr><tr><td>铁骨<br>银参</td><td>采集随机掉落</td><td>第一章中许多地方都有的人参采摘概率获得</td><td>3</td></tr><tr><td>青山骨</td><td>采集随机掉落</td><td>第一章中许多地方都有的甘草采摘概率获得</td><td>3</td></tr><tr><td>胆中珠</td><td>任务获取</td><td>第一章从土地庙“白雾泽”出发，击杀栈桥上的蛇妖救出申猴获得</td><td>3</td></tr><tr><td>霹雳角</td><td>商店购买</td><td>第三章 NPC 申猴出售</td><td>3</td></tr><tr><td>甜雪</td><td>宝箱获取</td><td>从土地庙”寺门“出发走主路，穿过殿后向右走进右侧院门（中央一个泥塑金刚）后，右侧高处亭内</td><td>3</td></tr><tr><td>火焰<br>丹头</td><td>怪物随机掉落</td><td>第五章许多地方都有分布的火岩敌怪概率掉落，同时可采集火枣概率掉落。推荐从谷口出发一路刷石头，至燧统领处采集 4 颗火枣</td><td>3</td></tr></tbody></table><h4 id="概率掉落整理-1"><a href="#概率掉落整理-1" class="headerlink" title="概率掉落整理"></a>概率掉落整理</h4><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th><th>最大获取数量</th><th>个人收集情况</th></tr></thead><tbody><tr><td>不老藤</td><td>怪物随机掉落</td><td>第四章隐藏击杀青冉冉（树人）概率掉落，推荐落花庄土地庙回头出门，岔路两侧一边一个</td><td>3</td><td></td></tr><tr><td>清虚<br>道果</td><td>怪物随机掉落</td><td>第四章在黄花观和紫云山场景中许多地方都有分布的拿拂尘的黄袍道人概率掉落</td><td>1</td><td></td></tr><tr><td>嫩玉藕</td><td>采集随机掉落</td><td>全游戏许多场景都有的水上莲藕采集概率获得</td><td>3</td><td></td></tr><tr><td>铁骨<br>银参</td><td>采集随机掉落</td><td>第一章中许多地方都有的人参采摘概率获得</td><td>3</td><td></td></tr><tr><td>青山骨</td><td>采集随机掉落</td><td>第一章中许多地方都有的甘草采摘概率获得</td><td>3</td><td></td></tr><tr><td>火焰<br>丹头</td><td>怪物随机掉落</td><td>第五章许多地方都有分布的火岩敌怪概率掉落，同时可采集火枣概率掉落。推荐从谷口出发一路刷石头，至燧统领处采集 4 颗火枣</td><td>3</td><td>1</td></tr></tbody></table><h3 id="附录9：全防具列表（79难）"><a href="#附录9：全防具列表（79难）" class="headerlink" title="附录9：全防具列表（79难）"></a>附录9：全防具列表（79难）</h3><p><strong>由于防具可以升阶，各个玩家的顺序有些差别，本指南按照全满级默认顺序排列</strong></p><h4 id="头冠-共19个"><a href="#头冠-共19个" class="headerlink" title="头冠 共19个"></a>头冠 共19个</h4><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2411201949261977483/07341568548BED06E41D7BC3C25F0825AB5C9C62/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th></tr></thead><tbody><tr><td>凤翅紫金冠</td><td>BOSS 奖励</td><td>第六章凤翅将军 BOSS 战奖励</td></tr><tr><td>大力王面</td><td>铸造获得</td><td>大力套装，第五章隐藏击杀 BOSS 壁水金睛兽后解锁配方，务必单周目收集全 4 个大力铁角材料，可在两周目全部铸造完毕</td></tr><tr><td>厌火夜叉面</td><td>铸造获得</td><td>厌火套装，第五章击败 BOSS 红孩儿&amp;夜叉王后解锁配方</td></tr><tr><td>玄铁双角盔</td><td>铸造获得</td><td>玄铁套装，如意画卷向 NPC 寅虎发起挑战获胜解锁配方</td></tr><tr><td>不净残面</td><td>铸造获得</td><td>不净套装，第四章击败 BOSS 猪八戒后解锁配方</td></tr><tr><td>羽士云笠</td><td>铸造获得</td><td>羽士套装，第四章击杀 BOSS 百眼魔君后解锁配方</td></tr><tr><td>金身怒目面</td><td>铸造获得</td><td>金身套装，第三章击败 BOSS 黄眉后解锁配方</td></tr><tr><td>藏风兽面</td><td>铸造获得</td><td>藏风套装，第二章击败 BOSS 石先锋解锁配方</td></tr><tr><td>昆蚑佛笠</td><td>铸造获得</td><td>昆蚑套装，第二章隐藏击败 BOSS 蝜蝂解锁配方</td></tr><tr><td>青铜猴面</td><td>铸造获得</td><td>青铜套装，第一章隐藏击败 BOSS 金池长老后解锁配方</td></tr><tr><td>行者戒箍</td><td>铸造获得</td><td>行者套装，第一章抵达土地庙“观音禅院”后解锁防具铸造功能的同时解锁配方</td></tr><tr><td>百戏傩面</td><td>豪华版奖励</td><td>百戏套装，豪华版初始奖励，不计入成就</td></tr><tr><td>地灵伞盖</td><td>BOSS 战奖励</td><td>第五章面对土地庙“火燎三关”向右，九叶灵芝精 BOSS 战奖励</td></tr><tr><td>鳖宝头骨</td><td>怪物随机掉落</td><td>第三章和第五章中的鳖宝（大锤老鼠）随机掉落，推荐第五章灰烬台土地庙前进，不进门直走到头有一只</td></tr><tr><td>长须头面</td><td>怪物随机掉落</td><td>第四章蜢虫精随机掉落，推荐第四章花间桥向后第一个卵中就有一只</td></tr><tr><td>闭眼禅</td><td>怪物随机掉落</td><td>第三章监院僧（蒙眼僧）随机掉落，推荐第三章寺门出发进入，到大广场先右后左并上楼</td></tr><tr><td>长嘴脸</td><td>BOSS 战奖励</td><td>第二章黄袍员外 BOSS 战奖励</td></tr><tr><td>白脸子</td><td>BOSS 战奖励</td><td>第一章灵虚子 BOSS 战奖励</td></tr><tr><td>凤翅紫金冠（凡品）</td><td>宝箱获取</td><td>凡品大圣套，第六章青嶂道土地庙，从王灵官 BOSS 战场地往回飞，中间视野所见的粗斜树干下</td></tr></tbody></table><br><h4 id="衣甲-共20个"><a href="#衣甲-共20个" class="headerlink" title="衣甲 共20个"></a>衣甲 共20个</h4><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2411201949261897634/197225F7FD31E1F18B8E939B7864332A4E5024E4/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th></tr></thead><tbody><tr><td>锁子黄金甲</td><td>BOSS 奖励</td><td>第六章金甲犀 BOSS 战奖励</td></tr><tr><td>大力山文甲</td><td>铸造获得</td><td>大力套装，第五章隐藏击杀 BOSS 壁水金睛兽后解锁配方，务必单周目收集全 4 个大力铁角材料，可在两周目全部铸造完毕</td></tr><tr><td>厌火绣衫</td><td>铸造获得</td><td>厌火套装，第五章击败 BOSS 红孩儿&amp;夜叉王后解锁配方</td></tr><tr><td>玄铁征战袍</td><td>铸造获得</td><td>玄铁套装，如意画卷向 NPC 寅虎发起挑战获胜解锁配方</td></tr><tr><td>不净盘龙甲</td><td>铸造获得</td><td>不净套装，第四章击败 BOSS 猪八戒后解锁配方</td></tr><tr><td>羽士戗金甲</td><td>铸造获得</td><td>羽士套装，第四章击杀 BOSS 百眼魔君后解锁配方</td></tr><tr><td>金身绣衫</td><td>铸造获得</td><td>金身套装，第三章击败 BOSS 黄眉后解锁配方</td></tr><tr><td>龙鳞战袍</td><td>铸造获得</td><td>龙鳞套装，第三章击败 BOSS 亢金星君后解锁配方</td></tr><tr><td>赭黄战袍</td><td>铸造获得</td><td>赭黄套装，第二章击败 BOSS 黄风大圣后解锁配方</td></tr><tr><td>藏风兽吞铠</td><td>铸造获得</td><td>藏风套装，第二章击败 BOSS 石先锋解锁配方</td></tr><tr><td>昆蚑毒敌甲</td><td>铸造获得</td><td>昆蚑套装，第四章隐藏击败 BOSS 毒敌大王解锁配方</td></tr><tr><td>乌金皂罗袍</td><td>铸造获得</td><td>乌金套装，第一章击败 BOSS 黑熊精解锁配方</td></tr><tr><td>锦鳞战袍</td><td>铸造获得</td><td>锦鳞套装，第一章击败 BOSS 白衣秀士解锁配方</td></tr><tr><td>青铜锦征袍</td><td>铸造获得</td><td>青铜套装，第一章隐藏击败 BOSS 金池长老后解锁配方</td></tr><tr><td>行者直䄌(duo)</td><td>铸造获得</td><td>行者套装，第一章抵达土地庙“观音禅院”后解锁防具铸造功能的同时解锁配方</td></tr><tr><td>百戏衬钱衣</td><td>豪华版奖励</td><td>百戏套装，豪华版初始奖励，不计入成就</td></tr><tr><td>阴阳法衣</td><td>BOSS 战奖励</td><td>第五章守炉道士&amp;阴阳鱼 BOSS 战奖励</td></tr><tr><td>山珍蓑衣</td><td>BOSS 战奖励</td><td>第三章老人参精 BOSS 战奖励</td></tr><tr><td>锁子黄金甲（凡品）</td><td>宝箱获取</td><td>凡品大圣套，第六章青嶂道土地庙，从王灵官 BOSS 战场地往回飞，中间视野所见的粗斜树干下</td></tr><tr><td>虎皮裙</td><td>初始拥有</td><td>初始道具</td></tr></tbody></table><br><h4 id="臂甲-共21个"><a href="#臂甲-共21个" class="headerlink" title="臂甲 共21个"></a>臂甲 共21个</h4><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2411201949262192041/897CFACD3290E2AAB90E1082633F90856ED990C3/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th></tr></thead><tbody><tr><td>点翠飞龙釬</td><td>BOSS 奖励</td><td>第六章碧臂螂 BOSS 战奖励</td></tr><tr><td>大力臂甲</td><td>铸造获得</td><td>大力套装，第五章隐藏击杀 BOSS 壁水金睛兽后解锁配方，务必单周目收集全 4 个大力铁角材料，可在两周目全部铸造完毕</td></tr><tr><td>厌火魔手</td><td>铸造获得</td><td>厌火套装，第五章击败 BOSS 红孩儿&amp;夜叉王后解锁配方</td></tr><tr><td>玄铁硬手</td><td>铸造获得</td><td>玄铁套装，如意画卷向 NPC 寅虎发起挑战获胜解锁配方</td></tr><tr><td>不净护釬</td><td>铸造获得</td><td>不净套装，第四章击败 BOSS 猪八戒后解锁配方</td></tr><tr><td>羽士刺釬</td><td>铸造获得</td><td>羽士套装，第四章击杀 BOSS 百眼魔君后解锁配方</td></tr><tr><td>金身护臂</td><td>铸造获得</td><td>金身套装，第三章击败 BOSS 黄眉后解锁配方</td></tr><tr><td>龙鳞臂甲</td><td>铸造获得</td><td>龙鳞套装，第三章击败 BOSS 亢金星君后解锁配方</td></tr><tr><td>赭黄臂甲</td><td>铸造获得</td><td>赭黄套装，第二章击败 BOSS 黄风大圣后解锁配方</td></tr><tr><td>藏风护臂</td><td>铸造获得</td><td>藏风套装，第二章击败 BOSS 石先锋解锁配方</td></tr><tr><td>昆蚑刺手</td><td>铸造获得</td><td>昆蚑套装，第二章隐藏击败 BOSS 蝜蝂解锁配方</td></tr><tr><td>乌金臂鞲(gou)</td><td>铸造获得</td><td>乌金套装，第一章击败 BOSS 黑熊精解锁配方</td></tr><tr><td>锦鳞护臂</td><td>铸造获得</td><td>锦鳞套装，第一章击败 BOSS 白衣秀士解锁配方</td></tr><tr><td>青铜臂鞲</td><td>铸造获得</td><td>青铜套装，第一章隐藏击败 BOSS 金池长老后解锁配方</td></tr><tr><td>行者扎腕</td><td>铸造获得</td><td>行者套装，第一章抵达土地庙“观音禅院”后解锁防具铸造功能的同时解锁配方</td></tr><tr><td>百戏护手</td><td>豪华版奖励</td><td>百戏套装，豪华版初始奖励，不计入成就</td></tr><tr><td>下毒手</td><td>BOSS 概率掉落</td><td>第四章黑手道人部位破坏背后四只手后概率掉落，不可逆！</td></tr><tr><td>金刚护臂</td><td>怪物概率掉落</td><td>第三章击杀小雷音寺泥塑金刚概率掉落，推荐寺门出发右边小门前进，出大门直接高台跳下有一只</td></tr><tr><td>南海念珠</td><td>宝箱获取</td><td>第一章隐藏旧观音禅院土地庙所在院内开箱获得</td></tr><tr><td>点翠飞龙釬（凡品）</td><td>宝箱获取</td><td>凡品大圣套，第六章青嶂道土地庙，从王灵官 BOSS 战场地往回飞，中间视野所见的粗斜树干下</td></tr><tr><td>锦布扎腕</td><td>初始拥有</td><td>初始道具</td></tr></tbody></table><br><h4 id="腿甲-共18个"><a href="#腿甲-共18个" class="headerlink" title="腿甲 共18个"></a>腿甲 共18个</h4><p><img src="https://steamuserimages-a.akamaihd.net/ugc/2411201949262330291/B76B8D214E046F6B7458C58E798BC6F3D710C556/"></p><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th></tr></thead><tbody><tr><td>藕丝步云履</td><td>BOSS 奖励</td><td>第六章步云鹿 BOSS 战奖励</td></tr><tr><td>大力胫甲</td><td>铸造获得</td><td>大力套装，第五章隐藏击杀 BOSS 壁水金睛兽后解锁配方，务必单周目收集全 4 个大力铁角材料，可在两周目全部铸造完毕</td></tr><tr><td>厌火魔足</td><td>铸造获得</td><td>厌火套装，第五章击败 BOSS 红孩儿&amp;夜叉王后解锁配方</td></tr><tr><td>玄铁硬足</td><td>铸造获得</td><td>玄铁套装，如意画卷向 NPC 寅虎发起挑战获胜解锁配方</td></tr><tr><td>不净泥足</td><td>铸造获得</td><td>不净套装，第四章击败 BOSS 猪八戒后解锁配方</td></tr><tr><td>羽士护腿</td><td>铸造获得</td><td>羽士套装，第四章击杀 BOSS 百眼魔君后解锁配方</td></tr><tr><td>金身护腿</td><td>铸造获得</td><td>金身套装，第三章击败 BOSS 黄眉后解锁配方</td></tr><tr><td>龙鳞胫甲</td><td>铸造获得</td><td>龙鳞套装，第三章击败 BOSS 亢金星君后解锁配方</td></tr><tr><td>赭黄胫甲</td><td>铸造获得</td><td>赭黄套装，第二章击败 BOSS 黄风大圣后解锁配方</td></tr><tr><td>藏风护腿</td><td>铸造获得</td><td>藏风套装，第二章击败 BOSS 石先锋解锁配方</td></tr><tr><td>昆蚑刺足</td><td>铸造获得</td><td>昆蚑套装，第二章隐藏击败 BOSS 蝜蝂解锁配方</td></tr><tr><td>乌金行缠</td><td>铸造获得</td><td>乌金套装，第一章击败 BOSS 黑熊精解锁配方</td></tr><tr><td>锦鳞行缠</td><td>铸造获得</td><td>锦鳞套装，第一章击败 BOSS 白衣秀士解锁配方</td></tr><tr><td>青铜吊腿</td><td>铸造获得</td><td>青铜套装，第一章隐藏击败 BOSS 金池长老后解锁配方</td></tr><tr><td>行者腿绷</td><td>铸造获得</td><td>行者套装，第一章抵达土地庙“观音禅院”后解锁防具铸造功能的同时解锁配方</td></tr><tr><td>百戏吊腿</td><td>豪华版奖励</td><td>百戏套装，豪华版初始奖励，不计入成就</td></tr><tr><td>藕丝步云履（凡品）</td><td>宝箱获取</td><td>凡品大圣套，第六章青嶂道土地庙，从王灵官 BOSS 战场地往回飞，中间视野所见的粗斜树干下</td></tr><tr><td>锦布腿绷</td><td>初始拥有</td><td>初始道具</td></tr></tbody></table><h4 id="概率掉落整理-2"><a href="#概率掉落整理-2" class="headerlink" title="概率掉落整理"></a>概率掉落整理</h4><table><thead><tr><th>名称</th><th>获得方式</th><th>获取地点</th><th>个人收集情况</th></tr></thead><tbody><tr><td>鳖宝头骨</td><td>怪物随机掉落</td><td>第三章和第五章中的鳖宝（大锤老鼠）随机掉落，推荐第五章灰烬台土地庙前进，不进门直走到头有一只</td><td>√</td></tr><tr><td>长须头面</td><td>怪物随机掉落</td><td>第四章蜢虫精随机掉落，推荐第四章花间桥向后第一个卵中就有一只</td><td>√</td></tr><tr><td>闭眼禅</td><td>怪物随机掉落</td><td>第三章监院僧（蒙眼僧）随机掉落，推荐第三章寺门出发进入，到大广场先右后左并上楼</td><td>√</td></tr><tr><td>金刚护臂</td><td>怪物概率掉落</td><td>第三章击杀小雷音寺泥塑金刚概率掉落，推荐寺门出发右边小门前进，出大门直接高台跳下有一只</td><td>√</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑神话：悟空 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】基础</title>
      <link href="/p/305331f0/"/>
      <url>/p/305331f0/</url>
      
        <content type="html"><![CDATA[<h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><h2 id="MySQL-执行流程是怎样的？"><a href="#MySQL-执行流程是怎样的？" class="headerlink" title="MySQL 执行流程是怎样的？"></a>MySQL 执行流程是怎样的？</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/mysql%25E6%259F%25A5%25E8%25AF%25A2%25E6%25B5%2581%25E7%25A8%258B.png" alt="查询语句执行流程"></p><p>可以看到，MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始，InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句。连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。</p><p>当你的账号或密码不正确时，会报 <code>Access denied for user</code> 错误，连接成功如果后续没有任何操作，那么这个连接就处于空闲状态，到达一定时间后它便会断开连接，这个时间一般是 8 小时，是由 <strong>wait_timeout</strong> 参数控制的。</p><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>连接器的工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（Query Cache）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>这么看，查询缓存还挺有用，但是其实<strong>查询缓存挺鸡肋</strong>的。</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p><p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><div class="note  flat info"><p>这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。</p></div><h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><p>在正式执行 SQL 查询语句之前，MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器会做如下两件事情。</p><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、where 条件等等。</p><p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。</p><p>但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7 和 8.0）得出结论是解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。</p><p>那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了。</p><h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>当然，我们本次的查询语句（select * from product where id &#x3D; 1）很简单，就是选择使用主键索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205611.png"></p><p>如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type &#x3D; ALL），这种查询扫描的方式是效率最低档次的。</p><p>这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205643.png"></p><p>这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from product where id &gt; 1  and name like &#x27;i%&#x27;;</span><br></pre></td></tr></table></figure><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p><p>在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。</p><p><img src="https://camo.githubusercontent.com/1e12ed50cb7447fce7914d30701cfcd44373d091298ec1c3d69ccb85d7131d24/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f73716c2545362538392541372545382541312538432545382542462538372545372541382538422f2545392538302538392545362538422541392545372542342541322545352542432539352e706e67" alt="img"></p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以数据行为单位的。</p><p>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程。</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from product where id = 1;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1 的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了。</p><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户端（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server 层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server 层）返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><p>至此，这个语句就执行完成了。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。</p><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205709.png"></p><p>现在有下面这条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_user  where age &gt; 20 and reward = 100000;</span><br></pre></td></tr></table></figure><p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题</a></p><p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p><p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward 列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li><li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward &#x3D; 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，<strong>节省了很多回表操作</strong>。</p><p>当你发现执行计划里的 Extra 部分显示了“Using index condition”，说明使用了索引下推。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205729.png"></p><br><h1 id="HAVING-子句是什么？"><a href="#HAVING-子句是什么？" class="headerlink" title="HAVING 子句是什么？"></a>HAVING 子句是什么？</h1><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><ul><li><p>Having子句的作用和WHERE子句差不多，都是用来做条件筛选的；</p></li><li><p>只是Having子句需要写在GROPY BY子句的后面；</p></li><li><p>GROPY BY 子句执行完毕之后，才会轮到Having子句去执行；自然Having子句的执行顺序是在WHERRE子句之后的，所以在Having子句中可以使用聚合函数做条件判断。</p></li></ul><h2 id="having-和-where-区别"><a href="#having-和-where-区别" class="headerlink" title="having 和 where 区别"></a>having 和 where 区别</h2><ul><li>having是对一个表的数据进行分组之后，对组信息进行相应条件筛选</li><li>having筛选时，只能根据select子句中可出现的字段（数据）来进行条件设定</li><li>having子句与where子句一样，都是用于条件判断</li><li>where是判断数据从磁盘读入内存的时候</li><li>having是判断分组统计之前的所有条件</li><li>having子句中可以使用字段别名，而where不能使用</li><li>having能够使用统计函数，而where不能使用</li></ul><h2 id="having-和-where-应用"><a href="#having-和-where-应用" class="headerlink" title="having 和 where 应用"></a>having 和 where 应用</h2><p>在 MySQL 中，HAVING 和 WHERE 是用于筛选数据的两个关键字，它们有以下用法：</p><p>用途：</p><ul><li><p>WHERE：WHERE 子句用于在执行查询之前筛选行。它可用于过滤 SELECT、UPDATE、DELETE 语句中的行，根据指定的条件选择要操作的数据行。</p></li><li><p>HAVING：HAVING 子句用于在执行聚合查询后筛选结果集。它仅能在包含聚合函数（如 SUM、COUNT、AVG 等）的 SELECT 语句中使用，并在查询结果进行聚合操作后，对聚合结果进行筛选。</p></li></ul><p>位置：</p><ul><li><p>WHERE：WHERE 子句通常出现在 SELECT、UPDATE、DELETE 语句的 FROM 子句之后、GROUP BY 子句之前。</p></li><li><p>HAVING：HAVING 子句通常出现在 GROUP BY 子句之后、ORDER BY 子句之前。</p></li></ul><p>过滤条件：</p><ul><li><p>WHERE：WHERE 子句用于指定过滤条件，其中可以使用比较操作符（如 &#x3D;, &lt;&gt;, &lt;, &gt;, BETWEEN, IN 等）和逻辑操作符（如 AND, OR, NOT）。</p></li><li><p>HAVING：HAVING 子句用于指定对聚合结果的过滤条件，其中可以使用比较操作符和逻辑操作符，也可以使用聚合函数。</p></li></ul><p>示例： 假设有一个名为 orders 的表，其中包含 customer_id（客户ID）和 total_price（总价格）字段。我们希望查找每个客户的总价格大于 100 的订单。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(total_price) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(total_price) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><br><h1 id="MySQL-一行记录是怎么存储的？"><a href="#MySQL-一行记录是怎么存储的？" class="headerlink" title="MySQL 一行记录是怎么存储的？"></a>MySQL 一行记录是怎么存储的？</h1><h2 id="MySQL-的数据存放在哪个文件？"><a href="#MySQL-的数据存放在哪个文件？" class="headerlink" title="MySQL 的数据存放在哪个文件？"></a>MySQL 的数据存放在哪个文件？</h2><p>大家都知道 MySQL 的数据都是保存在磁盘的，那具体是保存在哪个文件呢？</p><p>MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。</p><p>InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。</p><p>先来看看 MySQL 数据库的文件存放在哪个目录？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们每创建一个 database（数据库）都会在 <code>/var/lib/mysql/</code> 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205812.png"></p><p>然后，我们进入 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;my_test 目录，看看里面有什么文件？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xiaolin ~]#ls /var/lib/mysql/my_test</span><br><span class="line">db.opt  </span><br><span class="line">t_order.frm  </span><br><span class="line">t_order.ibd</span><br></pre></td></tr></table></figure><p>可以看到，共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后，MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p>好了，现在我们知道了一张数据库表的数据是保存在「表名字.ibd」的文件里的，这个文件也称为独占表空间文件。</p><h3 id="表空间文件的结构是怎么样的？"><a href="#表空间文件的结构是怎么样的？" class="headerlink" title="表空间文件的结构是怎么样的？"></a>表空间文件的结构是怎么样的？</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB 存储引擎的逻辑存储结构大致如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205834.png"></p><p>下面我们从下往上一个个看看。</p><h4 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。</p><h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章：<a href="https://xiaolincoding.com/mysql/index/page.html">换一个角度看 B+ 树</a></p><p>总之知道表中的记录存储在「数据页」里面就行。</p><h4 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h4><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机 I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><p>好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。</p><p>之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。</p><h2 id="InnoDB-行格式有哪些？"><a href="#InnoDB-行格式有哪些？" class="headerlink" title="InnoDB 行格式有哪些？"></a>InnoDB 行格式有哪些？</h2><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic 和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了，MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li></ul><p>Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。</p><p>所以，弄懂了 Compact 行格式，之后去了解其他行格式，很快也能看懂。</p><h2 id="COMPACT-行格式长什么样？"><a href="#COMPACT-行格式长什么样？" class="headerlink" title="COMPACT 行格式长什么样？"></a>COMPACT 行格式长什么样？</h2><p>先跟 Compact 行格式混个脸熟，它长这样：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205852.png"></p><p>可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p><h3 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h3><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p><h4 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h4><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><p>为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">  `phone` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;</span><br></pre></td></tr></table></figure><p>现在 t_user 表里有这三条记录：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205914.png"></p><p>接下来，我们看看看看这三条记录的行格式中的「变长字段长度列表」是怎样存储的。</p><p>先来看第一条记录：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「03 01」，而不是「01 03」。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205930.png"></p><p>同样的道理，我们也可以得出<strong>第二条记录</strong>的行格式中，「变长字段长度列表」里的内容是「04 02」，如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112205941.png"></p><p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112210014.png"></p><div class="note  flat info"><p>为什么「变长字段长度列表」的信息要按照逆序存放？</p></div><p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理，NULL 值列表的信息也需要逆序存放。</p><h4 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h4><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL 值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为 NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为 NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1 字节 8 位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><p>看看<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112210053.png"></p><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112210112.png"></p><div class="note  flat info"><p>每个数据库表的行格式都有「NULL 值列表」吗？</p></div><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><div class="note  flat info"><p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p></div><p>「NULL 值列表」的空间不是固定 1 字节的。</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><ul><li>delete_mask：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录</li></ul><h3 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h3><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112210129.png"></p><ul><li>row_id</li></ul><p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id 不是必需的，占用 6 个字节。</p><ul><li>trx_id</li></ul><p>事务 id，表示这个数据是由哪个事务生成的。trx_id 是必需的，占用 6 个字节。</p><ul><li>roll_pointer</li></ul><p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p><p>如果你熟悉 MVCC 机制，你应该就清楚 trx_id 和 roll_pointer 的作用了，如果你还不知道 MVCC 机制，可以看完<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">这篇文章</a>，一定要掌握，面试也很经常问 MVCC 是怎么实现的。</p><h2 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h2><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1 个字符要占用多少字节，比如 ascii 字符集，1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><h3 id="单字段的情况"><a href="#单字段的情况" class="headerlink" title="单字段的情况"></a>单字段的情况</h3><p>前面我们知道了，一行记录最大只能存储 65535 字节的数据。</p><p>那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下，varchar(n) 中 n 最大取值是 65535 吗？</p><p><strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和「NULL 值列表」所占用的字节数的</strong>。所以，我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><p>这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为 NULL，这部分不需要</li></ul><p>当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：</p><ul><li>在 UTF-8 字符集下，一个字符串最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li></ul><p>上面所说的只是针对于一个字段的计算方式。</p><h2 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h2><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p>当发生行溢出时，在记录的真实数据处只会<strong>保存该列的一部分数据</strong>，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20241112210150.png"></p><p>上面这个是 Compact 行格式在发生行溢出后的处理。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处<strong>不会存储该列的一部分数据</strong>，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><br><h1 id="MySQL-的存储引擎有哪些？它们之间有什么区别？"><a href="#MySQL-的存储引擎有哪些？它们之间有什么区别？" class="headerlink" title="MySQL 的存储引擎有哪些？它们之间有什么区别？"></a>MySQL 的存储引擎有哪些？它们之间有什么区别？</h1><p>在 MySQL 8.4 版本一共提供了 10 个引擎，每种引擎都有其特定的特性和用途，但相对而言比较常见的是以下几个：</p><table><thead><tr><th>特性</th><th>MyISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th><th>NDB</th></tr></thead><tbody><tr><td>B+树索引</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>备份&#x2F;按时间点恢复</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>集群数据库支持</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>聚簇索引</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>压缩数据</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>数据缓存</td><td>No</td><td>N&#x2F;A</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>加密数据</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>外键支持</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>全文检索</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>地理空间数据类型支持</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>地理空间索引支持</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>哈希索引</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>索引缓存</td><td>Yes</td><td>N&#x2F;A</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>锁的粒度</td><td>Table</td><td>Table</td><td>Row</td><td>Row</td><td>Row</td></tr><tr><td>MVCC</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>复制支持</td><td>Yes</td><td>Limited</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td><td>384EB</td></tr><tr><td>T-tree 索引</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>事务</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr></tbody></table><p>实际上我们仅需重点了解 InnoDB 和 MyISAM 即可，其它仅需有点印象即可。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>1）MyISAM 是基于 ISAM 引擎而来的，支持全文检索、数据压缩、空间函数，<strong>不支持事务和行级锁，只有表级别锁</strong>，它适用于 OLAP 场景，也就是分析类的，基本上都是读取，不会有什么写入动作的场景。</p><p>2）MyISAM 的索引也是 B+ 树，只是不像 InnoDB 那种叶子节点会存储完整的数据，MyISAM 的数据是独立于索引单独存储的，所以主键和非主键索引差别不大。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/L8OYQmWD_image.png"></p><p>3）MyISAM 不支持崩溃后的安全恢复，而 InnoDB 有个 redolog 可以支持安全恢复。</p><p>4）MyISAM 写入性能差。因为锁的粒度太粗了，不支持行锁，只有表锁，所以写入的时候会对整张表加锁。不过有个并发插入的开关，开启之后当数据中间没有空洞的时候，也就是插入的新数据是从末尾插入时，读取数据是不会阻塞的。</p><h2 id="InnoDB（MySQL-默认引擎）"><a href="#InnoDB（MySQL-默认引擎）" class="headerlink" title="InnoDB（MySQL 默认引擎）"></a>InnoDB（MySQL 默认引擎）</h2><p>1）InnoDB <strong>支持事务</strong>，实现了<strong>四种标准的隔离级别</strong>，利用 MVCC 来支持高并发，默认事务隔离级别为可重复读，支持行锁，利用行锁+间隙锁提供可重复读级别下防止幻读的能力，支持崩溃后的数据安全恢复。</p><p>2）支持外键，不过一般互联网项目都不会用外键的，性能太差，利用业务代码来实现约束即可。</p><p>3）由于 InnoDB 使用行级锁定和支持事务，因此在并发性能方面表现较好，特别是在多个用户同时对数据库进行读写操作时。</p><p>4）InnoDB 的主键索引称为聚簇索引，也就是<strong>数据和索引是放在一起的</strong>，这与 MyISAM 有所不同，并且它的辅助索引(非主键索引)只存储索引值与主键，因此当辅助索引不能覆盖查询的列时，需要通过找到的主键再去聚簇索引查询数据，这个过程称之为回表。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/yMAM6R4d_image.png"></p><h2 id="MyISAM-和-InnoDB-适用场景"><a href="#MyISAM-和-InnoDB-适用场景" class="headerlink" title="MyISAM 和 InnoDB 适用场景"></a>MyISAM 和 InnoDB 适用场景</h2><p>InnoDB 更适合需要高并发、事务处理和数据完整性保证的场景，例如电商平台、金融系统和社交网络等。</p><p>而 MyISAM 更适合读操作远多于写操作且对数据完整性要求不高的场景，例如内容管理系统、博客平台和报表系统等。</p><br><h1 id="为什么在-MySQL-中不推荐使用多表-JOIN？"><a href="#为什么在-MySQL-中不推荐使用多表-JOIN？" class="headerlink" title="为什么在 MySQL 中不推荐使用多表 JOIN？"></a>为什么在 MySQL 中不推荐使用多表 JOIN？</h1><p>这里的多表往往指的是超过三个表才是多表，正常两个表 join 是没问题的！（但是也需要评估下量级和是否命中索引）</p><p>阿里的 Java 规范手册里也有一句话：“超过三个表禁止使用 Join”。</p><p>这是为什么呢？</p><p>其实数据量小都无所谓。但当数据量大的时候，影响就被放大了。如果让数据库来承担这个复杂的关联操作，需要对联接的每个表进行扫描、匹配和组合，消耗大量的 CPU 和内存资源。让复杂的关联操作占用了大量的数据库资源，会影响其他查询修改操作。</p><p><strong>数据库往往是我们系统的弱点</strong>，很多情况下性能瓶颈都在数据库，<strong>因此我们需要尽量避免把压力放在数据库上</strong>。</p><br><h1 id="MySQL-中-DELETE、DROP-和-TRUNCATE-的区别是什么？"><a href="#MySQL-中-DELETE、DROP-和-TRUNCATE-的区别是什么？" class="headerlink" title="MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？"></a>MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？</h1><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><code>Delete</code> 用于删除行数据，但保留表结构和相关的对象。</p><p>本质上这个删除其实就是给数据行打个标记，并不实时删除，因此 delete 之后，空间的大小不会变化。</p><p>而且 delete 操作会生成 binlog、redolog 和 undolog，所以如果删除全表使用 delete 的话，性能会比较差！ 但是它可以回滚。</p><h2 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h2><p><code>Drop</code> 用于<strong>完全删除数据库表，包括数据和结构</strong>。</p><p>在 InnoDB 中，每张表数据内容和索引都存储在一个以 .ibd 后缀的文件中，drop 就是直接把这个文件给删除了！还有一个 .frm 后缀的文件也会被删除，这个文件包含表的元数据和结构定义。</p><p>文件都删了，所以这个操作无法回滚，表空间会被回收，但是如果表存在系统共享表空间，则不会回收空间。</p><p>默认创建的表会有独立表空间，把 <code>innodb_file_per_table</code> 的值改为 OFF 后，就会被放到共享表空间中，即统一的 ibdata1 文件中。</p><h2 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h2><p><code>Truncate</code> 只删除数据，不会删除表结构和索引等其他结构。</p><p><code>Truncate</code> 会对整张表的数据进行删除，且不会记录回滚等日志，所以它无法被回滚。</p><p>并且主键字段是自增的，使用 <code>Truncate</code> 删除后自增重新从 1 开始。</p><br><h1 id="MySQL-中-DATETIME-和-TIMESTAMP-类型的区别是什么？"><a href="#MySQL-中-DATETIME-和-TIMESTAMP-类型的区别是什么？" class="headerlink" title="MySQL 中 DATETIME 和 TIMESTAMP 类型的区别是什么？"></a>MySQL 中 DATETIME 和 TIMESTAMP 类型的区别是什么？</h1><h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><ul><li>DATETIME：存储的是具体的日期和时间，格式为 YYYY-MM-DD HH:MM:SS。它不依赖于时区信息，存储的是原始数据。</li><li>TIMESTAMP：存储的是自 1970-01-01 00:00:01 UTC 以来的秒数，格式为 YYYY-MM-DD HH:MM:SS。它依赖于时区信息，存储的是 UTC 时间。</li></ul><h2 id="时间范围"><a href="#时间范围" class="headerlink" title="时间范围"></a>时间范围</h2><ul><li>DATETIME：可以表示从 1000-01-01 00:00:00 到 9999-12-31 23:59:59 的时间范围。</li><li>TIMESTAMP：可以表示从 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC 的时间范围（32 位整数表示的限制）。</li></ul><h2 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h2><ul><li>DATETIME：不考虑时区，它存储的是输入的日期和时间值，不进行任何时区转换。</li><li>TIMESTAMP：考虑时区，它存储的是 UTC 时间，插入和检索时会根据当前时区进行转换。这意味着在不同的时区中，TIMESTAMP 类型的数据会自动调整以显示本地时间。</li></ul><h2 id="默认值和自动更新"><a href="#默认值和自动更新" class="headerlink" title="默认值和自动更新"></a>默认值和自动更新</h2><ul><li>DATETIME：在 MySQL 5.6 及更早版本中，DATETIME 列不能有自动更新的默认值。在 MySQL 5.6 及以后版本中，可以使用 DEFAULT 和 ON UPDATE 子句来指定自动初始化和更新行为，但不像 TIMESTAMP 那么直观。</li><li>TIMESTAMP：在 MySQL 5.6 及更高版本中，TIMESTAMP 列可以有默认的当前时间戳 CURRENT_TIMESTAMP，并且可以使用 ON UPDATE CURRENT_TIMESTAMP 使其在行更新时自动更新为当前时间戳。这使得 TIMESTAMP 非常适合记录行的创建和修改时间。</li></ul><br><h1 id="数据库的三大范式是什么？"><a href="#数据库的三大范式是什么？" class="headerlink" title="数据库的三大范式是什么？"></a>数据库的三大范式是什么？</h1><p>数据库的三大范式是数据库设计中常用的规范，它们的目的是<strong>减少数据冗余，提高数据的完整性和一致性</strong>，使得表的设计更清晰。</p><h2 id="第一范式（1NF）：规范化"><a href="#第一范式（1NF）：规范化" class="headerlink" title="第一范式（1NF）：规范化"></a>第一范式（1NF）：规范化</h2><p>定义：第一范式要求数据库表中的所有字段值必须是原子值，即每个字段值是不可再分的基本数据项。换句话说，表中的每一列都只包含单一值，不允许出现重复的列或多值列。</p><p>目的：确保数据表的每一列都是单一值，消除重复的列，从而保证数据的原子性。</p><p>例如地址作为一个字段，实际上可以拆分成省、市、区等，所以这就不符合第一范式。</p><h2 id="第二范式（2NF）：消除部分依赖"><a href="#第二范式（2NF）：消除部分依赖" class="headerlink" title="第二范式（2NF）：消除部分依赖"></a>第二范式（2NF）：消除部分依赖</h2><p>定义：在满足第一范式的基础上，第二范式要求所有非主键字段必须完全依赖于整个主键。</p><p>目的：消除非主键字段对主键部分依赖，从而避免数据冗余和更新异常。</p><p>例如 【员工ID、员工姓名、部门ID、部门名】 为一张表，员工 ID 为主键。此时，员工姓名依赖员工ID，部门名依赖部门ID，这就违反了第二范式。</p><p>符合范式的设计是：员工表【员工ID、员工姓名、部门ID】，部门表【部门ID、部门名】。</p><h2 id="第三范式（3NF）：消除传递依赖"><a href="#第三范式（3NF）：消除传递依赖" class="headerlink" title="第三范式（3NF）：消除传递依赖"></a>第三范式（3NF）：消除传递依赖</h2><p>定义：在满足第二范式的基础上，第三范式要求非主键字段必须直接依赖于主键，而不能通过其他非主键字段间接依赖于主键。</p><p>目的：消除非主键字段对主键的传递依赖，从而进一步减少数据冗余和更新异常。</p><p>例如 【员工ID、员工姓名、部门ID、部门名、经理ID】 为一张表，员工 ID 为主键。此时，经理 ID 依赖部门 ID，部门 ID 依赖员工ID，这说明有依赖传递，违反了第三范式。</p><p>符合范式的设计是：员工表【员工ID、员工姓名、部门ID】，部门表【部门ID、部门名、经理ID】。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>第一范式（1NF）：确保每一列都是原子值，即是不可分割的基础数据项。</li><li>第二范式（2NF）：在满足1NF的基础上，消除非主键字段对主键部分依赖。</li><li>第三范式（3NF）：在满足2NF的基础上，消除非主键字段对主键的传递依赖。</li></ul><p><strong>不过现在业务上的表设计基本都是反范式的</strong>。当然不是说完全不遵守范式，而是适当的进行调整。</p><p>比如业务上经常需要冗余字段，减少联表查询，提升性能，特别是业务量比较大的公司，这种冗余是很有必要的！</p><br><h1 id="MySQL-中-AUTO-INCREMENT-列达到最大值时会发生什么？"><a href="#MySQL-中-AUTO-INCREMENT-列达到最大值时会发生什么？" class="headerlink" title="MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？"></a>MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？</h1><p>先说结论：在 MySQL 中，<strong>如果表定义的自增 ID 到达上限后，再申请下一个 ID，得到的值不变！</strong></p><p>例如 int 是 4 个字节，上限是 2 的 32 次方 -1，即 2147483647，当到达这个值的之后，下次插入得到的还是这个值。</p><p>再列举下 AUTO_INCREMENT 列不同数据类型的最大值：</p><ul><li>对于 TINYINT（8位），最大值是 127（有符号）或 255（无符号）。</li><li>对于 SMALLINT（16位），最大值是 32,767（有符号）或 65,535（无符号）。</li><li>对于 MEDIUMINT（24位），最大值是 8,388,607（有符号）或 16,777,215（无符号）。</li><li>对于 INT（32位），最大值是 2,147,483,647（有符号）或 4,294,967,295（无符号）。</li><li>对于 BIGINT（64位），最大值是 9,223,372,036,854,775,807（有符号）或 18,446,744,073,709,551,615（无符号）。</li></ul><br><h1 id="在-MySQL-中存储金额数据，应该使用什么数据类型？"><a href="#在-MySQL-中存储金额数据，应该使用什么数据类型？" class="headerlink" title="在 MySQL 中存储金额数据，应该使用什么数据类型？"></a>在 MySQL 中存储金额数据，应该使用什么数据类型？</h1><p>在数据库中业界常用两种类型来存储金额：bigint 和 decimal。</p><p>1）bigint 代码中用 long。</p><ul><li>范围：可以存储的整数范围为 -2^63 到 2^63 - 1（在 MySQL 中为 64 位有符号整数）</li><li>存储空间：占用 8 字节（64 位）</li><li>精度：精确存储整数，但<strong>不支持小数部分</strong>，存储的金额单位是分</li></ul><p>2）decimal 代码中使用 BigDecimal。</p><ul><li>范围：可以存储的数字范围和小数位数由定义的精度和标度决定</li><li>存储空间：存储空间取决于定义的精度和标度，存储较大数值时会占用更多空间</li><li>精度：支持高精度的小数运算，精确存储定点数，一般用 decimal(18,6)，18 是总位数，6 是小数</li></ul><p>long 类型保存到分，使得小数位（厘）的数据不好处理（需要手动处理，比较麻烦），因此精度不够高。</p><p>在高精度金额计算场景下不合适，例如有些三方支付系统是需要抽成的，例如千分之三、万分之一等等，这类的抽成要求精度比较高，例如 会得到 1234.5678 这样的金额，乘以 100 后仍然无法存储为精确整数，还是小数，存储则会丢失精度。</p><p>0.0078 看似很少，但抽成的笔数一多，比如一天 30 万笔，每笔少个 0.0078，每天的差额也得 2340 元！一年不得 85 万！</p><p>所以<strong>高精度的计算不推荐使用 bigint</strong>。</p><p>BigDecimal 则很适用于高精度金额场景，且非常灵活，只不过相对于 long 性能会差一些，但是在大部分业务上我个人认为可以忽略这个性能问题，除非是特殊场景要求极端性能，所以一般情况下我推荐使用 decimal。</p><br><h1 id="什么是数据库的视图？"><a href="#什么是数据库的视图？" class="headerlink" title="什么是数据库的视图？"></a>什么是数据库的视图？</h1><p>视图是一种虚拟表，它是基于 SQL 查询结果的，它本身并不存储数据，而是<strong>存储 SQL 查询</strong>。</p><p>视图可以包含一个或多个表的数据，并且可以对这些数据进行筛选、计算、排序等操作。</p><p>它的作用如下：</p><ul><li>简化复杂查询：视图可以将复杂的查询封装成一个简单的视图，使得用户在查询数据时更加方便。</li><li>安全性：通过视图可以限制用户访问特定的表和列，保护敏感数据。例如，只允许用户查看某些列而不是整个表。</li><li>数据抽象：视图提供了一种数据抽象层，用户可以通过视图获取需要的数据，而不必关心底层表的结构和关系。</li><li>可重用性：定义一次视图，可以在多个查询中重复使用，减少代码冗余。</li></ul><br><h1 id="MySQL-中-EXISTS-和-IN-的区别是什么？"><a href="#MySQL-中-EXISTS-和-IN-的区别是什么？" class="headerlink" title="MySQL 中 EXISTS 和 IN 的区别是什么？"></a>MySQL 中 EXISTS 和 IN 的区别是什么？</h1><p>exists 和 in 都用于子查询，exists 检查子查询是否返回结果集，返回布尔值。in 检查某个值是否在子查询返回的结果集中，返回具体的值。</p><p>在性能上，由于两者机制的问题，在不同场景性能有所差异。</p><p>exists 的查询机制是<strong>循环外表</strong>，通过外表的每行数据去内表查询是否有匹配的值，<strong>一旦找到符合条件的记录，此次内表子查询就会停止执行</strong>。然后再通过下一个外表的值来查询，如此循环。所以它适合子查询中表比外表大且有索引的场景。</p><p>而 in 子查询在执行时会先执行子查询并生成结果集，然后将结果集与外部查询的列进行比较，所以它适合子查询记录少，且主查询表大有索引的场景。</p><p>简单总结：外层查询表量级小于子查询表，则用 exists，外层查询表量级大于子查询表，则用 in ，如果外层和子查询表差不多，则都行。建议具体情况还是以 explain 分析为主。</p><br><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E8%BF%9E%E6%8E%A5%E5%99%A8">执行一条 select 语句，期间发生了什么？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#mysql-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%87%E4%BB%B6">MySQL 一行记录是怎么存储的？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://blog.csdn.net/csucsgoat/article/details/115380747">数据库的高级查询四：Having子句（Having子句需要和GROUP BY子句结合，才能使用）_sql having必须和group by-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】JVM（二） | GC</title>
      <link href="/p/66be4b4/"/>
      <url>/p/66be4b4/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-中的内存泄漏通常发生在哪些场景？"><a href="#Java-中的内存泄漏通常发生在哪些场景？" class="headerlink" title="Java 中的内存泄漏通常发生在哪些场景？"></a>Java 中的内存泄漏通常发生在哪些场景？</h2><p>内存泄漏是指在程序运行过程中，已经<strong>不再使用的内存却没有被及时释放或回收</strong>，导致系统中的可用内存逐渐减少，最终可能导致系统性能下降，甚至引发系统崩溃。内存泄漏通常发生在程序中某些对象持续占用内存空间但又无法被正确释放的情况下。</p><h3 id="产生内存泄漏的场景"><a href="#产生内存泄漏的场景" class="headerlink" title="产生内存泄漏的场景"></a>产生内存泄漏的场景</h3><h4 id="未关闭的资源"><a href="#未关闭的资源" class="headerlink" title="未关闭的资源"></a>未关闭的资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 未在finally块中关闭文件流</span></span><br><span class="line">    <span class="comment">// 应该在此处调用fis.close()以释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="未正确释放对象引用"><a href="#未正确释放对象引用" class="headerlink" title="未正确释放对象引用"></a>未正确释放对象引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        list.add(obj); <span class="comment">// 每次循环创建新对象并添加到list中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处未调用list.clear()或将list置为null，导致list中的对象无法被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池导致的内存泄漏"><a href="#线程池导致的内存泄漏" class="headerlink" title="线程池导致的内存泄漏"></a>线程池导致的内存泄漏</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 程序结束后未调用executor.shutdown()，线程池资源未被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听器和回调函数未取消注册"><a href="#监听器和回调函数未取消注册" class="headerlink" title="监听器和回调函数未取消注册"></a>监听器和回调函数未取消注册</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ActionListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> e -&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">    &#125;;</span><br><span class="line">    listeners.add(listener); <span class="comment">// 添加监听器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序运行结束后未取消注册监听器，导致listener对象无法被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>两个或多个对象之间相互引用，导致彼此无法被回收。</p><h3 id="内存泄漏工具无法检测的场景"><a href="#内存泄漏工具无法检测的场景" class="headerlink" title="内存泄漏工具无法检测的场景"></a>内存泄漏工具无法检测的场景</h3><p>有些情况下，内存泄漏工具无法检测到内存泄漏，例如：</p><p>1）使用匿名对象。</p><p>2）使用内部类或匿名类。</p><h3 id="避免内存泄漏的建议"><a href="#避免内存泄漏的建议" class="headerlink" title="避免内存泄漏的建议"></a>避免内存泄漏的建议</h3><p>1）使用合理的变量作用域。</p><p>2）避免使用全局变量。</p><p>3）及时清理不使用的对象。</p><p>4）使用 try-with-resources 语句来关闭资源。</p><p>5）避免循环引用。</p><p>6）使用内存泄漏工具来检测和解决内存泄漏问题。</p><h2 id="如何在-Java-中进行内存泄漏分析？"><a href="#如何在-Java-中进行内存泄漏分析？" class="headerlink" title="如何在 Java 中进行内存泄漏分析？"></a>如何在 Java 中进行内存泄漏分析？</h2><p>先确认是否真的发生了内存泄漏，即观察内存使用情况。</p><p>利用 jstat 命令（<code>jstat -gc &lt;pid&gt; &lt;interval in ms&gt; </code>）来观察 gc 概要信息，如果发现 GC 后内存并没有明显的减少且还是持续增加持续触发 gc，那说明内存泄漏的概率很大。</p><p>此时可以利用 jmap（<code>jmap -dump:format=b,file=heapdump.hprof &lt;pid&gt;</code>）生成 heap dump，然后将其导入 Eclipse MAT 或者 VisualVM 工具内进行分析，通过大量内存的占用可以找到对应的对象。</p><p>通过对象找到对应的代码分析，确认是否可能存在内存泄漏的场景，最终修复代码，解决内存泄漏的问题。</p><h2 id="什么是垃圾回收GC？"><a href="#什么是垃圾回收GC？" class="headerlink" title="什么是垃圾回收GC？"></a>什么是垃圾回收GC？</h2><p>Java的垃圾回收（Garbage Collection, GC）是Java虚拟机（JVM）自动管理内存的一种机制。它的主要目的是自动回收不再使用的对象所占用的内存，以防止内存泄漏和优化内存使用。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/5b48c5872bdbac5871b543b14b0c6a8b.png"></p><h3 id="为什么要进行垃圾回收？"><a href="#为什么要进行垃圾回收？" class="headerlink" title="为什么要进行垃圾回收？"></a>为什么要进行垃圾回收？</h3><p>垃圾回收是对于 堆（Heap） 而言的，我们创建的对象或数组一般都是在 Heap 堆中。我们不能无限制的创建对象，同时不是所有对象都是需要一直存活，如果不进行垃圾回收，则内存迟早会被耗尽，因此及时的垃圾回收是有必要的。</p><h3 id="GC-的分类"><a href="#GC-的分类" class="headerlink" title="GC 的分类"></a>GC 的分类</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/hotspot-heap-structure.png" alt="堆内存结构"></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><h3 id="为什么要这样分？"><a href="#为什么要这样分？" class="headerlink" title="为什么要这样分？"></a>为什么要这样分？</h3><p>因为不同对象的生命周期不一样，大部分对象朝生夕死，而少部分一直存在堆中，所以按照存活时间分区管理更加高效。</p><p>也因为不同分区的生命周期不同，所以可以采用不同的清除算法来优化处理，像新生代的对象“死亡率”比较高，因此标记复制比较合适（大部分对象都消失了，把存活的复制到一边，死亡的全部清理即可）</p><p>而老年代的对象存活时间比较长，因此标记清除即可（存活对象比较多，整理或复制耗时比较长）</p><p>且分区后可以减少 GC 暂停的时间，你想想每次处理一个堆的数据，还是将堆分区处理来的快？</p><p>总而言之，分区是为了<strong>更高效地管理不同生命周期的对象</strong>。</p><h3 id="为什么-Java-新生代被划分为-S0、S1-和-Eden-区？"><a href="#为什么-Java-新生代被划分为-S0、S1-和-Eden-区？" class="headerlink" title="为什么 Java 新生代被划分为 S0、S1 和 Eden 区？"></a>为什么 Java 新生代被划分为 S0、S1 和 Eden 区？</h3><p>因为新生代对象朝生夕死的特性，适合复制算法。按正常思路将新生代一分为二，划两块区域，每次只使用其中一个，GC 后将存活的复制到另一个区域，然后清理老区域非存活对象，这样替换使用两块区域可以避免内存碎片的存在。</p><p>但如果一分为二的话，空间利用率只有一半了（每次分配对象只能占据一半的内存大小），这样不太划算。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/fnafB1VT_image.png"></p><p>基于这点，定义了三个区域，Eden 区和两个 Survivor 区，Eden 区 + 1 个 Survivor 区可以比二分之一大，提升利用率，默认 Eden 占 80% ，一个 Survivor 占 10%。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/pOLqfW0n_image.png"></p><p>然后利用两个 Survivor 来交替接收 gc 后存活的对象。</p><p>比如当前用 Eden + s0 两块区域，gc 的时候将存活的对象拷贝至 s1，然后清理 Eden 和 s0，接着使用 Eden + s1 作为新的对象分配区域。</p><p>后面 gc 后，把存活的对象拷贝至 s0，就这样往复使用两个 Survivor 区即可，这种划分手段就提升了内存的利用率。</p><p>并且程序可以根据自身的特性调整 Eden 区和 Survivor 区的比例，默认 8:1:1。</p><h3 id="如果单个-Survivor-放不下-GC-存活的对象怎么办？"><a href="#如果单个-Survivor-放不下-GC-存活的对象怎么办？" class="headerlink" title="如果单个 Survivor 放不下 GC 存活的对象怎么办？"></a>如果单个 Survivor 放不下 GC 存活的对象怎么办？</h3><p><strong>老年代兜底</strong>。</p><p>也就是说如果 Survivor 放不下存活的对象，那么超出的对象直接晋升到老年代。</p><p>如果老年代剩余的空间也放不下这些存活的对象怎么办？</p><p>如果是 CMS 垃圾回收器，则会触发 CMS 回收。如果 CMS 回收不足以回收足够的空间，会触发 Full GC（Serial Old 回收器）。</p><p>如果是 G1 垃圾回收器则会触发 Mixed GC。</p><h2 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h2><h3 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><div class="tabs" id="recycle"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#recycle-1">引用计数法</button></li><li class="tab"><button type="button" data-href="#recycle-2">可达性分析算法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="recycle-1"><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/object-circular-reference.png" alt="对象之间循环引用"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="recycle-2"><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/jvm-gc-roots.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h2 id="被标记为垃圾的对象一定会被回收吗"><a href="#被标记为垃圾的对象一定会被回收吗" class="headerlink" title="被标记为垃圾的对象一定会被回收吗"></a>被标记为垃圾的对象一定会被回收吗</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p><ul><li>第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；</li><li>第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。在 <code>finalize()</code> 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</li></ul><p>第二次标记成功的对象将真的会被回收，如果对象在 <code>finalize()</code> 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/copying-garbage-collection-algorithm.png" alt="复制算法"></p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法"></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><ul><li>新生代默认的空间占比总空间的 1&#x2F;3；</li><li>老生代的默认占比是 2&#x2F;3。</li></ul><p>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。</p><p>因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><p>分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li><li>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li></ul><p>老生代一般使用标记整理的执行算法：</p><ul><li>当空间占用到达某个值之后就会触发全局垃圾收回。</li></ul><p>以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h3 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><ul><li><strong>单线程</strong>收集器，适合小型应用和单处理器环境。</li><li>触发 <strong>Stop-The-World（STW）</strong>操作，所有应用线程在 GC 时暂停。</li><li>适用场景：适用于单线程应用和客户端模式。</li></ul><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ul><li>是 Serial 收集器的<strong>多线程</strong>版本，能够并行进行垃圾收集。</li><li>与 CMS 收集器配合使用时，通常会选择 ParNew 收集器作为新生代收集器。</li><li>适用场景：适用于多处理器环境，通常配合 CMS 收集器使用。</li></ul><h4 id="Parallel-Scavenge-收集器（吞吐量优先）"><a href="#Parallel-Scavenge-收集器（吞吐量优先）" class="headerlink" title="Parallel Scavenge 收集器（吞吐量优先）"></a>Parallel Scavenge 收集器（吞吐量优先）</h4><ul><li>也称为 “吞吐量收集器”，追求最大化 CPU 时间的利用率。</li><li>并行处理新生代垃圾回收，适合大规模后台任务处理，注重吞吐量而非延迟。</li><li>适用场景：适用于大规模运算密集型后台任务，适合对吞吐量要求较高的场景。</li></ul><h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul><li>Serial 收集器的老年代版本，使用<strong>标记-整理（Mark-Compact）算法</strong>进行垃圾回收。</li><li>适用场景：适合<strong>单线程</strong>环境和低内存使用场景，通常<strong>配合 Serial 收集器</strong>一起使用。</li></ul><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul><li>Parallel Scavenge 收集器的老年代版本，使用<strong>多线程并行标记-整理算法</strong>。</li><li>适用场景：适合大规模并行计算的场景，适用于高吞吐量要求的任务。</li></ul><h4 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark-Sweep）收集器"></a>CMS（Concurrent Mark-Sweep）收集器</h4><ul><li>并发标记-清除收集器，追求低延迟，减少 GC 停顿时间。</li><li>使用并发标记和清除算法，适合对响应时间有较高要求的应用。</li><li>缺点：<strong>可能会产生内存碎片</strong>，并且在并发阶段可能会发生 Concurrent Mode Failure，导致 Full GC。</li></ul><div class="note  flat info"><p>要是 CMS 运行期间预留的内存无法满足程序分配新对象的需要（<strong>当minor GC进行时，旧生代所剩下的空间小于Eden区域+From区域的空间，或者在CMS执行老年带的回收时有业务线程试图将大的对象放入老年带，导致CMS在老年带的回收慢于业务对象对老年带内存的分配</strong>）， 就会出现一次“并发失败”（Concurrent Mode Failure） ，就意味着此时 JVM 将继续采用 Stop-The-World 的方式来进行 Full GC，这种情况下，CMS 就没什么意义了。 所以参数 -XX：CMSInitiatingOccupancyFraction 设置得太高将会很容易导致大量的并发失败产生， 性能反而降低， 用户应在生产环境中根据实际应用情况来权衡设置。</p></div><ul><li>适用场景：适用于对响应时间要求高的应用，如 Web 服务和电商平台。</li></ul><h4 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage First）收集器"></a>G1（Garbage First）收集器</h4><ul><li>设计用于取代 CMS 的低延迟垃圾收集器，能够提供可预测的停顿时间。</li><li>通过分区来管理内存，并在垃圾收集时优先处理最有价值的区域，避免了 CMS 的内存碎片问题。</li><li>适用场景：适合大内存、多 CPU 服务器应用，尤其在延迟和响应时间敏感的场景中表现出色。</li></ul><h4 id="ZGC（Z-Garbage-Collector）收集器"><a href="#ZGC（Z-Garbage-Collector）收集器" class="headerlink" title="ZGC（Z Garbage Collector）收集器"></a>ZGC（Z Garbage Collector）收集器</h4><ul><li>低停顿、高吞吐量的垃圾收集器，停顿时间一般不会超过 10 毫秒。</li><li>适用场景：适用于需要管理大堆内存且对低延迟要求极高的应用。</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>它们之间的关系（连线代表可以搭配使用）：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/3bzFOHV8_image_mianshiya.png"></p><p>总结：</p><ul><li>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</li><li>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li></ul><h2 id="安全点是什么？"><a href="#安全点是什么？" class="headerlink" title="安全点是什么？"></a>安全点是什么？</h2><ol><li>从线程的角度，安全点是代码执行中的一些特殊位置，当线程执行到这些特殊的位置，如果此时在GC，那么在这个地方线程会暂停，直到GC结束。</li><li>GC的时候要挂起所有活动的线程，因此线程挂起，会选择在到达安全点的时候挂起。</li><li>安全点这个特殊的位置保存了线程上下文的全部信息。说白了，在进入安全点的时候打印日志信息能看出线程此刻都在干嘛。</li></ol><p>有关安全点的详细说明，请移步：<br><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/c79c5e02ebe6">JVM源码分析之安全点safepoint</a><br>[<a href="https://link.zhihu.com/?target=https://blog.csdn.net/lqp276/article/details/52249438">Java JVM] Hotspot GC研究- GC安全点 (Safepoint&amp;Stop The World)</a></p><h2 id="什么是STW-stop-the-world"><a href="#什么是STW-stop-the-world" class="headerlink" title="什么是STW(stop the world)"></a>什么是STW(stop the world)</h2><p>等待所有用户线程进入安全点后并阻塞，做一些全局性操作的行为。</p><h3 id="什么时候会STW？（换句话说什么时候会触发进入安全点？）"><a href="#什么时候会STW？（换句话说什么时候会触发进入安全点？）" class="headerlink" title="什么时候会STW？（换句话说什么时候会触发进入安全点？）"></a>什么时候会STW？（换句话说什么时候会触发进入安全点？）</h3><ul><li>Garbage collection pauses（垃圾回收）</li><li>JIT相关，比如Code deoptimization, Flushing <a href="https://zhida.zhihu.com/search?content_id=108559749&content_type=Article&match_order=1&q=code+cache&zhida_source=entity">code cache</a></li><li>Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation)</li><li>Biased lock revocation 取消偏向锁</li><li>Various debug operation (e.g. thread dump or deadlock check) dump 线程</li></ul><h2 id="如何对-Java-的垃圾回收进行调优？"><a href="#如何对-Java-的垃圾回收进行调优？" class="headerlink" title="如何对 Java 的垃圾回收进行调优？"></a>如何对 Java 的垃圾回收进行调优？</h2><p>GC 调优这种问题肯定是具体场景具体分析，但是在面试中就不要讲太细，大方向说清楚就行，不需要涉及具体的垃圾收集器比如 CMS 调什么参数，G1 调什么参数之类的。</p><p><strong>GC 调优的核心思路就是尽可能的使对象在年轻代被回收，减少对象进入老年代。</strong></p><p>具体调优还是得看场景根据 GC 日志具体分析，常见的需要关注的指标是 Young GC 和 Full GC 触发频率、原因、晋升的速率、老年代内存占用量等等。</p><p>比如发现频繁会产生 Full GC，分析日志之后发现没有内存泄漏，只是 Young GC 之后会有大量的对象进入老年代，然后最终触发 Ful GC。所以就能得知是 Survivor 空间设置太小，导致对象过早进入老年代，因此调大 Survivor 。</p><p>或者是晋升年龄设置的太小，也有可能分析日志之后发现是内存泄漏、或者有第三方类库调用了 System.gc 等等。</p><p>反正具体场景具体分析，<strong>核心思想就是尽量在新生代把对象给回收了。</strong></p><p>基本上这样答就行了，然后就等着面试官延伸了。</p><h2 id="如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？"><a href="#如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？" class="headerlink" title="如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？"></a>如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？</h2><h3 id="为什么会-OOM"><a href="#为什么会-OOM" class="headerlink" title="为什么会 OOM"></a>为什么会 OOM</h3><p>OOM 全称 “Out Of Memory”，表示内存耗尽。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个错误</p><p>为什么会出现 OOM，一般由这些问题引起</p><ol><li>分配过少：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理</li><li>代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽</li></ol><p><strong>内存泄漏</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</p><p><strong>内存溢出</strong>：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出</p><p>内存泄漏持续存在，最后一定会溢出，两者是因果关系</p><h3 id="常见的-OOM"><a href="#常见的-OOM" class="headerlink" title="常见的 OOM"></a>常见的 OOM</h3><p>比较常见的 OOM 类型有以下几种</p><h4 id="java-lang-OutOfMemoryError-PermGen-space"><a href="#java-lang-OutOfMemoryError-PermGen-space" class="headerlink" title="java.lang.OutOfMemoryError: PermGen space"></a>java.lang.OutOfMemoryError: PermGen space</h4><p>Java7 永久代（方法区）溢出，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。每当一个类初次加载的时候，元数据都会存放到永久代</p><p>一般出现于大量 Class 对象或者 JSP 页面，或者采用 CgLib 动态代理技术导致</p><p>我们可以通过 <code>-XX：PermSize</code> 和 <code>-XX：MaxPermSize</code> 修改方法区大小</p><h4 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h4><p><strong>虚拟机栈溢出</strong>，一般是由于程序中存在 <strong>死循环或者深度递归调用</strong> 造成的。如果栈大小设置过小也会出现溢出，可以通过 <code>-Xss</code> 设置栈的大小</p><p>虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法</p><h4 id="java-lang-OutOfMemoryError-Java-heap-space"><a href="#java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="java.lang.OutOfMemoryError: Java heap space"></a>java.lang.OutOfMemoryError: Java heap space</h4><p><strong>Java 堆内存溢出</strong>，溢出的原因一般由于 JVM 堆内存设置不合理或者内存泄漏导致</p><p>如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置</p><p>如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些</p><p>小结：方法区和虚拟机栈的溢出场景不在本篇过多讨论，下面主要讲解常见的 Java 堆空间的 OOM 排查思路</p><h3 id="Dump-文件分析"><a href="#Dump-文件分析" class="headerlink" title="Dump 文件分析"></a>Dump 文件分析</h3><p>Dump 文件是 Java 进程的内存镜像，其中主要包括 <strong>系统信息</strong>、<strong>虚拟机属性</strong>、<strong>完整的线程 Dump</strong>、<strong>所有类和对象的状态</strong> 等信息</p><p>当程序发生内存溢出或 GC 异常情况时，怀疑 JVM 发生了 <strong>内存泄漏</strong>，这时我们就可以导出 Dump 文件分析</p><p>JVM 启动参数配置添加以下参数</p><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li><li>-XX:HeapDumpPath&#x3D;.&#x2F;（参数为 Dump 文件生成路径）</li></ul><p>上面配置是在应用抛出 OOM 后自动导出 Dump，或者可以在 JVM 运行时导出 Dump 文件</p><h4 id="JvisualVM-分析"><a href="#JvisualVM-分析" class="headerlink" title="JvisualVM 分析"></a>JvisualVM 分析</h4><p>Dump 分析工具有很多，相对而言 <strong>JvisualVM</strong>、<strong>JProfiler</strong>、<strong>Eclipse Mat</strong>，使用人群更多一些。下面以 JvisualVM 举例分析 Dump 文件</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/a4d49e1889535602234ca7e484bf0819.png"></p><p>列举两个常用的功能，第一个是能看到触发 OOM 的线程堆栈，清晰得知程序溢出的原因</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/05beb7cade93bc2d2bd0ca881d5cb912.png"></p><p>第二个就是可以查看 JVM 内存里保留大小最大的对象，可以自由选择排查个数</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/4c3aba0bfabda558f410bc97a64e0703.png"></p><p>点击对象还可以跳转具体的对象引用详情页面</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/c534bdbcbc536151d5d3c18dc65706d5.png"></p><p>文中 Dump 文件较为简单，而正式环境出错的原因五花八门，所以不对该 Dump 文件做深度解析</p><p><strong>注意</strong>：JvisualVM 如果分析大 Dump 文件，可能会因为内存不足打不开，需要调整默认的内存</p><h3 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h3><p>线上如遇到 JVM 内存溢出，可以分以下几步排查</p><ol><li><code>jmap -heap</code> 查看是否内存分配过小</li><li><code>jmap -histo</code> 查看是否有明显的对象分配过多且没有释放情况</li><li><code>jmap -dump</code> 导出 JVM 当前内存快照，使用 JDK 自带或 MAT 等工具分析快照</li></ol><p>如果上面还不能定位问题，那么需要排查应用是否在不断创建资源，比如网络连接或者线程，都可能会导致系统资源耗尽。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">JVM垃圾回收详解（重点） | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/java-basic-and-jvm.html#java-io">Java 与 JVM — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://blog.csdn.net/o9109003234/article/details/121917786">某团面试：如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44382896/article/details/140835275">【JVM基础09】——垃圾回收-对象什么时候可以被垃圾回收器回收？_jvm垃圾回收器啥时候回收-CSDN博客</a></p><p><a href="https://blog.csdn.net/ScorpC/article/details/114626650">CMS产生的问题：promotion failed和concurrent mode failure，及解决方案-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】JVM（一） | 内存区域 &amp; 类加载</title>
      <link href="/p/de2d10bc/"/>
      <url>/p/de2d10bc/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-是如何实现跨平台的？"><a href="#Java-是如何实现跨平台的？" class="headerlink" title="Java 是如何实现跨平台的？"></a>Java 是如何实现跨平台的？</h2><p>所谓的跨平台主要指的是在不同的硬件或操作系统上，Java 代码都可以运行，不需要针对不同平台做对应的修改。</p><p>之所以能实现一次编写到处运行，主要靠的是 JVM，也就是 Java 虚拟机。</p><p>我们编写的 Java 代码会被编译成 .class 文件这个过程想必大家都了解。</p><p>但是机器最终只认识 0101 这种二进制指令，不论在什么 x86 还是 arm，windows 还是 linux 机器都只认二进制。</p><p>把 .class 转换成对应硬件和操作系统认可的二进制指令就是 JVM 的工作。</p><h2 id="class文件与字节码文件的区别？"><a href="#class文件与字节码文件的区别？" class="headerlink" title=".class文件与字节码文件的区别？"></a>.class文件与字节码文件的区别？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>.class 文件：是指文件扩展名称为 .class 的文件，表示由 java 源程序经过 java 编译器编译而成且由 JVM 执行的二进制文件，因此可以通过拥有一份 .class 文件在不同的操作系统平台上的 JVM 执行，实现跨平台运行的特性</li><li>字节码 bytecode 文件：简单说不是文件，而是 JVM 操作的指令格式，通常我们通过 <code>javap -c -v xx.class</code> 生成的文件称为字节码文件，是属于可阅读的字节码指令文件，能够让我们清楚地知道 java 文件编译成 .class 文件之后显示的执行指令，便于程序员理解 jvm 的相关的知识</li></ul><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>.class 文件（16进制）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/c7b9f48861fa76b2da1ac682bd3edd0d.png"></p><p>字节码文件（可阅读的指令文件）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/131b7de6a17be3ac306cc0f074ba47ea.png"></p><h2 id="编译执行与解释执行的区别是什么？JVM-使用哪种方式？"><a href="#编译执行与解释执行的区别是什么？JVM-使用哪种方式？" class="headerlink" title="编译执行与解释执行的区别是什么？JVM 使用哪种方式？"></a>编译执行与解释执行的区别是什么？JVM 使用哪种方式？</h2><p>编译执行是将源代码一次性编译成机器码（目标代码），然后直接执行机器码；</p><p>而解释执行是将源代码逐行解释，每解释一行就立即翻译成机器码并执行。</p><p>编译执行的程序运行速度通常更快，因为它不需要在运行时进行翻译工作；而解释执行由于需要边解释边执行，运行效率相对较低。</p><p>JVM 是哪个呢？<strong>都有！</strong></p><p>正常情况下 JVM 是解释执行，但是如果 JVM 发现这段逻辑执行特别频繁，是个热点代码，那么就会把它就会通过 JIT (JUST IN TIME) 即时编译将其直接编译成机器码，这样就是编译执行了。</p><h2 id="什么是-Java-中的-JIT（Just-In-Time）"><a href="#什么是-Java-中的-JIT（Just-In-Time）" class="headerlink" title="什么是 Java 中的 JIT（Just-In-Time）?"></a>什么是 Java 中的 JIT（Just-In-Time）?</h2><p>Java 中的 JIT（Just-In-Time，即时编译）编译器是一种在<strong>程序运行时</strong>将字节码转换为机器码的技术。因为这种转换是在程序运行时即时进行的，因此得名“Just-In-Time”。</p><p>它在 Java 程序运行的时候，发现热点代码（频繁执行的代码段）时，就将这段代码编译成机器码，减少解释执行的开销，使得 Java 代码接近本地代码的性能。</p><h3 id="热点代码（Hotspot-Code）"><a href="#热点代码（Hotspot-Code）" class="headerlink" title="热点代码（Hotspot Code）"></a>热点代码（Hotspot Code）</h3><p>JIT 编译器重点优化“热点代码”，即被<strong>多次调用或循环执行的代码</strong>。通过分析代码执行频率，JIT 能识别这些热点并进行优化编译。</p><p>这里的优化编译采用了多种技术：如<strong>方法内联（Inlining）、逃逸分析（Escape Analysis）、循环展开（Loop Unrolling）等</strong>，使得编译后的机器码更加高效。</p><h2 id="什么是-Java-的-AOT（Ahead-Of-Time）？"><a href="#什么是-Java-的-AOT（Ahead-Of-Time）？" class="headerlink" title="什么是 Java 的 AOT（Ahead-Of-Time）？"></a>什么是 Java 的 AOT（Ahead-Of-Time）？</h2><p>Java 的 AOT（Ahead-Of-Time，预编译）是一种在<strong>程序运行之前</strong>，将 Java 字节码直接编译为本地机器码的技术。</p><p>JIT 是在 Java 运行时将一些代码编译成机器码，而 AOT 则是在代码运行之前就编译成机器吗，也就是提前编译。</p><p>提前编译的好处是减少运行时编译的开销，且减少程序启动所需的编译时间，提高启动速度。</p><h3 id="AOT-的工作原理"><a href="#AOT-的工作原理" class="headerlink" title="AOT 的工作原理"></a>AOT 的工作原理</h3><p>AOT 编译是在构建阶段对 Java 字节码进行静态分析，并将其编译为目标平台的机器码。编译后的代码可以直接运行在目标硬件上，无需在运行时通过 JVM 进行解释或即时编译。</p><h3 id="AOT-的优点"><a href="#AOT-的优点" class="headerlink" title="AOT 的优点"></a>AOT 的优点</h3><ul><li>快速启动：由于代码已经编译为本地机器码，AOT 减少了程序启动时的编译开销，适合需要快速启动的应用场景。</li><li>更小的内存占用：在不需要 JIT 编译器的情况下，AOT 编译减少了 JVM 的内存占用。</li></ul><h3 id="AOT-的缺点"><a href="#AOT-的缺点" class="headerlink" title="AOT 的缺点"></a>AOT 的缺点</h3><p>缺乏运行时优化：AOT 编译器无法像 JIT 编译器那样利用运行时的动态信息进行深度优化，可能导致在<strong>长时间运行</strong>的应用程序中性能低于 JIT。</p><p>平台依赖性：AOT 编译出的机器码是针对特定平台的，<strong>缺乏跨平台的灵活性</strong>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>AOT 主要用于要求快速启动的应用程序，如微服务、容器化应用、嵌入式系统，以及对启动性能比较敏感的场景。</p><h2 id="什么是动态代理？JDK-动态代理和-CGLIB-动态代理有什么区别？"><a href="#什么是动态代理？JDK-动态代理和-CGLIB-动态代理有什么区别？" class="headerlink" title="什么是动态代理？JDK 动态代理和 CGLIB 动态代理有什么区别？"></a>什么是动态代理？JDK 动态代理和 CGLIB 动态代理有什么区别？</h2><h3 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h3><p>动态代理是一种在<strong>运行时动态生成代理对象</strong>，并在代理对象上进行方法调用的编程技术。它主要用于在<strong>不修改原有代码基础上，增加或改变某些功能的执行流程</strong>。动态代理广泛应用于 AOP（面向切面编程）、RPC（远程过程调用）、事务管理等领域。在 Java 中，主要有两种动态代理的实现方式：JDK 动态代理和 CGLIB 动态代理。</p><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>JDK 动态代理是<strong>基于接口</strong>的代理技术。它使用 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口来创建代理对象。当你调用代理对象的任何方法时，调用会被转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法。你可以在这个 <code>invoke</code> 方法中定义拦截逻辑，比如前置处理、后置处理等。</p><p>为了使用 JDK 动态代理，你的<strong>类必须实现一个或多个接口</strong>。JDK 动态代理的局限性在于，它只能代理接口方法，如果你有一个类并希望代理其非接口方法，则不能使用 JDK 动态代理。</p><p><strong>优点以及缺点</strong></p><ul><li><strong>优点</strong>：原生支持，无需引入额外依赖。</li><li><strong>缺点</strong>：只能代理接口，如果一个类没有实现任何接口，则不能使用 JDK 动态代理。</li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><p>1）定义一个接口及其实现类。</p><p>2）创建一个实现了 <code>InvocationHandler</code> 接口的类，在该类的 <code>invoke</code> 方法中定义代理逻辑。</p><p>3）通过 <code>Proxy.newProxyInstance</code> 方法动态创建接口的代理对象。</p><h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>CGLIB（Code Generation Library）是一个强大的、高性能、高质量的 Code 生成库，它可以在运行时扩展 Java 类和实现 Java 接口。不同于 JDK 动态代理，CGLIB 不需要接口，它是<strong>通过继承方式</strong>实现代理的。</p><p>CGLIB 底层通过使用一个小而快的字节码处理框架 ASM ，来<strong>转换字节码并生成新的类</strong>。不仅可以代理普通类的方法，还能代理那些没有接口的类的方法。</p><p><strong>优点以及缺点</strong></p><ul><li><strong>优点</strong>：无需接口实现。在大量调用的场景下，其生成的代理对象在调用时性能比 JDK 动态代理高</li><li><strong>缺点</strong>：对 final 方法无效，需添加额外的依赖。</li></ul><h4 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h4><p>1）创建一个需要被代理的类。</p><p>2）创建一个继承 <code>MethodInterceptor</code> 的代理类，在 <code>intercept</code> 方法中定义代理逻辑。</p><p>3）使用 <code>Enhancer</code> 类创建被代理类的子类，并设置回调。</p><p>它们之间的性能随着 JDK 版本的不同而不同，以下内容取自：<a href="https://www.cnblogs.com/haiq/p/4304615.html">haiq的博客</a></p><blockquote><ul><li>jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显，甚至更快一些；而当调用次数增加之后， cglib 表现稍微更快一些</li><li>jdk7 下，情况发生了逆转！在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍</li><li>jdk8 表现和 jdk7 基本一致</li></ul></blockquote><h2 id="JVM-的内存区域是如何划分的？"><a href="#JVM-的内存区域是如何划分的？" class="headerlink" title="JVM 的内存区域是如何划分的？"></a>JVM 的内存区域是如何划分的？</h2><p>Java 虚拟机运行时数据区分为程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p><p>1）程序计数器</p><p>作为当前线程执行字节码的行号指示器，简单理解就是标记执行到第一行了，每个线程都有自己的程序计数器。</p><p>2）虚拟机栈</p><p>每个线程执行时在虚拟机栈中都会有自己的栈帧，存储局部变量、方法出口、操作数栈等信息，在方法调用栈帧入栈，方法返回，栈帧出栈。</p><p>3）本地方法栈</p><p>与虚拟机栈类似，但它是用于本地方法的调用，即 native 方法。</p><p>4）堆</p><p>堆主要存放的就是平时 <strong>new 的对象实例和数组</strong>，按垃圾回收划分，堆可以分为新生代、老年代、永久代（Java 8 后被元空间取代，不在堆内了）。</p><p>5）方法区</p><p>方法区主要存储<strong>类结构、常量、静态变量</strong>、即时编译(JIT)后的代码等信息，Java 8 后存在元空间（元空间可以认为是方法区的一个实现），存储在堆外内存中。</p><p>程序计数器、虚拟机栈、本地方法栈这 3 个区域是<strong>线程私有</strong>的，会随线程消亡而自动回收，所以不需要管理。</p><p>而堆和方法区是<strong>线程共享</strong>的，所以垃圾回收器会关注这两个地方。</p><h2 id="Java-中堆和栈的区别是什么？"><a href="#Java-中堆和栈的区别是什么？" class="headerlink" title="Java 中堆和栈的区别是什么？"></a>Java 中堆和栈的区别是什么？</h2><p>栈（Stack）：主要用于存储局部变量和方法的调用信息（如返回地址、参数等）。在方法执行期间，局部变量（包括引用变量，但不包括它们引用的对象）被创建在栈上，并在方法结束时被销毁。</p><p>堆（Heap）：用于存储对象实例和数组。每当使用 new 关键字创建对象时，JVM 都会在堆上为该对象分配内存空间。</p><p>从其他方面进一步区分：</p><ul><li>生命周期：我们知道JVM里面的垃圾回收主要是对堆空间的处理，而栈空间是不会被回收的，所以栈空间的生命周期都非常的短，比如一次方法的调用，调用的时候存入，执行完成就被弹出释放。而堆空间是需要通过GC进行回收的。所以堆空间的数据生命周期会相对较长！</li><li>空间大小：栈的空间大小都是固定的，根据操作系统决定，如果是64位的则大小为8个字节。但是堆的空间大小并不确定，根据对象的大小进行一个划分</li></ul><p><strong>特别注意</strong>，如果定义的变量是一个基本数据类型，比如<code>int a = 10</code>；这个时候并不会分配堆内存，10 会直接存在栈空间。</p><p>如果是引用数据类型，比如<code>A a = new A()</code>；这种 a 分配到栈空间是一个地址，指向堆中的实例化的A。</p><p>如果 A 中定义了一个属性<code>B b = new B()</code>；这个b并不会存在栈空间，而是直接放在堆空间，存储的是事例化的B的地址！</p><h2 id="什么是-Java-中的直接内存？"><a href="#什么是-Java-中的直接内存？" class="headerlink" title="什么是 Java 中的直接内存？"></a>什么是 Java 中的直接内存？</h2><p>我们启动 JVM 的时候都会设置堆的大小，而直接内存占用的是堆外的内存，它<strong>不属于堆</strong>。</p><p>理论上我们在 Java 中想要操作堆外的内存，需要将其拷贝到堆内，因此 Java 弄了个 Direct Memory，它允许 Java 访问原生内存（非堆内内存），这样就减少了堆外到堆内的这次拷贝，提升 I&#x2F;O 效率，在文件读写和网络传输场景直接内存有很大的优势。</p><p>不过堆外内存不归 JVM 设置的堆大小限制（在 JVM 中可以利用 -XX:MaxDirectMemorySize 参数设置直接内存的最大值），<strong>且不受垃圾回收器管理</strong>，因此<strong>在使用上需要注意直接内存的释放，防止内存泄漏</strong>。</p><p>在 Java 中可以利用 Unsafe 类和 NIO 类库使用直接内存。</p><p>例如利用 NIO 的 <code>ByteBuffer.allocateDirect(1024)</code> 即可分配得到一个直接内存。</p><p>简单示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分配直接内存</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        directBuffer.put(<span class="string">&quot;Hello, 面试鸭 Direct Memory!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为读模式</span></span><br><span class="line">        directBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[directBuffer.remaining()];</span><br><span class="line">        directBuffer.get(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">retrievedData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(retrievedData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动释放直接内存</span></span><br><span class="line">        ((sun.nio.ch.DirectBuffer)directBuffer).cleaner().clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意最后一行释放内存的 cleaner 。因为垃圾回收器无法直接管理堆外内存，所以 JVM 在创建 ByteBuffer 的时候，在堆内存储了这个对象的指针，然后注册了一个关联的 cleaner（清理器）。而这个 cleaner 是个虚引用。</p><p>如果 JVM 检测到没有对象关联 ByteBuffer，说明这个堆外内存已经成为了垃圾，此时 ByteBuffer 会被回收，然后 cleaner 会被加入到引用队列中，之后会就会被触发其 clean 接口，然后清理堆外内存。</p><h2 id="什么是-Java-中的常量池？"><a href="#什么是-Java-中的常量池？" class="headerlink" title="什么是 Java 中的常量池？"></a>什么是 Java 中的常量池？</h2><p>常量池其实就是<strong>方法区的一部分</strong>，全称应该是运行时常量池（runtime constant pool），主要用于存储字面量和符号引用等编译期产生的一些常量数据。</p><p>比如一些字符串、整数、浮点数都是字面量，源代码中一个写了一个固定的值的都叫字面量。</p><p>比如你代码写了一个 <code>String s = &#39;aa&#39;;</code> 那么 aa 就是字面量，存储在常量池当中。</p><p>符号引用指的是字段的名称、接口全限定名等等，这些都算符号引用。</p><p>常量池的好处是减少内存的消耗，比如同样的字符串，常量池仅需存储一份。</p><p>且常理池在类加载后就已经准备好了，这样程序运行时可以快速的访问这些数据，提升运行时的效率。</p><p>不过在 Java 1.7 的时候，HotSpot 将字符串从运行时常量池（方法区内）中剥离出来，搞了个字符串常量池存储在堆内，因为字符串对象也经常需要被回收，因此放置到堆中好管理回收。</p><h2 id="你了解-Java-的类加载器吗？Java-的类加载过程是怎样的？"><a href="#你了解-Java-的类加载器吗？Java-的类加载过程是怎样的？" class="headerlink" title="你了解 Java 的类加载器吗？Java 的类加载过程是怎样的？"></a>你了解 Java 的类加载器吗？Java 的类加载过程是怎样的？</h2><p>我们平常写的代码是保存在一个 .java文件里面，经过编译会生成.class文件，这个文件存储的就是字节码，如果要用上我们的代码，那就必须把它加载到 JVM 中。</p><p>而类加载的步骤主要分为：<strong>加载、连接、初始化</strong>。连接还能拆分为：<strong>验证、准备、解析</strong>三个阶段。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载阶段，需要用到类加载器来将 <strong>class 文件里面的内容加载到 JVM 中生成类对象</strong>。</p><p>JDK8 的时候一共有三种类加载器：</p><ol><li>启动类加载器(Bootstrap ClassLoader)，它是属于虚拟机自身的一部分，用 C++ 实现的（JDK9 后用 java 实现），主要负责加载<JAVA_HOME>\lib目录中或被 -Xbootclasspath 指定的路径中的并且文件名是被虚拟机识别的文件，它是所有类加载器的父亲。</li><li>扩展类加载器(Extension ClassLoader)，它是 Java 实现的，独立于虚拟机，主要负责加载<JAVA_HOME>\lib\ext目录中或被 java.ext.dirs 系统变量所指定的路径的类库。</li><li>应用程序类加载器(Application ClassLoader)，它是 Java 实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这个加载器就是我们程序中的默认加载器。</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/W8ylN5Ac_78f53bd2-1515-4dc7-8d17-ff727829a223.png" alt="img"></p><p>在 JDK9 之后，类加载器进行了一些修改，主要是因为 JDK9 引入了模块化，即 Jigsaw，原来的 rt.jar、tool.jar 等都被拆成了数十个 jmod 文件，已满足可扩展需求，无需保留 <JAVA_HOME>\lib\ext ，所以扩展类加载器也被重命名为平台类加载器（PlatformClassLoader），主要加载被 module-info.java 中定义的类。</p><p>且双亲委派的路径也做了一定的变化：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/JsOSPBN2_356498bd-8c60-4b0e-b599-999b047d4376.png"></p><p>在平台和应用类加载器受到加载请求时，会先判断该类是否属于一个系统模块，如果属于则委派给对应的模块类加载器加载，反之才委派给父类加载器。</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p>双亲委派模型是 Java 类加载机制的设计模式之一。它的核心思想是：类加载器在加载某个类时，会先委派给父类加载器去加载，父类加载器无法加载时，才由当前类加载器自行加载。</p><p><strong>工作流程</strong>：</p><ul><li>当一个类加载器（如自定义类加载器）试图加载某个类时，先将加载请求向上委派给父类加载器，父类加载器再向上委派给它的父类，直到根类加载器（Bootstrap ClassLoader）。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p><ul><li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>如果我们要自定义自己的类加载器，需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p><p>但是，<strong>如果想打破双亲委派模型</strong>则需要重写 <code>loadClass()</code> 方法。</p><h4 id="为什么叫双亲？"><a href="#为什么叫双亲？" class="headerlink" title="为什么叫双亲？"></a>为什么叫双亲？</h4><p>在 Java 的类加载机制中，双亲委派机制之所以被称为 “双亲”，是因为在加载一个类时，并不是由单个类加载器独立完成，而是通过把请求委派给父类加载器，层层向上委托，就好像有两个 “双亲”。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 <code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code> 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h4 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84">双亲委派模型的好处</a></h4><p>双亲委派模型保证了 Java 程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>主要是验证加载进来的二进制流是否符合一定格式，是否规范，是否符合当前 JVM 版本等等之类的验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为静态变量(类变量)赋初始值，也即为它们在方法区划分内存空间。这里注意是<strong>静态变量</strong>，并且是初始值，比如 int 的初始值是 0。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池的符号引用转化成直接引用。</p><p>符号引用可以理解为只是个替代的标签，比如你此时要做一个计划，暂时还没有人选，你设定了个 A 去做这个事。然后等计划真的要落地的时候肯定要找到确定的人选，到时候就是小明去做一件事。解析就是把 A(符号引用) 替换成小明(直接引用)。符号引用就是一个字面量，没有什么实质性的意义，只是一个代表。</p><p>直接引用指的是一个真实引用，在内存中可以通过这个引用查找到目标。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行一些静态代码块，为静态变量赋值，这里的赋值才是<strong>代码里面的赋值</strong>，准备阶段只是设置初始值占个坑。</p><h2 id="Java-中的强引用、软引用、弱引用和虚引用分别是什么？"><a href="#Java-中的强引用、软引用、弱引用和虚引用分别是什么？" class="headerlink" title="Java 中的强引用、软引用、弱引用和虚引用分别是什么？"></a>Java 中的强引用、软引用、弱引用和虚引用分别是什么？</h2><p>Java 根据其生命周期的长短将引用类型又分为强引用、软引用、弱引用、幻象引用。</p><ul><li>强引用：就是我们平时 new 一个对象的引用。当 JVM 的内存空间不足时，宁愿抛出 OutOfMemoryError 使得程序异常终止，也不愿意回收具有强引用的存活着的对象。</li><li>软引用：生命周期比强引用短，当 JVM 认为<strong>内存空间不足时，会试图回收</strong>软引用指向的对象，也就是说在 JVM 抛出 OutOfMemoryError 之前，会去清理软引用对象，适合用在内存敏感的场景。</li><li>弱引用：比软引用还短，在 GC 的时候，<strong>不管内存空间足不足都会回收这个对象</strong>，ThreadLocal中的 key 就用到了弱引用，适合用在内存敏感的场景。</li><li>虚引用：也称幻象引用，之所以这样叫是因为虚引用的 get 永远都是 null ，称为 get 了个空虚，所以叫虚。</li></ul><p>虚引用的唯一作用就是配合引用队列来监控引用的对象是否被加入到引用队列中，也就是可以准确的让我们知晓对象何时被回收。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】并发（三） | JMM</title>
      <link href="/p/e6628f8e/"/>
      <url>/p/e6628f8e/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Java-内存模型（JMM）？"><a href="#什么是-Java-内存模型（JMM）？" class="headerlink" title="什么是 Java 内存模型（JMM）？"></a>什么是 Java 内存模型（JMM）？</h2><p>JMM 即 Java Memory Model，Java 内存模型。</p><p>它的基本目标是：</p><ul><li>确保基本的读写操作的<strong>原子性</strong>：多个线程对一个变量的读写操作是不可分割的</li><li>确保线程的<strong>可见性</strong>：一个线程对共享变量的修改，能够被其他线程看到。</li><li>确保线程的<strong>有序性</strong>：保证代码的执行顺序不会被编译器或 CPU 重新排列，使得代码的执行顺序符合开发者的预期，从而避免在并发环境下出现意外的结果。</li></ul><p>操作系统有一套内存模型，而 Java 是跨平台实现的，因此它需要自己定义一套内存模型屏蔽各操作系统之间的差异。</p><p>JMM <a href="https://www.cs.umd.edu/~pugh/java/memoryModel/CommunityReview.pdf">（JSR133）</a> 定义了 Java 源码到 CPU 指令执行一套规范，我们仅需直接使用 Java 提供的并发类（synchronized、volatile 等），知晓它定义的 happens-before 原则，即可写出并发安全的代码，无需关心底层的 CPU 指令重排、多级缓存等各种底层原理。</p><p>抽象的来看 JMM 会把内存分为本地内存和主存，每个线程都有自己的私有化的本地内存，然后还有个存储共享数据的主存。</p><h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h3><p>Happens-Before 是 JMM 中的重要概念，用于确定两个操作之间的执行顺序，确保多线程程序的正确性和一致性，底层主要是利用内存屏障来实现的。</p><p>具体来说：<strong>Happens-Before 关系定义了某个操作的结果对另一个操作可见，即如果操作 A Happens-Before 操作 B，则操作 A 的结果对操作 B 可见</strong>。</p><p>Happens-Before 规则包括以下几个重要的顺序：</p><p>1）程序顺序规则：</p><p>在一个线程内，按照代码顺序，前面的操作 Happens-Before 后面的操作。</p><p>2）监视器锁规则：</p><p>对一个锁的解锁操作 Happens-Before 后续对这个锁的加锁操作。</p><p>3）volatile 变量规则：</p><p>对一个 volatile 变量的写操作 Happens-Before 后续对这个 volatile 变量的读操作。</p><p>4）线程启动规则：</p><p>对线程的 Thread.start() 调用 Happens-Before 该线程中的每一个动作。</p><p>5）线程终止规则：</p><p>线程中的所有操作 Happens-Before 其他线程检测到该线程已经终止（通过 Thread.join()、Thread.isAlive() 返回的值等）。</p><p>6）线程中断规则：</p><p>对线程的 interrupt() 调用 Happens-Before 检测到中断事件的代码（如 Thread.interrupted() 或 Thread.isInterrupted()）。</p><p>7）对象终结规则：</p><p>一个对象的初始化完成 Happens-Before 它的 finalize() 方法的开始。</p><p>8）传递性：</p><p>如果操作 A Happens-Before 操作 B，操作 B Happens-Before 操作 C，则操作 A Happens-Before 操作 C。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>volatile 关键字是用来保证<strong>有序性和可见性</strong>的。</p><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><strong><code>volatile</code> 关键字还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。（我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。）</p><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p><p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p><p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p><p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li></ol><p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p><p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code>、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p><h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h2><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li><li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞。</li><li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化。</li></ul><h2 id="Java-中的-final-关键字是否能保证变量的可见性？"><a href="#Java-中的-final-关键字是否能保证变量的可见性？" class="headerlink" title="Java 中的 final 关键字是否能保证变量的可见性？"></a>Java 中的 final 关键字是否能保证变量的可见性？</h2><p>不可以。</p><p>你可能看到一些答案说可以保证可见性，那不是我们常说的可见性。</p><p>一般而言我们指的可见性是一个线程修改了共享变量，<strong>另一个线程可以立马得知更改</strong>，得到最新修改后的值。</p><p>而 final 并不能保证这种情况的发生，volatile 才可以。</p><p>而有些答案提到的 final 可以保证可见性，其实指的是 final 修饰的字段在构造方法初始化完成，并且期间没有把 this 传递出去，那么当构造器执行完毕之后，其他线程就能看见 final 字段的值。</p><p>如果不用 final 修饰的话，那么有可能在构造函数里面对字段的写操作被排序到外部，这样别的线程就拿不到写操作之后的值。</p><p>对于 final 域，编译器和处理器要遵守两个重排序规则(参考自infoq程晓明)：</p><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><p>所以这才是 final 的可见性，这种可见性和我们在并发中常说的可见性不是一个概念！</p><p>所以 final 无法保证可见性！</p><h2 id="什么是-Java-中的指令重排？"><a href="#什么是-Java-中的指令重排？" class="headerlink" title="什么是 Java 中的指令重排？"></a>什么是 Java 中的指令重排？</h2><p>为了提高程序执行的效率，CPU或者编译器就将执行命令重排序。</p><p>原因是因为内存访问的速度比 CPU 运行速度慢很多，因此需要编排一下执行的顺序，<strong>防止因为访问内存的比较慢的指令而使得 CPU 闲置着</strong>，其实和典型的烧水喝茶洗杯子的排序类似。</p><p>CPU 执行有个指令流水线的概念，还有分支预测等。</p><p>总之为了提高效率就会有指令重排的情况，导致指令乱序执行的情况发生，不过会保证结果肯定是与单线程执行结果一致的，这叫 as-if-serial。</p><p>不过多线程就无法保证了，在 Java 中的 volatile 关键字可以禁止修饰变量前后的指令重排。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】并发（二） | 锁</title>
      <link href="/p/4131eeff/"/>
      <url>/p/4131eeff/</url>
      
        <content type="html"><![CDATA[<h1 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h1><h2 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。</p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ul><li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li><li>第二步，将锁设置为当前线程持有；</li></ul><p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p>自旋锁是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p><p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p><p>读写锁的工作原理是：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p><p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p><p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。</p><p>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。</p><p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><h2 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h2><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p>理论上来说：</p><ul><li>悲观锁通常多用于<strong>写比较多</strong>的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于<strong>写比较少</strong>的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h2 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h2><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><h3 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h3><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><div class="note  flat info no-icon"><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></div><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p>优点：</p><ul><li>无锁并发：CAS 操作不使用锁，因此不会导致线程阻塞，提高了系统的并发性和性能。</li><li>原子性：CAS 操作是原子的，保证了线程安全。</li></ul><p>缺点：</p><ul><li>ABA 问题：CAS 操作中，如果一个变量值从 A 变成 B，又变回 A，CAS 无法检测到这种变化，可能导致错误。</li><li>自旋开销：CAS 操作通常通过自旋实现，可能导致 CPU 资源浪费，尤其在高并发情况下。</li><li>单变量限制：CAS 操作仅适用于单个变量的更新，不适用于涉及多个变量的复杂操作。</li></ul><h2 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="循环时间长、开销大"><a href="#循环时间长、开销大" class="headerlink" title="循环时间长、开销大"></a>循环时间长、开销大</h3><p>AS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p><h2 id="什么是-Java-的-Semaphore？"><a href="#什么是-Java-的-Semaphore？" class="headerlink" title="什么是 Java 的 Semaphore？"></a>什么是 Java 的 Semaphore？</h2><p>Semaphore 是<strong>信号量</strong>，广泛应用于各种操作系统中，相对于平日只允许一个线程访问临界区的 lock 和 synchronized 来说，信号量允许多线程同时访问一个临界区。</p><p>原理就简单的理解为初始化一个数，如果来了一个线程则把数减一，如果减一之后数的值小于 0 则阻塞当前线程，移入一个阻塞队列中，否则允许执行。</p><p>当一个线程执行完毕之后将数加一，并唤醒阻塞队列中的一个等待线程。</p><p>实际是内部有个继承自 AQS 的 Sync 类，通过依托 AQS 的封装来实现功能。</p><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p><code>synchronized</code> 关键字主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h3 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，monitor 对象是同步的基本实现单元，<strong>其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/synchronized-principle.png" alt="synchronized关键字原理"></p><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/synchronized%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597%25E5%258E%259F%25E7%2590%25862.png" alt="synchronized关键字原理"></p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><p>在 Java 1.6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。</p><p>但在 Java 1.6 的时候，Java 虚拟机对此进行了改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：</p><ul><li>偏向锁（Biased Locking）</li><li>轻量级锁</li><li>重量级锁</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p><ol><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ol><p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、修饰静态方法</strong> （锁当前类）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p><p><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</p><p>对括号里指定的对象&#x2F;类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> ，因为 JVM 中，字符串常量池具有缓存功能。</li></ul><h2 id="Java-的-synchronized-是怎么实现的？"><a href="#Java-的-synchronized-是怎么实现的？" class="headerlink" title="Java 的 synchronized 是怎么实现的？"></a>Java 的 synchronized 是怎么实现的？</h2><p>Synchronized 的原理其实就是基于一个锁对象和锁对象相关联的一个 monitor 对象。</p><p>在偏向锁和轻量级锁的时候只需要利用 CAS 来操控锁对象头即可完成加解锁动作。</p><p>在升级为重量级锁之后还需要利用 monitor 对象，利用 CAS 和 mutex 来作为底层实现。</p><p>monitor 对象内部会有等待队列和条件等待队列，未竞争到锁的线程存储到等待队列中，获得锁的线程调用 wait 后便存放在条件等待队列中，解锁和 notify 都会唤醒相应队列中的等待线程来争抢锁。</p><p>然后由于阻塞和唤醒依赖于底层的操作系统实现，系统调用存在用户态与内核态之间的切换，所以有较高的开销，因此称之为重量级锁。</p><p>所以才会有偏向锁和轻量级锁的优化，并且引入自适应自旋机制，来提高锁的性能。</p><h2 id="什么是-Java-中的锁自适应自旋？"><a href="#什么是-Java-中的锁自适应自旋？" class="headerlink" title="什么是 Java 中的锁自适应自旋？"></a>什么是 Java 中的锁自适应自旋？</h2><p>这里指的就是 Syncronized 在身为<strong>重量级锁</strong>时候的自旋。</p><p>具体指的是在重量级锁时，一个线程<strong>如果竞争锁失败会进行自旋操作</strong>，说白了就是执行一些无意义的执行，空转 CPU 等着锁的释放。</p><p>因为一些情况下可能线程刚被阻塞，锁就被释放了，这样开销就比较大，所以自旋在一定程度上是有优化的。</p><p>形象一点就像怠速停车和熄火的区别，如果等待时候很长(长时候都拿不到锁)，那肯定熄火划算(阻塞)。</p><p>如果一会儿就要出发(拿到锁)，那怠速停车(自旋)比较划算。</p><p>不过因为这个自旋次数不好判断，所以引入自适应自旋。</p><p>说白了就是结合经验值来看，如果上次自旋一会儿就拿到锁，那这次多自旋几次，如果上次自旋很久都拿不到，这次就少自旋。</p><p>这就叫锁的自适应自旋。</p><h2 id="说说-AQS-吧？"><a href="#说说-AQS-吧？" class="headerlink" title="说说 AQS 吧？"></a>说说 AQS 吧？</h2><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。AQS 就是一个抽象类，主要用来构建锁和同步器。</p><p>AQS 将一些操作封装起来，比如入队等基本方法，暴露出方法，便于其他相关 JUC 锁的使用。</p><p>比如 ReentrantLock、CountDownLatch、Semaphore 等等。</p><p>简单来说 AQS 就是起到了一个抽象、封装的作用，将一些排队、入队、加锁、中断等方法提供出来，具体加锁时机、入队时机等都需要实现类自己控制。</p><h2 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h2><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即<strong>不存在队列实例</strong>，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><p>CLH 队列结构如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/40cb932a64694262993907ebda6a0bfe~tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p><p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图（图源<a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java 并发之 AQS 详解</a>）如下：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/CLH.png"></p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><h2 id="Semaphore-是什么？"><a href="#Semaphore-是什么？" class="headerlink" title="Semaphore 是什么？"></a>Semaphore 是什么？</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><p><code>Semaphore</code> 的使用简单，我们这里假设有 <code>N(N&gt;5)</code> 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><h2 id="Java-中-ReentrantLock-的实现原理是什么？"><a href="#Java-中-ReentrantLock-的实现原理是什么？" class="headerlink" title="Java 中 ReentrantLock 的实现原理是什么？"></a>Java 中 ReentrantLock 的实现原理是什么？</h2><p>ReentrantLock 其实就是<strong>基于 AQS 实现的一个可重入锁</strong>，支持<strong>公平和非公平</strong>两种方式。</p><p>内部实现依靠一个 state 变量和两个等待队列：同步队列和等待队列。</p><p>利用 CAS 修改 state 来争抢锁。</p><p>争抢不到则入同步队列等待，同步队列是一个双向链表。</p><p>条件 condition 不满足时候则入等待队列等待，是个单向链表。</p><p>是否是公平锁的区别在于：线程获取锁时是加入到<strong>同步队列尾部</strong>还是直接<strong>利用 CAS 争抢锁</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/VWa8SBRY_image.png"></p><h2 id="Synchronized-和-ReentrantLock-有什么区别？"><a href="#Synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="Synchronized 和 ReentrantLock 有什么区别？"></a>Synchronized 和 ReentrantLock 有什么区别？</h2><p>Synchronized 是 Java 内置的<strong>关键字</strong>，实现基本的同步机制，不支持超时，非公平，不可中断，不支持多条件。</p><p>ReentrantLock 是 JUC 类库提供的，由 JDK 1.5 引入，支持设置超时时间，可以避免死锁，比较灵活，并且支持公平锁，可中断，支持多条件判断。</p><p>ReentrantLock 需要手动解锁，而 Synchronized 不需要，它们都是可重入锁。</p><h2 id="什么是-Java-的-CyclicBarrier？"><a href="#什么是-Java-的-CyclicBarrier？" class="headerlink" title="什么是 Java 的 CyclicBarrier？"></a>什么是 Java 的 CyclicBarrier？</h2><p>从名字分析，这是一个可循环的屏障。</p><p>屏障的意思是：让一组线程都运行到同一个屏障点之后，线程会阻塞等待所有线程都达到这个屏障点，然后所有线程才得以继续执行。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/cxYBXIj7_74e49a4c-81cb-494b-99c5-4dbf5ccaf073.png"></p><p>来看一下例子，十名运动员各自准备比赛，需要等待所有运动员都准备好以后，裁判才能说开始然后所有运动员一起跑，代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有人都准备好了裁判开始了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在准备&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备好了&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始跑了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子线程Thread-0正在准备</span><br><span class="line">子线程Thread-2正在准备</span><br><span class="line">子线程Thread-1正在准备</span><br><span class="line">子线程Thread-3正在准备</span><br><span class="line">子线程Thread-4正在准备</span><br><span class="line">子线程Thread-0准备好了</span><br><span class="line">子线程Thread-5正在准备</span><br><span class="line">子线程Thread-6正在准备</span><br><span class="line">子线程Thread-7正在准备</span><br><span class="line">子线程Thread-8正在准备</span><br><span class="line">子线程Thread-9正在准备</span><br><span class="line">子线程Thread-1准备好了</span><br><span class="line">子线程Thread-2准备好了</span><br><span class="line">子线程Thread-3准备好了</span><br><span class="line">子线程Thread-4准备好了</span><br><span class="line">子线程Thread-5准备好了</span><br><span class="line">子线程Thread-6准备好了</span><br><span class="line">子线程Thread-7准备好了</span><br><span class="line">子线程Thread-8准备好了</span><br><span class="line">子线程Thread-9准备好了</span><br><span class="line">所有人都准备好了裁判开始了</span><br><span class="line">子线程Thread-9开始跑了</span><br><span class="line">子线程Thread-0开始跑了</span><br><span class="line">子线程Thread-2开始跑了</span><br><span class="line">子线程Thread-1开始跑了</span><br><span class="line">子线程Thread-7开始跑了</span><br><span class="line">子线程Thread-6开始跑了</span><br><span class="line">子线程Thread-5开始跑了</span><br><span class="line">子线程Thread-4开始跑了</span><br><span class="line">子线程Thread-3开始跑了</span><br><span class="line">子线程Thread-8开始跑了</span><br></pre></td></tr></table></figure><p>可以看到所有线程在其他线程没有准备好之前都在被阻塞中，等到所有线程都准备好了才继续执行。我们在创建CyclicBarrier对象时传入了一个方法，当调用CyclicBarrier的await方法后，当前线程会被阻塞等到所有线程都调用了await方法后，调用传入CyclicBarrier的方法，然后让所有的被阻塞的线程一起运行。</p><p>它实际上是基于 ReentrantLock 和 Condition 的封装来实现这一功能的。</p><p><strong>原理我先口述一下，因为面试官很有可能会问原理。</strong></p><p>首先设置了达到屏障的线程数量，当线程调用 await 的时候计数器会减一，如果计数器减一不等于 0 的时候，线程会调用 condition.await 进行阻塞等待。</p><p>如果计数器减一的值等于0，说明最后一个线程也到达了屏障，于是如果有 barrierCommand 就执行 barrierCommand ，然后调用 condition.signalAll 唤醒之前等待的线程，并且重置计数器，然后开启下一代。</p><p>源码我就不贴了，建议自己看下，不难的，算上一大推注释都不到 500 行，核心方法就 60 几行。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/gpCZG7AX_5c937bfd-20f3-4e6a-a9d3-9c1395553168.png"></p><h2 id="什么是-Java-的-CountDownLatch？"><a href="#什么是-Java-的-CountDownLatch？" class="headerlink" title="什么是 Java 的 CountDownLatch？"></a>什么是 Java 的 CountDownLatch？</h2><p>这个锁其实和 CyclicBarrier 有点类似，都是等待一个节点的到达，但是还是不太一样的。</p><p>CyclicBarrier 是各个线程等待阻塞所有线程都达到一个节点之后，所有线程继续执行。</p><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕，这个过程中其他线程是不会阻塞的。</p><p>应用场景：</p><ol><li>某个线程需要在其他 n 个线程执行完毕后再向下执行</li><li>多个线程并行执行同一个任务，提高响应速度</li></ol><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p><p>假设某公司一共有十个人，门卫要等十个人都来上班以后，才可以休息，代码实现如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在赶路&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到公司了&quot;</span>);</span><br><span class="line">                <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;门卫等待员工上班中...&quot;</span>);</span><br><span class="line">        <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;员工都来了,门卫去休息了&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子线程Thread-0正在赶路</span><br><span class="line">子线程Thread-2正在赶路</span><br><span class="line">子线程Thread-0到公司了</span><br><span class="line">子线程Thread-0开始工作</span><br><span class="line">子线程Thread-1正在赶路</span><br><span class="line">门卫等待员工上班中...</span><br><span class="line">子线程Thread-4正在赶路</span><br><span class="line">子线程Thread-9正在赶路</span><br><span class="line">子线程Thread-5正在赶路</span><br><span class="line">子线程Thread-6正在赶路</span><br><span class="line">子线程Thread-7正在赶路</span><br><span class="line">子线程Thread-8正在赶路</span><br><span class="line">子线程Thread-3正在赶路</span><br><span class="line">子线程Thread-1到公司了</span><br><span class="line">子线程Thread-1开始工作</span><br><span class="line">子线程Thread-2到公司了</span><br><span class="line">子线程Thread-2开始工作</span><br><span class="line">子线程Thread-3到公司了</span><br><span class="line">子线程Thread-3开始工作</span><br><span class="line">子线程Thread-4到公司了</span><br><span class="line">子线程Thread-4开始工作</span><br><span class="line">子线程Thread-5到公司了</span><br><span class="line">子线程Thread-5开始工作</span><br><span class="line">子线程Thread-6到公司了</span><br><span class="line">子线程Thread-6开始工作</span><br><span class="line">子线程Thread-7到公司了</span><br><span class="line">子线程Thread-7开始工作</span><br><span class="line">子线程Thread-8到公司了</span><br><span class="line">子线程Thread-8开始工作</span><br><span class="line">子线程Thread-9到公司了</span><br><span class="line">子线程Thread-9开始工作</span><br><span class="line">员工都来了,门卫去休息了</span><br></pre></td></tr></table></figure><p>可以看到子线程并没有因为调用 latch.countDown 而阻塞，会<strong>继续进行该做的工作</strong>，只是通知计数器-1，即完成了我们如上说的场景，只需要在所有进程都进行到某一节点后才会执行被阻塞的进程。如果我们想要多个线程在同一时间进行就要用到CyclicBarrier了。</p><p>实现原理：内部有一个继承自 AQS 的 Sync 类，核心其实就是围绕一个整数 state。</p><p>初始化 state 的值，当调用一次 countDown 会把 state 的值减一，当 state 的值减到 0 的时候就会唤醒之前调用 await 等待的线程。</p><p>主要是依靠 AQS 封装的好，所以代码很少，原理也很清晰简单。</p><h3 id="CountDownLatch-的两种典型用法"><a href="#CountDownLatch-的两种典型用法" class="headerlink" title="CountDownLatch 的两种典型用法"></a>CountDownLatch 的两种典型用法</h3><ol><li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch</code> 上 <code>await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</li></ol><h2 id="什么是-Java-的-CompletableFuture？"><a href="#什么是-Java-的-CompletableFuture？" class="headerlink" title="什么是 Java 的 CompletableFuture？"></a>什么是 Java 的 CompletableFuture？</h2><p>实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。举个例子：用户请求获取订单信息，可能需要同时获取用户信息、商品详情、物流信息、商品推荐等数据。</p><p>如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 <strong>无前后顺序关联</strong> 的，可以 <strong>并行执行</strong> ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。对于存在前后调用顺序关系的任务，可以进行任务编排。</p><p>对于 Java 程序来说，Java 8 才被引入的 <code>CompletableFuture</code> 可以帮助我们来做多个任务的编排，功能非常强大。</p><h3 id="Future-是什么？"><a href="#Future-是什么？" class="headerlink" title="Future 是什么？"></a>Future 是什么？</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p>CompletableFuture 的核心特性如下：</p><p>1）异步执行：通过 runAsync 和 supplyAsync 方法，可以异步地执行任务。</p><p>2）任务完成回调：使用 thenApply、thenAccept、thenRun 等方法，可以在任务完成后执行回调。</p><p>3）任务组合：可以将多个 CompletableFuture 组合在一起，通过 thenCombine、thenCompose 等方法，处理多个异步任务之间的依赖关系。</p><p>4）异常处理：提供了 exceptionally、handle 等方法，可以在异步任务发生异常时进行处理。</p><p>5）并行处理：可以通过 allOf 和 anyOf 方法，并行地执行多个异步任务，并在所有任务完成或任意一个任务完成时执行回调。</p><h3 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><code>thenApply()</code></li><li><code>thenAccept()</code></li><li><code>thenRun()</code></li><li><code>whenComplete()</code></li></ul><p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenApply()</code> 方法使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>你还可以进行 <strong>流式调用</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p><h2 id="如何优化-Java-中的锁？"><a href="#如何优化-Java-中的锁？" class="headerlink" title="如何优化 Java 中的锁？"></a>如何优化 Java 中的锁？</h2><p>锁的优化主要有两种方式：</p><ol><li>减少锁的持有时间</li><li>减少锁的粒度</li></ol><p>其实第二点也是为了满足第一点，不过还是需要单独提下。</p><p>减少锁的持有时间其实很好理解，并发资源已操作完成后，里面释放锁，不然别的线程就会阻塞等待，这样就不高效了。</p><p>减少锁的粒度，比如以前用 Synchronized 修饰整个方法，可以优化下用代码块仅包括需要抢占的逻辑，减少整体锁定码逻辑。</p><p>又或者以前使用的是 HashTable，可以替换成 ConcurrentHashMap，是因为 Hashtable 虽然是线程安全的，但是它太粗暴了，它为所有的方法都上了同一把锁！</p><p>还有比如读读不需要互斥，写才需要互斥的场景，不要简单的用一把锁，可以用读写锁，这也是减少锁的粒度。</p><h2 id="线程同步和线程协作有什么区别？"><a href="#线程同步和线程协作有什么区别？" class="headerlink" title="线程同步和线程协作有什么区别？"></a>线程同步和线程协作有什么区别？</h2><p>线程同步是指多个线程按照预定的<strong>先后次序</strong>进行运行，即在一个线程对内存进行操作时，其他线程都不能对该内存地址进行操作，直到该线程完成操作。线程同步的主要目的是避免多个线程同时访问共享资源时出现的数据不一致或竞态条件等问题。实现线程同步的方法包括使用同步关键字（如<code>synchronized</code>）、锁（如<code>ReentrantLock</code>）、信号量等。</p><p>线程协作是指多个线程之间通过某种机制来<strong>协调工作，以完成共同的任务</strong>。线程协作的主要目的是实现线程之间的通信和协作，例如一个线程等待另一个线程完成某个操作后再继续执行，或者多个线程按照一定的顺序执行等。实现线程协作的方法包括使用等待&#x2F;通知机制（如<code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code>）、条件变量、线程阻塞队列等。</p><p>总的来说，线程同步主要关注的是线程之间的<strong>互斥和同步</strong>，以保证共享资源的正确性；而线程协作主要关注的是线程之间的<strong>通信和协作</strong>，以实现更复杂的任务。在实际编程中，线程同步和线程协作通常是结合使用的，以实现高效、正确的多线程程序。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">Java并发常见面试题总结（上） | JavaGuide</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">Java并发常见面试题总结（中） | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/java-basic-and-jvm.html#volatile">Java 与 JVM — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解 | JavaGuide</a></p><p><a href="https://javaguide.cn/java/concurrent/completablefuture-intro.html">CompletableFuture 详解 | JavaGuide</a></p><p><a href="https://zhuanlan.zhihu.com/p/139020914">CountdownLatch和CyclicBarrier的区别使用场景与具体实现 - 知乎</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%94%A8%E8%BF%87-countdownlatch-%E4%B9%88-%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%94%A8%E7%9A%84">Java并发常见面试题总结（下） | JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】思华年【忘川风华录·李商隐】</title>
      <link href="/p/27705e17/"/>
      <url>/p/27705e17/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%e3%80%90%e5%bf%98%e5%b7%9d%e9%a3%8e%e5%8d%8e%e5%bd%95%c2%b7%e6%9d%8e%e5%95%86%e9%9a%90%e3%80%91%e6%80%9d%e5%8d%8e%e5%b9%b4%e3%80%90%e6%98%9f%e5%b0%98infinity%e5%8e%9f%e5%88%9b%e3%80%91+%e2%80%9c%e5%94%af%e6%9c%89%e9%94%a6%e7%91%9f%e4%b8%80%e5%a3%b0%e5%bc%a6+%ef%bc%8c%e9%95%bf%e5%96%9f%e5%a4%a9%e5%9c%b0%e9%97%b4%e2%80%9d.jpg"></p><p>已灌词</p><p>BPM：138</p><hr><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>企划运营：酷丘</p><p>演唱：星尘infinity | 调校：坐标P</p><p>作词：冉语优 | 作曲：崔博源</p><p>编曲：Terence Teo | 制作人：酷丘</p><p>弦乐：国际首席爱乐乐团 | 乐队监制：李朋</p><p>吉他：Zeno | 箫：王华</p><p>和声编写：沈雾敛 | 分轨混音&#x2F;母带：周天澈@Studio21A</p><p>曲绘：梨乖酥、雪代薰、唐七奘</p><p>PV：宇言DX、千雨</p><p>协力：玄林、叶萱</p><h2 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h2><p>链接: <a href="https://pan.baidu.com/s/1-gqz3p7rZZX7crx1tQ2RVA">https://pan.baidu.com/s/1-gqz3p7rZZX7crx1tQ2RVA</a></p><p>提取码: pc7p</p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>月碎在了眉尖 梦也醉去樽前</p><p>再向明河中看一眼 看到迷离人间</p><br><p>姮娥横波眄 云母屏边 珠灯泪浅</p><p>鲤鱼引水仙 沧海明月 碧海青天</p><p>人向蓬山去 青鸟啼鹤怨</p><p>此生何未至 只留无题诗几篇</p><br><p>难道 是隔雨帘悲绮筵</p><p>忘前事 睡在残荷声间</p><p>是坐烛前 对空笺</p><p>遣怀时不忍用 最惘然的梦去填</p><br><p>难道 是登高野临古原</p><p>借茫茫的夜远望天阙</p><p>平生事如雀过眼</p><p>不知何以言</p><br><p>画楼看宝焰 舞喧诗艳 剑山酒泉</p><p>歌哭声重叠 白骨茂陵 墨客梁园</p><p>长安多少檐 萧萧风雨间</p><p>多少人走过 只留绝句几篇</p><br><p>从来 是古人绝来者鲜</p><p>偶得自天地悠悠之间</p><p>是岁晚心怀亦远</p><p>便与当年群贤 终老于辋川蓝田</p><br><p>从来 是朱雀桥边少年</p><p>乱雨中吟哦大厦倾前</p><p>老骨恃笔如倚剑</p><p>力竭欲回天</p><br><p>就在 满眼朝风暮雨间</p><p>是谁仍淋漓挥毫不倦</p><p>似一生非要写完</p><p>永无绝的悲欢 和爱恨感怀伤别</p><br><p>千载 万龄后古碑残卷</p><p>旧迹都化作松雪云烟</p><p>唯有锦瑟一声弦</p><p>长喟天地间</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 忘川风华录 </tag>
            
            <tag> 星尘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】并发（一） | 进程 &amp; 线程</title>
      <link href="/p/74e1a37c/"/>
      <url>/p/74e1a37c/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-线程和操作系统的线程有啥区别？"><a href="#Java-线程和操作系统的线程有啥区别？" class="headerlink" title="Java 线程和操作系统的线程有啥区别？"></a>Java 线程和操作系统的线程有啥区别？</h2><p>JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。</p><p>在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：</p><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><p>顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</p><br><h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><p><strong>进程</strong>：<strong>是资源分配的基本单位</strong>，每个进程都有自己独立的内存空间（代码段、数据段、堆栈等），可以看作是一个正在运行的程序实例。进程之间是相互独立的。</p><p><strong>线程</strong>：<strong>是 CPU 调度的基本单位</strong>，属于进程，一个进程中可以包含多个线程。线程共享进程的内存空间和资源（如文件句柄、数据段），但每个线程有自己独立的栈和寄存器。</p><p><strong>其它区别</strong>：</p><ul><li><strong>资源消耗不同</strong>：进程时需要为其分配独立的内存空间和系统资源，创建和切换进程的开销较大。线程间共享进程的资源，创建线程所需的开销较小，线程切换的开销也远小于进程切换。</li><li><strong>通信方式</strong>：因为各自独立的内存空间，进程间通信（IPC）较为复杂，需要使用管道、消息队列、共享内存、套接字等方式。同一进程内的线程共享内存空间，因此线程直接读写内存即可，但注意需要使用同步机制避免数据错误。</li></ul><p>从 JVM 角度说进程和线程之间的关系。</p><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><br><h2 id="什么是协程？Java-支持协程吗？"><a href="#什么是协程？Java-支持协程吗？" class="headerlink" title="什么是协程？Java 支持协程吗？"></a>什么是协程？Java 支持协程吗？</h2><p>协程（Coroutine），是一个比线程轻量级的执行单位。尤其适合于高并发场景和异步编程。协程在某些语言中被称为绿色线程（Green Threads）。</p><p>协程是在程序层面的定义，它不属于操作系统的概念，你可以理解<strong>一个线程在执行中可切换执行不同的协程的任务</strong>，对 CPU 而言还是在运行同一个线程。</p><p>我们在程序层面切换不同的协程来执行任务，它<strong>不属于操作系统调用，不涉及系统上下文的切换</strong>，所以它的性能相比线程切换会更高。</p><p>协程暂停执行后会保存当前的状态，当协程恢复执行时，可以从之前保存的状态开始执行，也就是程序层面来进行协程的调度管理。</p><p>像 Java 之前也是有协程的，但是后面废除了，好像是因为难度比较高，但是经过不断地迭代，在 Java21 又引入了虚拟线程，它是用户线程，和其他语言区别在于，它的实现是 JVM 级别，而不是 Java 语言级别。</p><p>典型的像 Go 是语言级别支持协程的。</p><p>综上，我们要知晓协程是程序调度的基本单位。线程可以包含多个协程，协程可以在单个线程中运行，当然也可以在多个线程之间共享。</p><p>总结特征：</p><ul><li>协程的切换是由<strong>程序显式控制</strong>的，而不是由操作系统调度。</li><li>协程的开销非常小，比线程更轻量，因为它们不需要操作系统内核的干预。</li><li>协程之间的切换是<strong>非抢占式的</strong>，也就是说，协程只有在显式调用挂起操作时才会切换。</li></ul><p>协程优点：</p><ul><li>由于不需要内核的参与，协程切换的开销非常低，可以显著提高程序的性能。</li><li>协程通过协作式调度避免了许多传统多线程编程中的复杂问题，如锁和竞态条件。</li><li>协程更容易实现大量并发操作，因为它们消耗的资源（如内存和 CPU）更少。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>协程非常适合处理大量 I&#x2F;O 操作（如网络请求、文件读写等），因为它们可以在等待 I&#x2F;O 完成时释放 CPU 资源。</p><p>协程非常适合高并发场景，例如可以使用协程来处理大量并发连接，以提高吞吐量和响应时间。</p><h3 id="关联协程库和框架"><a href="#关联协程库和框架" class="headerlink" title="关联协程库和框架"></a>关联协程库和框架</h3><p>除了 Go 语言的 goroutine，还有许多其他语言和框架支持协程，例如：</p><ul><li>Python 的 asyncio</li><li>Kotlin 的 协程</li><li><strong>JavaScript 的 async&#x2F;await</strong></li><li>C# 的 async&#x2F;await</li></ul><br><h2 id="Java-线程的生命周期和状态"><a href="#Java-线程的生命周期和状态" class="headerlink" title="Java 线程的生命周期和状态"></a>Java 线程的生命周期和状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，需要被显式唤醒才能继续执行。</li><li>TIME_WAITING：超时等待状态，线程进入等待状态，但指定了等待时间，超时后会被唤醒。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><p>Java 线程状态变迁图(图源：<a href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</a>)：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/640.png" alt="Java 线程状态变迁图"></p><ul><li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li></ul><br><h2 id="Java-中如何创建多线程？"><a href="#Java-中如何创建多线程？" class="headerlink" title="Java 中如何创建多线程？"></a>Java 中如何创建多线程？</h2><p>常见有以下五种方式创建使用多线程：</p><p>1）<strong>实现 <code>Runnable</code> 接口</strong>：</p><ul><li>实现 <code>Runnable</code> 接口的 <code>run()</code> 方法，使用 <code>Thread</code> 类的构造函数传入 <code>Runnable</code> 对象，调用 <code>start()</code> 方法启动线程。</li><li>例子：<code>Thread thread = new Thread(new MyRunnable()); thread.start();</code></li></ul><p>2）<strong>继承 <code>Thread</code> 类</strong>：</p><ul><li>继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，直接创建 <code>Thread</code> 子类对象并调用 <code>start()</code> 方法启动线程。</li><li>例子：<code>MyThread thread = new MyThread(); thread.start();</code></li></ul><p>3）**使用 <code>Callable</code> 和 <code>FutureTask</code>**：</p><ul><li>实现 <code>Callable</code> 接口的 <code>call()</code> 方法，使用 <code>FutureTask</code> 包装 <code>Callable</code> 对象，再通过 <code>Thread</code> 启动。</li><li>例子：<code>FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new MyCallable()); Thread thread = new Thread(task); thread.start();</code></li></ul><p>4）<strong>使用线程池（<code>ExecutorService</code>）</strong>：</p><ul><li>通过 <code>ExecutorService</code> 提交 <code>Runnable</code> 或 <code>Callable</code> 任务，不直接创建和管理线程，适合管理大量并发任务。</li><li>例子：<code>ExecutorService executor = Executors.newFixedThreadPool(10); executor.submit(new MyRunnable());</code></li></ul><p>5）<strong>CompletableFuture（本质也是线程池，默认 forkjoinpool）</strong>：</p><ul><li>Java 8 引入的功能，非常方便地进行异步任务调用，且通过 <code>thenApply</code>、<code>thenAccept</code> 等方法可以轻松处理异步任务之间的依赖关系。</li><li><code>CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;&#125;);</code></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>1）**<code>Runnable</code> vs <code>Callable</code>**：</p><ul><li><code>Runnable</code> 的 <code>run()</code> 方法不返回结果，不能抛出检查异常；<code>Callable</code> 的 <code>call()</code> 方法可以返回结果，并允许抛出检查异常。使用 <code>Callable</code> 更适合需要返回结果或处理异常的并发任务。</li></ul><h2 id="什么是-Java-的-CompletableFuture？"><a href="#什么是-Java-的-CompletableFuture？" class="headerlink" title="什么是 Java 的 CompletableFuture？"></a>什么是 Java 的 CompletableFuture？</h2><p>实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。举个例子：用户请求获取订单信息，可能需要同时获取用户信息、商品详情、物流信息、商品推荐等数据。</p><p>如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 <strong>无前后顺序关联</strong> 的，可以 <strong>并行执行</strong> ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。对于存在前后调用顺序关系的任务，可以进行任务编排。</p><p>对于 Java 程序来说，Java 8 才被引入的 <code>CompletableFuture</code> 可以帮助我们来做多个任务的编排，功能非常强大。</p><h3 id="Future-是什么？"><a href="#Future-是什么？" class="headerlink" title="Future 是什么？"></a>Future 是什么？</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p>CompletableFuture 的核心特性如下：</p><p>1）异步执行：通过 runAsync 和 supplyAsync 方法，可以异步地执行任务。</p><p>2）任务完成回调：使用 thenApply、thenAccept、thenRun 等方法，可以在任务完成后执行回调。</p><p>3）任务组合：可以将多个 CompletableFuture 组合在一起，通过 thenCombine、thenCompose 等方法，处理多个异步任务之间的依赖关系。</p><p>4）异常处理：提供了 exceptionally、handle 等方法，可以在异步任务发生异常时进行处理。</p><p>5）并行处理：可以通过 allOf 和 anyOf 方法，并行地执行多个异步任务，并在所有任务完成或任意一个任务完成时执行回调。</p><h3 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h3><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><code>thenApply()</code></li><li><code>thenAccept()</code></li><li><code>thenRun()</code></li><li><code>whenComplete()</code></li></ul><p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenApply()</code> 方法使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>你还可以进行 <strong>流式调用</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p><h2 id="Java-中线程之间如何进行通信？"><a href="#Java-中线程之间如何进行通信？" class="headerlink" title="Java 中线程之间如何进行通信？"></a>Java 中线程之间如何进行通信？</h2><p>线程之间的通信（Inter-Thread Communication, ITC）主要依赖于<strong>共享内存</strong>。由于线程共享同一个进程的内存空间，因此可以直接通过共享变量进行通信。</p><p>常见的线程通信方式包括：</p><p>1）共享变量：</p><ul><li>线程可以通过访问共享内存变量来交换信息（需要注意<strong>同步问题</strong>，防止数据竞争和不一致）。</li><li>共享的也可以是文件，例如写入同一个文件来进行通信。</li></ul><p>2）同步机制：</p><ul><li>synchronized：Java 中的同步关键字，用于确保同一时刻只有一个线程可以访问共享资源，利用 Object 类提供的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>实现线程之间的等待&#x2F;通知机制</li><li>ReentrantLock：配合 Condition 提供了类似于 wait()、notify() 的等待&#x2F;通知机制</li><li>BlockingQueue：通过阻塞队列实现生产者-消费者模式</li><li>CountDownLatch：可以允许一个或多个线程等待，直到在其他线程中执行的一组操作完成</li><li>CyclicBarrier：可以让一组线程互相等待，直到到达某个公共屏障点</li><li>Volatile：Java 中的关键字，确保变量的可见性，防止指令重排</li><li>Semaphore：信号量，可以控制对特定资源的访问线程数</li></ul><p>补充 Object 中的方法说明：</p><ul><li>wait()：使线程进入等待状态，释放锁。</li><li>notify()：唤醒单个等待线程。</li><li>notifyAll()：唤醒所有等待线程。</li></ul><h2 id="Java-中父子线程之间如何传递数据？"><a href="#Java-中父子线程之间如何传递数据？" class="headerlink" title="Java 中父子线程之间如何传递数据？"></a>Java 中父子线程之间如何传递数据？</h2><p>这个问题其实问的是 InheritableThreadLocal 类。</p><p>InheritableThreadLocal 相比 ThreadLocal 它可以在父线程创建子线程的时候，将 InheritableThreadLocal 变量复制给子线程而实现数据的传递。</p><p>使用方式和 ThreadLocal 一致，无非就是将类替换成 InheritableThreadLocal 即可。</p><p>原理也不难，就是父线程在创建一个新的线程时，会将 InheritableThreadLocal 值传递给子线程。因为 InheritableThreadLocal 重写了 ThreadLocal 类的 createMap 方法，它会在创建新线程时将父线程的 ThreadLocalMap 复制到子线程中，从而使得子线程可以继承父线程的 InheritableThreadLocal 值。</p><h2 id="Java-中的线程安全是什么意思？"><a href="#Java-中的线程安全是什么意思？" class="headerlink" title="Java 中的线程安全是什么意思？"></a>Java 中的线程安全是什么意思？</h2><p>在Java中，线程安全指的是当多个线程并发访问、变更共享的资源（包括但不限制为共享的全局变量、数据存储），能够保证程序的执行结果是正确和可预测的。</p><p>如果不能有效处理多线程对资源的并发访问和变更，就可能会导致并发问题，出现数据不一致、数据竞争等问题。</p><h3 id="线程安全实现方式"><a href="#线程安全实现方式" class="headerlink" title="线程安全实现方式"></a>线程安全实现方式</h3><p>为了实现线程安全，可以采用以下常见的方法：</p><p>1）原子操作：使用不可分割的操作，避免并发修改数据问题，例如基于Java并发包下的原子实现类<code>AtomicInteger</code>进行数据叠加。</p><p>2）锁机制：使用 <code>synchronized</code> 关键字或者 <code>Lock</code> 接口及其实现类（如 <code>ReentrantLock</code> ）来实现同步控制。</p><p>3）线程安全的集合类：使用如 <code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 等，而不是非线程安全的集合类（如 <code>HashMap</code> 、 <code>ArrayList</code> ）。</p><p>4）并发控制：使用信号量、条件变量等控制线程的执行顺序，例如<code>Semaphore</code>、<code>CountDownLatch</code></p><h2 id="线程安全的集合有哪些？"><a href="#线程安全的集合有哪些？" class="headerlink" title="线程安全的集合有哪些？"></a>线程安全的集合有哪些？</h2><p><code>ConcurrentHashMap</code> 、 <code>CopyOnWriteArrayList</code> 等。</p><p>这里的详细一点：<a href="https://rean-schwarze.github.io/p/9b8bc45a/">【Java】集合（二） | Rean’s Blog (rean-schwarze.github.io)</a></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>JDK 1.7 <code>ConcurrentHashMap</code> 采用的是<strong>分段锁</strong>，即每个 <code>Segment</code> 是独立的，可以并发访问不同的 <code>Segment</code>，默认是 16 个 <code>Segment</code>，所以最多有 16 个线程可以并发执行。具体上锁的方式来源于 Segment，<strong>这个类实际继承了 ReentrantLock</strong>，因此它自身具备加锁的功能。</p><p>而 JDK 1.8 移除了 <code>Segment</code>，锁的粒度变得更加细化，锁只在链表或红黑树的<strong>节点级别</strong>上进行。通过 CAS 进行插入操作，只有在更新链表或红黑树时才使用 <code>synchronized</code>，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。</p><p>并且 JDK 1.7 <code>ConcurrentHashMap</code> 只使用了<strong>数组 + 链表</strong>的结构，而 JDK 1.8 和 <code>HashMap</code>一样引入了红黑树。</p><p>除此之外，还有扩容的区别以及 <code>size</code> 方法的计算也不一样。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它通过<strong>写时复制</strong>机制，即在每次修改（写入）操作时，复制原始数组的内容来保证线程安全，在副本上进行修改，然后将修改后的副本替换原来的数据结构。</p><p>由于写操作涉及复制整个数组，所以它的写操作开销较大，但读取操作则完全无锁。这使得 <code>CopyOnWriteArrayList</code> 适合于<strong>读多写少</strong>的场景。</p><h2 id="你了解-Java-线程池的原理吗？"><a href="#你了解-Java-线程池的原理吗？" class="headerlink" title="你了解 Java 线程池的原理吗？"></a>你了解 Java 线程池的原理吗？</h2><p>首先，简述线程池的作用：线程池是一种池化技术，用于预先创建并管理一组线程，避免频繁创建和销毁线程的开销，提高性能和响应速度。</p><p>然后，简单带一下线程池的几个关键的配置：核心线程数、最大线程数、空闲存活时间、工作队列、拒绝策略。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240816171159.png"></p><p>最后，简述一下线程池的工作原理，按照下面的顺序来回答即可：</p><ol><li>默认情况下线程不会预创建，任务提交之后才会创建线程（不过设置 prestartAllCoreThreads 可以预创建核心线程）。</li><li>当核心线程满了之后不会新建线程，而是把任务堆积到工作队列中。</li><li>如果工作队列放不下了，然后才会新增线程，直至达到最大线程数。</li><li>如果工作队列满了，然后也已经达到最大线程数了，这时候来任务会执行拒绝策略。</li><li>如果线程空闲时间超过空闲存活时间，并且线程线程数是大于核心线程数的则会销毁线程，直到线程数等于核心线程数（设置 allowCoreThreadTimeOut 为 true 可以回收核心线程，默认为 false）。</li></ol><h3 id="如何设置-Java-线程池的线程数？"><a href="#如何设置-Java-线程池的线程数？" class="headerlink" title="如何设置 Java 线程池的线程数？"></a>如何设置 Java 线程池的线程数？</h3><p>线程池的线程数设置需要看具体执行的任务是什么类型的。</p><p>任务类型可以分：CPU 密集型任务和 I&#x2F;O 密集型任务。</p><h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p>CPU 密集型任务，就好比单纯的数学计算任务，它不会涉及 I&#x2F;O 操作，也就是说它可以充分利用 CPU 资源（如果涉及 I&#x2F;O，在进行 I&#x2F;O 的时候 CPU 是空闲的），不会因为 I&#x2F;O 操作被阻塞，因此不需要很多线程，线程多了上下文开销反而会变多。</p><p>根据经验法则，<code>CPU 密集型任务线程数 = CPU 核心数 + 1</code>。</p><h4 id="I-O-密集型任务"><a href="#I-O-密集型任务" class="headerlink" title="I&#x2F;O 密集型任务"></a>I&#x2F;O 密集型任务</h4><p>I&#x2F;O 密集型任务，有很多 I&#x2F;O 操作，例如文件的读取、数据库的读取等等，任务在读取这些数据的时候，是无法利用 CPU 的，对应的线程会被阻塞等待 I&#x2F;O 读取完成，因此如果任务比较多，就需要有更多的线程来执行任务，来提高等待 I&#x2F;O 时候的 CPU 利用率。</p><p>根据经验法则，<code>I/O 密集型任务线程数 = CPU 核心数 * 2</code> 或更多一些。</p><p><strong>注意，实际的最佳线程数还是需要具体应用压测分析的，以上公式仅供参考！</strong></p><h3 id="Java-线程池核心线程数在运行过程中能修改吗？如何修改？"><a href="#Java-线程池核心线程数在运行过程中能修改吗？如何修改？" class="headerlink" title="Java 线程池核心线程数在运行过程中能修改吗？如何修改？"></a>Java 线程池核心线程数在运行过程中能修改吗？如何修改？</h3><p><strong>可以动态修改的</strong>。Java 的 <code>ThreadPoolExecutor</code> 提供了动态调整核心线程数和最大线程数的方法。</p><p>1）<strong>修改核心线程数的方法</strong>：</p><ul><li>使用 <code>ThreadPoolExecutor.setCorePoolSize(int corePoolSize)</code> 方法可以动态修改核心线程数。<code>corePoolSize</code> 参数代表线程池中的核心线程数，当池中线程数量少于核心线程数时，会创建新的线程来处理任务。这个修改可以在线程池运行的过程中进行，立即生效。</li></ul><p>2）<strong>注意事项</strong>：</p><ul><li>核心线程数的修改不会中断现有任务，新的核心线程数会在新任务到来时生效。</li><li><code>setCorePoolSize()</code> 方法可以减少核心线程数，但如果当前线程池中的线程数量超过了新的核心线程数，多余的线程不会立即被销毁，直到这些线程空闲后被回收。</li></ul><h3 id="线程池监控与调整"><a href="#线程池监控与调整" class="headerlink" title="线程池监控与调整"></a><strong>线程池监控与调整</strong></h3><ul><li>在实际生产环境中，可以通过监控线程池的状态（如当前活跃线程数、队列长度等）来决定是否动态调整线程池大小。</li><li>可以使用 JMX（Java Management Extensions）来监控 <code>ThreadPoolExecutor</code>，结合指标来自动调整线程池大小以优化性能。</li></ul><h3 id="Java-线程池有哪些拒绝策略？"><a href="#Java-线程池有哪些拒绝策略？" class="headerlink" title="Java 线程池有哪些拒绝策略？"></a>Java 线程池有哪些拒绝策略？</h3><p>看源码，一共提供了 4 种（其中的 blockPolicy 是 hutool 的不算 ThreadPoolExecutor）：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QpgJV87M_1e539a6e-6c95-4007-a6ab-8657feeea739.png"></p><ol><li>AbortPolicy，当任务队列满且没有线程空闲，此时添加任务会直接<strong>抛出 RejectedExecutionException 错误</strong>，这也是默认的拒绝策略。适用于必须通知调用者任务未能被执行的场景。</li><li>CallerRunsPolicy，当任务队列满且没有线程空闲，此时<strong>添加任务由即调用者线程执行</strong>。适用于希望通过减缓任务提交速度来稳定系统的场景。</li><li>DiscardOldestPolicy，当任务队列满且没有线程空闲，会<strong>删除最早的任务</strong>，然后重新提交当前任务。适用于希望丢弃最旧的任务以保证新的重要任务能够被处理的场景。</li><li>DiscardPolicy，<strong>直接丢弃</strong>当前提交的任务，不会执行任何操作，也不会抛出异常。适用于对部分任务丢弃没有影响的场景，或系统负载较高时不需要处理所有任务。</li></ol><h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>可以实现 RejectedExecutionHandler 接口来定义自定义的拒绝策略。例如，记录日志或将任务重新排队。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected&quot;</span>);</span><br><span class="line">        <span class="comment">// 可以在这里实现日志记录或其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？"><a href="#Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？" class="headerlink" title="Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？"></a>Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</h2><p>默认情况下，线程池不会直接报告哪个线程发生了异常，但是可以采取以下几种方法：</p><p>1）**自定义线程池的 <code>ThreadFactory</code>**：</p><ul><li>通过自定义 <code>ThreadFactory</code>，为每个线程设置一个异常处理器（<code>UncaughtExceptionHandler</code>），在其中记录发生异常的线程信息。</li></ul><p>2）**使用 <code>Future</code>**：</p><ul><li>提交任务时使用 <code>submit()</code> 方法，而不是 <code>execute()</code>，这样可以通过 <code>Future</code> 对象捕获并检查任务的执行结果和异常。</li></ul><p>3）<strong>任务内部手动捕获异常并记录</strong>：</p><ul><li>在任务的 <code>run()</code> 方法内部，使用 <code>try-catch</code> 结构捕获异常，并记录或处理异常，同时记录线程信息。</li></ul><h2 id="什么是-Java-的-Timer？"><a href="#什么是-Java-的-Timer？" class="headerlink" title="什么是 Java 的 Timer？"></a>什么是 Java 的 Timer？</h2><p>Timer 可以实现延时任务，也可以实现周期性任务，它的核心就是一个优先队列和封装的执行任务的线程。</p><p>实现原理是：维持一个小顶堆，即最快需要执行的任务排在优先队列的第一个，根据堆的特性我们知道插入和删除的时间复杂度都是 O(logn)。</p><p>然后有个 TimerThread 线程不断地拿排着的第一个任务的执行时间和当前时间做对比。</p><p>如果时间到了先看看这个任务是不是周期性执行的任务，如果是则修改当前任务时间为下次执行的时间，如果不是周期性任务则将任务从优先队列中移除。最后执行任务。如果时间还未到则调用 <code>wait()</code> 等待。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/TrqE6H13_f1c9ec68-db02-4cf1-98b5-785fbf526725.png" alt="img"></p><p>可以看出 Timer 实际就是根据任务的执行时间维护了一个优先队列，并且起了一个线程不断地拉取任务执行。</p><p>有什么弊端呢？</p><p>首先优先队列的插入和删除的时间复杂度是O(logn)，当数据量大的时候，频繁的入堆出堆性能有待考虑。</p><p>并且是单线程执行，那么如果一个任务执行的时间过久则会影响下一个任务的执行时间(当然你任务的run要是异步执行也行)。</p><p>并且从代码可以看到对异常没有做什么处理，那么一个任务出错的时候会导致之后的任务都无法执行。</p><h2 id="Java-并发库中提供了哪些线程池实现？它们有什么区别？"><a href="#Java-并发库中提供了哪些线程池实现？它们有什么区别？" class="headerlink" title="Java 并发库中提供了哪些线程池实现？它们有什么区别？"></a>Java 并发库中提供了哪些线程池实现？它们有什么区别？</h2><p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p><ul><li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>这个线程池实现特点是<strong>核心线程数和最大线程数是一致的</strong>，然后 keepAliveTime 的时间是 0 ，队列是无界队列。</p><p>按照这几个设定可以得知它任务线程数是固定，如其名 Fixed。</p><p>然后可能出现 OOM 的现象，因为队列是无界的，所以任务可能挤爆内存。</p><p>它的特性就是<strong>我就固定出这么多线程，多余的任务就排队，就算队伍排爆了我也不管</strong>。</p><p>因此不建议用这个方式来创建线程池，仅用于提交相对稳定且数量确定的任务场景。</p><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p>这个实现 JDK8 才有，从代码可以看到返回的就是 ForkJoinPool，我们 JDK8 用的并行流就是这个线程池。</p><p>比如 <code>users.parallelStream().filter(...).sum();</code> 用的就是 ForkJoinPool 。</p><p>线程数会参照当前服务器可用的处理核心数，并行数是核心数-1。</p><p>这个线程池的特性从名字就可以看出 Stealing，<strong>会窃取任务</strong>。</p><p>每个线程都有自己的<strong>双端队列</strong>，当自己队列的任务处理完毕之后，会去<strong>别的线程的任务队列尾部拿任务来执行</strong>，加快任务的执行速率。</p><p>至于 ForkJoin 的话，就是<strong>分而治之</strong>，把大任务分解成一个个小任务，然后分配执行之后再总和结果。</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>一个线程池就一个线程，配备的也是无界队列。</p><p>它的特性就是能保证任务是按顺序执行的。</p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>这个线程池<strong>核心线程数是 0，最大线程数看作无限大</strong>，且然后任务队列 SynchronousQueue 是没有存储空间的，每个插入操作必须等待一个删除操作。</p><p>简单理解就是<strong>来个任务就必须找个线程接着</strong>，不然就阻塞了。</p><p>cached 意思就是会缓存之前执行过的线程，缓存时间是 60 秒，这个时候如果有任务进来就可以用之前的线程来执行。</p><p>所以它<strong>适合用在短时间内有大量短任务的场景</strong>。如果暂无可用线程，那么来个任务就会新启一个线程去执行这个任务，快速响应任务。</p><p>但是如果任务的时间很长，那存在的线程就很多，上下文切换就很频繁，切换的消耗就很明显，并且存在太多线程在内存中，也有 OOM 的风险。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>用于需要定时或周期性执行任务的场景，底层使用 DelayedWorkQueue 实现延时任务。</p><h2 id="Java-中的-DelayQueue-和-ScheduledThreadPool-有什么区别？"><a href="#Java-中的-DelayQueue-和-ScheduledThreadPool-有什么区别？" class="headerlink" title="Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？"></a>Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？</h2><p>DelayQueue 是一个阻塞队列，而 ScheduledThreadPool 是线程池，不过内部核心原理都是差不多的。</p><p>DelayQueue 是利用优先队列存储元素，当从队列中获取任务的时候，如果最老的任务已经到了执行时间，可以从队列中出队一个任务，反之可以获得 null 或者阻塞等待任务到时。</p><p>ScheduledThreadPool 内部也使用的一个优先队列 DelayedWorkQueue 且可以内部多线程执行任务，支持定时执行的任务，即每隔一段时间执行一次的任务。</p><h2 id="如何在-Java-中控制多个线程的执行顺序？"><a href="#如何在-Java-中控制多个线程的执行顺序？" class="headerlink" title="如何在 Java 中控制多个线程的执行顺序？"></a>如何在 Java 中控制多个线程的执行顺序？</h2><p>1）CompletableFuture，它内部有 thenRun 的方法</p><p>2）synchronized + wait()&#x2F;notify() ，通过对象锁和线程间通信机制来控制线程的执行顺序。</p><p>3）ReentrantLock + condition。</p><p>4）Thread 类的 join()，通过调用这个方法，可以使一个线程等待另一个线程执行完毕后再继续执行。</p><p>5）CountDownLatch，使一个或多个线程等待其他线程完成各自工作后再继续执行。</p><p>6）CyclicBarrier，使多个线程互相等待，直到所有线程都到达某个共同点后再继续执行。</p><p>7）Semaphore，控制线程的执行顺序，适用于需要限制同时访问资源的线程数量的场景。</p><p>8）线程池，内部仅设置一个线程来执行任务，按序的将任务提交到线程池中就可以了。</p><h2 id="为什么在-Java-中需要使用-ThreadLocal？"><a href="#为什么在-Java-中需要使用-ThreadLocal？" class="headerlink" title="为什么在 Java 中需要使用 ThreadLocal？"></a>为什么在 Java 中需要使用 ThreadLocal？</h2><p>就是为了通过本地化资源来避免共享，避免了多线程竞争导致的锁等消耗。</p><p>这里需要强调一下，不是说任何东西都能直接通过避免共享来解决，因为有些时候就必须共享。</p><p>举个例子：当利用多线程同时累加一个变量的时候，此时就必须共享，因为一个线程的对变量的修改需要影响要另个线程，不然累加的结果就不对了。</p><p>再举个不需要共享的例子：比如现在每个线程需要判断当前请求的用户来进行权限判断，那这个用户信息其实就不需要共享，因为每个线程只需要管自己当前执行操作的用户信息，跟别的用户不需要有交集。</p><h2 id="Java-中的-ThreadLocal-是如何实现线程资源隔离的？"><a href="#Java-中的-ThreadLocal-是如何实现线程资源隔离的？" class="headerlink" title="Java 中的 ThreadLocal 是如何实现线程资源隔离的？"></a>Java 中的 ThreadLocal 是如何实现线程资源隔离的？</h2><p><strong>需要在每个线程的本地都存一份值</strong>，说白了就是每个线程需要有个变量，来存储这些需要本地化资源的值，并且值有可能有多个，所以怎么弄呢？</p><p>在线程对象内部搞个 map，把 ThreadLocal 对象自身作为 key，把它的值作为 map 的值。</p><p>这样每个线程可以利用同一个对象作为 key ，去各自的 map 中找到对应的值。</p><p>这不就完美了嘛！比如我现在有 3 个 ThreadLocal 对象，2 个线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal1 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;Integer&gt; threadLocal2 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">ThreadLocal&lt;Integer&gt; threadLocal3 =  <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>那此时 ThreadLocal 对象和线程的关系如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f32303232303132333136353032302e706e67.png"></p><p>这样一来就满足了本地化资源的需求，每个线程维护自己的变量，互不干扰，实现了变量的线程隔离，同时也满足存储多个本地变量的需求，完美！</p><h2 id="为什么在-Java-中使用-ThreadLocal-时需要用弱引用来防止内存泄漏？"><a href="#为什么在-Java-中使用-ThreadLocal-时需要用弱引用来防止内存泄漏？" class="headerlink" title="为什么在 Java 中使用 ThreadLocal 时需要用弱引用来防止内存泄漏？"></a>为什么在 Java 中使用 ThreadLocal 时需要用弱引用来防止内存泄漏？</h2><p>我们知道，如果一个对象没有强引用，只有弱引用的话，这个对象是活不过一次 GC 的，所以这样的设计就是为了让当外部没有对 ThreadLocal 对象有强引用的时候，可以将 ThreadLocal 对象给清理掉。</p><p>那为什么要这样设计呢？</p><p>假设 Entry 对 key 的引用是强引用，那么来看一下这个引用链：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240816220605.png"></p><p>从这条引用链可以得知，如果线程一直在，那么相关的 ThreadLocal 对象肯定会一直在，因为它一直被强引用着。</p><p>看到这里，可能有人会说那线程被回收之后就好了呀。</p><p>重点来了！线程在我们应用中，常常是以线程池的方式来使用的，比如 Tomcat 的线程池处理了一堆请求，而线程池中的线程一般是不会被清理掉的，所以这个引用链就会一直在，那么 ThreadLocal 对象即使没有用了，也会随着线程的存在，而一直存在着！</p><p>所以这条引用链需要弱化一下，而能操作的只有 Entry 和 key 之间的引用，所以它们之间用弱引用来实现。</p><p>与之对应的还有一个条引用链，结合着上面的线程引用链都画出来：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f79657373696d6964612f63646e5f696d6167652f696d672f32303232303132333136353134362e706e67.png"></p><p>另一条引用链就是栈上的 ThreadLocal 引用指向堆中的 ThreadLocal 对象，这个引用是强引用。</p><p>如果有这条强引用存在，那说明此时的 ThreadLocal 是有用的，此时如果发生 GC 则 ThreadLocal 对象不会被清除，因为有个强引用存在。</p><p>当随着方法的执行完毕，相应的栈帧也出栈了，此时这条强引用链就没了，如果没有别的栈有对 ThreadLocal 对象的引用，那么说明 ThreadLocal 对象无法再被访问到(定义成静态变量的另说)。</p><p>那此时 ThreadLocal 只存在与 Entry 之间的弱引用，那此时发生 GC 它就可以被清除了，因为它无法被外部使用了，那就等于没用了，是个垃圾，应该被处理来节省空间。</p><p>至此，想必你已经明白为什么 Entry 和 key 之间要设计为弱引用，就是因为<strong>平日线程的使用方式基本上都是线程池</strong>，所以<strong>线程的生命周期就很长</strong>，可能从你部署上线后一直存在，<strong>而 ThreadLocal 对象的生命周期可能没这么长</strong>。</p><p>所以为了能让已经没用 ThreadLocal 对象得以回收，所以 Entry 和 key 要设计成弱引用，不然 Entry 和 key是强引用的话，ThreadLocal 对象就会一直在内存中存在。</p><p>但是这样设计就可能产生内存泄漏。</p><p>那什么叫内存泄漏？就是指：程序中已经无用的内存无法被释放，造成系统内存的浪费。</p><p>当 Entry 中的 key 即 ThreadLocal 对象被回收了之后，会发生 Entry 中 key 为 null 的情况，其实这个 Entry 就已经没用了，但是又无法被回收，因为有 Thread-&gt;ThreadLocalMap -&gt;Entry 这条强引用在，这样没用的内存无法被回收就是内存泄露。</p><p>那既然会有内存泄漏还这样实现？</p><p>这里就要填一填上面的坑了，也就是涉及到的关于 expungeStaleEntry即清理过期的 Entry 的操作。</p><p>设计者当然知道会出现这种情况，所以在多个地方都做了清理无用 Entry ，即 key 已经被回收的 Entry 的操作。</p><p>比如通过 key 查找 Entry 的时候，如果下标无法直接命中，那么就会向后遍历数组，此时遇到 key 为 null 的 Entry 就会清理掉。</p><h3 id="如果将-value-也设置为弱引用，是否可以防止内存泄漏？"><a href="#如果将-value-也设置为弱引用，是否可以防止内存泄漏？" class="headerlink" title="如果将 value 也设置为弱引用，是否可以防止内存泄漏？"></a>如果将 value 也设置为弱引用，是否可以防止内存泄漏？</h3><p>答案肯定是可以的。value 一般都是局部变量赋值，栈帧出栈后，局部变量的强引用没了，如果 Entry 对其是弱引用，那么发生一次 gc 后 value 就被回收了，肯定没内存泄漏问题。</p><p>但是一次 gc 就没了，等用到的时候不就找不到 value 了？<strong>所以 value 不能被设置为弱引用</strong>。</p><h2 id="Java-中使用-ThreadLocal-的最佳实践是什么？"><a href="#Java-中使用-ThreadLocal-的最佳实践是什么？" class="headerlink" title="Java 中使用 ThreadLocal 的最佳实践是什么？"></a>Java 中使用 ThreadLocal 的最佳实践是什么？</h2><p>最佳实践是用完了之后，调用一下 remove 方法，手工把 Entry 清理掉，这样就不会发生内存泄漏了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> yesDosth &#123;</span><br><span class="line">threadlocal.set(xxx);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do sth</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">threadlocal.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是使用 Threadlocal 的一个正确姿势啦，即不需要的时候，显示的 remove 掉。</p><p>当然，如果不是线程池使用方式的话，其实不用关系内存泄漏，反正线程执行完了就都回收了，但是一般我们都是使用线程池的，可能只是你没感觉到。</p><p>比如你用了 tomcat ，其实请求的执行用的就是 tomcat 的线程池，这就是隐式使用。</p><p>还有一个问题，关于 withInitial 也就是初始化值的方法。</p><p>由于类似 tomcat 这种隐式线程池的存在，即线程第一次调用执行 Threadlocal 之后，如果没有显示调用 remove 方法，则这个 Entry 还是存在的，那么下次这个线程再执行任务的时候，不会再调用 withInitial 方法，也就是说会拿到上一次执行的值。</p><p><strong>但是你以为执行任务的是新线程，会初始化值，然而它是线程池里面的老线程，这就和预期不一致了，所以这里需要注意。</strong></p><h2 id="ThreadLocal-的缺点？"><a href="#ThreadLocal-的缺点？" class="headerlink" title="ThreadLocal 的缺点？"></a>ThreadLocal 的缺点？</h2><p>ThreadLocal 的一个缺点：hash 冲突用的是<strong>线性探测法</strong>，效率低。</p><p>还有一个缺点是 ThreadLocal 使用了 WeakReference 以保证资源可以被释放，但是这可能会产生一些 Etnry 的 key 为 null，即无用的 Entry 存在。</p><p>所以调用 ThreadLocal 的 get 或 set 方法时，会主动清理无用的 Entry，减轻内存泄漏的发生。</p><p>还有一个就是内存泄漏的问题了，当然这个问题只存在于用线程池使用的时候，并且上面也提到了 get 和 set 的时候也能清理一些无用的 Key，所以没有那么的夸张，只要记得用完后调用 ThreadLocal#remove 就不会有内存泄漏的问题了。</p><h2 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h2><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><h2 id="Java-中-Thread-sleep-0-的作用是什么？"><a href="#Java-中-Thread-sleep-0-的作用是什么？" class="headerlink" title="Java 中 Thread.sleep(0) 的作用是什么？"></a>Java 中 Thread.sleep(0) 的作用是什么？</h2><p>看起来 Thread.sleep(0) 很奇怪，让线程睡眠 0 毫秒？那不是等于没睡眠吗？</p><p>是的，确实没有睡眠，但是调用了 Thread.sleep(0) 当前的线程会暂时出让 CPU ，这使得 CPU 的资源短暂的空闲出来别的线程有机会得到 CPU 资源。</p><p>所以，在一些大循环场景，如果害怕这段逻辑一直占用 CPU 资源，则可以调用 Thread.sleep(0) 让别的线程有机会使用 CPU。</p><p>实际上 Thread.yield() 这个命令也可以让当前线程主动放弃 CPU 使用权，使得其他线程有机会使用 CPU。</p><h2 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h2><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">Java并发常见面试题总结（上） | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/operating-system.html#id33">操作系统 — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">Java并发常见面试题总结（中） | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/java-basic-and-jvm.html#volatile">Java 与 JVM — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://xiaolincoding.com/os/4_process/process_base.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Halo 博客配置</title>
      <link href="/p/b5223f80/"/>
      <url>/p/b5223f80/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Halo-是什么？"><a href="#Halo-是什么？" class="headerlink" title="Halo 是什么？"></a>Halo 是什么？</h3><p>Halo 是一款强大易用的开源建站工具，你可以理解为是 Hexo 的动态版本（</p><p>官网：<a href="https://www.halo.run/">Halo - 强大易用的开源建站工具</a></p><h3 id="为什么选择-Halo？"><a href="#为什么选择-Halo？" class="headerlink" title="为什么选择 Halo？"></a>为什么选择 Halo？</h3><p>这个话题免不了要将 Halo 和 Hexo 进行比较，那么就列出它们各自的优缺点吧~</p><h4 id="Halo"><a href="#Halo" class="headerlink" title="Halo"></a>Halo</h4><p>优点：</p><ol><li>Halo 是动态博客，这意味着我们无需在每次发布文章或进行修改时都要经历冗长的生成&amp;部署的步骤</li><li>Halo 可以部署在服务器上，我们可以随时随地、跨平台访问后台来进行文章的修改、发布或记录此刻的瞬间想法</li><li>所有设置、文章的新建&#x2F;编辑&#x2F;修改&#x2F;发布等都是可视化的，非常方便！</li><li>配置简单，毕竟都是点点点就可以了，不用一条一条命令输入执行，也不用对着密密麻麻的配置文件一个一个修改</li></ol><p>缺点：</p><ol><li>如果部署在服务器上，那么首先得有一个服务器（，而且服务器的安全、续期等也要考虑</li><li>此外大概率也需要一个域名，除非不嫌弃</li><li>文章迁移较为麻烦，原本的<code>FrontMatter</code> 这里是不认的，需要额外设置，以及<code>Tag Plugins</code>的使用方式不同。（第一次接触博客的朋友就不用担心这个了）</li><li>即刻短文能编辑的东西就只有文字和图片（还得手动从附件里面选，不能直接输入链接），没有音乐、视频、链接、自定义日期</li></ol><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p>优点：</p><ol><li>可以无需服务器进行部署，也可以不需要域名（</li><li>稳定，你猜猜是 Github 寄的概率高还是你的服务器寄的概率高（</li></ol><p>缺点：</p><ol><li>Hexo 是静态博客，文章一多起来，生成和部署需要非常久，100+文章就需要1分钟+来生成</li><li>网上的入门教程（包括本站，后续会修改~）都是让你用控制台来进行操作的，显得非常原始人，虽然有 Hexon 这样的可视化工具，但是比较鲜为人知（本人正在基于原版上开发新功能！）</li><li>源文件及配置文件只在本地保存，万一硬盘寄了（真人真事（。））那就全完了</li></ol><p>当然我不怕折腾，准备两手抓，两边同步更新，就当是互相的一个备份吧（</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>此处基于宝塔来进行 Halo 的搭建，不会宝塔的朋友可以翻翻我前面不知道多少篇教程（</p><p>确保服务器端口<code>8090</code>没有被别的什么东西占用！！！有的话改成别的！</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>点击宝塔面板左侧的<code>Docker</code>，如果还没安装过，直接点击安装即可</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>理论上可以在宝塔面板里面拉取，但是我试过了，不行（</p><p>于是选择在控制台里面拉取了，进入服务器的控制台后输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.fit2cloud.com/halo/halo:2.18</span><br></pre></td></tr></table></figure><p>稍等片刻即可</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>点击<code>容器</code>-<code>创建容器</code>，名称随便输，镜像选择刚刚拉取的，端口添加一组映射：自定义端口→8090（当然还是建议8090，防止对不上号（））</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723640825286.png"></p><p>别忘了在防火墙开放自定义端口！</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在首次访问网站的时候会自动跳转到初始化页面，你需要完成这个步骤才能正常使用 Halo。</p><p><img src="https://docs.halo.run/assets/images/setup-1b63edae411fece2cb79d0369e87853b.png" alt="Setup"></p><p>表单项说明：</p><ol><li><strong>站点名称</strong>：网站的名称，将会显示在浏览器标签页上。</li><li><strong>邮箱</strong>：初始管理员的邮箱地址。</li><li><strong>用户名</strong>：初始管理员的用户名。</li><li><strong>密码</strong>：初始管理员的密码。</li><li><strong>确认密码</strong>：重复输入密码以验证是否匹配。</li></ol><p>输入完成之后点击<strong>初始化</strong>按钮即可完成初始化，初始化完成之后，将会跳转到登录页面，输入刚才设置的用户名和密码即可登录。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>我们需要通过反向代理，反向绑定映射的方式使得我们能够通过域名来访问我们的Halo博客。</p><p>首先在宝塔面板里面添加一个网站，直接点创建就好，其他的默认。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/6ef480629bb34c46eea63214191a7ead.png"></p><p>在站点修改中点击反向代理并创建。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240403-1f721715.png"></p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><p>在后台面板（<code>http://你的地址/console</code>）中找到左侧的系统 - 设置，点击进入</p><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723653802356.png" alt="QQ_1723653802356"></p><p>以 Halo 2.0 的<a href="https://github.com/halo-dev/theme-earth">默认主题 Earth</a> 为例，这些设置信息将在如下位置进行展示。</p><p><img src="https://docs.halo.run/assets/images/setting-basic-3503787481fda5671286f997d4fb8bd0.png" alt="默认主题基本设置说明"></p><p>其中<code>Logo</code>在<code>Hao</code>主题中以<strong>个人头像</strong>的形式展现。</p><h3 id="文章设置"><a href="#文章设置" class="headerlink" title="文章设置"></a>文章设置</h3><p>主要修改这个就好了，其他按需修改</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654018912.png" alt="QQ_1723654018912"></p><h3 id="主题路由设置"><a href="#主题路由设置" class="headerlink" title="主题路由设置"></a>主题路由设置</h3><p>主要修改这个就好了，其他按需修改</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654056347.png" alt="QQ_1723654056347"></p><div class="note  flat info"><p>变量说明</p><ul><li><code>slug</code>：文章别名</li><li><code>name</code>：文章 <code>metadata.name</code> 字段值</li><li><code>year</code>：四位数格式的文章发布年份</li><li><code>month</code>：两位数格式的文章发布月份</li><li><code>day</code>：两位数格式的文章发布日</li></ul></div><p>其他没提到的设置自行调整吧~</p><p><a href="https://docs.halo.run/user-guide/settings#%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE">站点设置 | Halo 文档</a></p><h2 id="主题-插件安装"><a href="#主题-插件安装" class="headerlink" title="主题&amp;插件安装"></a>主题&amp;插件安装</h2><p>主题此处选择<code>Hao</code>，与我目前在Hexo使用的solitude主题基本一致。</p><p>点击右上角主题管理，在应用市场里面就能找到了</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654373199.png"></p><p>安装完直接启用就行</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654511304.png"></p><p>插件就按着这里安装就行，安装完了别忘了启动（</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240815121448372.png"></p><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>没提到的看自己调整即可，参考：<a href="https://docs.kunkunyu.com/docs/hao/zhu-ti-she-zhi-hao/ding-bu-hao">hao主题文档 (kunkunyu.com)</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>没啥好说的，直接设置就可以</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654595441.png"></p><h3 id="顶部"><a href="#顶部" class="headerlink" title="顶部"></a>顶部</h3><p><code>Banner 左侧</code>如果是自定义技术栈，目前还没搞懂为什么无法显示，文档中是说“自定义技术栈需要在<code>个人</code>中配置技术栈”，但是目前这个版本里面似乎去掉了，留个爪</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654764785.png"></p><p>其他的按需修改</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>按照这里修改即可，也可以按自己的</p><p>需要注意的是，默认的随机封面地址已经失效了，可以换成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://picsum.photos/600/400</span><br></pre></td></tr></table></figure><p>或自己寻找随机封面地址</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723654877460.png"></p><h3 id="侧栏"><a href="#侧栏" class="headerlink" title="侧栏"></a>侧栏</h3><h4 id="个人卡片"><a href="#个人卡片" class="headerlink" title="个人卡片"></a>个人卡片</h4><p>此处选择<code>样式一</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723655903348.png"></p><p>按着填写即可</p><p>其中社交媒体这里提一下吧，图标可以使用主题自带的（<a href="https://npm.onmicrosoft.cn/hao-theme-static@1.5.2/icon/demo_index.html">iconfont Demo (onmicrosoft.cn)</a>），也可以用自己的（<a href="https://ono.ee/?p=1693459637574">Halo博客Hao主题菜单栏小图标设置 | 狗头军师 (ono.ee)</a>）</p><p>如果是使用主题自带的，图标名（不含<code>.</code>）前面加上<code>haofont </code>就可以用了</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656051822.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656029607.png"></p><h4 id="音乐卡片"><a href="#音乐卡片" class="headerlink" title="音乐卡片"></a>音乐卡片</h4><p>详细配置参考：<a href="https://github.com/zonemeen/netease-recent-profile">zonemeen&#x2F;netease-recent-profile: 🎧 在 Github Profile 上显示你在网易云音乐上的听歌记录</a></p><p>这里只提一下默认的地址也是失效的，替换成<code>netease-recent-profile.vercel.app</code>即可（以及<code>?id=xxx</code>替换为自己的网易云的id）</p><div class="note  flat warning"><p>这个地址有可能失效，暂时不知道为什么</p></div><p>预览：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656264500.png"></p><p>翻转后：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656289462.png"></p><p>其他的按需修改</p><h3 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656462451.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656484936.png"></p><p>其中<code>中间logo</code>建议自己裁一下，裁成圆的</p><p>左右侧logo按上面一样设置就好</p><h3 id="瞬间"><a href="#瞬间" class="headerlink" title="瞬间"></a>瞬间</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656598625.png"></p><p>修改这几个就好了，其他的不用动，需要注意的是这个主题的背景图是顶端对齐的，而solitude主题中是中间对齐的（</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656682476.png" alt="Hao主题"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656710058.png" alt="solitude主题"></p><h3 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h3><p>自己看着改吧！图片标签是上传图片时填的那个名字（感觉没什么用）</p><p>默认样式和样式一给个预览吧！喜欢哪个选哪个就是了！</p><p>具体页面的配置后面再写</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723691536967.png"></p><p>以下是默认样式：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240815112117724.png" alt="默认相册页"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240815112040730.png" alt="默认具体相册"></p><p>以下是样式一：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723691650760.png" alt="样式一相册页"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723691968485.png" alt="样式一具体相册"></p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><h4 id="个人标签"><a href="#个人标签" class="headerlink" title="个人标签"></a>个人标签</h4><p>直接添加即可</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656848355.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723656830784.png"></p><p>其他按需修改</p><h2 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h2><ol><li>进入站点后台</li><li>点击左侧面板中的<code>菜单</code></li><li>点击<code>主菜单</code></li><li>点击右上角的<code>新增</code></li><li>可以通过拖拽调整缩进，从而创建子菜单</li><li>填写相应表单即可</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1697463822043-718ca78d-18d2-485c-9d25-d072312e515a.png"></p><p>图标：<a href="https://npm.onmicrosoft.cn/hao-theme-static@1.5.2/icon/demo_index.html">iconfont Demo (onmicrosoft.cn)</a></p><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><h3 id="关于-1"><a href="#关于-1" class="headerlink" title="关于"></a>关于</h3><p>新建一个页面，输入标题，设置别名（链接）以及自定义模板</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723693112657.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240815113945252.png"></p><h3 id="相册（图库）"><a href="#相册（图库）" class="headerlink" title="相册（图库）"></a>相册（图库）</h3><p>同理，其中封面图如果使用默认样式则需要设置</p><p>别名：<code>/album</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723693245124.png"></p><p>具体的图片分组等在图库设置，其中分组图片就是该分组的封面图</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723693547389.png"></p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>同上，封面图无需设置</p><p>别名：<code>/music</code></p><h3 id="最新评论"><a href="#最新评论" class="headerlink" title="最新评论"></a>最新评论</h3><p>同上，封面图需要设置</p><p>别名：<code>/newest</code></p><h2 id="Tag-Plugins-使用"><a href="#Tag-Plugins-使用" class="headerlink" title="Tag Plugins 使用"></a>Tag Plugins 使用</h2><p><a href="https://blog.xindu.site/archives/1712043167249?preview-theme=theme-hao#Note" title="Bootstrap Callout">Hao主题相关标签 | 新·都在 (xindu.site)</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.halo.run/getting-started/install/docker">使用 Docker 部署 | Halo 文档</a></p><p><a href="https://docs.halo.run/getting-started/setup">初始化 | Halo 文档</a></p><p><a href="https://cloud.tencent.com/developer/article/2404389">全网首发的傻瓜级教程：用宝塔面板Docker搭建halo2.9-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://www.yuque.com/liuzhihangs/halo-theme-hao">halo-theme-hao (yuque.com)</a></p><p><a href="https://blog.csdn.net/qq_36535538/article/details/133871575">Halo-Theme-Hao文档：如何设置导航栏？_halo-hao美化-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Halo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】集合（二）</title>
      <link href="/p/9b8bc45a/"/>
      <url>/p/9b8bc45a/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Java-的-LinkedHashMap？"><a href="#什么是-Java-的-LinkedHashMap？" class="headerlink" title="什么是 Java 的 LinkedHashMap？"></a>什么是 Java 的 LinkedHashMap？</h2><p>LinkedHashMap 的父类是 HashMap，所以 HashMap 有的它都有，然后基于 HashMap 做了一些扩展。</p><p>首先它把 HashMap 的 Entry 加了两个指针：before 和 after。这目的已经很明显了，就是要把塞入的 Entry 之间进行关联，串成双向链表，如下图红色的就是新增的两个指针：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203058.png" alt="20220219203058.png"></p><p>并且内部还有个 accessOrder 成员，默认是 false， 代表链表是顺序是按插入顺序来排的，如果是 true 则会根据访问顺序来进行调整，就是咱们熟知的 LRU 那种，如果哪个节点访问了，就把它移到最后，代表最近访问的节点。</p><p>具体实现其实就是 HashMap 埋了几个方法，然后 LinkedHashMap 实现了这几个方法做了操作，比如以下这三个，从方法名就能看出了：访问节点之后干啥；插入节点之后干啥；删除节点之后干啥。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203123.png" alt="20220219203123.png"></p><p>假如你想用 map 做个本地缓存，由于缓存的数量不可能无限大，所以你就能继承 LinkedHashMap 来实现，当节点超过一定数量的时候，在插入新节点的同时，移除最老最久没有被访问的节点，<strong>这样就实现了一个 LRU 了</strong>。</p><p>具体做法是把 accessOrder 设置为 true，这样每次访问节点就会把刚访问的节点移动到尾部，然后再重写removeEldestEntry 方法，LinkedHashMap 默认的实现是直接返回 true。</p><p>这样就简单的实现一个 LRU 了！下面展示下完整的代码，非常简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxCacheSize;</span><br><span class="line"></span><br><span class="line">    LRUCache(<span class="type">int</span> initialCapacity, <span class="type">int</span> maxCacheSize) &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxCacheSize = maxCacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() &gt; <span class="built_in">this</span>.maxCacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还能引申出一个笔试题，手写实现一个 LRU 算法，来我给你写！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; prev, next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveNodeToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; node = map.get(key);</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class="line">                map.remove(tail.prev.key);</span><br><span class="line">                removeTailNode();</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;K,V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node&lt;K,V&gt; newNode)</span> &#123;</span><br><span class="line">        newNode.prev = head;</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next.prev = newNode;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveNodeToHead</span><span class="params">(Node&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTailNode</span><span class="params">()</span> &#123;</span><br><span class="line">        removeNode(tail.prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LRUCache&lt;Integer,Integer&gt; lruCache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        lruCache.get(<span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(lruCache); <span class="comment">// toString 我就没贴了，代码太长了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是-Java-的-TreeMap？"><a href="#什么是-Java-的-TreeMap？" class="headerlink" title="什么是 Java 的 TreeMap？"></a>什么是 Java 的 TreeMap？</h2><p>TreeMap 内部是通过红黑树实现的，可以让 key 的实现 Comparable 接口或者自定义实现一个 comparator 传入构造函数，这样塞入的节点就会根据你定义的规则进行排序。</p><p>基本特性：</p><ul><li>数据结构：TreeMap 基于<strong>红黑树</strong>实现，红黑树是一种自平衡的二叉查找树，能够保证基本操作（插入、删除、查找）的时间复杂度为 O(log n)。</li><li>键的有序性：TreeMap 中的键是<strong>有序</strong>的，默认按自然顺序（键的 Comparable 实现）排序，也可以通过构造时提供的 Comparator 进行自定义排序。</li><li>不允许 null 键：TreeMap 不允许键为 null，但允许值为 null。</li></ul><p>这个用的比较少，我常用在跟加密有关的时候，有些加密需要根据字母序排，然后再拼接成字符串排序，在这个时候就可以把业务上的值统一都塞到 TreeMap 里维护，取出来就是有序的。</p><h3 id="扩展：红黑树"><a href="#扩展：红黑树" class="headerlink" title="扩展：红黑树"></a>扩展：红黑树</h3><p>红黑树是一种<strong>自平衡二叉查找树</strong>，具有以下性质：</p><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>所有叶子节点（NIL 节点）是黑色。</li><li>红色节点的两个子节点都是黑色（从每个叶子到根的路径上不能有两个连续的红色节点）。</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/uSLHAEiw_image.png"></p><p>这些性质保证了红黑树的高度近似平衡，从而使得插入、删除、查找操作的时间复杂度保持在 O(log n)。</p><p>1）插入操作</p><ul><li>新节点总是红色。</li><li>将新节点插入到树中。</li><li>进行修正，以保持红黑树的性质。这里可能会涉及到颜色的交换和旋转操作。</li></ul><p>2）删除操作</p><ul><li>找到要删除的节点。</li><li>删除节点后进行修正，以保持红黑树的性质。这里可能会涉及到颜色的交换和旋转操作。</li></ul><p>关于红黑树动态渲染可以利用这个网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><h2 id="什么是-Java-的-IdentityHashMap？"><a href="#什么是-Java-的-IdentityHashMap？" class="headerlink" title="什么是 Java 的 IdentityHashMap？"></a>什么是 Java 的 IdentityHashMap？</h2><p>理解这个 map 的关键就在于它的名字 Identity，也就是<strong>它判断是否相等的依据不是靠 equals，而是对象本身是否是它自己</strong>。</p><p>什么意思呢？</p><p>首先看它覆盖的 hash 方法：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203206.png"></p><p>可以看到，它用了个 <code>System.identityHashCode(x)</code>，而不是 <code>x.hashCode()</code>。</p><p>而这个方法会返回原来默认的 hashCode 实现，不管对象是否重写了 hashCode 方法</p><p>默认的实现返回的值是：<strong>对象的内存地址转化成整数</strong>，是不是有点感觉了？</p><p>然后我们再看下它的 get 方法：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203229.png"></p><p>可以看到，它判断 key 是否相等并不靠 hash 值和 equals，而是直接用了 &#x3D;&#x3D; 。</p><p>而 &#x3D;&#x3D; 其实就是<strong>地址判断</strong>！只有相同的对象进行 &#x3D;&#x3D; 才会返回 true。</p><p>因此我们得知，IdentityHashMap 的中的 key 只认它自己（对象本身）。</p><p>即便你伪造个对象，就算值都相等也没用，put 进去 IdentityHashMap 只会多一个键值对，而不是替换，这就是 Identity 的含义。</p><p>这里眼尖的小伙伴发现代码里，为什么返回值是 tab[i+1]？</p><p>这是因为 IdentityHashMap 的存储方式有点不一样，它是<strong>将 value 存在 key 的后面</strong>。</p><p>认识到这就差不多了。它是一个非常特殊和有限用途的映射实现，主要用于需要引用相等性的场景。在一些框架中，代理对象可能需要根据实际对象实例进行映射，而不是逻辑相等的对象，这时候 IdentityHashMap 就派上用场了。</p><h2 id="什么是-Java-的-WeakHashMap？"><a href="#什么是-Java-的-WeakHashMap？" class="headerlink" title="什么是 Java 的 WeakHashMap？"></a>什么是 Java 的 WeakHashMap？</h2><p>WeakHashMap 是 Java 中的一种特殊的 Map 实现，它使用弱引用（WeakReference）来存储键。</p><p>WeakHashMap 里对 key 的引用就是弱引用，所以当一个键不再有任何强引用时，<strong>即使它被 WeakHashMap 引用着，垃圾回收器也可以回收该键和它对应的值</strong>。</p><p>它被使用在临时需要大量数据，但这些数据又可以因为内存吃紧随时被回收的场景。</p><p>比如一些缓存场景，例如缓存一些图片，当图片不再被其他部分引用时，它们可以被垃圾回收，从而避免内存泄漏。</p><p>在一些框架中，需要为对象存储额外的元数据，但不希望这些元数据影响对象的生命周期。可以用 WeakHashMap 来存储这些元数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; weakMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入键值对</span></span><br><span class="line">        weakMap.put(key1, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        weakMap.put(key2, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Before GC: &quot;</span> + weakMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除强引用</span></span><br><span class="line">        key1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待垃圾回收完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 WeakHashMap 的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC: &quot;</span> + weakMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中-ConcurrentHashMap-1-7-和-1-8-之间有哪些区别？"><a href="#Java-中-ConcurrentHashMap-1-7-和-1-8-之间有哪些区别？" class="headerlink" title="Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？"></a>Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？</h2><h3 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h3><p>其实大体的哈希表实现跟 HashMap 没有本质的区别，都是经过 key 的 hash 定位到一个下标，然后获取元素，如果冲突了就用链表相连。</p><p>差别就在于引入了一个 Segments 数组，我们来看下大致的结构。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203435.png"></p><p>原理就是先通过 key 的 hash 判断得到 Segment 数组的下标，将这个 Segment 上锁，然后再次通过 key 的 hash 得到 Segment 里 HashEntry 数组的下标，下面这步其实就是 HashMap 一致了，所以我说差别就是引入了一个 Segments 数组。</p><p>因此可以简化的这样理解：每个 Segment 数组存放的就是一个单独的 HashMap。</p><p>具体上锁的方式来源于 Segment，<strong>这个类实际继承了 ReentrantLock</strong>，因此它自身具备加锁的功能。</p><p>可以看出，1.7 的分段锁已经有了细化锁粒度的概念，它的一个缺陷是 Segment 数组一旦初始化了之后不会扩容，只有 HashEntry 数组会扩容，这就导致并发度过于死板，不能随着数据的增加而提高并发度。</p><h3 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h3><p>1.8 ConcurrentHashMap 做了更细粒度的锁控制，可以理解为 1.8 HashMap 的数组的每个位置都是一把锁，这样扩容了锁也会变多，并发度也会增加。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219203455.png"></p><p>思想的转变就是把粒度更加细化。不分段了，我直接把 Node 数组的每个节点分别上一把锁，这样并发度不就更高了吗？</p><p>并且 1.8 也不借助于 ReentrantLock 了，直接用 synchronized，这也侧面证明，都 1.8 了 synchronized 优化后的速度已经不下于 ReentrantLock 了。</p><p>具体实现思路也简单：当塞入一个值的时候，先计算 key 的 hash 后的下标，如果计算到的下标还未有 Node，那么就通过 cas 塞入新的 Node。如果已经有 node 则通过 synchronized 将这个 node 上锁，这样别的线程就无法访问这个 node 及其之后的所有节点。</p><p>然后判断 key 是否相等，相等则是替换 value ，反之则是新增一个 node，这个操作和 HashMap 是一样的。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>1.8 的扩容，它允许协助扩容，也就是多线程扩容。</p><p>当 put 的时候，发现当前 node hash 值是 -1，则表明当前的节点正在扩容，则会触发协助扩容机制</p><p>其实大家大致理解下就够了：</p><p>扩容无非就是搬迁 Node，假设当前数组长度为 32，那就可以分着搬迁，31-16 这几个下标的 Node 都由线程 A 来搬迁，然后线程 B 来搬迁 15-0 这几个下标的 Node。</p><p>简单说就是会维护一个 transferIndex 变量，来的线程死循环 cas 争抢下标，如果下标已经分配完了，那自然就不需要搬迁了，如果 cas 抢到了要搬运的下标，那就去帮忙搬就好了，就是这么个事儿。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>1.7 有个尝试的思想，当调用 size 方法的时候不会加锁，而是先尝试三次不加锁获取 sum。</p><p>如果三次总数一样，说明当前数量没有变化，那就直接返回了。如果总数不一样，那说明此时有线程在增删 map，于是加锁计算，这时候其他线程就操作不了 map 了。</p><p>而 1.8 不一样，它就是直接计算返回结果，具体采用的是类似 LongAdder 的思想，累加不再是基于一个成员变量，而是搞了一个数组，每个线程在自己对应的下标地方进行累加，等最后的时候把数组里面的数据统一一下，就是最终的值了。</p><p>所以这是一个分治的思想。</p><p>总而言之，就是平日的操作会维护 map 里面的节点数量，会先通过 CAS 修改 baseCount ，如果成功就直接返回，如果失败说明此时有线程在竞争，那么就通过 hash 选择一个 CounterCell 对象就行修改，最终 size 的结果就是 baseCount + 所有 CounterCell 。</p><p>这种通过 counterCell 数组来减少并发下场景下对单个成员变量的竞争压力，提高了并发度，提升了性能，<strong>这也就是 LongAdder 的思想</strong>。</p><h3 id="get-方法是否需要加锁？"><a href="#get-方法是否需要加锁？" class="headerlink" title="get 方法是否需要加锁？"></a>get 方法是否需要加锁？</h3><p>不需要加锁。</p><p>保证 put 的时候线程安全之后，get 的时候只需要保证可见性即可，而可见性不需要加锁。</p><h3 id="为什么不支持-key-或-value-为-null？"><a href="#为什么不支持-key-或-value-为-null？" class="headerlink" title="为什么不支持 key 或 value 为 null？"></a>为什么不支持 key 或 value 为 null？</h3><p>首先，key 为什么也不能为 null ？</p><p>我猜测可能是因为如果允许 key 为 null 值，那么担心在并发条件下，其他 key 被意外置为 null 之后，导致访问到 null 对应的 value 而产生错误？</p><p>网上也没找到什么有说服力的答案（可能是作者 lea 佬不喜欢 null 值）。</p><p>那 value 为什么不能为 null ？</p><p>1）避免二义性</p><p>因为在多线程情况下，get 方法返回 null 时，无法区分 map 里到底是不存在在这个 key ，还是说被 <code>put(key，null)</code> 了。</p><p>这里可能有人会说，那 HashMap 不一样有这个问题？ HashMap 可以通过 <code>containsKey</code> 来判断是否存在这个 key，而多线程使用的 ConcurrentHashMap 就不能够。</p><p>比如你 get（key） 得到了 null，此时 map 里面没有这个 key 的，但是你不知道，所以你想调用 <code>containsKey</code> 看看，而恰巧在你调用之前，别的线程 put 了这个 key ，这样你 <code>containsKey</code> 就发现有这个 key，这是不是就发生“误会”了?</p><p>2）简化实现</p><p>不支持 null，这样在并发环境下，可以避免对 null 的特殊处理，可以减少代码中的条件分支，提高性能和可维护性。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别是什么？"><a href="#ConcurrentHashMap-和-Hashtable-的区别是什么？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别是什么？"></a>ConcurrentHashMap 和 Hashtable 的区别是什么？</h2><p>它们都是 Java 中常用的线程安全的哈希表实现，它们主要在性能有显著的差异。</p><p><strong>因为在线程安全性上的实现方式不同，导致了它们性能上的差别</strong>：</p><ul><li>**<code>Hashtable</code>**：<code>Hashtable</code> 使用的是单一的锁机制（全表锁），即对整个哈希表进行同步，所有的操作（如插入、删除、查找等）都必须通过一个锁（synchronized）来保证线程安全。这种方式使得 <code>Hashtable</code> 在多线程环境下效率较低，因为无论是读取还是写入操作都需要获得锁，无法做到并发访问。</li><li>**<code>ConcurrentHashMap</code>**：在 Java 8 中，<code>ConcurrentHashMap</code> 采用了 <code>CAS + synchronized</code> 的方式进行线程安全控制。CAS 用于无锁的写入操作。如果某个 Node 节点为空，则通过 CAS 将数据插入节点。如果不为空，则会退化到 synchronized。使用 synchronized 锁定冲突节点的头结点。这种锁的粒度更细，仅锁住特定的冲突节点，而非整个表，因此在并发访问时性能较好。高的并发性能。</li></ul><p><code>null</code><strong>键值的允许情况</strong>：</p><ul><li><p><code>ConcurrentHashMap</code>：在<code>ConcurrentHashMap</code>中，是不允许<code>null</code>键和<code>null</code>值的。这是因为在并发环境下，<code>null</code>值可能会导致歧义，难以区分是因为初始值未设置还是因为键对应的值就是<code>null</code>。</p></li><li><p><code>Hashtable</code>：<code>Hashtable</code>也不允许<code>null</code>键和<code>null</code>值。这是因为<code>Hashtable</code>在设计时就规定键和值都不能为<code>null</code>，如果插入<code>null</code>键或<code>null</code>值，会抛出<code>NullPointerException</code>。</p></li></ul><p><strong>迭代操作异常情况</strong>：</p><ul><li><p><code>ConcurrentHashMap</code>：<code>ConcurrentHashMap</code>的迭代器具有弱一致性，在迭代过程中，即使其他线程修改了<code>map</code>，迭代器不会抛出<code>ConcurrentModificationException</code>，它会尽量反映出已经完成的修改。</p></li><li><p><code>Hashtable</code>：<code>Hashtable</code>的迭代器具有强一致性，在迭代过程中，如果<code>map</code>的结构被其他线程修改，会快速失败并抛出<code>ConcurrentModificationException</code>。</p></li></ul><h2 id="你遇到过-ConcurrentModificationException-错误吗？它是如何产生的？"><a href="#你遇到过-ConcurrentModificationException-错误吗？它是如何产生的？" class="headerlink" title="你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？"></a>你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？</h2><p>这个错误发生在迭代集合对象时候，修改集合本身内容，包括新增、修改和删除。</p><p>其实这个错误是为了检测并发修改的行为，在非线程安全的集合中，并发修改集合数据可能会发生数据丢失等一些奇怪的问题。</p><p>因此 Java 引入了这个错误，是<strong>为了保证集合迭代时语义的一致性。</strong></p><p>简单来说就是：规矩就这样定了！这个集合非并发安全的，不让你改，改了就报错。</p><p>它的原理是在集合内部维护了一个修改次数的记录，如果发生了修改，那么这个次数会增加。在每次迭代的时候会检查这个次数，发现增加了就立马抛错。</p><p>如果非要修改那么可以使用线程安全的集合，例如可以使用 <code>Collections.synchronizedList</code> 将 List 包装为线程安全的集合或者直接使用 <code>CopyOnWriteArrayList</code>、<code>ConcurrentHashMap</code>。</p><h2 id="Java-的-CopyOnWriteArrayList-和-Collections-synchronizedList-有什么区别？分别有什么优缺点？"><a href="#Java-的-CopyOnWriteArrayList-和-Collections-synchronizedList-有什么区别？分别有什么优缺点？" class="headerlink" title="Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？"></a>Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？</h2><h3 id="CopyOnWriteArrayList："><a href="#CopyOnWriteArrayList：" class="headerlink" title="CopyOnWriteArrayList："></a><strong>CopyOnWriteArrayList</strong>：</h3><p>是一个线程安全的 List 实现，特性就是<strong>写时复制</strong>。</p><p>每次对 List 的修改操作（如 add, set, remove）都会复制创建一个新的底层数组。读操作不需要加锁，写操作需要加锁。</p><p>优点：</p><ul><li>读操作无锁：每次写操作都会创建并复制新数组，所以读写之间不冲突，因此读操作不需要加锁，能够提供非常高效的并发读性能。</li></ul><p>缺点：</p><ul><li>写操作开销大：每次写操作都会创建并复制新数组，且要将数据复制到新的数组中，在写操作频繁的场景下性能会较低。</li><li>内存消耗大：每次写操作都会创建并复制新数组，在数据量大的情况下，同一时刻会存在两倍 List 大小的内存占用，开销较大。</li></ul><p><code>CopyOnWriteArrayList</code> <strong>适合读多写少的场景</strong>。</p><h3 id="Collections-synchronizedList："><a href="#Collections-synchronizedList：" class="headerlink" title="Collections.synchronizedList："></a><strong>Collections.synchronizedList</strong>：</h3><p>是一个包装方法，可以将任何 List 转换为线程安全的版本，它会对每个访问方法（如 get, set, add, remove）进行同步（加 synchronized 锁），从而保证线程安全。</p><p>优点：</p><ul><li>方便：简单一个方法就可以将 List 变为线程安全版本，非常方便。</li></ul><p>缺点：</p><ul><li>并发低：读写操作都需要加锁，高并发场景下性能不高。</li></ul><p><code>Collections.synchronizedList</code> <strong>适用于简单将 List 转为线程安全版本临时使用的场景</strong>。特定的场景还需使用并发度高的 JUC 类。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】集合（一） | HashMap</title>
      <link href="/p/c9cb7159/"/>
      <url>/p/c9cb7159/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-中有哪些集合类？"><a href="#Java-中有哪些集合类？" class="headerlink" title="Java 中有哪些集合类？"></a>Java 中有哪些集合类？</h2><p>Java 中的集合类主要分为两大类：Collection 接口和 Map 接口。Collection 接口下又分为 List、Set 和 Queue 接口。每个接口有其具体实现类。以下是主要的集合类：</p><h3 id="List-接口："><a href="#List-接口：" class="headerlink" title="List 接口："></a>List 接口：</h3><ul><li>ArrayList：基于<strong>动态数组</strong>，查询速度快，插入、删除慢。</li><li>LinkedList：基于<strong>双向链表</strong>，插入、删除快，查询速度慢。</li><li>Vector：线程安全的动态数组，类似于 ArrayList，但开销较大（加了<code>synchronized </code>）。</li><li>CopyOnWriteArrayList：线程安全的动态数组，<strong>但所有可变操作（如 add()、set() 等）都会创建一个新的数组</strong>（写实复制）。</li></ul><h3 id="Set-接口："><a href="#Set-接口：" class="headerlink" title="Set 接口："></a>Set 接口：</h3><ul><li>HashSet：基于哈希表，元素无序，不允许重复。</li><li>LinkedHashSet：基于链表和哈希表，维护插入顺序，不允许重复。</li><li>TreeSet：基于红黑树，元素有序，不允许重复。</li></ul><p>所以网上有些说 Set 是无序集合非常不准确，因为需要看具体的实现类。</p><h3 id="Queue-接口："><a href="#Queue-接口：" class="headerlink" title="Queue 接口："></a>Queue 接口：</h3><ul><li>PriorityQueue：基于优先级堆，元素按照自然顺序或指定比较器排序。</li><li>LinkedList：可以作为队列使用，支持 FIFO（先进先出）操作。</li></ul><h4 id="Map-接口："><a href="#Map-接口：" class="headerlink" title="Map 接口："></a>Map 接口：</h4><ul><li>HashMap：基于哈希表，键值对无序，不允许键重复。</li><li>LinkedHashMap：基于链表和哈希表，维护插入顺序，不允许键重复。</li><li>TreeMap：基于红黑树，键值对有序，不允许键重复。</li><li>Hashtable：线程安全的哈希表，不允许键或值为 null。</li><li>ConcurrentHashMap：线程安全的哈希表，适合高并发环境。</li></ul><h2 id="Java-中-HashMap-的实现原理是什么？"><a href="#Java-中-HashMap-的实现原理是什么？" class="headerlink" title="Java 中 HashMap 的实现原理是什么？"></a>Java 中 HashMap 的实现原理是什么？</h2><p>HashMap 基于哈希表的数据结构实现，允许存储键值对，并且通过键快速访问对应的值。</p><p>它内部使用数组和链表（在 Java 8 及以后还可以使用红黑树）来存储元素，每个数组槽位（bucket）对应一个链表或红黑树。</p><p>数组内的元素保存了 key 和 value。当要塞入一个键值对的时候，会根据一个 hash 算法计算 key 的 hash 值，然后通过数组大小 <code>n-1 &amp; hash</code> 值之后，得到一个数组的下标，然后往那个位置塞入这键值对。</p><p>为了解决键值对冲突的问题，采用了链表法，如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20240813173215.png"></p><p>在 JDK1.7 及之前链表的插入采用的是<strong>头插法</strong>，即在链表的头部插入新的键值对。</p><p>在 JDK1.8 的时候，改成了尾插法，并且引入了红黑树。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219202916.png"></p><p>当链表的长度大于 8 且数组大小大于等于 64 的时候，就把链表转化成红黑树，当红黑树节点小于 6 的时候，又会退化成链表。</p><h2 id="Java-中-HashMap-的扩容机制是怎样的？"><a href="#Java-中-HashMap-的扩容机制是怎样的？" class="headerlink" title="Java 中 HashMap 的扩容机制是怎样的？"></a>Java 中 HashMap 的扩容机制是怎样的？</h2><p>在 HashMap 中有阈值的概念，比如我们设置一个 16 大小的 map，那么默认的阈值等于 <code>16 * 0.75 = 12</code>。</p><p>也就是说，如果 map 中元素的数量超过 12，那么就会触发扩容。</p><p>扩容的时候，默认会新建一个数组，新数组的大小是老数组的两倍。</p><p>然后将 map 内的元素重新 hash 映射搬运到新的数组中。</p><p>因为数组的长度是 2 的 n 次方，所以假设以前的数组长度（16）二进制表示是 010000，那么新数组的长度（32）二进制表示是 100000，这个应该很好理解吧？</p><p>它们之间的差别就在于高位多了一个 1，而我们通过 key 的 hash 值定位其在数组位置所采用的方法是 <code>(数组长度-1) &amp; hash</code>（与运算）。我们还是拿 16 和 32 长度来举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16-1=15，二进制为 001111</span><br><span class="line">32-1=31，二进制为 011111</span><br></pre></td></tr></table></figure><p>所以重点就在 key 的 hash 值的从右往左数第五位是否是 1，如果是 1 说明需要搬迁到新位置，且新位置的下标就是原下标+16（原数组大小），如果是 0 说明吃不到新数组长度的高位，那就还是在原位置，不需要迁移。</p><p>所以，我们刚好拿老数组的长度（010000）来判断高位是否是 1，这里只有两种情况，要么是 1 要么是 0 。</p><h2 id="为什么-HashMap-在-Java-中扩容时采用-2-的-n-次方倍？"><a href="#为什么-HashMap-在-Java-中扩容时采用-2-的-n-次方倍？" class="headerlink" title="为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？"></a>为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？</h2><h3 id="哈希分布均匀性"><a href="#哈希分布均匀性" class="headerlink" title="哈希分布均匀性"></a>哈希分布均匀性</h3><p>如果数组容量为 2 的 n 次方，那么 <code>n - 1</code> 后低位都是 1 ，此时进行 &amp; （两个位都为 1 时，结果才为 1）运算可以确保哈希码的最低几位均匀分布。</p><p>比如 64 二进制表示为 0100 0000，64 - 1 &#x3D; 0011 1111。</p><p>此时 0011 1111 与哈希码进行 &amp; 运算，低位能均匀的反应出哈希码的随机性。</p><p>假设来个 0100 0000 与哈希码进行 &amp; 运算，那么低位得到的值就都是 0 了，随机性很差，都是冲突。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>正常情况下，如果基于哈希码来计算数组下标，我们想到的都是 %（取余）计算。例如数组长度为 5 ，那么哈希码 % 5 得到的值就是对应的数组下标。</p><p>但相比于位运算而言，效率比较低，所以推荐用位运算，而要满足 <code>i = (n - 1) &amp; hash</code> 这个公式，n 的大小就必须是 2 的 n 次幂。即：当 b 等于 2 的 n 次幂时，<code>a % b</code> 操作等于 <code>a &amp; ( b - 1 )</code></p><h2 id="为什么-Java-中-HashMap-的默认负载因子是-0-75？"><a href="#为什么-Java-中-HashMap-的默认负载因子是-0-75？" class="headerlink" title="为什么 Java 中 HashMap 的默认负载因子是 0.75？"></a>为什么 Java 中 HashMap 的默认负载因子是 0.75？</h2><p>设置 0.75 是因为空间和时间上的平衡。</p><p>较低的负载因子（例如 0.5）会导致 HashMap 需要频繁扩容，空间利用率就低。不过因为冲突少，查找效率就高，但是因为扩容频繁会增加 rehashing 的开销。</p><p>较高的负载因子（例如 1.0）会减少扩容次数，空间利用率高了，但会增加哈希冲突的概率，从而降低查找效率。</p><p>经过大量实践，0.75 被认为是大多数场景下比较合适的值，能够在时间和空间之间取得良好的平衡。</p><p>所以设置了 0.75。</p><h2 id="JDK-1-8-对-HashMap-进行了哪些改动？（不含红黑树）"><a href="#JDK-1-8-对-HashMap-进行了哪些改动？（不含红黑树）" class="headerlink" title="JDK 1.8 对 HashMap 进行了哪些改动？（不含红黑树）"></a>JDK 1.8 对 HashMap 进行了哪些改动？（不含红黑树）</h2><p>主要有以下几个方面：</p><ol><li>hash 函数的优化</li><li>扩容 rehash 的优化</li><li>头插法和尾插法</li><li>插入与扩容时机的变更</li></ol><h3 id="hash-函数的优化"><a href="#hash-函数的优化" class="headerlink" title="hash 函数的优化"></a>hash 函数的优化</h3><p>1.7 的操作太多了，经历了四次异或，所以 1.8 优化了下，它将 key 的哈希码的高 16 位和低 16 位进行了异或，得到的 hash 值同时拥有了高位和低位的特性，使得哈希码的分布更均匀，不容易冲突。</p><h3 id="扩容-rehash-的优化"><a href="#扩容-rehash-的优化" class="headerlink" title="扩容 rehash 的优化"></a>扩容 rehash 的优化</h3><p>按照我们的思维，正常扩容肯定是先申请一个更大的数组，然后将原数组里面的每一个元素重新 hash 判断在新数组的位置，然后一个一个搬迁过去。</p><p>在 1.7 的时候就是这样实现的，然而 1.8 在这里做了优化，<strong>关键点就在于数组的长度是 2 的次方，且扩容为 2 倍。</strong></p><p>在扩容过程中，节点被分布到新的桶中时，不再需要重新计算 hash，而是利用了原桶的位置和新桶的二进制位关系，来快速确定新桶的位置。</p><h3 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h3><p>1.7 是头插法，头插法的好处就是插入的时候不需要遍历链表，直接替换成头结点，但是缺点是扩容的时候会逆序，而逆序在多线程操作下可能会出现环，然后就死循环了。</p><p>然后 1.8 是尾插法，每次都从尾部插入的话，扩容后链表的顺序还是和之前一致，所以不可能出现多线程扩容成环的情况。</p><h3 id="插入与扩容时机的变更"><a href="#插入与扩容时机的变更" class="headerlink" title="插入与扩容时机的变更"></a>插入与扩容时机的变更</h3><p>1.7 是先判断 put 的键值对是新增还是替换，如果是替换则直接替换，如果是新增会判断当前元素数量是否大于等于阈值，如果超过阈值且命中数组索引的位置已经有元素了，那么就进行扩容。</p><p>所以 1.7 是<strong>先扩容，然后再插入</strong>。</p><p>而 1.8 则是先插入，然后再判断 size 是否大于阈值，若大于则扩容。</p><h2 id="为什么-JDK-1-8-对-HashMap-进行了红黑树的改动？"><a href="#为什么-JDK-1-8-对-HashMap-进行了红黑树的改动？" class="headerlink" title="为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？"></a>为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？</h2><p>主要是避免 hash 冲突导致链表的长度过长，这样 get 的时候时间复杂度严格来说就不是 O(1) 了，因为可能需要遍历链表来查找命中的键值对。</p><p>那么为什么定义链表长度为 8 且数组大小大于等于 64 才转红黑树？不要链表直接用红黑树不就得了吗？</p><p>因为红黑树节点的大小是普通节点大小的两倍，所以为了节省内存空间不会直接只用红黑树，只有当节点到达一定数量才会转成红黑树，这里定义的是 8。</p><p>为什么是 8 呢？这个其实 HashMap 注释上也有说的，和泊松分布有关系。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20220219202956.png"></p><p>简单翻译下就是在默认阈值是 0.75 的情况下，冲突节点长度为 8 的概率为 0.00000006，也就概率比较小（毕竟红黑树耗内存，且链表长度短点时遍历的还是很快的）。</p><p>这就是基于时间和空间的平衡了，红黑树占用内存大，所以节点少就不用红黑树，如果万一真的冲突很多，就用红黑树，选个参数为 8 的大小，就是为了平衡时间和空间的问题。</p><h3 id="为什么节点小于等于-6-要从红黑树转成链表？"><a href="#为什么节点小于等于-6-要从红黑树转成链表？" class="headerlink" title="为什么节点小于等于 6 要从红黑树转成链表？"></a>为什么节点小于等于 6 要从红黑树转成链表？</h3><p>链表树化的节点是 8，除此之外，当树节点数小于等于 6 时候，又会从红黑树转为链表。</p><p>这个操作是为了平衡时间和空间，节点太少链表遍历也很快，没必要成红黑树，变成链表节约内存。</p><p>为什么定了 6 而不是小于等于 8 就变？</p><p>是因为要留个缓冲余地，避免反复横跳。举个例子，一个节点反复添加，从 8 变成 9 ，链表变红黑树，又删了，从 9 变成 8，又从红黑树变链表，再添加，又从链表变红黑树？</p><p>所以余一点，毕竟树化和反树化都是有开销的。</p><h2 id="使用-HashMap-时，有哪些提升性能的技巧？"><a href="#使用-HashMap-时，有哪些提升性能的技巧？" class="headerlink" title="使用 HashMap 时，有哪些提升性能的技巧？"></a>使用 HashMap 时，有哪些提升性能的技巧？</h2><p>1）合理设置初始容量：</p><p>如果在使用时可以预估 HashMap 存储的数据量大小，那么需要在创建时设置一个合适的初始容量，以避免频繁的扩容操作。</p><p>Java 中 HashMap 默认初始容量是 16。</p><p>2）调整负载因子：</p><p>官方提供的默认负载因子是 0.75。</p><p>可以根据具体应用场景调整这个值。较低的负载因子会减少冲突，提高查找效率，但会占用更多内存。较高的负载因子则会减少内存消耗，但可能增加冲突的概率，降低查找效率。</p><p>3）确保 hashCode 均匀分布：</p><p>对应 key 的 hashCode() 方法生成的哈希值需均匀分布，减少哈希冲突。避免使用质量不高的哈希函数，防止大量键映射到相同的槽位上，造成性能瓶颈。</p><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>例如需要保留元素的插入顺序，则可以使用 <code>LinkedHashMap</code>替换 <code>HashMap</code>。它基于 <code>HashMap</code> 但维护了一个链表，记录元素的插入顺序。</p><p>这样就不需要我们从 <code>HashMap</code> 中获取数据，然后再排序。</p><p>如果是需要保留有序的键值对，则可以使用 <code>TreeMap</code>。</p><p>如果是线程安全场景，则可以使用 <code>ConcurrentHashMap</code>。</p><h2 id="Java-中的-HashMap-和-Hashtable-有什么区别？"><a href="#Java-中的-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="Java 中的 HashMap 和 Hashtable 有什么区别？"></a>Java 中的 HashMap 和 Hashtable 有什么区别？</h2><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>HashMap：不是线程安全的。如果多个线程同时访问一个 HashMap，并且至少有一个线程在结构上修改了它（比如添加或删除键值对），可以通过以下代码封装进行同步：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><p>Hashtable：是线程安全的。所有的方法都加了锁，可以在多线程环境中使用。</p><h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>HashMap：由于没有同步开销，所以它的性能一般比 Hashtable 更好，尤其是在单线程环境中。</p><p>Hashtable：由于每个方法都进行同步，因此性能比 HashMap 差。</p><h3 id="null-值的处理"><a href="#null-值的处理" class="headerlink" title="null 值的处理"></a>null 值的处理</h3><p>HashMap：允许一个 <code>null</code> 键和多个 <code>null</code> 值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="literal">null</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>Hashtable：不允许 <code>null</code> 键和 <code>null</code> 值。如果将 <code>null</code> 键或值放入 Hashtable，会抛出 <code>NullPointerException。</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// hashtable.put(null, &quot;value&quot;); // 抛出 NullPointerException</span></span><br><span class="line"><span class="comment">// hashtable.put(&quot;key&quot;, null); // 抛出 NullPointerException</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>HashMap：默认初始容量为 16，负载因子为 0.75。使用 <code>Iterator</code> 遍历键值对，支持 <code>fail-fast</code> 机制，如果在遍历过程中结构发生变化，会抛出 <code>ConcurrentModificationException</code></p><p>Hashtable：默认初始容量为 11，负载因子为 0.75。使用 <code>Enumeration</code> 遍历键值对，不支持 <code>fail-fast</code> 机制。</p><hr><p>Hashtable 其实是过期的类，如果真的需要线程安全的容器，现在也都用 ConcurrentHashMap，因为它的加锁粒度更低，性能更好，Hashtable 基本没有使用场景。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别是什么？"><a href="#ConcurrentHashMap-和-Hashtable-的区别是什么？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别是什么？"></a>ConcurrentHashMap 和 Hashtable 的区别是什么？</h2><p>它们都是 Java 中常用的线程安全的哈希表实现，它们主要在性能有显著的差异。</p><p><strong>因为在线程安全性上的实现方式不同，导致了它们性能上的差别</strong>：</p><ul><li>**<code>Hashtable</code>**：<code>Hashtable</code> 使用的是单一的锁机制（全表锁），即对整个哈希表进行同步，所有的操作（如插入、删除、查找等）都必须通过一个锁（synchronized）来保证线程安全。这种方式使得 <code>Hashtable</code> 在多线程环境下效率较低，因为无论是读取还是写入操作都需要获得锁，无法做到并发访问。</li><li>**<code>ConcurrentHashMap</code>**：在 Java 8 中，<code>ConcurrentHashMap</code> 采用了 <code>CAS + synchronized</code> 的方式进行线程安全控制。CAS 用于无锁的写入操作。如果某个 Node 节点为空，则通过 CAS 将数据插入节点。如果不为空，则会退化到 synchronized。使用 synchronized 锁定冲突节点的头结点。这种锁的粒度更细，仅锁住特定的冲突节点，而非整个表，因此在并发访问时性能较好。高的并发性能。</li></ul><p><code>null</code><strong>键值的允许情况</strong>：</p><ul><li><p><code>ConcurrentHashMap</code>：在<code>ConcurrentHashMap</code>中，是不允许<code>null</code>键和<code>null</code>值的。这是因为在并发环境下，<code>null</code>值可能会导致歧义，难以区分是因为初始值未设置还是因为键对应的值就是<code>null</code>。</p></li><li><p><code>Hashtable</code>：<code>Hashtable</code>也不允许<code>null</code>键和<code>null</code>值。这是因为<code>Hashtable</code>在设计时就规定键和值都不能为<code>null</code>，如果插入<code>null</code>键或<code>null</code>值，会抛出<code>NullPointerException</code>。</p></li></ul><p><strong>迭代操作异常情况</strong>：</p><ul><li><p><code>ConcurrentHashMap</code>：<code>ConcurrentHashMap</code>的迭代器具有弱一致性，在迭代过程中，即使其他线程修改了<code>map</code>，迭代器不会抛出<code>ConcurrentModificationException</code>，它会尽量反映出已经完成的修改。</p></li><li><p><code>Hashtable</code>：<code>Hashtable</code>的迭代器具有强一致性，在迭代过程中，如果<code>map</code>的结构被其他线程修改，会快速失败并抛出<code>ConcurrentModificationException</code>。</p></li></ul><h2 id="Java-中的-HashSet-和-HashMap-有什么区别？"><a href="#Java-中的-HashSet-和-HashMap-有什么区别？" class="headerlink" title="Java 中的 HashSet 和 HashMap 有什么区别？"></a>Java 中的 HashSet 和 HashMap 有什么区别？</h2><p>HashSet 其实内部的实现还是 HashMap！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/vT34Br6w_ecf08a80-1505-4e88-b377-7aae4059ae9f.png"></p><p>从上图我们可以发现，构造一个 HashSet 内部就是 new 了一个 HashMap，并且 add 方法实际上调用的就是 HashMap 的 put。</p><p>因此 HashSet 就是封装了一下 HashMap！内部的实现逻辑其实都由 HashMap 来代劳。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>详见：<a href="https://rean-schwarze.github.io/p/4f877c1e/">【Java】集合（三） | 集合类源码 | Rean’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】基础（三） | JDK</title>
      <link href="/p/82c942ab/"/>
      <url>/p/82c942ab/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h2><p>JRE(Java Runtime Environment)指的是 Java 运行环境，包含了 JVM、核心类库和其他支持运行 Java 程序的文件。</p><ul><li>JVM（Java Virtual Machine）：执行 Java 字节码，提供了 Java 程序的运行环境。</li><li>核心类库：一组标准的类库（如 java.lang、java.util 等），供 Java 程序使用。</li><li>其他文件：如配置文件、库文件等，支持 JVM 的运行。</li></ul><p>JDK（Java Development Kit）可以视为 JRE 的超集，是用于开发 Java 程序的完整开发环境，它包含了 JRE，以及用于开发、调试和监控 Java 应用程序的工具。</p><ul><li>JRE：JDK 包含了完整的 JRE，因此它也能运行 Java 程序。</li><li>开发工具：如编译器（javac）、调试器（jdb）、打包工具（jar）等，用于开发和管理 Java 程序。</li><li>附加库和文件：支持开发、文档生成和其他开发相关的任务。</li></ul><p>列举一下 JDK 提供的主要工具：</p><ul><li>javac：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。</li><li>java：Java 应用程序启动器，用于运行 Java 应用程序。</li><li>javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。</li><li>jar：归档工具，用于创建和管理 JAR（Java ARchive）文件。</li><li>jdb：Java 调试器，用于调试 Java 程序。</li><li>jps：Java 进程状态工具，用于列出当前所有的 Java 进程。</li><li>jstat：JVM 统计监视工具，用于监视 JVM 统计信息。</li><li>jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。</li><li>jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。</li><li>jhat：堆分析工具，用于分析堆转储文件。</li><li>jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。</li><li>javap：类文件反汇编器，用于反汇编和查看 Java 类文件。</li><li>jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系。</li></ul><h2 id="你使用过哪些-JDK-提供的工具？"><a href="#你使用过哪些-JDK-提供的工具？" class="headerlink" title="你使用过哪些 JDK 提供的工具？"></a>你使用过哪些 JDK 提供的工具？</h2><p>这个题目主要考察你平日里面是否有过利用 JDK 的工具进行问题的分析、排查。</p><p>（注意，这里不要说什么 javac 之类的命令，主要想考察的是问题分析、排查方面的内容）</p><p>比如排查内存问题的时候，利用 jmap 生成堆转储文件，下载后利用 Eclipse 的 MAT 工具进行分析。</p><div class="note  simple"><p>如果大家没有排查经验，强烈建议去尝试一下，难度不高的。</p></div><p>我列几个常见工具，建议可以用用，还是很简单的。</p><ul><li>jps：虚拟机进程状况工具</li><li>jstat：虚拟机统计信息监视工具</li><li>jmap：Java内存映像工具</li><li>jhat：虚拟机堆转储快照分析工具</li><li>jstack：Java堆栈跟踪工具</li><li>jinfo：Java配置信息工具</li><li>VisualVM：图形化工具，可以得到虚拟机运行时的一些信息：内存分析、CPU 分析等等，在 jdk9 开始不再默认打包进 jdk 中。</li></ul><p>工具其实还有很多，上个问题也有列举。</p><p>虽然面试这样答可能就差不多了，但还是希望大家可以自己找机会用用，没机会就自己给自己创造机会。</p><p>因为这属于线上排查能力，只有真正实践了，到时候自己负责的项目真的出了问题，才不至于手忙脚乱。我们毕竟是工程师，问题解决能力必须掌握。</p><h2 id="JDK8-有哪些新特性？"><a href="#JDK8-有哪些新特性？" class="headerlink" title="JDK8 有哪些新特性？"></a>JDK8 有哪些新特性？</h2><p>JDK8 较为重要和平日里经常被问的特性如下：</p><ol><li>用元空间替代了永久代</li><li>引入了 Lambda 表达式</li><li>引入了日期类、接口默认方法、静态方法</li><li>新增 Stream 流式接口</li><li>引入 Optional 类</li><li>新增了 CompletableFuture 、StampedLock 等并发实现类。</li></ol><p>如果你对 HashMap、ConcurrentHashMap 面试题有准备的话，这时候也可以抛出来，引导面试官来询问。比如：Java 8 修改了 HashMap 和 ConcurrentHashMap 的实现。</p><h3 id="元空间替代了永久代（JVM相关）"><a href="#元空间替代了永久代（JVM相关）" class="headerlink" title="元空间替代了永久代（JVM相关）"></a>元空间替代了永久代（JVM相关）</h3><p>因为 JDK8 要把 JRockit 虚拟机和 Hotspot 虚拟机融合，而 JRockit 没有永久代，所以把 Hotspot 永久代给去了（本质也是永久代回收效率太低）。</p><p>其实永久代之前的存在就有点尴尬，归堆管但是实际上回收效率很低，你听听这名字永久代，不就是对象几乎是永久存在吗？</p><p>而且有永久代的话，如果永久代满了也会触发 full gc，触发了回收但是回收率又很低，所以很不划算。</p><p>因此官方借着和 JRockit 合并就把永久代也干掉，用元空间代替。元空间放在堆外，至少没堆内内存的限制了。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 是 Java 8 引入的一种匿名函数，可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。</p><p>其本质是作为函数式接口的实例。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mianshiya.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;mianshiya.com&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>Java 8 引入了新的日期和时间 API（位于 java.time 包中），它们更加简洁和易于使用，解决了旧版日期时间 API 的许多问题。</p><p>例如 <code>Date</code>、<code>Calendar</code> 都是可变类且线程不安全。而新的日期类都是不可变的，一旦创建就不能修改，这样可以避免意外的修改，提升代码的安全性和可维护性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure><p><code>Date</code> 本身不包含时区信息，必须使用 <code>Calendar</code> 类来处理时区，但使用起来非常复杂且容易出错。</p><p>新 API 提供了专门的时区类（如 <code>ZonedDateTime</code>, <code>OffsetDateTime</code>, <code>ZoneId</code> 等），简化了时区处理，并且这些类的方法更加直观和易用。</p><h3 id="接口默认方法、静态"><a href="#接口默认方法、静态" class="headerlink" title="接口默认方法、静态"></a>接口默认方法、静态</h3><p>默认方法允许在接口中定义方法的默认实现，这样接口的实现类不需要再实现这些方法。之所以提供静态方法，是为了将相关的方法内聚在接口中，而不必创建新的对象。</p><h3 id="Stream-流式接口"><a href="#Stream-流式接口" class="headerlink" title="Stream 流式接口"></a>Stream 流式接口</h3><p>Stream API 提供了一种高效且易于使用的方式来处理数据集合。它支持链式操作、惰性求值和并行处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">                          .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">                          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p><code>Optional</code> 类用来解决可能出现的 <code>NullPointerException</code> 问题，提供了一种优雅的方式来处理可能为空的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;mianshiya.com&quot;</span>);</span><br><span class="line">optional.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>CompletableFuture 提供了一个新的异步编程模型，简化了异步任务的编写和管理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                 .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>)</span><br><span class="line">                 .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="什么是-Java-中的动态代理？"><a href="#什么是-Java-中的动态代理？" class="headerlink" title="什么是 Java 中的动态代理？"></a>什么是 Java 中的动态代理？</h2><p>动态代理是 Java 提供的一种强大机制，用于<strong>在运行时</strong>创建代理类或代理对象，以实现接口的行为，而不需要提前在代码中定义具体的类。动态是相对于静态来说的，之所以动态就是因为动作发生在运行时。</p><p>代理可以看作是调用目标的一个包装，通常用来在调用真实的目标之前进行一些逻辑处理，消除一些重复的代码。</p><p>静态代理指的是我们预先编码好一个代理类，而动态代理指的是运行时生成代理类。</p><p>动态更加方便，可以指定一系列目标来动态生成代理类(AOP)，而不像静态代理需要为每个目标类写对应的代理类。</p><p>代理也是一种解耦，目标类和调用者之间的解耦，因为多了代理类这一层。</p><p>动态代理的主要用途包括：</p><ul><li>简化代码：通过代理模式，可以减少重复代码，尤其是在横切关注点（如日志记录、事务管理、权限控制等）方面。</li><li>增强灵活性：动态代理使得代码更具灵活性和可扩展性，因为代理对象是在运行时生成的，可以动态地改变行为。</li><li>实现 AOP：动态代理是实现面向切面编程（AOP, Aspect-Oriented Programming）的基础，可以在方法调用前后插入额外的逻辑。</li></ul><h2 id="JDK-动态代理和-CGLIB-动态代理有什么区别？"><a href="#JDK-动态代理和-CGLIB-动态代理有什么区别？" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理有什么区别？"></a>JDK 动态代理和 CGLIB 动态代理有什么区别？</h2><p>JDK 动态代理是基于接口的，所以要求代理类一定是有定义接口的。</p><p>CGLIB 基于 ASM <strong>字节码</strong>生成工具，它是通过继承的方式来实现代理类，所以要注意 final 方法。</p><p>它们之间的性能随着 JDK 版本的不同而不同，以下内容取自：<a href="https://www.cnblogs.com/haiq/p/4304615.html">haiq的博客</a></p><div class="note  simple"><ul><li>jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显，甚至更快一些；而当调用次数增加之后， cglib 表现稍微更快一些</li><li>jdk7 下，情况发生了逆转！在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍</li><li>jdk8 表现和 jdk7 基本一致</li></ul></div><h3 id="扩展-JDK-动态代理"><a href="#扩展-JDK-动态代理" class="headerlink" title="扩展 JDK 动态代理"></a>扩展 JDK 动态代理</h3><p>JDK 动态代理是<strong>基于接口</strong>的代理，因此要求代理类一定是有定义的接口，使用 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要被代理的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 动态代理处理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invoke&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invoke&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建并使用动态代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(target)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxy.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-运行时异常和编译时异常之间的区别是什么？"><a href="#Java-运行时异常和编译时异常之间的区别是什么？" class="headerlink" title="Java 运行时异常和编译时异常之间的区别是什么？"></a>Java 运行时异常和编译时异常之间的区别是什么？</h2><p>在 Java 中其实分了两大类异常，受检异常（checked exception）和非受检异常（unchecked exception），<strong>它们之间的差别主要在于是否是编译时检查</strong>。</p><p>受检异常（checked exception）其实就是<strong>编译时异常</strong>，继承自 Exception，即在编译阶段检查代码中可能会出现的异常，需要开发者显式的捕获（catch）或声明抛出（throw）这种异常，否则编译就会报错，这是一种强制性规范。</p><p>常见的有：IOException、SQLException、FileNotFoundException 等等。</p><p>非受检异常（unchecked exception）就是<strong>运行时异常</strong>，继承自 RuntimeException 类。是指在运行期间可能会抛出的异常，编译期不强制要求处理，之所以不强制是因为它可以通过完善代码避免报错。</p><p>常见的有：NullPointerException、ArrayIndexOutOfBoundsException、ArithmeticException 等等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】基础（二） | OOP &amp; 内部类 &amp; 接口 &amp; 反射 &amp; 注解 &amp; 泛型</title>
      <link href="/p/4c19fcc6/"/>
      <url>/p/4c19fcc6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-的封装、继承、多态是什么？"><a href="#Java-的封装、继承、多态是什么？" class="headerlink" title="Java 的封装、继承、多态是什么？"></a>Java 的封装、继承、多态是什么？</h2><p>在Java中，封装、继承和多态是面向对象编程（OOP）的三大基本特性。</p><h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>封装指的是将对象的属性（字段）和行为（方法）封装在一个类中，并通过访问控制（如<code>private</code>、<code>protected</code>和<code>public</code>）来隐藏对象的内部实现细节。这样，外部的代码不能直接访问对象的内部数据，只能通过提供的公共方法（通常是getter和setter方法）来操作数据。</p><p><strong>理解：</strong></p><ul><li><strong>隐藏实现细节</strong>：用户不需要知道内部是如何实现的，只需要知道如何使用它。</li><li><strong>控制访问</strong>：通过设置不同的访问修饰符，可以控制哪些数据和方法可以被外部访问。</li><li><strong>提高安全性</strong>：避免了外部直接访问和修改对象的状态，从而防止数据被非法访问或修改。</li></ul><h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><p>继承是一种机制，允许一个类（子类）从另一个类（父类）继承属性和方法。通过继承，子类可以复用父类的代码，并可以在子类中扩展或重写父类的方法。</p><p><strong>理解：</strong></p><ul><li><strong>代码复用</strong>：子类可以继承父类的属性和方法，避免重复代码。</li><li><strong>实现层次结构</strong>：通过继承，类之间可以形成一种“是一个”的关系，从而构建类的层次结构。</li><li><strong>方法重写</strong>：子类可以根据需要重写父类的方法，以提供特定的实现。</li></ul><h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>多态指的是同一个方法或对象在不同场景下可以表现出<strong>不同的行为</strong>。在Java中，多态主要通过方法重载（Overloading）和方法重写（Overriding）实现。</p><p><strong>理解：</strong></p><ul><li><strong>方法重载</strong>：同一个类中可以有多个同名方法，但这些方法的参数列表不同。</li><li><strong>方法重写</strong>：子类可以重写父类的方法，以提供特定的实现。</li><li><strong>接口多态</strong>：对象可以通过父类或接口的引用指向子类的实例，调用方法时会根据实际对象类型执行对应的方法。</li></ul><h2 id="Java-方法重载和方法重写之间的区别是什么？"><a href="#Java-方法重载和方法重写之间的区别是什么？" class="headerlink" title="Java 方法重载和方法重写之间的区别是什么？"></a>Java 方法重载和方法重写之间的区别是什么？</h2><ul><li>重载：在同一个类中定义多个方法，它们<strong>具有相同的名字但参数列表不同</strong>。主要用于提供相同功能的不同实现。</li><li>重写：在子类中定义一个与父类方法具有<strong>相同签名</strong>的方法，以便提供子类的特定实现。且子类方法定义的访问修饰符，不能比父类更严格。例如父类方法是 <code>protected</code>，那么子类方法不能是 <code>private</code>，但可以是 <code>public</code>。且子类方法抛出的异常必须与父类一致，或者是其父类异常的子类。主要用于实现运行时多态性。<strong>例如，子类对父类方法进行扩展或修改以适应特定需求</strong>。</li></ul><h2 id="为什么-Java-不支持多重继承？"><a href="#为什么-Java-不支持多重继承？" class="headerlink" title="为什么 Java 不支持多重继承？"></a>为什么 Java 不支持多重继承？</h2><p>主要是因为多继承会产生菱形继承（也叫钻石继承）问题，Java 之父就是吸取 C++ 他们的教训，因此在不支持多继承。</p><p>所谓的菱形继承很好理解，我们来看下这个图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/Snipaste_2024-05-07_19-32-55.jpg"></p><p>是不是看起来很像一个菱形，BC 继承了 A，然后 D 继承了 BC, 假设此时要调用 D 内定义在 A 的方法，因为 B 和 C 都有不同的实现，此时就会出现歧义，不知道应该调用哪个了。</p><h2 id="this-和-super-是什么？有什么区别？"><a href="#this-和-super-是什么？有什么区别？" class="headerlink" title="this 和 super 是什么？有什么区别？"></a>this 和 super 是什么？有什么区别？</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this关键字用于<strong>指代当前对象实例本身</strong>。在Java中，当你创建一个类的实例（对象）时，this就是指向这个实例的引用。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li>引用当前对象的<strong>成员变量</strong>：当我们有一个局部变量与成员变量同名时，this可以帮助我们区分它们。</li><li>调用当前对象的<strong>成员方法</strong>：虽然直接调用成员方法很常见，但在某些特殊情况下（如构造方法中调用另一个构造方法），我们需要使用this。</li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super关键字用于从子类中访问父类的内容。当你创建一个子类对象时，它同时也包含了父类的所有内容（成员变量、成员方法等），super就是指向这个父类内容的引用。</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ul><li>访问父类的成员变量：如果子类覆盖了父类的成员变量，我们可以使用super来访问父类的成员变量。</li><li>调用父类的成员方法：如果子类覆盖了父类的方法，我们可以使用super来调用父类的方法。</li><li>调用父类的构造方法：在子类的构造方法中，我们可以使用super()来调用父类的构造方法。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>this引用的是当前对象本身，可以用来访问当前对象的成员变量、成员方法或返回当前对象本身。</li><li>super引用的是当前对象的父类对象，可以用来访问父类的成员变量、成员方法或构造方法。</li><li>在构造方法中，this(…)用于调用当前类的其他构造方法，而super(…)用于调用父类的构造方法。注意，这两者在构造方法中<strong>必须是第一条语句</strong>。</li><li>this和super都<strong>不能在静态方法、静态代码块或类变量声明中使用</strong>，因为它们都依赖于具体的对象实例。</li></ol><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><p><strong>接口</strong>：只能包含抽象方法（但在 Java8 之后可以设置 default 方法或者静态方法），成员变量只能是 <code>public static final</code> 类型，当 like-a 的情况下用接口。</p><p><strong>抽象类</strong>：可以包含成员变量和一般方法和抽象方法，当 is-a 并且主要用于代码复用的场景下使用抽象类继承的方式，子类必须实现抽象类中的抽象方法。</p><div class="note  simple info"><p>is-a、has-a、like-a 是什么？其怎么应用？</p></div><p>is-a、has-a、like-a 是什么？</p><ul><li>is-a ：是一个，代表继承关系，如果 A is-a B，那么 B 就是 A 的父类。</li><li>has-a ：有一个，代表从属关系，如果A has a B，那么 B 就是 A 的组成部分。</li><li>like-a ：像一个，代表组合关系，如果 A like a B，那么 B 就是 A 的接口。</li></ul><p>is-a、has-a、like-a 的应用</p><ul><li>如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。</li><li>如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。</li><li>如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</li></ul><h2 id="Java-中的序列化和反序列化是什么？"><a href="#Java-中的序列化和反序列化是什么？" class="headerlink" title="Java 中的序列化和反序列化是什么？"></a>Java 中的序列化和反序列化是什么？</h2><p>序列化其实就是将对象转化成可传输的字节序列格式，以便于存储和传输。Java 序列化不包含静态变量。</p><p>反序列化就是将字节序列格式转换为对象的过程。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/xbVYRn0Y_a8d32fe2-c98d-4240-a9c8-9961b259a2b7.png"></p><h2 id="什么是-Java-内部类？它有什么作用？"><a href="#什么是-Java-内部类？它有什么作用？" class="headerlink" title="什么是 Java 内部类？它有什么作用？"></a>什么是 Java 内部类？它有什么作用？</h2><p>内部类顾名思义就是定义在一个类的内部的类。它主要作用<strong>是为了封装和逻辑分组，提供更清晰的代码组织结构</strong>。</p><p>通过内部类，可以把逻辑上相关的类组织在一起，提升封装性和代码的可读性。后期维护时都在一个类里面，不需要在各地方找来找去。</p><p>按位置分：在成员变量的位置定义，则是成员内部类，在方法内定义，则是局部内部类。</p><p>如果用 static 修饰则为静态内部类，最后还有匿名内部类。</p><p>1）成员内部类，定义在另一个类中的类，可以使用外部类的所有成员变量以及方法，包括 private 的。</p><p>2）静态内部类，只能访问<strong>外部类的静态成员变量以及方法</strong>，其实它就等于一个顶级类，可以独立于外部类使用，所以更多的只是表明类结构和命名空间。</p><p>3）局部内部类，指在方法中定义的类，只在该方法内可见，可以访问外部类的成员以及方法中的局部变量（需要声明为 final 或 effectively final）。</p><p>4）匿名类，指的是没有类名的内部类。用于简化实现接口和继承类的代码，仅在创建对象时使用，例如回调逻辑定义场景。</p><p>局部内部类用的比较少，常用成员内部类、静态内部类和匿名内部类。</p><p>实际上内部类是一个编译层面的概念，像一个语法糖一样，经过编译器之后其实内部类会提升为外部顶级类，和外部类没有任何区别，所以<strong>在 JVM 中是没有内部类的概念的</strong>。</p><h2 id="Java-泛型的作用是什么？什么是泛型擦除？"><a href="#Java-泛型的作用是什么？什么是泛型擦除？" class="headerlink" title="Java 泛型的作用是什么？什么是泛型擦除？"></a>Java 泛型的作用是什么？什么是泛型擦除？</h2><p>泛型可以把类型当作参数一样传递，使得像一些集合类可以明确存储的对象类型，不用显示地强制转化（在没泛型之前只能是Object，然后强转）。</p><p>并且在编译期能识别类型，类型错误则会提醒，增加程序的健壮性和可读性。</p><p>泛型擦除指的是参数类型在编译之后就被抹去了，也就是生成的 class 文件是没有泛型信息的，所以称之为擦除。（在代码里写死的泛型类型是不会被擦除的）。例如，在<strong>运行时</strong>无法直接通过<code>instanceof</code>判断一个对象是否属于某个具体的泛型类型。</p><div class="note  flat info"><p>其他小知识</p></div><p>虽然Java中的泛型存在类型擦除，但可以通过反射来创建泛型数组。例如，可以先获取数组的<code>Class</code>对象，然后利用<code>Array.newInstance</code>方法来创建泛型数组。</p><p>反射可以绕过泛型类型检查。因为泛型类型检查主要在编译时进行，而反射是在运行时操作类和对象的机制，通过反射可以访问和操作那些在编译时受泛型约束的方法和类，即使传入不符合泛型约束的参数类型，也能在运行时通过反射调用相关方法。</p><h2 id="什么是-Java-泛型的上下界限定符？"><a href="#什么是-Java-泛型的上下界限定符？" class="headerlink" title="什么是 Java 泛型的上下界限定符？"></a>什么是 Java 泛型的上下界限定符？</h2><p>上界限定符是 extends ，下界限定符是 super</p><p><code>&lt;? extends T&gt;</code> 表示类型的上界，？这个类型要么是 T ，要么是 T 的子类</p><p><code>&lt;? super T&gt;</code> 表示类型的下界（也叫做超类型限定），？这个类型是 T 的超类型（父类型），直至 Object</p><p>我们在使用上下界通配符的时候，需要遵循 pecs 原则，即Producer Extends, Consumer Super；上界生产，下界消费。</p><p>什么意思呢？</p><p>如果要从集合中读取类型 T 的数据，<strong>并且不能写入</strong>，可以使用 ? extends 通配符；(Producer Extends)，如上面的 <code>processNumber</code> 方法，我们是要从方法中得到 T 类型，也就是方法给我们生产。</p><p>如果要从集合中写入类型 T 的数据，<strong>并且不需要读取</strong>，可以使用 ? super 通配符；(Consumer Super)，如上面的 <code>addElements</code> 方法，我们是要往方法中传入 T 类型，也就是方法帮我们消费。</p><h2 id="你使用过-Java-的反射机制吗？如何应用反射？"><a href="#你使用过-Java-的反射机制吗？如何应用反射？" class="headerlink" title="你使用过 Java 的反射机制吗？如何应用反射？"></a>你使用过 Java 的反射机制吗？如何应用反射？</h2><p>反射其实就是 Java 提供的能在<strong>运行期</strong>得到对象信息的能力，包括属性、方法、注解等，也可以调用其方法。</p><p>一般在业务编码中不会用到反射，在框架上用的较多，因为很多场景需要很灵活，不确定目标对象的类型，届时只能通过反射动态获取对象信息。</p><p>例如 Spring 使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。</p><p>比如动态代理场景可以使用反射机制在运行时动态地创建代理对象。</p><p>所以反射机制的优点是：</p><ul><li>可以<strong>动态地获取类的信息</strong>，不需要在编译时就知道类的信息。</li><li>可以<strong>动态地创建对象</strong>，不需要在编译时就知道对象的类型。</li><li>可以<strong>动态地调用对象的属性和方法</strong>，在运行时动态地改变对象的行为。</li></ul><p>虽然反射很灵活，但是它有个明显的缺点，<strong>性能问题</strong>。</p><p>如果正常调用没影响，但是在高并发场景下就一点性能问题就会放大。</p><p>之所以反射有性能问题是因为反射是在运行时进行的，所以程序每次反射解析检查方法的类型等都需要从 class 的类信息加载进行运行时的动态检查。</p><p>所以 Apache BeanUtils 的 copy 在高并发下就有性能问题。</p><p>如何优化呢？</p><p><strong>缓存</strong>，例如把第一次得到的 Method 缓存起来，后续就不需要再调用 Class.getDeclaredMethod 也就不需要再次动态加载了，这样就可以避免反射性能问题。</p><h2 id="Java-中的注解原理是什么？"><a href="#Java-中的注解原理是什么？" class="headerlink" title="Java 中的注解原理是什么？"></a>Java 中的注解原理是什么？</h2><p>注解其实就是一个标记，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。</p><p>有了标记之后，我们就可以在解析的时候得到这个标记，然后做一些特别的处理，这就是注解的用处。</p><p>比如我们可以定义一些切面，在执行一些方法的时候看下方法上是否有某个注解标记，如果是的话可以执行一些特殊逻辑(RUNTIME类型的注解)。</p><p>注解生命周期有三大类，分别是：</p><ul><li>RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件</li><li>RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了</li><li>RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息</li></ul><p>所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p><p>比如 <code>@Override</code> 就是给编译器用的，编译器编译的时候检查没问题就over了，class文件里面不会有 Override 这个标记。</p><p>再比如 Spring 常见的 <code>@Autowired</code> ，就是 RUNTIME 的，所以<strong>在运行的时候可以通过反射得到注解的信息</strong>，还能拿到标记的值 required 。</p><p>所以注解就是一个标记，可以给编译器用、也能运行时候用。</p><h2 id="什么是-Java-的-SPI（Service-Provider-Interface）机制？"><a href="#什么是-Java-的-SPI（Service-Provider-Interface）机制？" class="headerlink" title="什么是 Java 的 SPI（Service Provider Interface）机制？"></a>什么是 Java 的 SPI（Service Provider Interface）机制？</h2><p>SPI（Service Provider Interface）服务提供接口是 Java 的机制，主要用于实现模块化开发和插件化扩展。 SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过<strong>反射</strong>机制<strong>动态加载这些实现</strong>，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。</p><p>一个典型的 SPI 应用场景是 JDBC（Java 数据库连接库），不同的数据库驱动程序开发者可以使用 JDBC 库，然后定制自己的数据库驱动程序。</p><p>此外，我们使用的主流 Java 开发框架中，几乎都使用到了 SPI 机制，比如 Servlet 容器、日志框架、ORM 框架、Spring 框架。<strong>所以这是 Java 开发者必须掌握的一个重要特性</strong>！</p><h3 id="如何实现-SPI？"><a href="#如何实现-SPI？" class="headerlink" title="如何实现 SPI？"></a>如何实现 SPI？</h3><p>分为系统实现和自定义实现。</p><h4 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h4><p>其实 Java 内已经提供了 SPI 机制相关的 API 接口，可以直接使用，这种方式最简单。</p><ol><li>首先在 resources 资源目录下创建 META-INF&#x2F;services 目录，并且创建一个名称为要实现的接口的空文件</li><li>在文件中填写自己定制的接口实现类的 完整类路径，如图：</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/1783397053004488705.webp"></p><ol start="3"><li>直接使用系统内置的 ServiceLoader 动态加载指定接口的实现类，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定序列化器</span></span><br><span class="line"><span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ServiceLoader&lt;Serializer&gt; serviceLoader = ServiceLoader.load(Serializer.class);</span><br><span class="line"><span class="keyword">for</span> (Serializer service : serviceLoader) &#123;</span><br><span class="line">    serializer = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码能够获取到所有文件中编写的实现类对象，选择一个使用即可。</p><h4 id="自定义-SPI-实现"><a href="#自定义-SPI-实现" class="headerlink" title="自定义 SPI 实现"></a>自定义 SPI 实现</h4><p>系统实现 SPI 虽然简单，但是如果我们想定制多个不同的接口实现类，就没办法在框架中指定使用哪一个了，也就无法实现我们 “通过配置快速指定序列化器” 的需求。</p><p>所以我们需要自己定义 SPI 机制的实现，只要能够根据配置加载到类即可。</p><p>比如读取如下配置文件，能够得到一个 序列化器名称 &#x3D;&gt; 序列化器实现类对象 的映射，之后就可以根据用户配置的序列化器名称动态加载指定实现类对象了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdk=com.yupi.yurpc.serializer.JdkSerializer</span><br><span class="line">hessian=com.yupi.yurpc.serializer.HessianSerializer</span><br><span class="line">json=com.yupi.yurpc.serializer.JsonSerializer</span><br><span class="line">kryo=com.yupi.yurpc.serializer.KryoSerializer</span><br></pre></td></tr></table></figure><h2 id="什么是-Java-的网络编程？"><a href="#什么是-Java-的网络编程？" class="headerlink" title="什么是 Java 的网络编程？"></a>什么是 Java 的网络编程？</h2><p>这题一般会出现在笔试题中，例如让你手写一个基于 Java 实现网络通信的代码。</p><p>Java 的网络编程主要利用 java.net 包，它提供了用于网络通信的基本类和接口。</p><p>Java 网络编程的核心类：</p><ul><li>Socket：用于创建客户端套接字。</li><li>ServerSocket：用于创建服务器套接字。</li><li>DatagramSocket：用于创建支持 UDP 协议的套接字。</li><li>URL：用于处理统一资源定位符。</li><li>URLConnection：用于读取和写入 URL 引用的资源。</li></ul><p>示例代码参考(以下代码时基于 TCP 通信的，一般笔试考察的都是 TCP)：</p><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is listening on port 8080&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">//异步处理，优化可以用线程池</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取客户端消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应客户端</span></span><br><span class="line">            out.println(<span class="string">&quot;Hello, client!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">             <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息给服务器</span></span><br><span class="line">            out.println(<span class="string">&quot;Hello, server!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务器的响应</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server response: &quot;</span> + response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/uutale/article/details/139588654">【java关键字this和super的概念、用法和区别】-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【星尘2024诞生日】五维一姐歌选亚乐 高效演绎新单恨如冰《ICE》（Cover: Faouzia）【歌手2024】</title>
      <link href="/p/27446c6a/"/>
      <url>/p/27446c6a/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/ICE_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【星尘Infinity】ICE_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《ICE》(live)</p><p>翻唱：星尘Infinity</p><p>调教：Rean__</p><p>混音：Rean__</p><br><p>恭喜亚演 更喜亚乐</p><p>法语部分是参考的谷歌娘发音 包准的（</p><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1kS411w7Ed/">【简醇品牌大使】凡希亚Faouzia《ICE》</a></p><p>作词 : Faouzia&#x2F;Kristen Carpenter&#x2F;Inverness</p><p>作曲 : Faouzia&#x2F;Kristen Carpenter&#x2F;Inverness</p><p>原唱 : Faouzia</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：Inverness</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：黄群翰</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>Made of ice</p><p>The tears won’t fall down</p><p>No they’re crystallized</p><p>My body’s numb now but it’s kinda nice</p><p>I couldn’t take it anymore</p> <br><p>Left me crying on the bathroom floor</p><p>Wait a minute what was that all for</p><p>Now you’re banging on my door</p><p>Like of course</p><p>But it’s too late a little too late oh</p><br><p>Made of ice made of ice</p><p>Look at what you made of me</p><p>Recognize recognize</p><p>You can’t even recognize me</p><p>How can you look in my stone cold eyes</p><p>You took a burning red heart and made it ice oh</p><br><p>Made of ice made of ice</p><p>Look at what you made of me</p><p>I survived I survived</p><p>But every breath I take is heavy</p><p>How can you look in my stone cold eyes</p><p>You took a burning red heart and made it ice oh</p><br><p>Dead to me</p><p>Have you forgotten what you did to me</p><p>You put my flame out</p><p>You say I’ve changed now</p><p>I couldn’t take it anymore</p><br><p>You left me crying on the bathroom floor</p><p>Wait a minute what was that all for</p><p>Now you’re banging on my door</p><p>Like of course</p><p>But it’s too late a little too late oh</p><br><p>Made of ice made of ice</p><p>Look at what you made of me</p><p>Recognize recognize</p><p>You can’t even recognize me</p><p>How can you look in my stone cold eyes</p><p>You took a burning red heart and made it ice oh</p><br><p>Made of ice made of ice</p><p>Look at what you made of me</p><p>I survived I survived</p><p>But every breath I take is heavy</p><p>How can you look in my stone cold eyes</p><p>You took a burning red heart and made it ice oh</p><br><p>En premier</p><p>J’ai senti le froid glacial couler dans mes veines</p><p>J’avais peur</p><p>Mais ensuite le soulagement</p><p>Avec la realization qu’enfin</p><p>Mon coeur ne peux plus se briser en deux</p><p>Mon coeur ne peux plus se briser en deux</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Faouzia </tag>
            
            <tag> 星尘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】基础（一） | 数据类型 &amp; 类 &amp; 异常</title>
      <link href="/p/9f38852a/"/>
      <url>/p/9f38852a/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-中的基本数据类型有哪些？"><a href="#Java-中的基本数据类型有哪些？" class="headerlink" title="Java 中的基本数据类型有哪些？"></a>Java 中的基本数据类型有哪些？</h2><p>Java 中的数据类型可以分为两大类：基本数据类型和引用数据类型。</p><p>基本数据类型是 Java 中的原始数据类型，而引用数据类型则是对象引用。</p><h3 id="基本数据类型（Primitive-Data-Types）"><a href="#基本数据类型（Primitive-Data-Types）" class="headerlink" title="基本数据类型（Primitive Data Types）"></a>基本数据类型（Primitive Data Types）</h3><ul><li>整型：byte（8位有符号整数）、short（16位有符号整数）、int（32位有符号整数）、long（64位有符号整数，后缀 L 或 l）。</li><li>浮点型：float（32位浮点数，后缀 F 或 f）、double（64位浮点数，后缀 D 或 d）。</li><li>字符型：char（16位 Unicode 字符）。</li><li>布尔型：boolean（只有两个可能的值：true 或 false）。</li></ul><h3 id="引用数据类型（Reference-Data-Types）"><a href="#引用数据类型（Reference-Data-Types）" class="headerlink" title="引用数据类型（Reference Data Types）"></a>引用数据类型（Reference Data Types）</h3><ul><li>类（Class）：用户自定义的类或 Java 内置的类。</li><li>接口（Interface）：定义了类必须实现的方法的契约。</li><li>数组（Array）：一种容器对象，可以包含固定数量的单一类型值。</li><li>枚举（Enumeration）：用于表示一组预定义的常量，使代码更加简洁、可读。</li><li>注解（Annotation）：修饰方法或者类或者属性。</li></ul><h2 id="Java-中的参数传递是按值还是按引用？"><a href="#Java-中的参数传递是按值还是按引用？" class="headerlink" title="Java 中的参数传递是按值还是按引用？"></a>Java 中的参数传递是按值还是按引用？</h2><p><strong>Java 只有按值传递，不论是基本类型还是引用类型。</strong></p><p>JVM 内存有划分为栈和堆，局部变量和方法参数是在<strong>栈</strong>上分配的 ，引用类型占 4 个字节，基本类型看具体类型，例如 long 和 double 占 8 个字节。</p><p>而对象所占的空间是在<strong>堆</strong>中开辟的，引用类型变量存储的是对象<strong>在堆中的地址</strong>，并以此来访问对象，所以传递的时候可以理解为把变量存储的地址给传递过去，因此引用类型也是值传递。</p><h2 id="Java-中的深拷贝和浅拷贝有什么区别？"><a href="#Java-中的深拷贝和浅拷贝有什么区别？" class="headerlink" title="Java 中的深拷贝和浅拷贝有什么区别？"></a>Java 中的深拷贝和浅拷贝有什么区别？</h2><p>深拷贝：完全拷贝一个对象，包括基本类型和引用类型，堆内的引用对象也会复制一份。</p><p>浅拷贝：仅拷贝基本类型和引用，堆内的引用对象和被拷贝的对象共享。</p><p>所以假如拷贝的对象成员间有一个 list，深拷贝之后堆内有 2 个 list，之间不会影响，而浅拷贝的话堆内还是只有一个 list。</p><p>比如现在有个 teacher 对象，然后成员里面有一个 student 列表。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20210303201307397_mianshiya.png" alt="image-20210303201307397.png"></p><p>因此深拷贝是安全的，浅拷贝的话如果有引用对象则原先和拷贝对象修改引用对象的值会相互影响。</p><h2 id="Java-的类加载过程是怎样的？"><a href="#Java-的类加载过程是怎样的？" class="headerlink" title="Java 的类加载过程是怎样的？"></a>Java 的类加载过程是怎样的？</h2><p>类加载顾名思义就是把类加载到 JVM 中，而输入一段二进制流到内存，之后经过一番解析、处理转化成可用的 class 类，这就是类加载要做的事情。</p><p>二进制流可以来源于 class 文件，或者通过字节码工具生成的字节码或者来自于网络都行，只要符合格式的二进制流，JVM 来者不拒。</p><p>类加载流程分为<strong>加载、连接、初始化</strong>三个阶段，连接还能拆分为：验证、准备、解析三个阶段。</p><p>所以总的来看可以分为 5 个阶段：</p><ul><li>加载：将二进制流搞到内存中来，生成一个 Class 类。</li><li>验证：主要是验证加载进来的二进制流是否符合一定格式，是否规范，是否符合当前 JVM 版本等等之类的验证。</li><li>准备：为<strong>静态变量</strong>(类变量)赋初始值，也即为它们在方法区划分内存空间。这里注意是静态变量，并且是初始值，比如 int 的初始值是 0。</li><li>解析：将常量池的符号引用转化成直接引用。符号引用可以理解为只是个替代的标签，比如你此时要做一个计划，暂时还没有人选，你设定了个 A 去做这个事。然后等计划真的要落地的时候肯定要找到确定的人选，到时候就是小明去做一件事。解析就是把 A(符号引用) 替换成小明(直接引用)。符号引用就是一个字面量，没有什么实质性的意义，只是一个代表。直接引用指的是一个真实引用，在内存中可以通过这个引用查找到目标。</li><li>初始化：这时候就执行一些静态代码块，为静态变量赋值，这里的赋值才是<strong>代码里面的赋值</strong>，准备阶段只是设置初始值占个坑。</li></ul><h2 id="什么是-Java-中的不可变类？如何实现一个不可变类？"><a href="#什么是-Java-中的不可变类？如何实现一个不可变类？" class="headerlink" title="什么是 Java 中的不可变类？如何实现一个不可变类？"></a>什么是 Java 中的不可变类？如何实现一个不可变类？</h2><p>不可变类指的是无法修改对象的值，比如 String 就是典型的不可变类，当你创建一个 String 对象之后，这个对象就无法被修改。所以不要在字符串拼接频繁的场景使用 + 来拼接，因为这样会频繁的创建对象。</p><p>至于如何实现，就参考 String 的设计就行。</p><p>String 类用 final 修饰，表示无法被继承。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/7a891c1016266126c1428a76ae5f15c8.png"></p><p>String 本质是一个 char 数组，然后用 final 修饰，不过 final 限制不了数组内部的数据，所以这还不够。</p><p>所以 value 是用 private 修饰的，并且没有暴露出 set 方法，这样外部其实就接触不到 value 所以无法修改。</p><p>当然还是有修改的需求，比如 replace 方法，所以这时候就需要返回一个新对象来作为结果。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/2d578e400ef8b32f6846988d6707db01.png"></p><p>总结一下就是私有化变量，然后不要暴露 set 方法，即使有修改的需求也是返回一个新对象。</p><h2 id="Java-中-String、StringBuffer-和-StringBuilder-的区别是什么？"><a href="#Java-中-String、StringBuffer-和-StringBuilder-的区别是什么？" class="headerlink" title="Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？"></a>Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？</h2><p><code>String</code> 是 Java 中基础且重要的类，是可不变的。</p><p><strong><code>StringBuffer</code> 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类</strong>，它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上了 <code>synchronized</code>。但是保证了线程安全是需要性能的代价的。</p><p>在很多情况下我们的字符串拼接操作不需要线程安全，这时候 <strong>StringBuilder</strong> 登场了，<code>StringBuilder</code>是<code>JDK1.5</code>发布的，它和 <code>StringBuffer</code> 本质上没什么区别，就是<strong>去掉了保证线程安全的那部分，减少了开销</strong>。</p><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li>String：适用于少量字符串操作或需要字符串常量池优化的场景。</li><li>StringBuffer：适用于多线程环境下频繁的字符串操作。</li><li>StringBuilder：适用于单线程环境下频繁的字符串操作。</li></ul><h2 id="使用-new-String-语句在-Java-中会创建多少个对象？"><a href="#使用-new-String-语句在-Java-中会创建多少个对象？" class="headerlink" title="使用 new String() 语句在 Java 中会创建多少个对象？"></a>使用 new String() 语句在 Java 中会创建多少个对象？</h2><p>会创建 1 或 2 个字符串对象。</p><p>主要有两种情况：</p><p>1、如果字符串常量池中不存在字符串对象的引用，那么它会在堆上创建<strong>两个</strong>字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p><p>2、如果字符串常量池中已存在字符串对象“yupi”的引用，则只会在堆中创建 1 个字符串对象“yupi”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="为什么-JDK-9-中将-String-的-char-数组改为-byte-数组？"><a href="#为什么-JDK-9-中将-String-的-char-数组改为-byte-数组？" class="headerlink" title="为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？"></a>为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？</h2><p>这个操作主要是为了<strong>节省内存空间，提高内存利用率</strong>。</p><p>在 JDK 9 之前，String 类是基于 <code>char[]</code> 实现的，内部采用 UTF-16 编码，每个字符占用<strong>两个字节</strong>。</p><p>但是，如果当前的字符仅需一个字节的空间，这就造成了浪费。例如一些 <code>Latin-1</code> 字符用一个字节即可表示。</p><p>因此 JDK 9 做了优化采用 <code>byte</code> 数组来实现。</p><p>并引入了 coder 变量来标识编码方式（Latin-1 或 UTF-16）。对于大多数只包含 Latin-1 字符（即每个字符可以用一个字节表示）的字符串，内存使用量减半。</p><h3 id="Latin1-是什么？"><a href="#Latin1-是什么？" class="headerlink" title="Latin1 是什么？"></a>Latin1 是什么？</h3><p>Latin1 是国际标准编码 ISO-8859-1 的别名。Latin1 也是单字节编码，在 ASCII 编码的基础上，利用了 ASCII 未利用的最高位，扩充了 128 个字符，因此 Latin1 可以表示 256 个字符，并向下兼容 ASCII。</p><p>Latin1收录的字符除 ASCII 收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，没有被收录在 ISO-8859-1 当中，在后来的修订版 ISO-8859-15 加入了欧元符号。</p><p>Latin1的编码范围是 0x00-0xFF，ASCII的编码范围是 0x00-0x7F。</p><p>Latin1 相对 ASCII 而言，较少被提及，其实 Latin1 的使用还是比较广泛的，比如 MySQL（8.0之前）的数据表存储默认编码就是 Latin1。</p><h2 id="Java-的-BigDecimal-是什么？"><a href="#Java-的-BigDecimal-是什么？" class="headerlink" title="Java 的 BigDecimal 是什么？"></a>Java 的 BigDecimal 是什么？</h2><p><code>BigDecimal</code> 是 Java 中提供的一个用于高精度计算的类，属于 java.math 包。它提供对浮点数和定点数的精确控制，特别适用于金融和科学计算等需要高精度的领域。</p><p>主要特点：</p><ul><li>高精度：BigDecimal 可以处理<strong>任意精度</strong>的数值，而不像 float 和 double 存在精度限制。</li><li>不可变性：BigDecimal 是<strong>不可变</strong>类，所有的算术运算都会返回新的 BigDecimal 对象，而不会修改原有对象（所以要注意性能问题）。</li><li>丰富的功能：提供了加、减、乘、除、取余、舍入、比较等多种方法，并支持各种舍入模式。</li></ul><p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><h2 id="Java-中包装类型和基本类型的区别是什么？"><a href="#Java-中包装类型和基本类型的区别是什么？" class="headerlink" title="Java 中包装类型和基本类型的区别是什么？"></a>Java 中包装类型和基本类型的区别是什么？</h2><p>Java 中有 8 种基本数据类型，这些基本类型又有对应的包装类。</p><table><thead><tr><th>基本数据类型（默认值）</th><th>包装类（默认值）</th><th>长度</th><th>取值范围</th></tr></thead><tbody><tr><td>byte (0)</td><td>Byte (null)</td><td>1字节</td><td>-128～127</td></tr><tr><td>short (0)</td><td>Short (null)</td><td>2字节</td><td>-32768～32767</td></tr><tr><td>int (0)</td><td>Integer (null)</td><td>4字节</td><td>-231 ～ 2(31-1)</td></tr><tr><td>long (0)</td><td>Long (null)</td><td>8字节</td><td>-263 ~ 2(63-1)</td></tr><tr><td>float (0.0)</td><td>Float (null)</td><td>4字节</td><td>1.4E-45~3.4028235E38</td></tr><tr><td>double (0.0)</td><td>Double (null)</td><td>8字节</td><td>4.9E-324~1.7976931348623157E308</td></tr><tr><td>boolean (false)</td><td>Boolean (null)</td><td>&#x2F;</td><td>true | false</td></tr><tr><td>char (为空)</td><td>Character (null)</td><td>2字节</td><td>0～65535</td></tr></tbody></table><p><strong>因为 Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型</strong>。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是 Object类型。</p><p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h3 id="基本类型与包装类型的区别"><a href="#基本类型与包装类型的区别" class="headerlink" title="基本类型与包装类型的区别"></a>基本类型与包装类型的区别</h3><ol><li><strong>默认值不同</strong>：基本类型的默认值是 0，false 等，包装类默认为 null（包装类型可以为null，而基本类型不可以）</li><li><strong>初始化的方式不同</strong>：一个需要采用 new 的方式创建，一个则不需要</li><li><strong>存储方式有所差异</strong>：基本类型主要保存在<strong>栈</strong>上面，包装类对象保存在<strong>堆</strong>上（成员变量的话，在不考虑JIT优化的栈上分配时，都是随着对象一起保存在堆上的）</li><li>包装类型可用于<strong>泛型</strong>，而基本类型不可以</li><li>两个包装类型的值可以相同，但却不相等（&#x3D;&#x3D;）</li></ol><h2 id="什么是-Java-中的自动装箱和拆箱？"><a href="#什么是-Java-中的自动装箱和拆箱？" class="headerlink" title="什么是 Java 中的自动装箱和拆箱？"></a>什么是 Java 中的自动装箱和拆箱？</h2><p>自动装箱（Autoboxing）和拆箱（Unboxing）是 Java 语言中的一种特性，它们允许自动地在基本数据类型和相应的包装类之间进行转换。极大地简化了代码，使得基本类型和包装类之间的转换更加透明和自然。</p><h3 id="需要注意的事项："><a href="#需要注意的事项：" class="headerlink" title="需要注意的事项："></a>需要注意的事项：</h3><ol><li>性能影响：虽然自动装箱和拆箱提供了方便，但它们会产生额外的对象创建和拆箱操作，可能会影响性能，<strong>尤其是在循环或频繁使用的场景中</strong>。</li><li>NullPointerException：在进行拆箱操作时，如果包装类对象为 null，会抛出 NullPointerException。</li></ol><h2 id="什么是-Java-的-Integer-缓存池？"><a href="#什么是-Java-的-Integer-缓存池？" class="headerlink" title="什么是 Java 的 Integer 缓存池？"></a>什么是 Java 的 Integer 缓存池？</h2><p>因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置 <code>JVM-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来修改缓存的最大值，最小值改不了。</p><p>实现的原理是 <code>int</code> 在自动装箱的时候会调用Integer.valueOf，进而用到了 IntegerCache。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20210228112742081_mianshiya.png" alt="image-20210228112742081.png"></p><p>IntegerCache 在静态块中会初始化好缓存值。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20210228112757226_mianshiya.png" alt="image-20210228112757226.png"></p><p>所以这里还有个面试题，就是啥 Integer 127 之内的相等，而超过 127 的就不等了，因为 127 之内的就是同一个对象，所以当然相等。</p><p>不仅 Integer 有，Long 也是有的，不过范围是写死的 -128 到 127。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20210228112817173.png" alt="image-20210228112817173.png"></p><p>对了 Float 和 Double 是没有滴，毕竟是小数，能存的数太多了。</p><h2 id="Java-中-hashCode-和-equals-方法是什么？它们与-操作符有什么区别？"><a href="#Java-中-hashCode-和-equals-方法是什么？它们与-操作符有什么区别？" class="headerlink" title="Java 中 hashCode 和 equals 方法是什么？它们与 &#x3D;&#x3D; 操作符有什么区别？"></a>Java 中 hashCode 和 equals 方法是什么？它们与 &#x3D;&#x3D; 操作符有什么区别？</h2><p>这些都是 <code>Java</code> 中用于比较对象的三种方式。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p><code>hashCode</code>返回对象的哈希码（整数），主要用于支持基于哈希表的集合，用来确定对象的存储位置，如 <code>HashMap、HashSet</code> 等。</p><p><code>Object</code> 类中的默认实现会根据对象的内存地址生成哈希码（<code>native</code> 方法）。</p><p>在 <code>Java</code> 中，<code>hashCode</code> 方法和 <code>equals</code> 方法之间有一个 <strong>“合约”</strong>：</p><ul><li>如果两个对象根据 <code>equals</code> 方法被认为是相等的，那么它们必须具有<strong>相同的哈希码</strong>。</li><li>如果两个对象具有相同的哈希码，它们<strong>并不一定相等</strong>，但会被放在同一个哈希桶中。</li></ul><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>用于比较两个对象的<strong>内容是否相等</strong>。<code>Object</code> 类中的默认实现会使用 &#x3D;&#x3D; 操作符来比较对象的内存地址。</p><p>通常我们需要在自定义类中重写 <code>equals</code> 方法，以基于对象的属性进行内容比较。比如你可以自定义两个对象的名字一样就是相等的、年龄一样就是相等，可以灵活按照需求定制。</p><p>对于 <code>equals</code> 定义的比较，实际上还有以下五个要求：</p><ul><li>自反性：对于任何非空引用值 <code>x</code>，<code>x.equals(x)</code> 必须返回 <code>true</code>。</li><li>对称性：对于任何非空引用值 <code>x</code> 和 <code>y</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，则 <code>y.equals(x)</code> 也必须返回 <code>true</code>。</li><li>传递性：对于任何非空引用值 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code> 且 <code>y.equals(z)</code> 返回 <code>true</code>，则 <code>x.equals(z)</code> 也必须返回 <code>true</code>。</li><li>一致性：对于任何非空引用值 <code>x</code> 和 <code>y</code>，只要对象在比较中没有被修改，多次调用 <code>x.equals(y)</code> 应返回相同的结果。</li><li>对于任何非空引用值 <code>x</code>，<code>x.equals(null)</code> 必须返回 <code>false</code>。</li></ul><h3 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h3><p><code>==</code> 操作符用于比较两个引用是否指向同一个对象（即比较内存地址），如果是基本数据类型，<code>==</code> 直接比较它们的值。</p><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><p><code>hashCode</code> 用于散列存储结构中确定对象的存储位置。可用于快速比较两个对象是否不同，因为如果它们的哈希码不同，那么它们肯定不相等。</p><p><code>equals</code> 用于比较两个对象的内容是否相等，通常需要重写自定义比较逻辑。</p><p><code>==</code> 用于比较两个引用是否指向同一个对象（即内存地址）。对于基本数据类型，比较它们的值。</p><h3 id="散列表的相关类"><a href="#散列表的相关类" class="headerlink" title="散列表的相关类"></a>散列表的相关类</h3><p>比如 HashSet，我们常用来得到一个不重复的集合。</p><p>现在有个 Yes 类的 HashSet 集合，我只重写了 Yes 类的 equals 方法，表明如果 name 相同就返回 true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Yes) &#123;</span><br><span class="line">        <span class="type">Yes</span> <span class="variable">other</span> <span class="operator">=</span> (Yes) obj;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就重写一个 equals 的话，HashSet 中会出现相同 name 的 Yes 对象。</p><p>原因就是 hashCode 没有重写，那为什么会这样呢？因为 HashSet 是复用 HashMap 的能力存储对象，而塞入 key 的时候要计算 hash 值，可以看到这里实际会调用对象的 hashCode 方法来计算 hash 值。</p><p>然后在具体执行 putVal 方法的时候，相关的判断条件会先判断 hash 值是否相等，如果 hash 值都不同，那就认为这两个对象不相等，这与我们之前设定的 name 一样的对象就是相等的条件就冲突了</p><p>因此规定，重写 equals 方法的时候，也要重写 hashCode 方法，这样才能保持条件判断的同步。我建议不管会不会用到散列表，只要你重写 equals 就一起重写 hashCode ，这样肯定不会出错。</p><h2 id="Java-的-Optional-类是什么？它有什么用？"><a href="#Java-的-Optional-类是什么？它有什么用？" class="headerlink" title="Java 的 Optional 类是什么？它有什么用？"></a>Java 的 Optional 类是什么？它有什么用？</h2><p>Optional 是 Java 8 引入的一个用来解决空指针异常的问题的容器类，它用来<strong>表示一个值可能存在或不存在</strong>。通过Optional类，我们可以避免在获取对象值时出现空指针异常。常见的使用方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; userOption = Optional.ofNullable(userService.getUser(...));</span><br><span class="line"><span class="keyword">if</span> (!userOption.isPresent()) &#123;....&#125;</span><br></pre></td></tr></table></figure><p>Optional 其实就是一个壳，里面放着原先的值，至于这个值是不是 null 另说，反正拿到的这个壳肯定不是 null。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/UmdCliuo_c7362dfe-26af-4ae0-be83-57ebefcdcbfc.png"></p><p>我认为 Optional 的好处在于可以简化平日里一系列判断 null 的操作，使得用起来的时候看着不需要判断 null，纵享丝滑，表现出来好像用 Optional 就不需要关心空指针的情况。</p><p>而事实上是 Optional 在替我们负重前行，该有的判断它替我们完成了，而且用了 Optional 最后拿结果的时候还是小心的，盲目 get 一样会抛错。</p><p>Optional类主要有三个常用方法，分别是of()、ofNullable()和orElse()。</p><ul><li>of()方法用来创建一个非空的Optional实例</li><li>ofNullable()方法可以创建一个可能为空的Optional实例</li><li>orElse()方法可以在Optional为空时提供一个默认值。</li></ul><p>我们来看一下代码就很清楚 Optional 的好处在哪儿了。比如现在有个 yesSerivce 能 get 一个 Yes，此时需要输出 Yes 所在的省，此时的代码是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Yes</span> <span class="variable">yes</span> <span class="operator">=</span> getYes();</span><br><span class="line"><span class="keyword">if</span> (yes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Address</span> <span class="variable">yesAddress</span> <span class="operator">=</span> yes.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (yesAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Province</span> <span class="variable">province</span> <span class="operator">=</span> yesAddress.getProvince();</span><br><span class="line">        System.out.println(province.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); <span class="comment">//如果没找到就抛错</span></span><br></pre></td></tr></table></figure><p>如果用 Optional 的话，那就变成下面这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(getYes())</span><br><span class="line">        .map(a -&gt; a.getAddress())</span><br><span class="line">        .map(p -&gt; p.getProvince())</span><br><span class="line">        .map(n -&gt; n.getName())</span><br><span class="line">        .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>可以看到，如果用了 Optional，代码里不需要判空的操作，即使 address 、province 为空的话，也不会产生空指针错误，这就是 Optional 带来的好处！</p><h2 id="什么是-Java-中的迭代器（Iterator）？"><a href="#什么是-Java-中的迭代器（Iterator）？" class="headerlink" title="什么是 Java 中的迭代器（Iterator）？"></a>什么是 Java 中的迭代器（Iterator）？</h2><p>迭代器（Iterator）其实是一种<strong>设计模式</strong>，用于遍历集合（例如 List、Set、Map 等）中的元素，而不需要暴露集合的内部实现，即不需要了解集合的底层结构。</p><p>在 Java 中 Iterator 是一个接口，在 java.util 包中的，常用的方法是：</p><ul><li>hasNext()：如果迭代器还有更多的元素可以迭代，则返回 true，否则返回 false。</li><li>next()：返回迭代器的下一个元素。如果没有更多元素，调用该方法将抛出 NoSuchElementException。</li><li>remove()：从底层集合中移除 next() 方法返回的上一个元素。这个方法是可选的，不是所有的实现都支持该操作。如果不支持，调用时会抛出 UnsupportedOperationException。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取集合的迭代器</span></span><br><span class="line">      Iterator&lt;String&gt; iterator = list.iterator();</span><br></pre></td></tr></table></figure><p>迭代器模式带来了很多好处：</p><ul><li><strong>封装性</strong>：它将集合遍历行为和具体的实现分离，使得使用者不需要了解集合具体的内部实现。</li><li><strong>一致性</strong>：所有的集合都实现了 Iterator 接口，因此对于不同集合的遍历代码都是一致的。</li><li><strong>灵活性</strong>：因为遍历接口一致，使得可以很灵活的替换底层实现的集合而不需要改变上层的遍历代码。</li></ul><p>Iterator 提供了单向遍历方法，如果需要支持双向遍历，可以使用 ListIterator 接口。</p><h2 id="请解释一下-Java-8-Stream-API-和-Lambda-表达式的作用，以及在项目中如何应用它们来简化集合处理？"><a href="#请解释一下-Java-8-Stream-API-和-Lambda-表达式的作用，以及在项目中如何应用它们来简化集合处理？" class="headerlink" title="请解释一下 Java 8 Stream API 和 Lambda 表达式的作用，以及在项目中如何应用它们来简化集合处理？"></a>请解释一下 Java 8 Stream API 和 Lambda 表达式的作用，以及在项目中如何应用它们来简化集合处理？</h2><p>Stream API 和 Lambda 表达式是 Java 8 提供的语法糖，它们的作用是使集合处理更加简洁、易读和高效。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种匿名函数，允许你以更紧凑的方式传递代码块，简化代码的编写，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式过滤以 &quot;A&quot; 开头的名字</span></span><br><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">    .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h3><p>Stream API 是一种流式操作集合的方法，提供了丰富的集合处理操作，比如过滤、映射、排序等，还支持延迟加载和并行处理，简化代码、并提高编码效率。</p><p>上述代码示例同样也是 Stream API 的应用。</p><p>在本项目中，匹配相似用户时，将存储用户和匹配度的 List 转化为 Stream 流，用 sorted 方法进行编辑距离由小到大排序，用 limit 方法取流的前 N 项，用 collect 终结操作将处理好的流转化为集合 List。还有使用 Stream API 的 map 方法对用户列表中的每个用户信息进行脱敏、使用ParallelStream 实现并发流等。</p><h2 id="Java-异常有哪些种类？"><a href="#Java-异常有哪些种类？" class="headerlink" title="Java 异常有哪些种类？"></a>Java 异常有哪些种类？</h2><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p><h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 IO 操作的代码：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/checked-exception.png"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h2 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h2><p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p><p><code>catch</code>块：用于处理 try 捕获到的异常。</p><p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h3 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%BC%82%E5%B8%B8">Java基础常见面试题总结(下) | JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】进程管理</title>
      <link href="/p/2516f5f2/"/>
      <url>/p/2516f5f2/</url>
      
        <content type="html"><![CDATA[<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：</p><p><strong>内核态（Kernel Mode）</strong>：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。</p><p><strong>用户态（User Mode）</strong>：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。</p><p>内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操<br>作系统的核心功能，需要较高的权限来执行。</p><p>分为内核态和用户态的原因主要有以下几点：</p><ul><li><strong>安全性</strong>：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</li><li><strong>稳定性</strong>：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</li><li><strong>隔离性</strong>：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。</li></ul><br><h1 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h1><p><img src="https://cdn.xiaolincoding.com//picgo/1712907111634-f541e01f-2da1-426f-b7a8-ce769346a93d.webp" alt="进程&amp;线程"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配和调度的一个独立单位（<strong>资源分配的最小单位</strong>），进程切换耗费资源比线程切换大。</p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。进程有独立的进程地址空间。</p><h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。<strong>PCB 是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p><div class="note  flat"><p>PCB 具体包含什么信息呢？</p></div><p><strong>进程描述信息：</strong></p><ul><li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul><p><strong>进程控制和管理信息：</strong></p><ul><li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul><p><strong>资源分配清单：</strong></p><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li></ul><p><strong>CPU 相关信息：</strong></p><ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul><p>每个PCB通常是通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>。比如：</p><ul><li>将所有处于就绪状态的进程链在一起，称为<strong>就绪队列</strong>；</li><li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种<strong>阻塞队列</strong>；</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程中的一个实体，是 <strong>CPU 调度的基本单位</strong>，是比进程更小的能独立运行的基本单位。线程自己不拥有系统资源，只拥有运行中必不可少的资源（如程序计数器、寄存器、栈）。</p><p>在同一个进程内，可以有多个线程，多个线程共享同一个进程的资源，每个线程具有自己的线程栈。线程没有独立的线程地址空间，多个线程共享同一个进程地址空间。</p><p>进程间不会相互影响。一个进程内某个线程挂掉将导致整个进程挂掉。</p><h3 id="多线程比单线程的优势，劣势？"><a href="#多线程比单线程的优势，劣势？" class="headerlink" title="多线程比单线程的优势，劣势？"></a>多线程比单线程的优势，劣势？</h3><ul><li><strong>优势</strong>：提高程序的运行效率，可以充分利用多核处理器的资源，同时处理多个任务，加快程序的执行速度。</li><li><strong>劣势</strong>：存在多线程数据竞争访问的问题，需要通过锁机制来保证线程安全，增加了加锁的开销，并且还会有死锁的风险。多线程会消耗更多系统资源，如CPU和内存，因为每个线程都需要占用一定的内存和处理时间。</li></ul><h3 id="为什么要用多线程？"><a href="#为什么要用多线程？" class="headerlink" title="为什么要用多线程？"></a>为什么要用多线程？</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li></ul><h3 id="多线程是不是越多越好，太多会有什么问题？"><a href="#多线程是不是越多越好，太多会有什么问题？" class="headerlink" title="多线程是不是越多越好，太多会有什么问题？"></a>多线程是不是越多越好，太多会有什么问题？</h3><ul><li><strong>切换开销</strong>：线程的创建和切换会消耗系统资源，包括内存和CPU。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某个线程崩溃后，可能会导致进程崩溃。</li><li><strong>死锁的问题</strong>：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行。</li></ul><h3 id="线程切换为什么比进程切换快？-进程切换和线程切换的区别？"><a href="#线程切换为什么比进程切换快？-进程切换和线程切换的区别？" class="headerlink" title="线程切换为什么比进程切换快？&#x2F; 进程切换和线程切换的区别？"></a>线程切换为什么比进程切换快？&#x2F; 进程切换和线程切换的区别？</h3><p>线程切换比进程切换快是因为线程共享同一进程的地址空间和资源，线程切换时只需切换<strong>堆栈和程序计数器等</strong>少量信息，而不需要切换地址空间，避免了进程切换时需要切换整个进程的<strong>地址空间、全局变量、文件描述符等</strong>大量资源的开销，从而节省了时间和系统资源。</p><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p><img src="https://cdn.xiaolincoding.com//picgo/1715669823633-dcd21d9d-1bc9-44b0-b708-7afda68c2257.webp" alt="img"></p><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h2><p>线程与进程的比较如下：</p><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><br><h1 id="进程间的通信方法"><a href="#进程间的通信方法" class="headerlink" title="进程间的通信方法"></a>进程间的通信方法</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以 <strong>进程之间要交换数据必须通过内核</strong>。在内核中开辟一块缓冲区，进程 A 把数据从用户空间拷到内核缓冲区，进程 B 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。</p><p>进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 Socket。</p><ol><li>管道（Pipes）：管道是一种单向通信方式，用于在父进程和子进程之间或者同一主机上的不同进程之间传递数据。它可以是<strong>匿名</strong>的，也可以是<strong>命名</strong>的。</li><li>命名管道（Named Pipes）：与匿名管道类似，但具有一个在文件系统中有名的路径，允许不相关的进程之间进行通信。</li><li>消息队列（Message Queues）：消息队列允许一个进程向另一个进程发送消息，消息在队列中按顺序存储，并且接收方可以按需接收。</li><li>共享内存（Shared Memory）：<strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。共享内存允许多个进程访问同一块内存区域，从而实现快速的数据交换。但需要注意同步问题，以避免竞态条件和数据一致性问题。</li><li>信号量（Semaphores）：信号量是一种同步原语，用于管理对共享资源的访问。它可以用于实现进程间的互斥访问和同步操作。</li><li>套接字（Sockets）：套接字允许在网络上的不同主机上的进程进行通信，是实现网络通信的基础。</li><li>文件（File）：进程可以通过读写文件来进行通信，这种方式通常用于进程之间的间接通信，例如使用临时文件或者共享文件。</li></ol><p>可以根据不同的场景选取不同的通信方式。</p><h2 id="信号和信号量有什么区别？"><a href="#信号和信号量有什么区别？" class="headerlink" title="信号和信号量有什么区别？"></a>信号和信号量有什么区别？</h2><ul><li><strong>信号</strong>：一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。</li><li><strong>信号量</strong>：进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施，它负责协调各个线程以保证它们能够正确，合理的使用公共资源。</li></ul><br><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h2><p><strong>CPU停下当前的工作任务，去处理其他事情，处理完后回来继续执行刚才的任务</strong>，这一过程便是中断。</p><p>中断分为外部中断和内部中断：</p><ul><li>外部中断分为可屏蔽中断和不可屏蔽中断：<ul><li><strong>可屏蔽中断</strong>：通过INTR线向CPU请求的中断，主要来自外部设备如硬盘，打印机，网卡等。此类中断并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽。</li><li><strong>不可屏蔽中断</strong>：通过NMI线向CPU请求的中断，如电源掉电，硬件线路故障等。这里不可屏蔽的意思不是不可以屏蔽，不建议屏蔽，而是问题太大，屏蔽不了，不能屏蔽的意思。注：INTR和NMI都是CPU的引脚</li></ul></li><li>内部中断分为陷阱、故障、终止：<ul><li><strong>陷阱：是一种有意的，预先安排的异常事件</strong>，一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU将会调用特定程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令。如系统调用，程序调试功能等。如printf函数，最底层的实现中会有一条intOx80指令，这就是一条陷阱指令，使用0x80号中断进行系统调用。</li><li><strong>故障：故障是在引起故障的指令被执行，但还没有执行结束时，CPU检测到的一类的意外事件。</strong>出错时交由故障处理程序处理，如果能处理修正这个错误，就将控制返回到引起故障的指令即CPU重新执这条指令。如果不能处理就报错。常见的故障为缺页，当CPU引用的虚拟地址对应的物理页不存在时就会发生故障。缺页异常是能够修正的，有着专门的缺页处理程序，它会将缺失的物理页从磁盘中重新调进主存。而后再次执行引起故障的指令时便能够顺利执行了。</li><li><strong>终止：执行指令的过程中发生了致命错误，不可修复，程序无法继续运行，只能终止，通常会是一些硬件的错误。</strong>终止处理程序不会将控制返回给原程序，而是直接终止原程序。</li></ul></li></ul><h2 id="讲讲中断的流程"><a href="#讲讲中断的流程" class="headerlink" title="讲讲中断的流程"></a>讲讲中断的流程</h2><p>中断是计算机系统中一种机制，用于在处理器执行指令时暂停当前任务，并转而执行其他任务或处理特定事件。以下是中断的基本流程：</p><ul><li><strong>发生中断</strong>：当外部设备或者软件程序需要处理器的注意或者响应时，会发出中断信号。处理器在接收到中断信号后，会停止当前执行的指令，保存当前执行现场，并跳转到中断处理程序执行。</li><li><strong>中断响应</strong>：处理器接收到中断信号后，会根据中断向量表找到对应的中断处理程序的入口地址。处理器会保存当前执行现场（如程序计数器、寄存器状态等），以便在中断处理完成后能够恢复执行。</li><li><strong>中断处理</strong>：处理器跳转到中断处理程序的入口地址开始执行中断处理程序。中断处理程序会根据中断类型进行相应的处理，可能涉及到保存现场、处理中断事件、执行特定任务等。</li></ul><h2 id="中断的作用是什么？"><a href="#中断的作用是什么？" class="headerlink" title="中断的作用是什么？"></a>中断的作用是什么？</h2><p>中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率，如果没有中断系统，CPU就只能按照原来的程序编写的先后顺序，对各个外设进行查询和处理，即轮询工作方式，轮询方法貌似公平，但实际工作效率却很低，却不能及时响应紧急事件。</p><br><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><h2 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h2><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个<strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</p><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p><p>所以，<strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</strong></p><p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p><p><img src="https://camo.githubusercontent.com/6bec25942bb73a5681c4ebc24ffaf7bc8d4a8a83f5fdce4c382e1528e626d519/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f31332d2545382542462539422545372541382538422545342542382538412545342542382538422545362539362538372545352538382538372545362538442541322e6a7067" alt="进程上下文切换"></p><h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>在前面我们知道了，线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程；</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；</li></ul><p>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><div class="note  flat"><p>线程上下文切换的是什么？</p></div><p>这还得看线程是不是属于同一个进程：</p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li><strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul><p>所以，线程的上下文切换相比进程，开销要小很多。</p><br><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><div class="note  flat success"><p>我知道很多人会问，线程不是操作系统的调度单位吗？为什么这里参与调度的是进程？</p><p>先提前说明，这里的进程指只有主线程的进程，所以调度主线程就等于调度了整个进程。</p><p>那为什么干脆不直接取名线程调度？主要是操作系统相关书籍，都是用进程调度这个名字，所以我也沿用了这个名字。</p></div><h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p><p>比如，以下状态的变化都会触发操作系统的调度：</p><ul><li><em>从就绪态 -&gt; 运行态</em>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li><li><em>从运行态 -&gt; 阻塞态</em>：当进程发生 I&#x2F;O 事件而阻塞时，操作系统必须选择另外一个进程运行；</li><li><em>从运行态 -&gt; 结束态</em>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；</li></ul><p>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</p><p>另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：</p><ul><li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li><li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li></ul><h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><p><img src="https://camo.githubusercontent.com/f334b95a1650b889a12c4f50939569dd4ca63fc4090f575cdfe2efc5a7f42325/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f32332d2545342542412539342545372541372538442545382542302538332545352542412541362545382541372538342545352538382539392e6a7067" alt="五种调度原则"></p><ul><li><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li><strong>周转时间</strong>：周转时间是进程运行 + 阻塞时间 + 等待时间的总和，一个进程的周转时间越小越好；</li><li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ul><p>说白了，这么多调度原则，目的就是要使得进程要「快」。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><p><img src="https://camo.githubusercontent.com/e94cb03a507f1b22563f2046a974e851f111419f82f690c684c86a45716ea0b3/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f32342d2545352538352538382545362539442541352545352538352538382545362539432538442545352538412541312e6a7067" alt="FCFS 调度算法"></p><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><h3 id="最短作业有限（SJF）"><a href="#最短作业有限（SJF）" class="headerlink" title="最短作业有限（SJF）"></a>最短作业有限（SJF）</h3><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p><img src="https://camo.githubusercontent.com/b93644087095f975236748df7e74cd3c337634b238c98cd68e6fc43a027a61b1/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f32352d2545362539432538302545372539462541442545342542442539432545342542382539412545342542432539382545352538352538382545372541452539372545362542332539352e6a7067" alt="SJF 调度算法"></p><p>这显然对长作业不利，很容易造成一种极端现象。</p><p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><h3 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h3><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p><p><img src="https://camo.githubusercontent.com/348ec08ffabc14061451078e378c41706c3d589fad47c855c7f2d9a6e39b4378/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f32372d2545362539372542362545392539372542342545372538392538372545382542442541452545382541462541322e6a7067" alt="RR 调度算法"></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果时间片设得太长又可能引起短作业进程的响应时间变长，不利于短作业。</li></ul><p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><h3 id="最高优先级（HPF）"><a href="#最高优先级（HPF）" class="headerlink" title="最高优先级（HPF）"></a>最高优先级（HPF）</h3><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><h3 id="多级反馈队列（MFQ）"><a href="#多级反馈队列（MFQ）" class="headerlink" title="多级反馈队列（MFQ）"></a>多级反馈队列（MFQ）</h3><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="https://camo.githubusercontent.com/065ca4d7c1a1fd39320c76dbb4f262bb14dd50fc3b502753c868648302abfba8/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f32382d2545352541342539412545372542412541372545392539382539462545352538382539372e6a7067" alt="多级反馈队列"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><br><h1 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h1><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/2019-4sisuo1.png"></p><h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ul><li>互斥条件：当前进程所占有的临界资源，其他进程不可访问。</li><li>请求和保持条件：当前进程占有资源，但又请求其他资源。</li><li>不可被剥夺条件：当前进程结束前，所占有的资源不可被剥夺。</li><li>环路等待条件：进程发生死锁后，必然存在一个进程之间相互等待的环形链。</li></ul><h2 id="破坏死锁的必要条件"><a href="#破坏死锁的必要条件" class="headerlink" title="破坏死锁的必要条件"></a>破坏死锁的必要条件</h2><ul><li>破坏请求和保持条件：一次性申请所有的资源。</li><li>破坏不可被剥夺条件：如果已分配了部分资源，但其他资源未得到满足，释放已占有的资源。</li><li>破坏环路等待条件：资源有序分配，系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反。</li></ul><h2 id="预防死锁——银行家算法"><a href="#预防死锁——银行家算法" class="headerlink" title="预防死锁——银行家算法"></a>预防死锁——银行家算法</h2><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><div class="note  flat info no-icon"><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></div><p><strong>银行家算法是最有代表性的避免死锁的算法</strong>。</p><p>为什么叫银行家算法呢？就是这个算法的逻辑<strong>很像银行放贷的逻辑，也就是尽可能避免坏账的出现</strong>。</p><p>银行家算法的业务逻辑如下：</p><ul><li><strong>不负荷执行</strong>：一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行。</li><li><strong>可分期</strong>：一个进程可以分期请求资源，但总请求书不可超过最大需求量。</li><li><strong>推迟分配</strong>：当系统现有资源数小于进程需求时，对进程的需求可以延迟分配，但总让进程在有限时间内获取资源。</li></ul><p>听起来有点绕，我们还是举个例子来说明。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假如系统中有三类互斥资源 R1、R2、R3，可用资源数分别是9、8、5，在指定时刻有 P1、P2、P3、P4和P5这五个进程，这些进程的对三类互斥资源的最大需求量和已分配资源数如下表所示，那么系统如何先后运行这五个进程，不会发生死锁问题？</p><table><thead><tr><th>进程</th><th><strong>最大需求量（分别为R1 R2 R3）</strong></th><th><strong>已分配资源数（分别为R1 R2 R3）</strong></th></tr></thead><tbody><tr><td>P1</td><td>6 5 2</td><td>1 2 1</td></tr><tr><td>P2</td><td>2 2 1</td><td>2 1 1</td></tr><tr><td>P3</td><td>8 1 1</td><td>2 1 0</td></tr><tr><td>P4</td><td>1 2 1</td><td>1 2 0</td></tr><tr><td>P5</td><td>3 4 4</td><td>1 1 3</td></tr></tbody></table><h4 id="第一步：分析"><a href="#第一步：分析" class="headerlink" title="第一步：分析"></a>第一步：分析</h4><p>首先分析首次需求的资源，<strong>系统剩余可用资源数分别是 2、1、0</strong>，各进程需要的资源数如下表所示。</p><table><thead><tr><th>进程</th><th><strong>最大需求量</strong></th><th><strong>已分配资源数</strong></th><th><strong>需要的资源数</strong></th><th>剩余资源数</th></tr></thead><tbody><tr><td>P1</td><td>6 5 2</td><td>1 2 1</td><td>5 3 1</td><td>2 1 0</td></tr><tr><td>P2</td><td>2 2 1</td><td>2 1 1</td><td><strong>0 1 0</strong></td><td><strong>2 1 0</strong></td></tr><tr><td>P3</td><td>8 1 1</td><td>2 1 0</td><td>6 0 1</td><td>2 1 0</td></tr><tr><td>P4</td><td>1 2 1</td><td>1 2 0</td><td>0 0 1</td><td>2 1 0</td></tr><tr><td>P5</td><td>3 4 4</td><td>1 1 3</td><td>2 3 1</td><td>2 1 0</td></tr></tbody></table><p>根据银行家算法不负荷原则【一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行】，优先给进程P2执行</p><h4 id="第二部：执行P2"><a href="#第二部：执行P2" class="headerlink" title="第二部：执行P2"></a>第二部：执行P2</h4><p>P2 执行之后，释放了刚刚放入的2 1 0资源，而且可以释放已分配的2 1 1资源，所以此时的资源剩余量如下表所示。</p><table><thead><tr><th>进程</th><th><strong>最大需求量</strong></th><th><strong>已分配资源数</strong></th><th><strong>需要的资源数</strong></th><th>剩余资源数</th></tr></thead><tbody><tr><td>P1</td><td>6 5 2</td><td>1 2 1</td><td>5 3 1</td><td>4 2 1</td></tr><tr><td>P2</td><td>2 2 1</td><td></td><td></td><td></td></tr><tr><td>P3</td><td>8 1 1</td><td>2 1 0</td><td>6 0 1</td><td>4 2 1</td></tr><tr><td>P4</td><td>1 2 1</td><td>1 2 0</td><td><strong>0 0 1</strong></td><td><strong>4 2 1</strong></td></tr><tr><td>P5</td><td>3 4 4</td><td>1 1 3</td><td>2 3 1</td><td>4 2 1</td></tr></tbody></table><p>以此类推，安全执行顺序为 <strong>p2 &#x3D;&gt; p4 &#x3D;&gt; p5 &#x3D;&gt; p1 &#x3D;&gt; p3</strong> 或 <strong>p2 &#x3D;&gt; p4 &#x3D;&gt;p5 &#x3D;&gt; p3 &#x3D;&gt;p1</strong>。</p><br><h1 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h1><h2 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p><p><img src="https://camo.githubusercontent.com/62b79f1cdd6dcdb24c8d300cf3ac994520087d04ec8b25ff0dee20e4dd7a97d0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539342538312f2545342542412539322545362539362541352545392539342538312545352542372541352545342542442539432545362542352538312545372541382538422e706e67" alt="img"></p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p><p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p><ul><li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li><li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li></ul><p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ul><li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li><li>第二步，将锁设置为当前线程持有；</li></ul><p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p>自旋锁是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p><p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p><p>读写锁的工作原理是：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p><p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p><p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p><p><img src="https://camo.githubusercontent.com/a648bdf68c31de207ccb4497df5f0cec083f1e5fa90cc3bafcd6b3e64432070f/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539342538312f2545382541462542422545342542432539382545352538352538382545392539342538312545352542372541352545342542442539432545362542352538312545372541382538422e706e67" alt="img"></p><p>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：</p><p><img src="https://camo.githubusercontent.com/5989ae11624e52cafd9590c422e8efe16ac9e4cce9e58577d7b9028ea2ea0daf/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539342538312f2545352538362539392545342542432539382545352538352538382545392539342538312545352542372541352545342542442539432545362542352538312545372541382538422e706e67" alt="img"></p><p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><h2 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h2><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>理论上来说：</p><ul><li>悲观锁通常多用于<strong>写比较多</strong>的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话，也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于<strong>写比较少</strong>的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li></ul><h2 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h2><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】Cookie/Session/Token/JWT</title>
      <link href="/p/b27c77b3/"/>
      <url>/p/b27c77b3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h2><ul><li>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li>cookie 存储在客户端：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li>cookie 是不可跨域的：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</li></ul><p>cookie 重要的属性：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/pmur6hy3nphhs_f3cd85d2706d488a92956d17f49e9b8a.png"></p><h2 id="携带Cookie的HTTP请求是有状态还是无状态的？Cookie是HTTP协议簇的一部分，那为什么还说HTTP是无状态的"><a href="#携带Cookie的HTTP请求是有状态还是无状态的？Cookie是HTTP协议簇的一部分，那为什么还说HTTP是无状态的" class="headerlink" title="携带Cookie的HTTP请求是有状态还是无状态的？Cookie是HTTP协议簇的一部分，那为什么还说HTTP是无状态的?"></a>携带Cookie的HTTP请求是有状态还是无状态的？Cookie是HTTP协议簇的一部分，那为什么还说HTTP是无状态的?</h2><p>HTTP被描述为“无状态”的主要原因是每个HTTP请求都是独立的，服务器并不保存关于客户端的状态信息，每个请求都需要提供足够的信息来理解请求的意图。</p><p>虽然Cookie是HTTP协议簇的一部分，但是HTTP协议在设计初衷上仍然保持无状态特性，即每个请求都是相互独立的。使用Cookie只是在无状态协议下的一种补充机制，用于在客户端存储状态信息以实现状态保持。</p><p>可以说即使HTTP本身是无状态的协议，但通过Cookie的使用可以实现一定程度的状态保持功能。</p><h2 id="什么是-Session？"><a href="#什么是-Session？" class="headerlink" title="什么是 Session？"></a>什么是 Session？</h2><ul><li>session 是另一种记录服务器和客户端会话状态的机制</li><li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</li></ul><p><strong>session 认证流程：</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><h2 id="Cookie、Session、Token-之间有什么区别？"><a href="#Cookie、Session、Token-之间有什么区别？" class="headerlink" title="Cookie、Session、Token 之间有什么区别？"></a>Cookie、Session、Token 之间有什么区别？</h2><p>Cookie 存储在浏览器（客户端），生命周期可以由服务器端设置。</p><p>Session 存储在服务器，生命周期由服务器端控制（在默认情况下，当用户关闭浏览器时，Session结束）。</p><p>**性能:**使用Cookie时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在Cookie数据较大时。使用Session时，因为数据存储在服务器端，每次请求都需要查询服务器上的Session数据，这可能会增加服务器的负载，特别是在高并发场景下。</p><p>Token（如JWT）存储在客户端，是一个加密的令牌，可以跨多个会话使用。</p><p>简单来说，Cookie 和 Session 更适合用于单次会话的认证和状态管理，而 Token 更适合用于跨会话的认证和状态管理。</p><h2 id="如果我把数据存储到-LocalStorage，和Cookie有什么区别？"><a href="#如果我把数据存储到-LocalStorage，和Cookie有什么区别？" class="headerlink" title="如果我把数据存储到 LocalStorage，和Cookie有什么区别？"></a>如果我把数据存储到 LocalStorage，和Cookie有什么区别？</h2><ul><li><strong>存储容量</strong>：Cookie 的存储容量通常较小，每个 Cookie 的大小限制在几 KB 左右。而 Localstorage 的存储容量通常较大，一般限制在几 MB 左右。因此，如果需要存储大量数据，LocalStorage 通常更适合;</li><li><strong>数据发送</strong>：Cookie 在每次 HTTP 请求中都会自动发送到服务器，这使得 Cookie 适合用于在客户端和服务器之间传递数据。而 Localstorage 的数据不会自动发送到服务器，它仅在浏览器端存储数据，因此LocalStorage 适合用于在同一域名下的不同页面之间共享数据;</li><li><strong>生命周期</strong>：Cookie 可以设置一个过期时间,使得数据在指定时间后自动过期。而 LocalStorage 的数据将永久存储在浏览器中，除非通过 JavaScript 代码手动删除;</li><li><strong>安全性</strong>：Cookie 的安全性较低，因为 Cookie 在每次 HTTP 请求中都会自动发送到服务器，存在被窃取或篡改的风险。而 LocalStorage 的数据仅在浏览器端存储，不会自动发送到服务器，相对而言更安全一些;</li></ul><h2 id="什么是-Token？"><a href="#什么是-Token？" class="headerlink" title="什么是 Token？"></a>什么是 Token？</h2><p>作为计算机术语时，Token 是“令牌”的意思。Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/pmur6hy3nphhs_497bd3c338ab459ca936c4155b041155.png"></p><h3 id="简单-token-的组成"><a href="#简单-token-的组成" class="headerlink" title="简单 token 的组成"></a>简单 token 的组成</h3><p>uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p><h3 id="🌱-token的使用小结："><a href="#🌱-token的使用小结：" class="headerlink" title="🌱 token的使用小结："></a><strong>🌱 token的使用小结：</strong></h3><p>◾ 前端登陆的时候向服务器发送请求，服务器验证成功，会生成一个token</p><p>◾ 前端会存储这个token，放在session或cookie中，用于之后的业务请求身份验证</p><p>◾ 拿着这个token，可以在当前登录的账号下进行请求业务，发送请求时，token会放在请求头里，服务器收到这个业务请求，验证token，成功就允许这个请求获取数据</p><p>◾ token可以设置失效期</p><h3 id="Token-设置"><a href="#Token-设置" class="headerlink" title="Token 设置"></a>Token 设置</h3><p>利用 token 机制进行登录认证，可以有以下方式：</p><ol><li>用设备 mac 地址作为 token</li><li>用 sessionid 作为 token</li></ol><h3 id="Token-的存储"><a href="#Token-的存储" class="headerlink" title="Token 的存储"></a>Token 的存储</h3><p>token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失（其实token丢失了再重新认证一个就好，但是别丢太频繁，别让用户没事儿就去认证）。</p><p>为了避免查询时间过长，可以将token放到内存中。这样查询速度绝对就不是问题了，也不用太担心占据内存，就算token是一个32位的字符串，应用的用户量在百万级或者千万级，也是占不了多少内存的。</p><h3 id="Token-的加密"><a href="#Token-的加密" class="headerlink" title="Token 的加密"></a>Token 的加密</h3><p>token是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登录。加密的方式一般有：</p><p>在存储的时候把token进行对称加密存储，用到的时候再解密。</p><p>文章最开始提到的签名sign：将请求URL、时间戳、token三者合并，通过算法进行加密处理。</p><p>最好是两种方式结合使用。</p><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/pmur6hy3nphhs_a0f8c2eb2add476f951d6c31b4265f9c.png"></p><p>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</p><h2 id="什么是-JWT？"><a href="#什么是-JWT？" class="headerlink" title="什么是 JWT？"></a>什么是 JWT？</h2><p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p><p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p><p>可以看出，<strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则</strong> 。</p><p>并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。</p><p>JWT 可以使用 HMAC 算法或者是 RSA 的公&#x2F;私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p><p>我在 <a href="https://javaguide.cn/system-design/security/advantages-and-disadvantages-of-jwt.html">JWT 身份认证优缺点分析 | JavaGuide</a> 这篇文章中有详细介绍到使用 JWT 做身份认证的优势和劣势。（这篇文章下面也搬运了~）</p><h2 id="Token-和-JWT-的区别是什么？"><a href="#Token-和-JWT-的区别是什么？" class="headerlink" title="Token 和 JWT 的区别是什么？"></a>Token 和 JWT 的区别是什么？</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>不同：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h2 id="JWT-令牌都有哪些字段？"><a href="#JWT-令牌都有哪些字段？" class="headerlink" title="JWT 令牌都有哪些字段？"></a>JWT 令牌都有哪些字段？</h2><p>JWT令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为JSON格式，使用Base64编码进行序列化，而签名部分是对头部、载荷和密钥进行签名后的结果。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231451188.png" alt="JWT结构"></p><p>JWT 本质上就是一组字串，通过（<code>.</code>）切分成三个为 Base64 编码的部分：</p><ul><li><strong>Header（头部）</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。Header 被 Base64Url 编码后成为 JWT 的第一部分。</li><li><strong>Payload（载荷）</strong> : 用来存放实际需要传递的数据，包含声明（Claims），如<code>sub</code>（subject，主题）、<code>jti</code>（JWT ID）。Payload 被 Base64Url 编码后成为 JWT 的第二部分。</li><li><strong>Signature（签名）</strong>：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。生成的签名会成为 JWT 的第三部分。</li></ul><p>JWT 通常是这样的：<code>xxxxx.yyyyy.zzzzz</code>。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 通常由两部分组成：</p><ul><li><code>typ</code>（Type）：令牌类型，也就是 JWT。</li><li><code>alg</code>（Algorithm）：签名算法，比如 HS256。</li></ul><p>JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。</p><p>Claims 分为三种类型：</p><ul><li><strong>Registered Claims（注册声明）</strong>：预定义的一些声明，建议使用，但不是强制性的。</li><li><strong>Public Claims（公有声明）</strong>：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 <a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry</a> 中定义它们。</li><li><strong>Private Claims（私有声明）</strong>：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。</li></ul><p>下面是一些常见的注册声明：</p><ul><li><code>iss</code>（issuer）：JWT 签发方。</li><li><code>iat</code>（issued at time）：JWT 签发时间。</li><li><code>sub</code>（subject）：JWT 主题。</li><li><code>aud</code>（audience）：JWT 接收方。</li><li><code>exp</code>（expiration time）：JWT 的过期时间。</li><li><code>nbf</code>（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。</li><li><code>jti</code>（JWT ID）：JWT 唯一标识。</li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ff1212f5-d8d1-4496-bf41-d2dda73de19a&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">15323232</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;user&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Payload 部分默认是不加密的，<strong>一定不要将隐私信息存放在 Payload 当中！！！</strong></p><p>JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。</p><p>这个签名的生成需要用到：</p><ul><li>Header + Payload。</li><li>存放在服务端的密钥(一定不要泄露出去)。</li><li>签名算法。</li></ul><p>签名的计算公式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，这个字符串就是 JWT 。</p><h2 id="JWT-令牌为什么能解决集群部署，什么是集群部署？"><a href="#JWT-令牌为什么能解决集群部署，什么是集群部署？" class="headerlink" title="JWT 令牌为什么能解决集群部署，什么是集群部署？"></a>JWT 令牌为什么能解决集群部署，什么是集群部署？</h2><p>JWT令牌通过在令牌中包含所有必要的身份验证和会话信息，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。当用户进行登录认证后，服务器将生成一个JWT令牌并返回给客户端。客户端在后续的请求中携带该令牌，服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息，而无需访问共享的会话存储。<br>由于JWT令牌是自包含的，服务器可以独立地对令牌进行验证，而不需要依赖其他服务器或共享存储。这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和容错性。</p><h2 id="JWT-的优点是什么？"><a href="#JWT-的优点是什么？" class="headerlink" title="JWT 的优点是什么？"></a>JWT 的优点是什么？</h2><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p><p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：<strong>不可控！</strong></p><p>就比如说，我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。再比如说，当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。具体的解决办法，我们会在后面的内容中详细介绍到，这里只是简单提一下。</p><h3 id="有效避免-CSRF-攻击"><a href="#有效避免-CSRF-攻击" class="headerlink" title="有效避免 CSRF 攻击"></a>有效避免 CSRF 攻击</h3><p><strong>CSRF（Cross Site Request Forgery）</strong> 一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等安全攻击方式，CSRF 的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。就连业内技术标杆 Google 的产品 Gmail 也曾在 2007 年的时候爆出过 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p><p>CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 <code>SessionID</code> 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 <code>SessionID</code>，只要让你误点攻击链接，就可以达到攻击效果。</p><p>另外，并不是必须点击链接才可以达到攻击效果，很多时候，只要你打开了某个页面，CSRF 攻击就会发生。</p><p><strong>那为什么 JWT 不会存在这种问题呢？</strong></p><p>一般情况下我们使用 JWT 的话，在我们登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。因此，即使你点击了非法链接发送了请求到服务端，这个非法请求也是不会携带 JWT 的，所以这个请求将是非法的。</p><p>总结来说就一句话：<strong>使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击。</strong></p><p>不过，这样也会存在 XSS 攻击的风险。为了避免 XSS 攻击，你可以选择将 JWT 存储在标记为<code>httpOnly</code> 的 Cookie 中。但是，这样又导致了你必须自己提供 CSRF 保护，因此，实际项目中我们通常也不会这么做。</p><p>常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串。</p><p>在 Spring 项目中，我们一般是通过创建 XSS 过滤器来实现的。</p><h3 id="适合移动端应用"><a href="#适合移动端应用" class="headerlink" title="适合移动端应用"></a>适合移动端应用</h3><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 <code>SessionId</code>），所以不适合移动端。</p><p>但是，使用 JWT 进行身份认证就不会存在这种问题，因为只要 JWT 可以被客户端存储就能够使用，而且 JWT 还可以跨语言使用。</p><div class="note  flat info"><p>为什么使用 Session 进行身份认证的话不适合移动端 ？</p></div><ol><li>状态管理: Session 基于服务器端的状态管理，而移动端应用通常是无状态的。移动设备的连接可能不稳定或中断，因此难以维护长期的会话状态。如果使用 Session 进行身份认证，移动应用需要频繁地与服务器进行会话维护，增加了网络开销和复杂性;</li><li>兼容性: 移动端应用通常会面向多个平台，如 iOS、Android 和 Web。每个平台对于 Session 的管理和存储方式可能不同，可能导致跨平台兼容性的问题;</li><li>安全性: 移动设备通常处于不受信任的网络环境，存在数据泄露和攻击的风险。将敏感的会话信息存储在移动设备上增加了被攻击的潜在风险。</li></ol><h3 id="单点登录友好"><a href="#单点登录友好" class="headerlink" title="单点登录友好"></a>单点登录友好</h3><p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。</p><h2 id="JWT-的缺点是什么？"><a href="#JWT-的缺点是什么？" class="headerlink" title="JWT 的缺点是什么？"></a>JWT 的缺点是什么？</h2><h3 id="注销登录等场景下-JWT-还有效"><a href="#注销登录等场景下-JWT-还有效" class="headerlink" title="注销登录等场景下 JWT 还有效"></a>注销登录等场景下 JWT 还有效</h3><p>JWT一旦派发出去，在失效之前都是有效的，没办法即使撤销JWT。</p><p>与之类似的具体相关场景有：</p><ul><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被封禁&#x2F;删除；</li><li>用户被服务端强制注销；</li><li>用户被踢下线；</li><li>……</li></ul><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 JWT 认证的方式就不好解决了。我们也说过了，JWT 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p><p>那我们如何解决这个问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p><p><strong>1、将 JWT 存入数据库</strong></p><p>将有效的 JWT 存入数据库中，更建议使用内存数据库比如 Redis。如果需要让某个 JWT 失效就直接从 Redis 中删除这个 JWT 即可。但是，这样会导致每次使用 JWT 都要先从 Redis 中查询 JWT 是否存在的步骤，而且违背了 JWT 的无状态原则。</p><p><strong>2、黑名单机制</strong></p><p>和上面的方式类似，使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p><p>前两种方案的核心在于将有效的 JWT 存储起来或者将指定的 JWT 拉入黑名单。</p><p>虽然这两种方案都违背了 JWT 的无状态原则，但是一般实际项目中我们通常还是会使用这两种方案。</p><p><strong>3、修改密钥 (Secret)</strong> :</p><p>我们为每个用户都创建一个专属密钥，如果我们想让某个 JWT 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大：</p><ul><li>如果服务是分布式的，则每次发出新的 JWT 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</li><li>如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li></ul><p><strong>4、保持令牌的有效期限短并经常轮换</strong></p><p>很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p><p>另外，对于修改密码后 JWT 还有效问题的解决还是比较容易的。说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 JWT 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p><h3 id="JWT-的续签问题"><a href="#JWT-的续签问题" class="headerlink" title="JWT 的续签问题"></a>JWT 的续签问题</h3><p>JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？</p><p>我们先来看看在 Session 认证中一般的做法：<strong>假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。</strong></p><p>JWT 认证的话，我们应该如何解决续签问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p><p><strong>1、类似于 Session 认证中的做法（不推荐）</strong></p><p>这种方案满足于大部分场景。假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ，对客户端不是很友好。</p><p><strong>2、每次请求都返回新 JWT（不推荐）</strong></p><p>这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</p><p><strong>3、JWT 有效期设置到半夜（不推荐）</strong></p><p>这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p><p><strong>4、用户登录返回两个 JWT（推荐）</strong></p><p>第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。refreshJWT 只用来获取 accessJWT，不容易被泄露。</p><p>客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p><p>这种方案的不足是：</p><ul><li>需要客户端来配合；</li><li>用户注销的时候需要同时保证两个 JWT 都无效；</li><li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li><li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。不过，由于 refreshJWT 只用来获取 accessJWT，不容易被泄露。</li></ul><h3 id="JWT-体积太大"><a href="#JWT-体积太大" class="headerlink" title="JWT 体积太大"></a>JWT 体积太大</h3><p>JWT 结构复杂（Header、Payload 和 Signature），包含了更多额外的信息，还需要进行 Base64Url 编码，这会使得 JWT 体积较大，增加了网络传输的开销。</p><p>解决办法：</p><ul><li>尽量减少 JWT Payload（载荷）中的信息，只保留必要的用户和权限信息。</li><li>在传输 JWT 之前，使用压缩算法（如 GZIP）对 JWT 进行压缩以减少体积。</li><li>在某些情况下，使用传统的 Token 可能更合适。传统的 Token 通常只是一个唯一标识符，对应的信息（例如用户 ID、Token 过期时间、权限信息）存储在服务端，通常会通过 Redis 保存。</li></ul><h2 id="JWT-令牌如果泄露了，怎么解决，JWT是怎么做的？"><a href="#JWT-令牌如果泄露了，怎么解决，JWT是怎么做的？" class="headerlink" title="JWT 令牌如果泄露了，怎么解决，JWT是怎么做的？"></a>JWT 令牌如果泄露了，怎么解决，JWT是怎么做的？</h2><ul><li><strong>及时失效令牌</strong>：当检测到JWT令牌泄露或存在风险时，可以立即将令牌标记为失效状态。服务器在接收到带有失效标记的令牌时，会拒绝对其进行任何操作，从而保护用户的身份和数据安全。</li><li><strong>刷新令牌</strong>：JWT令牌通常具有一定的有效期，过期后需要重新获取新的令牌。当检测到令牌泄露时，可以主动刷新令牌，即重新生成一个新的令牌，并将旧令牌标记为失效状态。这样，即使泄露的令牌被恶意使用，也会很快失效，减少了被攻击者滥用的风险。</li><li><strong>使用黑名单</strong>：服务器可以维护一个令牌的黑名单，将泄露的令牌添加到黑名单中。在接收到令牌时，先检查令牌是否在黑名单中，如果在则拒绝操作。这种方法需要服务器维护黑名单的状态，对性能有一定的影响，但可以有效地保护泄露的令牌不被滥用。</li></ul><h2 id="前端如何存储JWT？"><a href="#前端如何存储JWT？" class="headerlink" title="前端如何存储JWT？"></a>前端如何存储JWT？</h2><h3 id="Local-Storage（本地存储）"><a href="#Local-Storage（本地存储）" class="headerlink" title="Local Storage（本地存储）"></a>Local Storage（本地存储）</h3><ul><li><strong>优点</strong>：Local Storage 提供了较大的存储空间（一般为5MB），且不会随着HTTP请求一起发送到服务器，因此不会出现在HTTP缓存或日志中。</li><li><strong>缺点</strong>：存在<strong>XSS（跨站脚本攻击）</strong>的风险，恶意脚本可以通过JavaScript访问到存储在Local Storage中的JWT，从而盗取用户凭证。</li></ul><h3 id="Session-Storage（会话存储）"><a href="#Session-Storage（会话存储）" class="headerlink" title="Session Storage（会话存储）"></a>Session Storage（会话存储）</h3><ul><li><strong>优点</strong>：与Local Storage类似，但仅限于当前浏览器窗口或标签页，当窗口关闭后数据会被清除，这在一定程度上减少了数据泄露的风险。</li><li><strong>缺点</strong>：用户体验可能受影响，因为刷新页面或在新标签页打开相同应用时需要重新认证。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li><strong>优点</strong>：可以设置HttpOnly标志来防止通过JavaScript访问，减少XSS攻击的风险；可以利用Secure标志确保仅通过HTTPS发送，增加安全性。</li><li><strong>缺点</strong>：大小限制较小（通常4KB），并且每次HTTP请求都会携带Cookie，可能影响性能；设置不当可能会受到<strong>CSRF（跨站请求伪造）</strong>攻击。</li></ul><h2 id="使用常见问题"><a href="#使用常见问题" class="headerlink" title="使用常见问题"></a>使用常见问题</h2><h3 id="使用-cookie-时需要考虑的问题"><a href="#使用-cookie-时需要考虑的问题" class="headerlink" title="使用 cookie 时需要考虑的问题"></a>使用 cookie 时需要考虑的问题</h3><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li>cookie 无法跨域</li><li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h3 id="使用-session-时需要考虑的问题"><a href="#使用-session-时需要考虑的问题" class="headerlink" title="使用 session 时需要考虑的问题"></a>使用 session 时需要考虑的问题</h3><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h3 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h3><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h3 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h3><p>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p><ul><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://javaguide.cn/system-design/security/jwt-intro.html">JWT 基础概念详解 | JavaGuide</a></p><p><a href="https://blog.csdn.net/sunyctf/article/details/126509232">什么是token？token是用来干嘛的？_token是什么意思-CSDN博客</a></p><p><a href="https://developer.aliyun.com/article/1358589">还分不清 Cookie、Session、Token、JWT？看这一篇就够了-阿里云开发者社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】网络I/O</title>
      <link href="/p/7a3264f/"/>
      <url>/p/7a3264f/</url>
      
        <content type="html"><![CDATA[<p>网络 I&#x2F;O 指的是网卡与内存之间的输入输出。</p><p>当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。</p><br><h1 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h1><p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I&#x2F;O、异步 I&#x2F;O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。</p><h2 id="为什么要有-DMA-技术？"><a href="#为什么要有-DMA-技术？" class="headerlink" title="为什么要有 DMA 技术？"></a>为什么要有 DMA 技术？</h2><p>在没有 DMA 技术前，I&#x2F;O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p><p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术：<strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I&#x2F;O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I&#x2F;O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到，整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><p>早期 DMA 只存在在主板上，如今由于 I&#x2F;O 设备越来越多，数据传输的需求也不尽相同，所以每个 I&#x2F;O 设备里面都有自己的 DMA 控制器。</p><h2 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h2><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="https://camo.githubusercontent.com/c7ffeaac66ae49eb6f9fb14de5956a8879b3c21efb7cee79963092613b34f719/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f2545342542432541302545372542422539462545362539362538372545342542422542362545342542432541302545382542452539332e706e67" alt="img"></p><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换的成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h2 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h2><div class="note  flat info"><p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p></div><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p><div class="note  flat info"><p>再来看看，如何减少「数据拷贝」的次数？</p></div><p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以<strong>不用搬运到用户空间</strong>，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><h2 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h2><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li>mmap + write</li><li>sendfile</li></ul><p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://camo.githubusercontent.com/05b885a91872c387a0a8d959940a4d004a21c196bbff36ef9f2649f1078ff151/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f6d6d61702532302b25323077726974652532302545392539422542362545362538422542372545382542342539442e706e67" alt="img"></p><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>，可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="https://camo.githubusercontent.com/b9a95f41c9463cbbdecd67ed20b8b491e13ee3c20d853a86e8bf1ec9e64c07d7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f73656e66696c652d332545362541432541312545362538422542372545382542342539442e706e67" alt="img"></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持 SG-DMA 技术的网卡， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区<strong>描述符和数据长度</strong>传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="https://camo.githubusercontent.com/44f34500205fc055d0c2c5d8cf268255b939f273c04184f9c39c3e8df3f706c4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f73656e66696c652d2545392539422542362545362538422542372545382542342539442e706e67" alt="img"></p><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h3 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h3><p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I&#x2F;O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p><p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(FileChannel fileChannel, <span class="type">long</span> position, <span class="type">long</span> count)</span> <span class="keyword">throws</span> IOException &#123; </span><br><span class="line">    <span class="keyword">return</span> fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Linux 系统支持 <code>sendfile()</code> 系统调用，那么 <code>transferTo()</code> 实际上最后就会使用到 <code>sendfile()</code> 系统调用函数。</p><p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">    sendfile on</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h2><p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（<em>PageCache</em>）</strong>。</p><p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p><p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写<strong>内存</strong>」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p><p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p><p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p><p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p><p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p><p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p><p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p><p>所以，PageCache 的优点主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p>这两个做法，将大大提高读写磁盘的性能。</p><p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p><p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p><p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p><ul><li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li><li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li></ul><p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p><h2 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h2><p>可以用异步 I&#x2F;O 来解决，它工作方式如下图：</p><p><img src="https://camo.githubusercontent.com/434438fae3b7c4355f3cd01c210757a4d205c676bd489896f036d08b9aaca319/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f254535254243253832254536254144254135253230494f2532302545372539412538342545382542462538372545372541382538422e706e67" alt="img"></p><p>它把读操作分为两部分：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><p>而且，我们可以发现，异步 I&#x2F;O 并没有涉及到 PageCache，所以使用异步 I&#x2F;O 就意味着要绕开 PageCache。</p><p>绕开 PageCache 的 I&#x2F;O 叫直接 I&#x2F;O，使用 PageCache 的 I&#x2F;O 则叫缓存 I&#x2F;O。通常，对于磁盘，异步 I&#x2F;O 只支持直接 I&#x2F;O。</p><p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p><p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p><p>直接 I&#x2F;O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I&#x2F;O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I&#x2F;O。</li></ul><p>另外，由于直接 I&#x2F;O 绕过了 PageCache，就无法享受内核的这两点的优化：</p><ul><li>内核的 I&#x2F;O 调度算法会缓存尽可能多的 I&#x2F;O 请求在 PageCache 中，最后「<strong>合并</strong>」成一个更大的 I&#x2F;O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li><li>内核也会「<strong>预读</strong>」后续的 I&#x2F;O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li></ul><p>于是，传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」了，就可以无阻塞地读取文件了。</p><p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p><ul><li>传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」；</li><li>传输小文件的时候，则使用「零拷贝技术」；</li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /video/ &#123; </span><br><span class="line">    sendfile on; </span><br><span class="line">    aio on; </span><br><span class="line">    directio 1024m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当文件大小大于 <code>directio</code> 值后，使用「异步 I&#x2F;O + 直接 I&#x2F;O」，否则使用「零拷贝技术」。</p><br><h1 id="I-O-多路复用：select-poll-epoll"><a href="#I-O-多路复用：select-poll-epoll" class="headerlink" title="I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h1><h2 id="最基本的-Socket-模型"><a href="#最基本的-Socket-模型" class="headerlink" title="最基本的 Socket 模型"></a>最基本的 Socket 模型</h2><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p><p>Socket 的中文名叫作插口，乍一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p><p>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作<strong>监听 Socket</strong>；</li><li>一个叫作<strong>已连接 Socket</strong>；</li></ul><p><img src="https://camo.githubusercontent.com/31a966ea9c1c2e07ec292b7570ea0eed0de8bec4242f7f6cabe084bb56e87515/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f7463705f736f636b65742e706e67" alt="img"></p><h2 id="如何服务更多的用户？"><a href="#如何服务更多的用户？" class="headerlink" title="如何服务更多的用户？"></a>如何服务更多的用户？</h2><p>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I&#x2F;O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I&#x2F;O 模型，以支持更多的客户端。</p><p>在改进网络 I&#x2F;O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？</p><p>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机 IP, 本机端口，对端 IP, 对端端口</strong>。</p><p>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<strong>最大 TCP 连接数 &#x3D; 客户端 IP 数 × 客户端端口数</strong>。</p><p>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</p><p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p><p>并发 1 万请求，也就是经典的 C10K 问题，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</p><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p><p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I&#x2F;O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p><h2 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h2><p>基于最原始的阻塞网络 I&#x2F;O，如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，<code>accept()</code> 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket」和客户端通信了，</p><p><img src="https://camo.githubusercontent.com/416f566cccc92bb579706f05a034a546b1531d9417499c6ec3b550087d125395/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f2545352541342539412545382542462539422545372541382538422e706e67" alt="img"></p><p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上下文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。</p><p>那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出已连接 Socket 进程处理。</p><p><img src="https://camo.githubusercontent.com/f6dddc8eeb3801fc3200327c8351477c8ad24587839b0f2eaee7ab5b609f20ef/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f2545372542412542462545372541382538422545362542312541302e706e67" alt="img"></p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程&#x2F;线程，操作系统就算死扛也是扛不住的。</p><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>既然为每个请求分配一个进程&#x2F;线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I&#x2F;O 多路复用</strong> 技术。</p><p><img src="https://camo.githubusercontent.com/8deb554d2227ba70793c1c6be722a07082a17537f5f03e281fbafec55623a9fb/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f2545352541342539412545382542372541462545352541342538442545372539342541382e706e67" alt="img"></p><p>一个进程虽然任意时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select&#x2F;poll&#x2F;epoll 是内核提供给用户态的多路复用系统调用，主要用于同时监视多个文件描述符的状态变化，包括可读、可写和异常事件。通过这些机制，可以在单个线程中同时处理多个 I&#x2F;O 操作，提高系统的性能和效率。</p><p>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p><p>select&#x2F;poll&#x2F;epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 <code>select()</code> 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合（使用了一个 <code>fd_set</code> 集合来保存需要监视的文件描述符，并提供了三个不同的集合来分别表示可读、可写和异常事件。）的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一次是在用户态里，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制，默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以<strong>链表</strong>形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题。</p><p><em>第一点</em>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述符</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 <code>O(logn)</code>，通过对这棵红黑树进行操作，这样就不需要像 select&#x2F;poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p><em>第二点</em>，epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p>从下图你可以看到 epoll 相关的接口作用：</p><p><img src="https://camo.githubusercontent.com/627a09ab8929f2931927437c73c739d63222cc41e946f8a0f69dcec01ec55143/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f65706f6c6c2e706e67" alt="img"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（<em>edge-triggered，ET</em>）和水平触发（<em>level-triggered，LT</em>）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证<strong>一次性</strong>将内核缓冲区的数据<strong>读取完</strong>；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 <code>epoll_wait</code> 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select&#x2F;poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><br><h1 id="I-O-模型总结"><a href="#I-O-模型总结" class="headerlink" title="I&#x2F;O 模型总结"></a>I&#x2F;O 模型总结</h1><h2 id="同步阻塞I-O"><a href="#同步阻塞I-O" class="headerlink" title="同步阻塞I&#x2F;O"></a>同步阻塞I&#x2F;O</h2><p>当用户程序的线程调用 read 获取网络数据的时候，首先这个数据得有，也就是网卡得先收到客户端的数据，然后这个数据有了之后需要拷贝到内核中，然后再被拷贝到用户空间内，这<strong>整一个过程用户线程都是被阻塞</strong>的。</p><p>假设没有客户端发数据过来，那么这个用户线程就会一直阻塞等着，直到有数据。即使有数据，那么两次拷贝的过程也得阻塞等着。</p><h2 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I&#x2F;O"></a>同步非阻塞I&#x2F;O</h2><p>在没数据的时候可以不再傻傻地阻塞等着，而是直接返回错误，告知暂无准备就绪的数据！</p><p>这里要注意，<strong>从内核拷贝到用户空间这一步，用户线程还是会被阻塞的</strong>。</p><p>这个模型相比于同步阻塞 I&#x2F;O 而言比较灵活，比如调用 read 如果暂无数据，则线程可以先去干干别的事情，然后再来<strong>继续调用 read</strong> 看看有没有数据。</p><p>但是如果你的线程就是取数据然后处理数据，不干别的逻辑，那这个模型又有点问题了。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><p><strong>只用一个线程查看多个连接是否有数据已准备就绪</strong>，比如我们可以往 select 注册需要被监听的连接，由 select 来监控它所管理的连接是否有数据已就绪，如果有则可以<strong>通知别的线程来 read 读取数据</strong>，<strong>这个 read 和之前的一样，还是会阻塞用户线程</strong>。</p><p>这样一来就可以<strong>用少量的线程去监控多条连接</strong>，减少了线程的数量，降低了内存的消耗且减少了上下文切换的次数，很舒服。</p><p>想必到此你已经理解了什么叫 I&#x2F;O 多路复用。</p><p>所谓的多路指的是多条连接，复用指的是用一个线程就可以监控这么多条连接。</p><h2 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I&#x2F;O"></a>信号驱动式I&#x2F;O</h2><p>上面的 select 虽然不阻塞了，但是他得时刻去查询看看是否有数据已经准备就绪，那是不是可以让内核告诉我们数据到了而不是我们去轮询呢？</p><p>信号驱动 I&#x2F;O 就能实现这个功能，由<strong>内核告知</strong>数据已准备就绪，然后用户线程再去 read（还是会阻塞）。</p><p>听起来是不是比 I&#x2F;O 多路复用好呀？那为什么好像很少听到信号驱动 I&#x2F;O？</p><p>因为我们的应用通常用的都是 TCP 协议，而 <strong>TCP 协议的 socket 可以产生信号事件有七种</strong>。</p><p>也就是说不仅仅只有数据准备就绪才会发信号，其他事件也会发信号，而这个信号又是同一个信号，所以我们的应用程序无从区分到底是什么事件产生的这个信号。</p><h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h2><p>其实思路很清晰：让内核直接把数据拷贝到用户空间之后再告知用户线程，来实现真正的非阻塞I&#x2F;O！</p><p>所以异步 I&#x2F;O 其实就是用户线程调用 <code>aio_read</code> ，然后包括将数据从内核拷贝到用户空间那步，所有操作都由内核完成，当内核操作完毕之后，再调用之前设置的回调，此时用户线程就拿着已经拷贝到用户控件的数据可以继续执行后续操作。</p><p>在整个过程中，用户线程没有任何阻塞点，<strong>这才是真正的非阻塞I&#x2F;O</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240809115338.png"></p><br><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF">9.1 什么是零拷贝？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">9.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> I/O多路复用 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程崩溃了，进程也会崩溃吗？</title>
      <link href="/p/7beadfaa/"/>
      <url>/p/7beadfaa/</url>
      
        <content type="html"><![CDATA[<div class="note  simple"><p>摘自：<a href="https://xiaolincoding.com/os/4_process/thread_crash.html#%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83-%E8%BF%9B%E7%A8%8B%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97">5.7 线程崩溃了，进程也会崩溃吗？ | 小林coding (xiaolincoding.com)</a></p></div><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，为什么系统要让进程崩溃呢，这主要是因为在进程中，<strong>各个线程的地址空间是共享的</strong>，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃</p><p><img src="https://camo.githubusercontent.com/0794ebfc2ba55a60eb3e5aded090ab9dea4773f00161b1a25adb4ac0cdd2a8b3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31376265393466333432656134653439613232376231393538343538383066642e706e67" alt="img"></p><h2 id="进程是如何崩溃的"><a href="#进程是如何崩溃的" class="headerlink" title="进程是如何崩溃的"></a>进程是如何崩溃的</h2><p>那么线程崩溃后，进程是如何崩溃的呢，这背后的机制到底是怎样的，答案是<strong>信号</strong>。</p><p>大家想想要干掉一个正在运行的进程是不是经常用 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中的 9 就是信号。</p><p>其实信号有很多类型的，在 Linux 中可以通过 <code>kill -l</code>查看所有可用的信号：</p><p><img src="https://camo.githubusercontent.com/843aba4f4ab0063e1280e1891bc2600ca8fbb4cd6286614533e6a3a61eb74763/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f65626134646365356535393434326238623262323464396531373162616230642e706e67" alt="img"></p><p>当然了发 kill 信号必须具有一定的权限，否则任意进程都可以通过发信号来终止其他进程，那显然是不合理的，实际上 kill 执行的是系统调用，将控制权转移给了内核（操作系统），由内核来给指定的进程发送信号。</p><p>那么发个信号进程怎么就崩溃了呢，这背后的原理到底是怎样的？</p><p>其背后的机制如下：</p><ol><li>CPU 执行正常的进程指令</li><li>调用 kill 系统调用向进程发送信号</li><li>进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统</li><li>调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）</li><li><strong>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出</strong></li></ol><p>注意上面的第五步，如果进程<strong>没有注册自己的信号处理函数</strong>，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数，这样的话就给了进程一个垂死挣扎的机会，它收到 kill 信号后，可以调用 exit() 来退出，<strong>但也可以使用 sigsetjmp，siglongjmp 这两个函数来恢复进程的执行</strong></p><p>说到这大家是否想起了一道经典面试题：<strong>如何让正在运行的 Java 工程的优雅停机？</strong></p><p>通过上面的介绍大家不难发现，其实是 JVM 自己定义了信号处理函数，这样当发送 kill pid 命令（默认会传 15 也就是 SIGTERM）后，JVM 就可以在信号处理函数中执行一些资源清理之后再调用 exit 退出。</p><p>这种场景显然不能用 kill -9，不然一下把进程干掉了资源就来不及清除了。</p><h2 id="为什么线程崩溃不会导致-JVM-进程崩溃"><a href="#为什么线程崩溃不会导致-JVM-进程崩溃" class="headerlink" title="为什么线程崩溃不会导致 JVM 进程崩溃"></a>为什么线程崩溃不会导致 JVM 进程崩溃</h2><p>有了上一节的铺垫，相信你不难回答，其实就是<strong>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃</strong>。</p><h2 id="openJDK-源码解析"><a href="#openJDK-源码解析" class="headerlink" title="openJDK 源码解析"></a>openJDK 源码解析</h2><p>详细看：<a href="https://xiaolincoding.com/os/4_process/thread_crash.html#openjdk-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">5.7 线程崩溃了，进程也会崩溃吗？ | 小林coding (xiaolincoding.com)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p><p>但如果进程觉得”罪不致死”，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。</p><p>回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。</p><p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误&#x2F;异常抛给用户来处理。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】内存管理</title>
      <link href="/p/e1d9906f/"/>
      <url>/p/e1d9906f/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是操作系统提供给每个运行中程序的一种地址空间，每个程序在运行时认为自己拥有的内存空间就是虚拟内存，其大小可以远远大于物理内存的大小。虚拟内存通过将程序的地址空间划分成若干个固定大小的页或段，并将这些页或者段映射到物理内存中的不同位置，从而使得程序在运行时可以更高效地利用物理内存。</p><p>而物理内存是计算机实际存在的内存，是计算机中的实际硬件部件。</p><p>如果两个程序都引用了绝对物理地址，第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容。</p><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p>于是，这里就引出了两种地址的概念：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）</li></ul><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>物理地址是内存中存储单元的实际地址，也称为真实地址。它是指计算机系统中 RAM 中的每个存储单元的唯一标识。物理地址是硬件层面上的地址，用于实际的数据存储和访问。在操作系统的内存管理中，物理地址是指内存中实际存放数据的位置，由硬件控制器直接访问。</p><h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>逻辑地址是程序中使用的虚拟地址，也称为虚拟地址。它是指程序中对内存的抽象表示，与实际的物理存储位置无关。逻辑地址由程序员或操作系统定义，用于访问内存中的数据。在计算机系统中，逻辑地址被映射到物理地址上，这个过程由内存管理单元(MMU)负责完成。逻辑地址空间可以大于物理地址空间，因为使用了分页或分段等技术，允许对内存进行灵活的管理和地址映射。</p><h4 id="逻辑地址的作用"><a href="#逻辑地址的作用" class="headerlink" title="逻辑地址的作用"></a>逻辑地址的作用</h4><ol><li>内存管理：逻辑地址提供了一种抽象的方式来管理内存。通过使用逻辑地址，程序可以将其内存访问操作与实际的物理存储位置解耦。这使得操作系统能够对内存进行更灵活的管理，包括内存的分配回收和保护。</li><li>地址空间隔离：逻辑地址空间可以使不同的程序或进程彼此隔离，从而确保它们不会相互干扰或访问对方的内存空间。每个程序都有自己的逻辑地址空间，其中包含了程序执行所需的代码、数据和堆栈等信息。</li><li>虚拟化和抽象：逻辑地址提供了一种虚拟化和抽象的方式，使得程序员可以更方便地编写和管理程序，而无需关注底层的物理硬件细节。这种抽象使得程序能够在不同的计算机系统上运行，而无需修改其代码。</li></ol><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="内存映射"></p><h2 id="程序的内存布局是怎么样的？"><a href="#程序的内存布局是怎么样的？" class="headerlink" title="程序的内存布局是怎么样的？"></a>程序的内存布局是怎么样的？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725233029022.png" alt="image-20240725233029022"></p><p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是6种不同的内存段：</p><ul><li>代码段：包括二进制可执行代码；</li><li>数据段：包括已初始化的静态常量和全局变量；</li><li>BSS段：包括未初始化的静态变量和全局变量；</li><li>堆段：包括动态分配的内存，从低地址开始向上增长;</li><li>文件映射段：包括动态库、共享内存等;</li><li>栈段：包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。当然系统也提供了参数，以便我们自定义大小;</li></ul><p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL 。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug ，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p><p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的<code>malloc()</code>或者<code>mmap()</code>，就可以分别在堆和文件映射段动态分配内存。</p><h3 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h3><ul><li><strong>分配方式</strong>：堆是动态分配内存，由程序员手动申请和释放内存，通常用于存储动态数据结构和对象。栈是静态分配内存，由编译器自动分配和释放内存，用于存储函数的局部变量和函数调用信息。</li><li><strong>内存管理</strong>：堆需要程序员手动管理内存的分配和释放，如果管理不当可能会导致内存泄漏或内存溢出。栈由编译器自动管理内存，遵循后进先出的原则，变量的生命周期由其作用域决定，函数调用时分配内存，函数返回时释放内存。</li><li><strong>大小和速度</strong>：堆通常比栈大，内存空间较大，动态分配和释放内存需要时间开销。栈大小有限，通常比较小，内存分配和释放速度较快，因为是编译器自动管理。</li></ul><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>分段将逻辑地址空间划分为若干个不同长度的段，每个段代表程序中的一个逻辑单元。</strong></p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/a9ed979e2ed8414f9828767592aadc21.png" alt="分段内存"></p><p>段选择因子和段内偏移量：</p><ul><li><strong>段选择因子</strong>就保存在段寄存器里面。段选择因子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li><li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>在上面，知道了虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/20240806150034.png" alt="分段寻址"></p><p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p><ul><li>第一个就是<strong>内存碎片</strong>的问题。</li><li>第二个就是<strong>内存交换的效率低</strong>的问题。</li></ul><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>内存碎片主要分为，<strong>内部内存碎片</strong>和<strong>外部内存碎片</strong>。</p><p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片</strong>。</p><p>但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以<strong>会出现外部内存碎片</strong>的问题。</p><p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p><ul><li>游戏占用了 512MB 内存</li><li>浏览器占用了 128MB 内存</li><li>音乐占用了 256 MB 内存。</li></ul><p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。</p><p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="https://camo.githubusercontent.com/bd4b4a66ef171477c27ee937c4b2c54309ed0ce90c814abeefa2e418c53ca0a8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36313432626333633931376534613632393862646236323933366530643333322e706e67" alt="外部内存碎片"></p><p>解决「外部内存碎片」的问题就是<strong>内存交换</strong>。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p><h3 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h3><p>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><p>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页。</p><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p><strong>分页将逻辑地址空间和物理内存空间划分为固定大小的页（<em>pages</em>）</strong>，通常为连续的 2 的幂大小，如 4 KB 或 4 MB。</p><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p><p><img src="https://camo.githubusercontent.com/7e5453c7f2d555c9634c00e38f4bce5c3061b99efeb921803124c0acda17c214/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30386138653331356665646334613835383036306462356362346136353461662e706e67" alt="分页"></p><p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p><p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>内存分页由于内存空间都是预先划分好的，也就<strong>不会</strong>像内存分段一样，在段与段之间会产生间隙非常小的内存。</p><p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用（LRU）」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p><p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p><h3 id="内存映射-1"><a href="#内存映射-1" class="headerlink" title="内存映射"></a>内存映射</h3><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p><p><img src="https://camo.githubusercontent.com/ae971854ba9993f34798409de8e291af052546e8c4c90af5f682ce7ea22db77f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37383834663464386462343934396637613562623462626430663435323630392e706e67" alt="img"></p><p>这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。</p><p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万（2^20）个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p><p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p><p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p><p>要解决上面的问题，就需要采用一种叫作<strong>多级页表</strong>（<em>Multi-Level Page Table</em>）的解决方案。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。如下图所示：</p><p><img src="https://camo.githubusercontent.com/7de1acad7d283959f0de6acfc0e80f65318089772ca3da3d53b1d07ec81714cf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31393239366532343962323234306332396639633532626537306636313164352e706e67" alt="img"></p><p>如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; <code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。</p><h3 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h3><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p><p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p><p><img src="https://camo.githubusercontent.com/c44bdc551441564ca063b8bad5f3628df997464b7148344b39a367f9818abfee/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f61336364663237363436623234363134613634636663356437636366666133352e706e67" alt="img"></p><p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p><p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p><p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p><h3 id="fork-会复制哪些东西？"><a href="#fork-会复制哪些东西？" class="headerlink" title="fork()会复制哪些东西？"></a>fork()会复制哪些东西？</h3><ul><li>fork 阶段会复制父进程的页表（虚拟内存）</li><li>fork 之后，如果发生了写时复制，就会复制物理内存</li></ul><h3 id="什么是copy-on-write-写时复制-？"><a href="#什么是copy-on-write-写时复制-？" class="headerlink" title="什么是copy on write(写时复制)？"></a>什么是copy on write(写时复制)？</h3><p>主进程在执行fork的时候，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1711953642784-59f9d165-53fa-47db-8f88-dec5b084a96b.png" alt="img"></p><p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「**写时复制(Copy On Write)**」。</p><p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止fork创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><h3 id="页面置换有哪些算法？"><a href="#页面置换有哪些算法？" class="headerlink" title="页面置换有哪些算法？"></a>页面置换有哪些算法？</h3><p>页面置换算法的功能是，当<strong>出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p><p>那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：</p><ul><li>最佳页面置换算法 (OPT)</li><li>先进先出置换算法 (FIFO)</li><li>最近最久未使用的置换算法 (LRU)</li><li>时钟页面置换算法 (Lock)</li><li>最不常用置换算法 (LFU)</li></ul><div class="note  flat info"><p>最佳页面置换算法</p></div><p>基本思路：<strong>置换在「未来」最长时间不访问的页面</strong>。</p><p>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</p><p>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</p><div class="note  flat info"><p>LRU置换算法</p></div><p>虽然LRU 在理论上是可以实现的，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</p><p>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p><p>所以，LRU虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p><div class="note  flat info"><p>时钟页面置换算法</p></div><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p><p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p><p>当发生缺页中断时，算法首先检查表针指向的页面：</p><ul><li>如果它的访问位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法"></p><div class="note  flat info"><p>LFU置换算法</p></div><p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1 。在发生缺页中断时，淘汰计数器值最小的那个页面。</p><p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。<br>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p><p>但还有个问题，LFU算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p><p>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</p><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p><p><img src="https://camo.githubusercontent.com/ad918113ad7283f07d5fd5278c787b92afa4a4a9d6d328659918de8a0e55fafe/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f38393034666238396165306334396334623066326637623561306137623039392e706e67" alt="img"></p><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note  flat"><p>虚拟内存有什么作用？</p></div><ul><li>第一，虚拟内存可以使得进程的<strong>运行内存超过物理内存</strong>大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li><li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突</strong>的问题。</li><li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的<strong>安全</strong>性。</li></ul><br><h1 id="内存满了，会发生什么？"><a href="#内存满了，会发生什么？" class="headerlink" title="内存满了，会发生什么？"></a>内存满了，会发生什么？</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/e069da38c4b54ee98a585a176e2c342f.png" alt="提纲"></p><h2 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h2><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p><p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存，这时会发现这个虚拟内存没有映射到物理内存，CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler（缺页中断函数）处理。</p><div class="note  simple info"><p>用户态和内核态是操作系统中的两种运行模式，它们描述了不同的权限级别和访问方式。</p><ul><li><p>用户态（User Mode）</p><ol><li>在用户态下，程序只能访问有限的资源和功能，如内存、CPU寄存器等。</li><li>用户态下的程序不能直接操作系统的核心部分，例如对硬件的直接访问。</li><li>大多数应用程序在用户态下运行，包括常见的软件如浏览器、文字处理器等。</li></ol></li><li><p>内核态（Kernel Mode）</p><ol><li>在内核态下，操作系统拥有对系统所有资源和硬件的完全控制权。</li><li>内核态下的代码可以执行特权指令，访问所有内存区域，并处理中断和异常。</li><li>操作系统的核心部分，如调度程序、内存管理器等，在内核态下运行。</li></ol></li></ul><p>用户态和内核态之间的切换由操作系统控制，通常发生在系统调用、中断或异常处理等情况下。当一个程序需要访问操作系统提供的服务或请求更高权限时，会触发从用户态到内核态的切换。这种切换的开销相对较高，因为涉及到保存和恢复进程的状态。</p></div><p>缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p><ul><li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li><li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li></ul><p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——<strong>触发 OOM（Out of Memory）机制</strong>。</p><p>OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p><p><img src="https://camo.githubusercontent.com/a37a5605e231bb465726d27dcb84c6a603e6603900860704728592c687ef7896/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32663631623038323262336334613335396639393737303233313938316230372e706e67" alt="img"></p><h2 id="哪些内存可以回收？"><a href="#哪些内存可以回收？" class="headerlink" title="哪些内存可以回收？"></a>哪些内存可以回收？</h2><p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p><ul><li><strong>文件页</strong>（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li><li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li></ul><p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p><ul><li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p><h1 id="在-4GB-物理内存的机器上，申请-8G-内存会怎么样？"><a href="#在-4GB-物理内存的机器上，申请-8G-内存会怎么样？" class="headerlink" title="在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"></a>在 4GB 物理内存的机器上，申请 8G 内存会怎么样？</h1><p>这个问题在没有前置条件下，就说出答案就是耍流氓。这个问题要考虑三个前置条件：</p><ul><li>操作系统是 32 位的，还是 64 位的？</li><li>申请完 8G 内存后会不会被使用？</li><li>操作系统有没有使用 Swap 机制？</li></ul><p>所以，我们要分场景讨论。</p><h2 id="操作系统虚拟内存大小"><a href="#操作系统虚拟内存大小" class="headerlink" title="操作系统虚拟内存大小"></a>操作系统虚拟内存大小</h2><p>32 位操作系统和 64 位操作系统的虚拟地址空间大小是不同的，在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，如下所示：</p><p><a href="https://camo.githubusercontent.com/c94f935422acd1848e43bfa2c3043f7757e3bbd4caa2853f23bb6aa2c6709e39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f33613663623465336632373234316433623039623437363662623062313132342e706e67"><img src="https://camo.githubusercontent.com/c94f935422acd1848e43bfa2c3043f7757e3bbd4caa2853f23bb6aa2c6709e39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f33613663623465336632373234316433623039623437363662623062313132342e706e67" alt="img"></a></p><p>通过这里可以看出：</p><ul><li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li><li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li></ul><h3 id="32-位系统的场景"><a href="#32-位系统的场景" class="headerlink" title="32 位系统的场景"></a>32 位系统的场景</h3><p>因为 32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败（我手上没有 32 位操作系统测试，我估计失败的错误是 cannot allocate memory，也就是无法申请内存失败）。</p><h3 id="64-位系统的场景"><a href="#64-位系统的场景" class="headerlink" title="64 位系统的场景"></a>64 位系统的场景</h3><p>64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。</p><p>我们可以简单做个测试，我的服务器是 64 位操作系统，但是物理内存只有 2 GB：</p><p><a href="https://camo.githubusercontent.com/f638e83dadd1fab26aaa8c40d9c075981beabdff05a6c5efd936c2f205bdce88/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3267622e706e67"><img src="https://camo.githubusercontent.com/f638e83dadd1fab26aaa8c40d9c075981beabdff05a6c5efd936c2f205bdce88/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3267622e706e67" alt="img"></a></p><p>现在，我在机器上，连续申请 4 次 1 GB 内存，也就是一共申请了 4 GB 内存，注意下面代码只是单纯分配了虚拟内存，并没有使用该虚拟内存：</p><p>可以看到，我的物理内存虽然只有 2GB，但是程序正常分配了 4GB 大小的虚拟内存：</p><p><a href="https://camo.githubusercontent.com/78b508f661cadf00108d4b17f7df833431cad370b7cbf7d6cfbf53d27fc684bd/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f25453825393925394125453625384225394625453525383625383525453525414425393834672e706e67"><img src="https://camo.githubusercontent.com/78b508f661cadf00108d4b17f7df833431cad370b7cbf7d6cfbf53d27fc684bd/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f25453825393925394125453625384225394625453525383625383525453525414425393834672e706e67" alt="img"></a></p><p>我们可以通过下面这条命令查看进程（test）的虚拟内存大小：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps aux | grep <span class="built_in">test</span></span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      7797  0.0  0.0 4198540  352 pts/1    S+   16:58   0:00 ./test</span><br></pre></td></tr></table></figure><p>其中，VSZ 就代表进程使用的虚拟内存大小，RSS 代表进程使用的物理内存大小。可以看到，VSZ 大小为 4198540，也就是 4GB 的虚拟内存。</p><p>读者的服务器物理内存是 2 GB，实验后发现，进程还没有申请到 128T 虚拟内存的时候就被杀死了。</p><p><a href="https://camo.githubusercontent.com/6c046e33dfd615b8aee168ee061affcb7c4a793bec495ea059f8ea9bc9d3a7f8/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d332e706e67"><img src="https://camo.githubusercontent.com/6c046e33dfd615b8aee168ee061affcb7c4a793bec495ea059f8ea9bc9d3a7f8/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d332e706e67" alt="img"></a></p><p>注意，这次是 killed，而不是 Cannot Allocate Memory，说明并不是内存申请有问题，而是触发 OOM 了。</p><p>但是为什么会触发 OOM 呢？</p><p>那得看你的主机的「物理内存」够不够大了，即使 malloc 申请的是虚拟内存，只要不去访问就不会映射到物理内存，但是申请虚拟内存的过程中，还是使用到了物理内存（比如内核保存虚拟内存的数据结构，也是占用物理内存的），如果你的主机是只有 2GB 的物理内存的话，大概率会触发 OOM。</p><p>可以使用 top 命令，点击两下 m，通过进度条观察物理内存使用情况。</p><p><a href="https://camo.githubusercontent.com/c38a110fcac674cf48a5c65f9804995bd824740f459f1883ab1a16bb17937209/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d342e706e67"><img src="https://camo.githubusercontent.com/c38a110fcac674cf48a5c65f9804995bd824740f459f1883ab1a16bb17937209/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d342e706e67" alt="img"></a></p><p>可以看到申请虚拟内存的过程中<strong>物理内存使用量一直在增长</strong>。</p><p><a href="https://camo.githubusercontent.com/61726a8ae5f195c4881880a6befe489477cf391ab2f4f53a035836d0b7be2a81/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d352e706e67"><img src="https://camo.githubusercontent.com/61726a8ae5f195c4881880a6befe489477cf391ab2f4f53a035836d0b7be2a81/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d352e706e67" alt="img"></a></p><p><a href="https://camo.githubusercontent.com/d0413874f73308be96564189519e0f1025afa8c1d9e1bd51c439a89ff8ac346d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d362e706e67"><img src="https://camo.githubusercontent.com/d0413874f73308be96564189519e0f1025afa8c1d9e1bd51c439a89ff8ac346d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d362e706e67" alt="img"></a></p><p><a href="https://camo.githubusercontent.com/e8723a0850da31cbffd4076e5358803ab9f51ee08ffa90e07676ca115d700d0f/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d372e706e67"><img src="https://camo.githubusercontent.com/e8723a0850da31cbffd4076e5358803ab9f51ee08ffa90e07676ca115d700d0f/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d372e706e67" alt="img"></a></p><p>直到直接内存回收之后，也无法回收出一块空间供这个进程使用，这个时候就会触发 OOM，给所有能杀死的进程打分，分数越高的进程越容易被杀死。</p><p>在这里当然是这个进程得分最高，那么操作系统就会将这个进程杀死，所以最后会出现 killed，而不是 Cannot allocate memory。</p><div class="note  flat info"><p>那么 2GB 的物理内存的 64 位操作系统，就不能申请 128T 的虚拟内存了吗？</p></div><p>其实可以，上面的情况是还没开启 swap 的情况。</p><p>使用 swapfile 的方式开启了 1GB 的 swap 空间之后再做实验：</p><p><a href="https://camo.githubusercontent.com/3df75ca2d1ba49eda1c8842ae9b95ebcbefe3c81ef2de7bf3ffececa8ac1d8cc/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d382e706e67"><img src="https://camo.githubusercontent.com/3df75ca2d1ba49eda1c8842ae9b95ebcbefe3c81ef2de7bf3ffececa8ac1d8cc/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d382e706e67" alt="img"></a></p><p><a href="https://camo.githubusercontent.com/41ef5679e39a1a14219fedc206b0321970fa0bc8e8a5775e70ee0478c9c3e205/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d392e706e67"><img src="https://camo.githubusercontent.com/41ef5679e39a1a14219fedc206b0321970fa0bc8e8a5775e70ee0478c9c3e205/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d392e706e67" alt="img"></a></p><p>发现出现了 Cannot allocate memory，但是其实到这里已经成功了，</p><p>打开计算器计算一下，发现已经申请了 127.998T 虚拟内存了。</p><p><a href="https://camo.githubusercontent.com/ec0b99c93dd73d5d421f60c171336a899ce15915e85bce9a1f2f8006ef230fd0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d31302e706e67"><img src="https://camo.githubusercontent.com/ec0b99c93dd73d5d421f60c171336a899ce15915e85bce9a1f2f8006ef230fd0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f3033332545382541462542422545382538302538352d31302e706e67" alt="img"></a></p><p>实际上我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间。</p><h2 id="Swap-机制的作用"><a href="#Swap-机制的作用" class="headerlink" title="Swap 机制的作用"></a>Swap 机制的作用</h2><p>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。</p><p>另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p><p>这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。</p><p>Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：</p><ul><li><strong>换出（Swap Out）</strong> ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</li><li><strong>换入（Swap In）</strong>，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；</li></ul><p>使用 Swap 机制优点是，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比内存要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是 Swap 的弊端。</p><p>Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：</p><ul><li><strong>内存不足</strong>：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。</li><li><strong>内存闲置</strong>：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在<a href="https://xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%B0%BD%E6%97%A9%E8%A7%A6%E5%8F%91-kSwapd-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98">空闲内存低于一定水位</a>时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</li></ul><p>Linux 提供了两种不同的方法启用 Swap，分别是 Swap 分区（Swap Partition）和 Swap 文件（Swapfile），开启方法可以看<a href="https://support.huaweicloud.com/trouble-ecs/ecs_trouble_0322.html">这个资料</a>：</p><ul><li>Swap 分区是硬盘上的独立区域，该区域只会用于交换分区，其他的文件不能存储在该区域上，我们可以使用 <code>swapon -s</code> 命令查看当前系统上的交换分区；</li><li>Swap 文件是文件系统中的特殊文件，它与文件系统中的其他文件也没有太多的区别；</li></ul><div class="note  flat"><p>Swap 换入换出的是什么类型的内存？</p></div><p>内核缓存的文件数据，因为都有对应的磁盘文件，所以在回收文件数据的时候，直接写回到对应的文件就可以了。</p><p>但是像进程的堆、栈数据等，它们是没有实际载体，这部分内存被称为匿名页。而且这部分内存很可能还要再次被访问，所以不能直接释放内存，于是就需要有一个能保存匿名页的磁盘载体，这个载体就是 Swap 分区。</p><p>匿名页回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">4.3 内存满了，会发生什么？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/os/3_memory/alloc_mem.html#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">4.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot + JavaFx 注入为空怎么办？</title>
      <link href="/p/a440b512/"/>
      <url>/p/a440b512/</url>
      
        <content type="html"><![CDATA[<p>在<code>JavaFx</code>的<code>controller</code>中用<code>@Autowired</code>和<code>@Resource</code>注入为空，是因为<code>JavaFx</code>的<code>controller</code>没有交给<code>spring</code>的ioc管理</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>使用一个静态工具类，对<code>mapper</code>进行管理&#x2F;注入，并提供静态方法</p><h2 id="工具类-MapperUtil-java"><a href="#工具类-MapperUtil-java" class="headerlink" title="工具类 MapperUtil.java"></a>工具类 MapperUtil.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperUtil</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MapperUtil mapperUtil;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        mapperUtil=<span class="built_in">this</span>;</span><br><span class="line">        mapperUtil.userMapper=<span class="built_in">this</span>.userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    添加用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User u)</span>&#123;</span><br><span class="line">        mapperUtil.userMapper.addUser(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FXML</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLoginButtonClick</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 此处省略</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> MapperUtil.findByName(name.getText());</span><br><span class="line">       <span class="keyword">if</span>(loginUser==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="comment">// 此处省略</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// 此处省略</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_44974947/article/details/116713657">springboot+javafx+mybatis在controller中注入mapper为空-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaFx </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Vue+TypeScript如何使用Aplayer</title>
      <link href="/p/a46aa116/"/>
      <url>/p/a46aa116/</url>
      
        <content type="html"><![CDATA[<p>先上效果~</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/QQ_1722589576087.png"></p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install aplayer --save</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">APlayer</span> <span class="keyword">from</span> <span class="string">&quot;APlayer&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;aPlayer/dist/APlayer.min.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> playerRef = <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ap</span>: <span class="title class_">APlayer</span></span><br><span class="line"><span class="keyword">const</span> audioList = ref&lt;<span class="title class_">IRMusicItem</span>[]&gt;([])</span><br></pre></td></tr></table></figure><p>其中<code>IRMusicItem</code>声明如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IRMusicItem</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">artist</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">cover</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">lrc</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>lrc</code>可以为<code>.lrc</code>文件的地址，也可以直接是文本，如<code>&#39;[00:00.00]APlayer\n[00:04.01]is\n[00:08.02]amazing&#39;</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">init</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">metingAPI</span>(props.<span class="property">server</span>, props.<span class="property">type</span>, props.<span class="property">id</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">audio</span>: <span class="title class_">IRMusicItem</span> = &#123;</span><br><span class="line">    <span class="comment">// 此处省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  audioList.<span class="property">value</span>.<span class="title function_">push</span>(audio)</span><br><span class="line">  ap = <span class="keyword">new</span> <span class="title class_">APlayer</span>(&#123;</span><br><span class="line">    <span class="attr">container</span>: playerRef.<span class="property">value</span>,</span><br><span class="line">    <span class="attr">audio</span>: audioList.<span class="property">value</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new Aplayer</code>中可以设置许多参数，但上面这两个是必须要有的，详细请看：<a href="https://aplayer.js.org/#/zh-Hans/?id=api">首页 - APlayer</a>，这里摘录一些</p><table><thead><tr><th>名称</th><th>默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td>container</td><td>document.querySelector(‘.aplayer’)</td><td align="left">播放器容器元素</td></tr><tr><td>autoplay</td><td>false</td><td align="left">音频自动播放</td></tr><tr><td>order</td><td>‘list’</td><td align="left">音频循环顺序, 可选值: ‘list’, ‘random’</td></tr><tr><td>preload</td><td>‘auto’</td><td align="left">预加载，可选值: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>volume</td><td>0.7</td><td align="left">默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</td></tr><tr><td>audio</td><td>-</td><td align="left">音频信息, 应该是一个对象或对象数组</td></tr></tbody></table><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>很简单，随便找个<code>div</code>绑定<code>ref</code>就可以了</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;playerRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>歌曲本身的获取，我们需要借助另外的<code>api</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">metingAPI</span> = (<span class="params">server: <span class="built_in">string</span>, <span class="keyword">type</span>: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">http</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;https://meting.qjqq.cn/&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">server</span>: server,</span><br><span class="line">      <span class="attr">type</span>: <span class="keyword">type</span>,</span><br><span class="line">      <span class="attr">id</span>: id,</span><br><span class="line">      <span class="attr">r</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【星尘Infinity/JUN】Shallow（Cover：Faouzia/张杰）【歌手2024】</title>
      <link href="/p/fe8dd3bd/"/>
      <url>/p/fe8dd3bd/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Shallow_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【星尘Infinity&JUN】Shallow.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Shallow》</p><p>翻唱：星尘Infinity、JUN</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>终于带上JUN玩了 但是张杰实在是太强了 D5闭口音 连续C5&#x2F;D5咬字 实在有点为难我这小小声库（ </p><br><p>第十一期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV16f421v7de/?spm_id_from=333.788.video.desc.click">BV16f421v7de</a></p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : Lady Gaga&#x2F;Andrew Wyatt&#x2F;Anthony Rossomando</p><p>作曲 : Lady Gaga&#x2F;Mark Daniel Ronson&#x2F;Lukas Nelson</p><p>原唱 : Lady Gaga&#x2F;Bradley Cooper</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：Nick Pyo</p><p>人声设计&#x2F;和声：Kim Heeyoung</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：甯子达（阿达）</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>弦乐：曜爆甘弦乐团</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>Tell me something girl</p><p>Are you happy in this modern world</p><p>Or do you need more</p><p>Is there something else you’re searching for</p><p>I’m falling</p><p>In all the good times</p><p>I find myself longing for change</p><p>And in the bad times I fear myself</p><br><p>Tell me something boy</p><p>Aren’t you tired trying to fill that void</p><p>Or do you need more</p><p>Ain’t it hard keeping it so hardcore</p><p>I’m falling</p><p>In all the good times</p><p>I find myself longing for change</p><p>And in the bad times I fear myself</p><br><p>I’m off the deep end</p><p>Watch as I dive in</p><p>I’ll never meet the ground</p><p>Crash through the surface</p><p>Where they can’t hurt us</p><p>We’re far from the shallow now</p><br><p>In the shallow shallow</p><p>In the shallow shallow</p><p>In the shallow shallow</p><p>We’re far from the shallow now</p><br><p>I’m off the deep end</p><p>Watch as I dive in</p><p>I’ll never meet the ground</p><p>Crash through the surface</p><p>Where they can’t hurt us</p><p>We’re far from the shallow now</p><br><p>In the shallow shallow</p><p>In the shallow shallow</p><p>In the shallow shallow</p><p>We’re far from the shallow now</p><br><p>I’m falling</p><p>In all the good times</p><p>I find myself longing for change</p><p>And in the bad times I fear myself</p><br><p>In the shallow shallow</p><p>In the shallow shallow</p><p>In the shallow shallow</p><p>We’re far from the shallow now</p><br><p>In the shallow shallow</p><p>We’re far from the shallow now</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 张杰 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Faouzia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】滴水一生 (live)【歌手2024】</title>
      <link href="/p/51c99199/"/>
      <url>/p/51c99199/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%BB%B4%E6%B0%B4%E4%B8%80%E7%94%9F.jpg"></p><p>已灌词</p><p>BPM：80</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 唐恬</p><p>作曲 : 孙楠</p><p>原唱 : 孙楠</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：张亦江</p><p>编曲：郭峻江&#x2F;张亦江</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：甯子达（阿达）</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><p>笛子&#x2F;和声：张亦江</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1J91-INSNu1NN1jorH-LroQ">https://pan.baidu.com/s/1J91-INSNu1NN1jorH-LroQ</a></p><p>提取码: 7fk9</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>小小的雨滴随风大哭着降临落地</p><p>这里是人间不可拒绝的邀请我和你</p><p>泪眼相望见过父母此生就</p><p>有姓有名有去有回赴河流</p> <br><p>走吧去翻过山见朝朝暮暮</p><p>此身有千吨重亦爱你似露珠</p><p>我丰美过草木生长的河畔</p><p>也告别停留在渡口的亲爱</p> <br><p>河水正年轻一路急行走万里风起</p><p>转过多少弯裹满时间的淤泥我和你</p><p>泪眼相望别过父母此生就</p><p>有姓有名有去无回水长流</p> <br><p>走吧去翻过山路风雪迷途</p><p>沿着岸的月光似他乡的故土</p><p>谁在桥上面朝江水喊归来</p><p>可是我长留在渡口的亲爱</p> <br><p>等河流翻过山见海上日出</p><p>等世间所有路都同归于殊途</p><p>寻光而去相约尽头我的爱</p><p>一定有重逢的湛蓝在等待</p><p>每滴水都终将清澈地醒来</p><p>每条河遥遥赴沧海无遗憾</p> <br><p>小小的雨滴把这一生的风景阅尽</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 孙楠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】RIP, Love (live)【歌手2024】</title>
      <link href="/p/91b418a/"/>
      <url>/p/91b418a/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/RIP%2c+Love.jpg"></p><p>已灌词，最后的转音没扒（</p><p>BPM：98</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>词曲 : Faouzia Ouihya&#x2F;Fran Hall&#x2F;Jakke Erixson</p><p>原唱 : Faouzia</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：陈牧荻@TalentUnion</p><p>改编编曲：陈牧荻@TalentUnion</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：甯子达（阿达）</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1Xc-wmasmktPz5URqAU6PIA">https://pan.baidu.com/s/1Xc-wmasmktPz5URqAU6PIA</a></p><p>提取码: fx6y</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>Oh no think I did it again</p><p>And it kills me to see you like this like this</p><p>Should’ve known from the moment we met</p><p>I’d rip your heart out of your chest</p><br><p>Swore I learned from the last time</p><p>Dressed in black I guess I lied</p><p>Warned you God knows that I tried</p><p>I told you I told you</p><br><p>Man down man down</p><p>Oh another one down for me</p><p>Said you’d die for love</p><p>But I never loved you sorry</p><p>So long you’re gone it hurts to see</p><p>Said you’d die for us</p><p>So now R. I. P. love</p><br><p>When I lay in my bed at night</p><p>I remembered the way that you’d cried but I</p><p>Can’t go back now I know it’s too late</p><p>And it haunts me every day</p><br><p>Swore I learned from the last time</p><p>Dressed in black I guess I lied</p><p>Warned you God knows that I tried</p><p>I told you</p><br><p>Man down man down</p><p>Oh another one down for me</p><p>Said you’d die for love</p><p>But I never loved you sorry</p><p>So long you’re gone it hurts to see</p><p>Said you’d die for us</p><p>So now R. I. P. love</p><br><p>R. I. P. love</p><p>R. I. P. love</p><br><p>R. I. P. love</p><p>R. I. P. love</p><br><p>Said you’d die for love</p><p>But I never loved you sorry</p><p>So long you’re gone it hurts to see</p><p>Said you’d die for us</p><p>So R. I. P. love</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Faouzia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】像梦一样自由 (live)【歌手2024】</title>
      <link href="/p/421add40/"/>
      <url>/p/421add40/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%83%8F%E6%A2%A6%E4%B8%80%E6%A0%B7%E8%87%AA%E7%94%B1.jpg"></p><p>已灌词</p><p>BPM：83.5</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 汪峰</p><p>作曲 : 汪峰</p><p>原唱 : 汪峰</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘卓@维伴音乐</p><p>改编编曲：郭小峰@耳肆山白</p><p>合音录制：石行&#x2F;马思莹</p><p>混音：林梦洋</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>吉他：金天@维伴音乐&#x2F;崔万平@维伴音乐</p><p>贝斯：李九君@维伴音乐</p><p>鼓：卢炜@维伴音乐</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1ZRtWJcRLduUkpwmYftADYQ">https://pan.baidu.com/s/1ZRtWJcRLduUkpwmYftADYQ</a></p><p>提取码: vw6h</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>你是否还会牵挂我</p><p>我最亲爱的朋友啊</p><p>当我决定放下所有</p><p>走上去自由的路</p><br><p>你是否还会陪着我</p><p>我最思念的亲人啊</p><p>当我已经告别昨日</p><p>驶向去未来的路</p><br><p>我要像梦一样自由</p><p>像天空一样坚强</p><p>在这曲折蜿蜒的路上</p><p>体验生命的意义</p><br><p>你是否还会陪着我</p><p>我最思念的亲人啊</p><p>当我已经告别昨日</p><p>驶向去未来的路</p><br><p>我要像梦一样自由</p><p>像大地一样宽容</p><p>在这艰辛放逐的路上</p><p>点亮生命的光芒</p><br><p>我要像梦一样自由</p><p>像天空一样坚强</p><p>在这曲折蜿蜒的路上</p><p>体验生命的意义</p><br><p>我要像梦一样自由</p><p>像大地一样宽容</p><p>在这艰辛放逐的路上</p><p>点亮生命的光芒</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Electron】数据存储方案：electron-store</title>
      <link href="/p/9d7a18c7/"/>
      <url>/p/9d7a18c7/</url>
      
        <content type="html"><![CDATA[<p>在开发Electron应用时，我们经常需要对一些数据进行本地化存储，比如用户的配置、应用的状态、缓存的数据等。本文将介绍一款简单而强大的数据持久化组件：<code>electron-store</code>。</p><p><code>electron-store</code>是一个基于Node.js文件系统的数据存储库，它可以将数据以JSON文件的形式保存在本地，并提供了一些方便的API来读写数据。</p><div class="note  flat info"><p>The data is saved in a JSON file named config.json in <a href="https://electronjs.org/docs/api/app#appgetpathname"><code>app.getPath(&#39;userData&#39;)</code></a>.</p><p>但其实我并没有找到这个<code>config.json</code>（（但能用就是了</p></div><p><code>electron-store</code>的优点有：</p><ul><li>简单易用，无需安装数据库或其他依赖</li><li>支持多进程访问，可以在主进程和渲染进程中使用</li><li>支持点符号访问嵌套属性，例如<code>store.get(&#39;foo.bar&#39;)</code></li><li>支持默认值，自动合并用户设置和默认设置</li><li>支持加密，可以使用密码对数据进行加密和解密</li><li>支持类型检查，可以使用<code>TypeScript</code>或<code>JSDoc</code>来定义数据类型</li><li>支持观察者模式，可以监听数据变化并执行回调函数</li></ul><h1 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install electron-store</span><br></pre></td></tr></table></figure><p>*Requires Electron 30 or later.*（since v9.0.0 on 2024&#x2F;05&#x2F;01）</p><p>记得检查一下Electron版本！</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这里使用IPC通信来进行数据的获取和存储。</p><div class="note  flat info"><p>可以看：<a href="https://rean-schwarze.github.io/p/5a18917b/">【Electron】无边框窗口实现 &amp; 自定义最小化、关闭 | Rean’s Blog (rean-schwarze.github.io)</a></p></div><h2 id="修改-background-ts"><a href="#修改-background-ts" class="headerlink" title="修改 background.ts"></a>修改 background.ts</h2><p>在主进程中使用<code>ipcMain</code>定义<code>ipcRenderer</code>监听事件：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Store</span> <span class="keyword">from</span> <span class="string">&#x27;electron-store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 此处省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设置</span></span><br><span class="line">    ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;get-settings&#x27;</span>, <span class="function">(<span class="params">event, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> store.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储设置</span></span><br><span class="line">    ipcMain.<span class="title function_">handle</span>(<span class="string">&#x27;set-settings&#x27;</span>, <span class="function">(<span class="params">event, key, value</span>) =&gt;</span> &#123;</span><br><span class="line">        store.<span class="title function_">set</span>(key, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="修改-preload-ts"><a href="#修改-preload-ts" class="headerlink" title="修改 preload.ts"></a>修改 preload.ts</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">contextBridge.<span class="title function_">exposeInMainWorld</span>(<span class="string">&#x27;myApi&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 此处省略</span></span><br><span class="line">    <span class="comment">// 设置相关api</span></span><br><span class="line">    <span class="attr">getSettings</span>: <span class="function">(<span class="params">key</span>) =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;get-settings&#x27;</span>, key),</span><br><span class="line">    <span class="attr">setSettings</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> ipcRenderer.<span class="title function_">invoke</span>(<span class="string">&#x27;set-settings&#x27;</span>, key, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSettings</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  uploadExceedNum.<span class="property">value</span> = <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">myApi</span>.<span class="title function_">getSettings</span>(<span class="string">&#x27;upload-exceed&#x27;</span>)</span><br><span class="line">  autoPlay.<span class="property">value</span> = <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">myApi</span>.<span class="title function_">getSettings</span>(<span class="string">&#x27;auto-play&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleExceedNumChange</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">myApi</span>.<span class="title function_">setSettings</span>(<span class="string">&#x27;upload-exceed&#x27;</span>,uploadExceedNum.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/7225824684997181496">Electron食用指南: 数据持久化组件Electron-Store - 掘金 (juejin.cn)</a></p><p><a href="https://github.com/sindresorhus/electron-store">sindresorhus&#x2F;electron-store: Simple data persistence for your Electron app or module - Save and load user preferences, app state, cache, etc (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】缘分一道桥 (live)【歌手2024】</title>
      <link href="/p/26345198/"/>
      <url>/p/26345198/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E7%BC%98%E5%88%86%E4%B8%80%E9%81%93%E6%A1%A5.jpg"></p><p>已灌词，京剧部分未扒</p><p>BPM：79</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 方文山</p><p>作曲 : 王力宏</p><p>原唱 : 王力宏&#x2F;谭维维</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘迦宁@共维音乐</p><p>改编编曲：周迪&#x2F;刘迦宁@共维音乐</p><p>混音：林梦洋</p><p>和音：刘芳&#x2F;林灵&#x2F;鱼椒盐&#x2F;李郡洲@爱之音</p><p>吉他：大迪&#x2F;宋宇</p><p>贝斯：周冠辰</p><p>鼓手：王澜</p><p>键盘：高做</p><p>中国鼓：衣钰良&#x2F;张福强</p><p>PGM混音：朱睿杰</p><p>京剧花脸：姚依伯</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1hZlb6zQhOKjvMRFR5N4rlg">https://pan.baidu.com/s/1hZlb6zQhOKjvMRFR5N4rlg</a></p><p>提取码: 8q9x</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>秦时明月汉时关</p><p>万里长征人未还</p><p>但使龙城飞将在</p><p>不教胡马度阴山</p> <br><p>狼烟千里乱葬岗</p><p>乱世孤魂无人访</p><p>无言苍天笔墨寒</p><p>笔刀春秋以血偿</p> <br><p>谈爱恨 不能潦草</p><p>战鼓敲呀敲</p><p>用信任 立下誓言我来熬</p> <br><p>这缘分 像一道桥</p><p>旌旗飘呀飘</p><p>你想走</p><p>就请立马抽刀</p><p>爱一笔勾销</p> <br><p>血肉筑城万箭穿</p><p>盔甲染血映月光</p><p>远方胡笳催断肠</p><p>狼嚎骤起震边关</p> <br><p>谈爱恨 不能潦草</p><p>红尘烧呀烧</p><p>以生死 无愧证明谁重要</p> <br><p>这缘分 像一道桥</p><p>故事瞧一瞧</p><p>走天涯</p><p>你我卸下战袍</p><p>梦回长城谣</p> <br><p>谈爱恨 不能潦草</p><p>红尘烧呀烧</p><p>以生死 无愧证明谁重要</p> <br><p>这缘分 像一道桥</p><p>故事瞧一瞧</p><p>走天涯</p><p>你我卸下战袍</p><p>梦回长城谣</p> <br><p>这缘分 像一道桥</p><p>故事瞧一瞧</p><p>走天涯</p><p>你我卸下战袍</p><p>梦回长城谣</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 谭维维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翎婉 | 粤语】李香兰（Cover：G.E.M.邓紫棋）【Synthesizer V Cover】</title>
      <link href="/p/fa30e874/"/>
      <url>/p/fa30e874/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/李香兰_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【翎婉】李香兰_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《李香兰》</p><p>翻唱：翎婉</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><br><p>非常好翎婉 使我嘎嘎乱调（不是</p><p>田娜真是太美丽了</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 松井五郎</p><p>作曲 : 玉置浩二</p><p>改编词 : 周礼茂</p><p>制作人 : G.E.M.邓紫棋&#x2F;T-Ma</p><p>编曲 : Euywein 杨展鸿&#x2F;Derrick Sepnio</p><p>混音 : T-Ma</p><p>母带 : T-Ma</p><p>OP : Fujipacific Music Inc.</p><p>SP : Fujipacific Music (S.E. Asia) Ltd.</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>恼春风</p><p>我心因何恼春风</p><p>说不出 借酒相送</p><br><p>夜雨冻</p><p>雨点透射到照片中</p><p>回头似是梦</p><p>无法弹动</p><p>迷住凝望你</p><p>褪色照片中</p><br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p><br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p><br><p>照片中</p><p>哪可以投照片中</p><p>盼找到 时间裂缝</p><br><p>夜放纵</p><p>告知我难寻你影踪</p><p>回头也是梦</p><p>仍似被动</p><p>逃避凝望你</p><p>却深印脑中</p><br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p><br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p><br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p><br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> T.I.M.E. </tag>
            
            <tag> 时光音乐会·老友记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】What&#39;s Up (live)【歌手2024】</title>
      <link href="/p/dea9a817/"/>
      <url>/p/dea9a817/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/What%27s+Up.jpg"></p><p>已灌词</p><p>BPM：134</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : I.Perry&#x2F;Linda Perry</p><p>作曲 : I.Perry&#x2F;Linda Perry</p><p>原唱 : 4 Non Blondes</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：达日丹</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;鱼椒盐&#x2F;李郡洲@爱之音</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：Charlie Huntley</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><p>钢琴：达日丹</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1dvHQMZL8iGcDcs0jhN3DHQ">https://pan.baidu.com/s/1dvHQMZL8iGcDcs0jhN3DHQ</a></p><p>提取码: 8atn</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>20 years and my life is still</p><p>Trying to get up that great big hill of hope</p><p>For a destination</p><p>I realized quickly when I knew I should</p><p>That the world was made up of this brotherhood of man</p><p>For whatever that means</p> <br><p>And so I cry sometimes when I’m lying in bed</p><p>Just wanna get it all out what’s in my head</p><p>And I, I am feeling a little peculiar</p><p>And so I wake in the morning and I step outside</p><p>And I take deep breath and I get real high</p><p>And I scream the top of my lungs</p><p>What’s going on</p><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p> <br><p>And I try, oh my God do I try</p><p>I try all the time</p><p>In this institution</p><p>And I pray, oh my God do I pray</p><p>I pray every single day</p><p>For a revolution</p> <br><p>And so I cry sometimes when I’m lying in bed</p><p>Just wanna get it all out what’s in my head</p><p>And I, I am feeling a little peculiar</p><p>And so I wake in the morning and I step outside</p><p>And I take a deep breath and I get real high</p><p>And I scream the top of my lungs</p><p>What’s going on</p> <br><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p> <br><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p> <br><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p><p>And I say hey hey</p><p>I said hey</p><p>What’s going on</p> <br><p>20 years and my life is still</p><p>Trying to get up that great big hill of hope</p><p>For a destination</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 张钰琪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【补档】【沨漪 | 粤语】情人 (live)（Cover：G.E.M.邓紫棋）</title>
      <link href="/p/59203ba6/"/>
      <url>/p/59203ba6/</url>
      
        <content type="html"><![CDATA[<p>原视频投稿于：2023年11月25日 12:00</p><p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/情人_cover.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【沨漪粤语】情人.mov" type="video/mp4" >      </video></p><hr><h2 id="悲报"><a href="#悲报" class="headerlink" title="悲报"></a>悲报</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240723234953.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1721749845842.png"></p><p>我有以下几点要说：</p><p>。。。。。。</p><br><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《情人》</p><p>翻唱：沨漪</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 刘卓辉</p><p>作曲 : 黄家驹</p><p>制作人 : G.E.M.邓紫棋&#x2F;T-Ma</p><p>混音：Matt Sim</p><p>母带：宫阁 @ Gong Studio</p><p>OP: Picasso Horses Ltd admin by Universal Music Publishing Ltd &#x2F; Universal Music Publishing Ltd</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>盼望你没有为我又再渡暗中淌泪</p><p>我不想留底你的心空虚</p><p>盼望你别再让我像背负太深的罪</p><p>我的心如水你不必痴醉</p><p>哦～你可知谁甘心归去</p><p>你与我之间有谁</p> <br><p>是缘是情是童真还是意外</p><p>有泪有罪有付出还有忍耐</p><p>是人是墙是寒冬藏在眼内</p><p>有日有夜有幻想无法等待</p> <br><p>盼望我别去后会共你在远方相聚</p><p>每一天望海每一天相对</p><p>盼望你现已没有让我别去的恐惧</p><p>我即使离开你的天空里</p><p>哦～你可知谁甘心归去</p><p>你与我之间有谁</p> <br><p>是缘是情是童真还是意外</p><p>有泪有罪有付出还有忍耐</p><p>是人是墙是寒冬藏在眼内</p><p>有日有夜有幻想无法等待</p> <br><p>多少春秋风雨改</p><p>多少崎岖不变爱</p><p>多少唏嘘的你在人海</p> <br><p>是缘是情是童真还是意外</p><p>有泪有罪有付出还有忍耐</p><p>是人是墙是寒冬藏在眼内</p><p>有日有夜有幻想无法等待</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> T.I.M.E. </tag>
            
            <tag> 时光音乐会·老友记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】长子 (live)【歌手2024】</title>
      <link href="/p/e5616c72/"/>
      <url>/p/e5616c72/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E9%95%BF%E5%AD%90.jpg"></p><p>国语部分已灌词，彝语部分请自行空耳（</p><p>BPM：120</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : JIHU</p><p>作曲 : JIHU</p><p>原唱 : JIHU</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘卓@维伴音乐</p><p>改编编曲：刘卓@维伴音乐&#x2F;傅一睁@维伴音乐&#x2F;靳瑞</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;鱼椒盐&#x2F;李郡洲@爱之音</p><p>PGM：杨阳&#x2F;施森铭</p><p>弦乐：曜爆甘弦乐团</p><p>彝语助唱：吉克巫呷莫</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1ncyJqBHF-77cSBkRx2C12A">https://pan.baidu.com/s/1ncyJqBHF-77cSBkRx2C12A</a></p><p>提取码: d5ws</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>母亲啊 我听见</p><p>谷穗堆 风在吹</p><p>星星在 家的北</p><p>弟弟们 已经睡</p><br><p>父亲啊 我看见</p><p>鹰在飞 狼在追</p><p>我长大了 会不会</p><p>去远方 成为谁</p><br><p>爱人啊 你的美</p><p>像麦浪 的纯粹</p><p>请点头 跟着我</p><p>这一生 都珍贵</p><br><p>布谷啊 轻声吹</p><p>有人在 山间睡</p><p>阿普说着 人再远</p><p>落幕时 魂要归</p><br><p>你过得好吗 长子啊</p><p>父母都很好</p><p>牛羊和庄稼都很好</p><br><p>你过得好吗 长子啊</p><p>父母都很好</p><p>牛羊和庄稼都很好</p><br><p>爱人啊 你的美</p><p>像麦浪 的纯粹</p><p>请点头 跟着我</p><p>这一生 都珍贵</p><br><p>布谷啊 轻声吹</p><p>有人在 山间睡</p><p>阿普说着 人再远</p><p>落幕时</p><br><p>不要怕 不要怕</p><p>不要怕 不要怕</p><p>不要怕</p><p>无论伤痛</p><p>或苦难</p><br><p>不要怕 不要怕</p><p>不要怕 不要怕</p><p>不要怕</p><p>无论严寒</p><p>或酷暑</p><br><p>不要怕 不要怕</p><p>不要怕 不要怕</p><p>不要怕</p><p>无论伤痛</p><p>或苦难</p><br><p>父亲啊 我看见</p><p>鹰在飞 狼在追</p><p>我长大了 会不会</p><p>去远方 成为谁</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 海来阿木 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】泪桥 (live)【歌手2024】</title>
      <link href="/p/971e9859/"/>
      <url>/p/971e9859/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E3%80%90%E6%9D%A8%E4%B8%9E%E7%90%B3%E3%80%91%E6%B3%AA%E6%A1%A5.jpg"></p><p>已灌词</p><p>BPM：140</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 伍佰</p><p>作曲 : 伍佰</p><p>原唱 : 伍佰 &amp; China Blue</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：陈君豪</p><p>改编编曲：赖伟哲</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;鱼椒盐&#x2F;李郡洲@爱之音</p><p>PGM：杨阳&#x2F;施森铭</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1IdevPRzzqsVEdhP6-mZ3LQ">https://pan.baidu.com/s/1IdevPRzzqsVEdhP6-mZ3LQ</a></p><p>提取码: 7i8m</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>无心过问你的心里我的吻</p><p>厌倦我的亏欠代替你所爱的人</p><p>这个时候我心落花一样飘落下来</p><p>顿时我的视线失去了色彩</p><br><p>知道你也一样不善于表白</p><p>想象你的相爱编织的谎言懈怠</p><p>甜美镜头竟也落花一样飘落下来</p><p>从此我的生命变成了尘埃</p><br><p>寂寞的人总是习惯寂寞的安稳</p><p>至少我们直线曾经交叉过</p><p>就像站在烈日骄阳大桥上</p><p>眼泪狂奔滴落在我的脸庞</p><br><p>知道你也一样不善于表白</p><p>想象你的相爱编织的谎言懈怠</p><p>甜美镜头竟也落花一样飘落下来</p><p>从此我的生命变成了尘埃</p><br><p>寂寞的人总是习惯寂寞的安稳</p><p>至少我们直线曾经交叉过</p><p>就像站在烈日骄阳大桥上</p><p>眼泪狂奔滴落在我的脸庞</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 杨丞琳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】裹着心的光（Cover：那英）【星尘Infinity】【歌手2024】</title>
      <link href="/p/d7f6ccff/"/>
      <url>/p/d7f6ccff/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/裹着心的光_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【星尘Infinity】裹着心的光_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《裹着心的光》</p><p>翻唱：星尘Infinity</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>非常好歌曲 使我sv旋转（不是</p><p>融入了一些JJ和周深的唱法！</p><br><p>第十期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1Pf421z7eb/?spm_id_from=333.788.video.desc.click">BV1Pf421z7eb</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1P_Nu7ssPM81CjxHJ2baOEQ">https://pan.baidu.com/s/1P_Nu7ssPM81CjxHJ2baOEQ</a></p><p>提取码: nu2r</p><p>附赠JJ&amp;周深鸟巢版无参</p><p>BPM：136</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><h3 id="那英版"><a href="#那英版" class="headerlink" title="那英版"></a>那英版</h3><p>作词：易家扬</p><p>作曲：林俊杰 JJ LIN</p><p>原唱：林俊杰 JJ LIN</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘卓@维伴音乐</p><p>改编编曲：刘卓@维伴音乐&#x2F;郭小峰@耳肆山白</p><p>录音合音：朱江&#x2F;樊竹青&#x2F;王笑文&#x2F;宋豪</p><p>录音管弦乐团：国际首席爱乐乐团</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：林金池</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳</p><p>长号：Ben Pelletier</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><p>童声：湖南省青少年活动中心少儿合唱团&#x2F;深空少年合唱团</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>光 拿乌云揉成团</p><p>像鲸鱼吻着浪</p><p>叫我 和你 去飞翔</p><p>人 老无语后落单</p><p>别跟丢了天空 沙滩</p><p>挣脱 回忆 壮胆</p><br><p>裹着心的光 很暖 与你 有关</p><p>有梦就听得到 用爱呼应感叹</p><p>心里裹着光 的人 世界 很宽</p><p>出发就走得到</p><p>来时路不会被 剪断</p><br><p>当 那无名领头羊</p><p>替明天找希望</p><p>说嘿 有我 别心慌</p><p>来 学萤火虫冥想</p><p>在昏暗中静默 发亮</p><p>是否 有梦 当然</p><br><p>裹着心的光 很响 说了 别慌</p><p>它说孤单很好 信念创造不凡</p><p>心里裹着光 的人 初衷 不换</p><p>誓言让心不老</p><p>带那些梦探索 远方</p><br><p>一路有雨 也有霜</p><p>月落无题江南</p><p>如我面对太阳</p><p>如你追希望</p><p>一诺冒险 就得闯</p><p>单板翻越冰川</p><p>未来不缺翅膀 冰雨和闷雷 别管</p><br><p>裹着心的光 很响 说了 别慌</p><p>它说孤单很好 信念创造不凡</p><p>心里裹着光 的人 初衷 不换</p><p>誓言让心不老</p><p>带那些梦探索 远方</p><p>问那些年的梦 有多烫</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 星尘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】Trouble Is a Friend (live)【歌手2024】</title>
      <link href="/p/1b2ec1c2/"/>
      <url>/p/1b2ec1c2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Trouble+Is+a+Friend.jpg"></p><p>已灌词</p><p>BPM：118</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : Lenka Kripac&#x2F;Thomas “Tawgs” Salter</p><p>作曲 : Lenka Kripac&#x2F;Thomas “Tawgs” Salter</p><p>原唱 : Lenka</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：Terence Hsieh谢燕辉&#x2F;Euywein杨展鸿&#x2F;吴加恩</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：林金池</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳</p><p>长号：Ben Pelletier</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/12jFpdJlKv0SuE7-r10ySIQ">https://pan.baidu.com/s/12jFpdJlKv0SuE7-r10ySIQ</a></p><p>提取码: 8av4</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>Trouble he will find you no matter where you go oh oh</p><p>No matter if you’re fast no matter if you’re slow oh oh</p><p>The eye of the storm or the cry in the morn oh oh</p><p>You’re fine for a while but you start to lose control</p> <br><p>He’s there in the dark</p><p>He’s there in my heart</p><p>He waits in the wings</p><p>He’s gotta play a part</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>Trouble is a friend but trouble is a foe oh oh</p><p>And no matter what I feed him he always seems to grow oh oh</p><p>He sees what I see and he knows what I know oh oh</p><p>So don’t forget as you ease on down the road</p> <br><p>He’s there in the dark</p><p>He’s there in my heart</p><p>He waits in the wings</p><p>He’s gotta play a part</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>So don’t be alarmed</p><p>If he takes you by the arm</p><p>I won’t let him win</p><p>But I’m a sucker for his charm</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>How I hate the way he makes me feel</p><p>And how I try to make him leave</p><p>I try</p><p>I try</p> <br><p>But he’s there in the dark</p><p>He’s there in my heart</p><p>He waits in the wings</p><p>He’s gotta play a part</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>So don’t be alarmed</p><p>If he takes you by the arm</p><p>I won’t let him win</p><p>But I’m a sucker for his charm</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>He’s there in the dark</p><p>He’s there in my heart</p><p>He waits in the wings</p><p>He’s gotta play a part</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p> <br><p>So don’t be alarmed</p><p>If he takes you by the arm</p><p>I won’t let him win</p><p>But I’m a sucker for his charm</p><p>Trouble is a friend yeah</p><p>Trouble is a friend of mine</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Lenka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】实战问题</title>
      <link href="/p/a0d1cef9/"/>
      <url>/p/a0d1cef9/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/redis/base/redis_interview.html#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p><br><h1 id="Redis-如何实现延迟队列？"><a href="#Redis-如何实现延迟队列？" class="headerlink" title="Redis 如何实现延迟队列？"></a>Redis 如何实现延迟队列？</h1><p>延迟队列的常见使用场景有以下几种：</p><ul><li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li><li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li><li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li></ul><p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p><p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png" alt="img"></p><br><h1 id="Redis-的大-key-如何处理？"><a href="#Redis-的大-key-如何处理？" class="headerlink" title="Redis 的大 key 如何处理？"></a>Redis 的大 key 如何处理？</h1><div class="note  info flat"><p>什么是大 key？</p></div><p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p><p>一般而言，下面这两种情况被称为大 key：</p><ul><li>String 类型的值大于 10 KB；</li><li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li></ul><div class="note  info flat"><p>大 key 会造成什么问题？</p></div><p>大 key 会带来以下四种影响：</p><ul><li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><h2 id="如何找到大-key-？"><a href="#如何找到大-key-？" class="headerlink" title="如何找到大 key ？"></a>如何找到大 key ？</h2><p><em><strong>1、redis-cli –bigkeys 查找大key</strong></em></p><p>可以通过 redis-cli –bigkeys 命令查找大 key：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys</span><br></pre></td></tr></table></figure><p>使用的时候注意事项：</p><ul><li>最好选择在<strong>从节点</strong>上执行该命令。因为主节点上执行时，会阻塞主节点；</li><li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</li></ul><p>该方式的不足之处：</p><ul><li>这个方法只能返回每种类型中<strong>最大的</strong>那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li><li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li></ul><p><em><strong>2、使用 SCAN 命令查找大 key</strong></em></p><p>使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。</p><p>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</p><p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p><ul><li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：<code>LLEN</code> 命令；Hash 类型：<code>HLEN</code> 命令；Set 类型：<code>SCARD</code> 命令；Sorted Set 类型：<code>ZCARD</code> 命令；</li><li>如果不能提前知道写入集合的元素大小，可以使用 <code>MEMORY USAGE</code> 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li></ul><p><em><strong>3、使用 RdbTools 工具查找大 key</strong></em></p><p>使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。</p><p>比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f redis.csv</span><br></pre></td></tr></table></figure><h2 id="如何删除大-key？"><a href="#如何删除大-key？" class="headerlink" title="如何删除大 key？"></a>如何删除大 key？</h2><p>删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><p>因此，删除大 key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：</p><ul><li>分批次删除</li><li>异步删除（Redis 4.0版本以上）</li></ul><p><em><strong>1、分批次删除</strong></em></p><p>对于<strong>删除大 Hash</strong>，使用 <code>hscan</code> 命令，每次获取 100 个字段，再用 <code>hdel</code> 命令，每次删除 1 个字段。</p><p>Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_hash</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">    large_hash_key =<span class="string">&quot;xxx&quot;</span> <span class="comment">#要删除的大hash键名</span></span><br><span class="line">    cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 使用 hscan 命令，每次获取 100 个字段</span></span><br><span class="line">        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data.items():</span><br><span class="line">                <span class="comment"># 再用 hdel 命令，每次删除1个字段</span></span><br><span class="line">                r.hdel(large_hash_key, item[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>对于<strong>删除大 List</strong>，通过 <code>ltrim</code> 命令，每次删除少量元素。</p><p>Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_list</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_list_key = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">#要删除的大list的键名</span></span><br><span class="line">  <span class="keyword">while</span> r.llen(large_list_key)&gt;<span class="number">0</span>:</span><br><span class="line">      <span class="comment">#每次只删除最右100个元素</span></span><br><span class="line">      r.ltrim(large_list_key, <span class="number">0</span>, -<span class="number">101</span>) </span><br></pre></td></tr></table></figure><p>对于<strong>删除大 Set</strong>，使用 <code>sscan</code> 命令，每次扫描集合中 100 个元素，再用 <code>srem</code> 命令每次删除一个键。</p><p>Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_set</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_set_key = <span class="string">&#x27;xxx&#x27;</span>   <span class="comment"># 要删除的大set的键名</span></span><br><span class="line">  cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span></span><br><span class="line">    cursor, data = r.sscan(large_set_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">      <span class="comment"># 再用 srem 命令每次删除一个键</span></span><br><span class="line">      r.srem(large_size_key, item)</span><br></pre></td></tr></table></figure><p>对于<strong>删除大 ZSet</strong>，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100个元素。</p><p>Python代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_sortedset</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;large_sortedset_key&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_sortedset_key=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> r.zcard(large_sortedset_key)&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span></span><br><span class="line">    r.zremrangebyrank(large_sortedset_key,<span class="number">0</span>,<span class="number">99</span>) </span><br></pre></td></tr></table></figure><p><em><strong>2、异步删除</strong></em></p><p>从 Redis 4.0 版本开始，可以采用<strong>异步删除</strong>法，<strong>用 unlink 命令代替 del 来删除</strong>。</p><p>这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。</p><p>除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。</p><p>主要有 4 种场景，默认都是关闭的：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del</span><br><span class="line">noslave-lazy-flush no</span><br></pre></td></tr></table></figure><p>它们代表的含义如下：</p><ul><li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li><li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li></ul><p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p><br><h1 id="Redis-管道有什么用？"><a href="#Redis-管道有什么用？" class="headerlink" title="Redis 管道有什么用？"></a>Redis 管道有什么用？</h1><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><p>普通命令模式，如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" alt="img"></p><p>管道模式，如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.jpg" alt="img"></p><p>使用<strong>管道技术可以解决多个命令执行时的网络等待</strong>，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p><p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><p>要注意的是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><br><h1 id="Redis-事务支持回滚吗？"><a href="#Redis-事务支持回滚吗？" class="headerlink" title="Redis 事务支持回滚吗？"></a>Redis 事务支持回滚吗？</h1><p>MySQL 在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。</p><p><strong>Redis 中并没有提供回滚机制</strong>，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p><div class="note  info flat"><p>为什么Redis 不支持事务回滚？</p></div><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%E5%9B%9E%E6%BB%9A.png" alt="img"></p><p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p><ul><li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li><li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li></ul><p>这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。</p><br><h1 id="如何用-Redis-实现分布式锁的？"><a href="#如何用-Redis-实现分布式锁的？" class="headerlink" title="如何用 Redis 实现分布式锁的？"></a>如何用 Redis 实现分布式锁的？</h1><p>这里也有：<a href="https://rean-schwarze.github.io/p/156c59d0/">【分布式】分布式锁介绍 &amp; 常见实现方案 | Rean’s Blog (rean-schwarze.github.io)</a></p><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt="img"></p><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li></ul><p>满足这三个条件的分布式命令如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX <span class="number">10000</span> </span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>基于 Redis 实现分布式锁的<strong>优点</strong>：</p><ol><li>性能高效（这是选择缓存实现分布式锁最核心的出发点）。</li><li>实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。</li><li>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。</li></ol><p>基于 Redis 实现分布式锁的<strong>缺点</strong>：</p><ul><li><p>超时时间不好设置</p><p>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。</p><ul><li><strong>那么如何合理设置超时时间呢？</strong> 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</li></ul></li><li><p><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p></li></ul><h2 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h2><p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。</p><p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p><p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p><p>Redlock 算法加锁三个过程：</p><ul><li>第一步是，客户端获取当前时间（t1）。</li><li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul><li>加锁操作使用 SET 命令，带上 NX，EX&#x2F;PX 选项，以及带上客户端的唯一标识。</li><li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li></ul></li><li>第三步是，一旦客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li></ul><p>可以看到，加锁成功要同时满足两个条件（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：</p><ul><li>条件一：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁；</li><li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li></ul><p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p><p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】氧气 (live)【歌手2024】</title>
      <link href="/p/a58b6af0/"/>
      <url>/p/a58b6af0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%B0%A7%E6%B0%94.jpg"></p><p>已灌词</p><p>BPM：95</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 许常德</p><p>作曲 : 黄怡</p><p>原唱 : 范晓萱</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人:汪苏泷&#x2F;谷粟</p><p>改编编曲:谷粟</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：林金池</p><p>鼓：李彦超</p><p>手碟：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳</p><p>竖琴：黄诗娜</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1JvCAmtZm-5kfir9V9P2bhA">https://pan.baidu.com/s/1JvCAmtZm-5kfir9V9P2bhA</a></p><p>提取码: 56sr</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>沉入越来越深的海底</p><p>我开始想念你</p><p>我好孤寂</p><br><p>跌进越来越冷的爱里</p><p>我快不能呼吸</p><p>我想要你</p><br><p>人活着赖着一口氧气</p><p>氧气是你</p><br><p>如果你爱我</p><p>你会来找我</p><p>你会知道我</p><p>快不能活</p><br><p>如果你爱我</p><p>你会来救我</p><p>空气很稀薄</p><p>因为寂寞</p><br><p>跌进越来越冷的爱里</p><p>我快不能呼吸</p><p>我想要你</p><br><p>人活着赖着一口氧气</p><p>氧气是你</p><br><p>如果你爱我</p><p>你会来找我</p><p>你会知道我</p><p>快不能活</p><br><p>如果你爱我</p><p>你会来救我</p><p>空气很稀薄</p><p>因为寂寞</p><br><p>因为寂寞</p><br><p>如果你爱我</p><p>你会来找我</p><p>你会知道我</p><p>快不能活</p><br><p>如果你爱我</p><p>你会来找我</p><p>你会知道我</p><p>因为寂寞</p><p>你会知道我</p><p>因为寂寞</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 汪苏泷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】过期删除与内存淘汰</title>
      <link href="/p/9381aa6d/"/>
      <url>/p/9381aa6d/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-使用的过期删除策略是什么？"><a href="#Redis-使用的过期删除策略是什么？" class="headerlink" title="Redis 使用的过期删除策略是什么？"></a>Redis 使用的过期删除策略是什么？</h1><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。</p><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><h2 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h2><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除的流程图如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg" alt="img"></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul><h2 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h2><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p>定期删除的流程如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><p>可以看到，惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><h2 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h2><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p><p>定时删除策略的<strong>优点</strong>：</p><ul><li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li></ul><p>定时删除策略的<strong>缺点</strong>：</p><ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li></ul><br><h1 id="Redis-持久化时，对过期键会如何处理的？"><a href="#Redis-持久化时，对过期键会如何处理的？" class="headerlink" title="Redis 持久化时，对过期键会如何处理的？"></a>Redis 持久化时，对过期键会如何处理的？</h1><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p><ul><li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li><li><strong>RDB 加载阶段</strong>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul><li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ul><p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p><ul><li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li><li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li></ul><br><h1 id="Redis-主从模式中，对过期键会如何处理？"><a href="#Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="Redis 主从模式中，对过期键会如何处理？"></a>Redis 主从模式中，对过期键会如何处理？</h1><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p><br><h1 id="Redis-内存满了，会发生什么？"><a href="#Redis-内存满了，会发生什么？" class="headerlink" title="Redis 内存满了，会发生什么？"></a>Redis 内存满了，会发生什么？</h1><p>在 Redis 的运行内存达到了某个阈值，就会触发<strong>内存淘汰机制</strong>，这个阈值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><br><h1 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h1><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><em><strong>1、不进行数据淘汰的策略</strong></em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p><p><em><strong>2、进行数据淘汰的策略</strong></em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis 3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><br><h1 id="LRU-算法和-LFU-算法"><a href="#LRU-算法和-LFU-算法" class="headerlink" title="LRU 算法和 LFU 算法"></a>LRU 算法和 LFU 算法</h1><h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><div class="note  info flat"><p>Redis 是如何实现 LRU 算法的？</p></div><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>Redis 实现的 LRU 算法的优点：</p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用；</li><li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li></ul><p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p><p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p><h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p>LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p><div class="note  info flat"><p>Redis 是如何实现 LFU 算法的？</p></div><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 LDT (Last Decrement Time)，低 8bit 存储 logc (Logistic Counter)。</p><ul><li>LDT 是用来记录 key 的访问时间戳；</li><li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的 logc 初始值为 5。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p><p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><br><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#lru-%E7%AE%97%E6%B3%95%E5%92%8C-lfu-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/redis/module/strategy.html#lru-%E7%AE%97%E6%B3%95%E5%92%8C-lfu-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Redis 过期删除策略和内存淘汰策略有什么区别？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】Because Of You (live)【歌手2024】</title>
      <link href="/p/38b8becb/"/>
      <url>/p/38b8becb/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Because+Of+You.jpg"></p><p>已灌词</p><p>BPM：135</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : Kelly Clarkson&#x2F;David Hodges&#x2F;Ben Moody</p><p>作曲 : Kelly Clarkson&#x2F;David Hodges&#x2F;Ben Moody</p><p>原唱 : Kelly Clarkson</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：赖伟哲</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：林金池</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳</p><p>长号：Ben Pelletier</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1CD9TSpBGGIoBHmzfSigaiA">https://pan.baidu.com/s/1CD9TSpBGGIoBHmzfSigaiA</a></p><p>提取码: rs3v</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>I will not make the same mistakes that you did</p><p>I will not let myself cause my heart so much misery</p><p>I will not break the way you did</p><p>You fell so hard</p><p>I’ve learned the hard way</p><p>To never let it get that far</p><br><p>Because of you</p><p>I never stray too far from the sidewalk</p><p>Because of you</p><p>I learned to play on the safe side so I don’t get hurt</p><p>Because of you</p><p>I find it hard to trust</p><p>Not only me but everyone around me</p><p>Because of you</p><p>I am afraid</p><br><p>I lose my way</p><p>And it’s not too long before you point it out</p><p>I cannot cry</p><p>Because I know that’s weakness in your eyes</p><p>I’m forced to fake a smile a laugh</p><p>Every day of my life</p><p>My heart can’t possibly break</p><p>When it wasn’t even whole to start with</p><br><p>Because of you</p><p>I never stray too far from the sidewalk</p><p>Because of you</p><p>I learned to play on the safe side so I don’t get hurt</p><p>Because of you</p><p>I find it hard to trust</p><p>Not only me but everyone around me</p><p>Because of you</p><p>I am afraid</p><br><p>I watched you die</p><p>I heard you cry every night in your sleep</p><p>I was so young</p><p>You should have known better than to lean on me</p><p>You never thought of anyone else</p><p>You just saw your pain</p><p>And now I cry in the middle of the night</p><p>For the same damn thing</p><br><p>Because of you</p><p>I never stray too far from the sidewalk</p><p>Because of you</p><p>I learned to play on the safe side so I don’t get hurt</p><br><p>Because of you</p><p>I try my hardest just to forget everything</p><p>Because of you</p><p>I don’t know how to let anyone else in</p><p>Because of you</p><p>I’m ashamed of my life because it’s empty</p><p>Because of you</p><p>I am afraid</p><p>Because of you</p><p>Because of you</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Chanté Moore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】集群 | 高可用</title>
      <link href="/p/d0a26095/"/>
      <url>/p/d0a26095/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-如何实现服务高可用？"><a href="#Redis-如何实现服务高可用？" class="headerlink" title="Redis 如何实现服务高可用？"></a>Redis 如何实现服务高可用？</h1><p>假设数据都是存储在一台服务器上，那么如果出事就完犊子了，比如：</p><ul><li>如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；</li><li>如果这台服务器的硬盘出现了故障，可能数据就都丢失了。</li></ul><p>要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。</p><p>要想设计一个高可用的 Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="img"></p><p>也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p><p>注意，主从服务器之间的命令复制是<strong>异步</strong>进行的。</p><p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。</p><p>所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p><h3 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h3><p>多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？</p><p>我们可以使用 <code>replicaof</code>（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。</p><p>比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure><p>接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。</p><p>主从服务器间的第一次同步的过程可分为三个阶段：</p><ul><li>第一阶段是建立链接、协商同步；</li><li>第二阶段是主服务器同步数据给从服务器；</li><li>第三阶段是主服务器发送新写操作命令给从服务器。</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png" alt="图片"></p><p><em>第二阶段：主服务器同步数据给从服务器</em></p><p>这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。</p><p>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。</p><p>那么为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong>：</p><ul><li>主服务器生成 RDB 文件期间；</li><li>主服务器发送 RDB 文件给从服务器期间；</li><li>「从服务器」加载 RDB 文件期间；</li></ul><p><em>第三阶段：主服务器发送新写操作命令给从服务器</em></p><p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。</p><p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p><p>至此，主从服务器的第一次同步的工作就完成了。</p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/03eacec67cc58ff8d5819d0872ddd41e.png" alt="图片"></p><p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p><p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p><h3 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h3><p>在前面的分析中，我们可以知道主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：生成 RDB 文件和传输 RDB 文件。</p><p>主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：</p><ul><li>由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；</li><li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。</li></ul><p>在 Redis 中，从服务器可以有自己的从服务器，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，组织形式如下图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/4d850bfe8d712d3d67ff13e59b919452.png" alt="图片"></p><p>通过这种方式，<strong>主服务器生成 RDB 和传输 RDB 的压力可以分摊到从服务器</strong>。</p><p>那具体怎么做到的呢？</p><p>其实很简单，我们在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">replicaof &lt;目标服务器的IP&gt; 6379</span><br></pre></td></tr></table></figure><p>此时如果目标服务器本身也是「从服务器」，那么该目标服务器不仅可以接受主服务器同步的数据，也会把数据同步给自己旗下的从服务器，从而减轻主服务器的负担。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/4845008abadaa871613873f5ffdcb542.png" alt="图片"></p><p>那么问题来了，如果此时断开的网络，又恢复正常了，要怎么继续保证主从服务器的数据一致性呢？</p><p>从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p>网络恢复后的增量复制过程如下图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/e081b470870daeb763062bb873a4477e.png" alt="图片"></p><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；</li><li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><p>那么关键的问题来了，<strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong></p><p>答案藏在这两个东西里：</p><ul><li><strong>repl_backlog_buffer</strong>，是一个「<strong>环形</strong>」缓冲区，用于主从服务器断连后，从中找到差异的数据；</li><li><strong>replication offset</strong>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「<em>写</em>」到的位置，从服务器使用 slave_repl_offset 来记录自己「<em>读</em>」到的位置。</li></ul><p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p><ul><li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li><li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li></ul><p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p><p>因此，<strong>为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些</strong>，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p><p>那 repl_backlog_buffer 缓冲区具体要调整到多大呢？</p><p>repl_backlog_buffer 最小的大小可以根据这面这个公式估算。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/5e9e65a4a59b3688fa37cadbd87bb5ac.png" alt="图片"></p><p>我来解释下这个公式的意思：</p><ul><li>second 为从服务器断线后重新连接上主服务器所需的平均时间(以秒计算)。</li><li>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</li></ul><p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p><p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p><p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="怎么判断-Redis-某个节点是否正常工作？"><a href="#怎么判断-Redis-某个节点是否正常工作？" class="headerlink" title="怎么判断 Redis 某个节点是否正常工作？"></a>怎么判断 Redis 某个节点是否正常工作？</h4><p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p><p>Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：</p><ul><li>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。</li><li>Redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：<ul><li>实时监测主从节点网络状态；</li><li>上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</li></ul></li></ul><h4 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h4><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p><h4 id="主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？"><a href="#主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？" class="headerlink" title="主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？"></a>主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</h4><p>replication buffer 、repl backlog buffer 区别如下：</p><ul><li>出现的阶段不一样：<ul><li>repl backlog buffer 是在增量复制阶段出现，<strong>一个主节点只分配一个 repl backlog buffer</strong>；</li><li>replication buffer 是在全量复制阶段和增量复制阶段都会出现，<strong>主节点会给每个新连接的从节点，分配一个 replication buffer</strong>；</li></ul></li><li>这两个 Buffer 都有大小限制的，当缓冲区满了之后，发生的事情不一样：<ul><li>当 repl backlog buffer 满了，因为是环形结构，会直接<strong>覆盖起始位置数据</strong>;</li><li>当 replication buffer 满了，会导致连接断开，删除缓存，从节点重新连接，<strong>重新开始全量复制</strong>。</li></ul></li></ul><h4 id="如何应对主从数据不一致？"><a href="#如何应对主从数据不一致？" class="headerlink" title="如何应对主从数据不一致？"></a>如何应对主从数据不一致？</h4><p>第一种方法，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。</p><p>第二种方法，可以开发一个外部程序来监控主从节点间的复制进度。具体做法：</p><ul><li>Redis 的 INFO replication 命令可以查看主节点接收写命令的进度信息（master_repl_offset）和从节点复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从节点和主节点间的复制进度差值了。</li><li>如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。不过，为了避免出现客户端和所有从节点都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些。</li></ul><h4 id="主从切换如何减少数据丢失？"><a href="#主从切换如何减少数据丢失？" class="headerlink" title="主从切换如何减少数据丢失？"></a>主从切换如何减少数据丢失？</h4><p>主从切换过程中，产生数据丢失的情况有两种：</p><ul><li><strong>异步复制同步丢失</strong>：对于 Redis 主节点与从节点之间的数据复制，是异步复制的，当客户端发送写请求给主节点的时候，客户端会返回 ok，接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失。</li><li><strong>集群产生脑裂数据丢失</strong>：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</li></ul><p>我们不可能保证数据完全不丢失，只能做到使得尽量少的数据丢失。</p><div class="note  info simple"><p>减少异步复制的数据丢失的方案</p></div><p>Redis 配置里有一个参数 min-slaves-max-lag，表示一旦所有的从节点数据复制和同步的延迟都超过了 min-slaves-max-lag 定义的值，那么主节点就会拒绝接收任何请求。</p><p>假设将 min-slaves-max-lag 配置为 10s 后，根据目前 master-&gt;slave 的复制速度，如果数据同步完成所需要时间超过10s，就会认为 master 未来宕机后损失的数据会很多，master 就拒绝写入新请求。这样就能将 master 和 slave 数据差控制在10s内，即使 master 宕机也只是这未复制的 10s 数据。</p><p>那么对于客户端，当客户端发现 master 不可写后，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失，也可以将数据写入 kafka 消息队列，等 master 恢复正常，再隔一段时间去消费 kafka 中的数据，让将数据重新写入 master 。</p><div class="note  info simple"><p>减少脑裂的数据丢失的方案</p></div><p>当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么主节点会禁止写操作，直接把错误返回给客户端。</p><p>在 Redis 的配置文件中有两个参数我们可以设置：</p><ul><li>min-slaves-to-write x，主节点必须要有<strong>至少 x 个从节点连接</strong>，如果小于这个数，主节点会禁止写数据。</li><li>min-slaves-max-lag x，主从数据复制和同步的延迟<strong>不能超过 x 秒</strong>，如果主从同步的延迟超过 x 秒，主节点会禁止写数据。</li></ul><p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p><p>这两个配置项组合后的要求是，<strong>主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒</strong>，否则，主节点就不会再接收客户端的写请求了。</p><p>即使原主节点是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从节点进行同步，自然也就无法和从节点进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主节点就会被限制接收客户端写请求，客户端也就不能在原主节点中写入新数据了</strong>。</p><p><strong>等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。我再来给你举个例子。</strong></p><p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主节点因为某些原因卡住了 15s，导致哨兵判断主节点客观下线，开始进行主从切换。同时，因为原主节点卡住了 15s，没有一个从节点能和原主节点在 12s 内进行数据复制，原主节点也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主节点能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p><h4 id="主从如何做到故障自动切换？"><a href="#主从如何做到故障自动切换？" class="headerlink" title="主从如何做到故障自动切换？"></a>主从如何做到故障自动切换？</h4><p>主节点挂了 ，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 Redis 无法对外提供写操作。</p><p>此时，Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。</p><h2 id="为什么要有哨兵机制？"><a href="#为什么要有哨兵机制？" class="headerlink" title="为什么要有哨兵机制？"></a>为什么要有哨兵机制？</h2><p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p><p><img src="https://cdn.xiaolincoding.com//picgo/db568766644a4d10b8a91cdd2f8a4070.png" alt="主节点挂了"></p><p>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p><p>这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！</p><p>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><h3 id="哨兵机制是如何工作的？"><a href="#哨兵机制是如何工作的？" class="headerlink" title="哨兵机制是如何工作的？"></a>哨兵机制是如何工作的？</h3><p>哨兵其实是一个运行在特殊模式下的 Redis 进程，所以它也是一个节点。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。</p><p>当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些“动作”，来修复异常状态。</p><p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/775865f6bd894dfba8d373ee54d79af1.png" alt="哨兵的职责"></p><h3 id="如何判断主节点真的故障了？"><a href="#如何判断主节点真的故障了？" class="headerlink" title="如何判断主节点真的故障了？"></a>如何判断主节点真的故障了？</h3><p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p><p><img src="https://cdn.xiaolincoding.com//picgo/26f88373d8454682b9e0c1d4fd1611b4.png" alt="哨兵监控主从节点"></p><p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p><div class="note  info simple"><p>主观下线？难道还有客观下线？</p></div><p>是的没错，客观下线只适用于主节点。</p><p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p><p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p><p>具体是怎么判定主节点为「客观下线」的呢？</p><p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p><p><img src="https://cdn.xiaolincoding.com//picgo/13e4361407ba46979e802eaa654dcf67.png" alt="img"></p><p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p><p>例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p><div class="note  info flat"><p>quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。而且<strong>哨兵节点的数量应该是奇数</strong>。</p></div><p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p><h3 id="由哪个哨兵进行主从故障转移？"><a href="#由哪个哨兵进行主从故障转移？" class="headerlink" title="由哪个哨兵进行主从故障转移？"></a>由哪个哨兵进行主从故障转移？</h3><p>前面说过，为了更加“客观”的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以<strong>哨兵是以哨兵集群的方式存在的</strong>。</p><p>问题来了，由哨兵集群中的哪个节点进行主从故障转移呢？</p><p>所以这时候，还需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</p><p>选举 leader 的过程其实是一个投票的过程，在投票开始前，肯定得有个「候选者」。哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</p><p>候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。</p><p>每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。</p><p>那么在投票过程中，任何一个「候选者」，要满足两个条件：</p><ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul><p>举个例子，假设哨兵节点有 3 个，quorum 设置为 2，那么任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p><p>这时候有的同学就会问了，如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？</p><p>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。</p><div class="note  info simple"><p>为什么哨兵节点至少要有 3 个？</p></div><p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票（2*0.5+1&#x3D;2），而不是 1 票。如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。</p><h3 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h3><p>主从故障转移操作包含以下四个步骤：</p><ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：<ul><li>过滤掉已经离线的从节点；</li><li>过滤掉历史网络连接状态不好的从节点；</li><li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li></ul></li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E9%9B%86%E7%BE%A4">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5">主从复制是怎么实现的？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6">为什么要有哨兵？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】小小虫（Cover：汪苏泷）【暮夜】【歌手2024】</title>
      <link href="/p/2b3bdada/"/>
      <url>/p/2b3bdada/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/小小虫_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【暮夜】小小虫_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《小小虫》</p><p>翻唱：暮夜</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>调了暮夜！非常好一款小男孩 使我ACE旋转（日常被ACE气晕.jpg</p><br><p>第九期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1H1421k77d/?spm_id_from=333.788.video.desc.click">BV1H1421k77d</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1BvHxJIfQjaE3iFd5xJnnUg">https://pan.baidu.com/s/1BvHxJIfQjaE3iFd5xJnnUg</a></p><p>提取码: sptd</p><p>BPM：94</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 农夫</p><p>作曲 : 方大同</p><p>原唱：方大同</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：汪苏泷 </p><p>改编编曲：金若晨&#x2F;曾怡</p><p>管乐编写：金若晨&#x2F;曾怡</p><p>吉他编写：王迪</p><p>录音萨克斯：陈嘉俊</p><p>录音小号：夏非</p><p>录音长号：胡清文</p><p>改编监制：金若晨</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：JQ Whitcomb</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>我从小不会说话</p><p>总会说些不该说的话 也没办法</p><p>我知道我是傻瓜</p><p>我不是说情话的专家 别怪我</p><p>我搞不懂 要不是这条小小的虫</p><p>吓得你跳进了我的怀中</p><p>可不可这样跟你相拥</p><p>我真的很没用</p><br><p>要感谢这小小虫给我机会</p><p>这是我初次抓到恋爱滋味</p><p>感觉好奇怪 好像伤害了谁</p><p>或许我太坏 把小虫摔下来</p><p>去换你的爱</p><br><p>小虫也有它用途</p><p>它用自己摔下的痛苦 换我幸福</p><p>也许相爱是这样</p><p>有人快乐就有人受伤 别紧张</p><p>像我这样 那么平凡一张大众脸</p><p>从来没人愿意多看我一眼</p><p>可是在人来人往之间</p><p>却有小虫还我心愿</p><br><p>要感谢这小小虫给我机会</p><p>这是我初次抓到恋爱滋味</p><p>感觉好奇怪 好像伤害了谁</p><p>或许我太坏 把小虫摔下来</p><p>去换你的爱</p><br><p>要感谢这小小虫给我机会</p><p>这是我初次抓到恋爱滋味</p><p>感觉好奇怪 好像伤害了谁</p><p>或许我太坏 把小虫摔下来</p><p>去换你的爱</p><br><p>如果爱没有那么烦</p><p>我不会吃不下晚饭</p><p>也不会多么的堕落 如果你说你爱我</p><p>如果爱可以更简单</p><p>我也不会有这么乱</p><p>整个世界在转</p><p>你或许可以说你爱我吗</p><br><p>如果爱没有那么烦</p><p>我不会吃不下晚饭</p><p>也不会多么的堕落</p><p>如果你说你爱我</p><p>爱我吗</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌手2024 </tag>
            
            <tag> 汪苏泷 </tag>
            
            <tag> 暮夜 </tag>
            
            <tag> ACE Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】缓存设计</title>
      <link href="/p/ba70636/"/>
      <url>/p/ba70636/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-缓存设计（生产问题）"><a href="#Redis-缓存设计（生产问题）" class="headerlink" title="Redis 缓存设计（生产问题）"></a>Redis 缓存设计（生产问题）</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/61781cd6d82e4a0cc5f7521333049f0d.png" alt="图片"></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/redis-cache-penetration.png" alt="缓存穿透"></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/bloom-filter-simple-schematic-diagram.png" alt="Bloom Filter 的简单原理示意图"></p><p>Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。这样来算的话，申请一个 100w 个元素的位数组只占用 1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000&#x2F;1024 KB ≈ 122KB 的空间。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/bloom-filter-bit-table.png" alt="位数组"></p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/redis-cache-penetration-bloom-filter.png" alt="加入布隆过滤器之后的缓存处理流程图"></p><p>更多关于布隆过滤器的详细介绍可以看看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">不了解布隆过滤器？一文给你整的明明白白！</a> ，强烈推荐。</p><p><strong>3）接口限流</strong></p><p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/redis-cache-breakdown.png" alt="缓存击穿"></p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片"></p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><h3 id="缓存雪崩-vs-缓存击穿"><a href="#缓存雪崩-vs-缓存击穿" class="headerlink" title="缓存雪崩 vs 缓存击穿"></a>缓存雪崩 vs 缓存击穿</h3><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li><li>多级缓存，例如本地缓存+Redis 缓存的组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效（不太推荐，实用性太差）。</li><li>缓存预热，也就是在程序启动后或运行过程中，主动将热点数据加载到缓存中。</li><li>互斥锁</li></ol><div class="note  info simple"><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></div><p><strong>缓存预热如何实现？</strong></p><p>常见的缓存预热方式有两种：</p><ol><li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ol><h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Snipaste_2024-05-18_11-11-29_mianshiya.jpg"></p><p>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p><ul><li>采用延时双删策略：在写库前后都进行删除缓存操作，并且设置合理的超时时间。先删除缓存，再写数据库，休眠一段时间，再次删除缓存。</li><li>读取 binlog 校对缓存：使用组件&#x2F;中间件获取数据库的 binlog。binlog 若采用 Row 模式，解析后一般会有数据行最新数据的信息。通过这个信息去查缓存，若发现不一致则删除缓存；若一致，则不作处理。</li></ul><h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Snipaste_2024-05-18_16-59-05_mianshiya.jpg"></p><p>这个方案为了避免旧数据被回种，等待一段时间后再延迟删除缓存，以确保在这段时间内，查询操作都可以从数据库中获取最新数据。</p><p>延时是确保 <strong>修改数据库 -&gt; 清空缓存前，其他事务的更改缓存操作已经执行完。</strong></p><p>也可以使用消息队列、定时任务或者延迟任务等方式去实现延迟删除：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Snipaste_2024-05-18_17-19-34_mianshiya.jpg"></p><h4 id="为什么是删缓存而不是更新缓存？"><a href="#为什么是删缓存而不是更新缓存？" class="headerlink" title="为什么是删缓存而不是更新缓存？"></a>为什么是删缓存而不是更新缓存？</h4><p>因为更新缓存可能会导致缓存和数据库中的数据不一致，而删除缓存可以保证下次查询时重新从数据库中获取最新数据。</p><h3 id="Cache-Aside-策略"><a href="#Cache-Aside-策略" class="headerlink" title="Cache Aside 策略"></a>Cache Aside 策略</h3><p>业界经常使用的 Cache Aside 策略，也就是对于写请求<strong>先更新数据库再删缓存</strong>的这种做法，在我们的服务中会遇到不少问题。所以最终改成了先更新数据库再更新缓存。</p><p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6e3db3ba2f829ddc14237f5c7c00e7ce.png" alt="图片"></p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong></li></ol><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</p><p>或者引入<strong>消息队列</strong>，将删除缓存要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/a4440f0d572612e0832b903e4a62bd2b.png" alt="图片"></p><p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis">Redis常见面试题总结(上) | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/database-system.html#id28">数据库系统 — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html">什么是缓存雪崩、击穿、穿透？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】线程模型</title>
      <link href="/p/374630f5/"/>
      <url>/p/374630f5/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p><br><h1 id="Redis-单线程"><a href="#Redis-单线程" class="headerlink" title="Redis 单线程"></a>Redis 单线程</h1><p><strong>Redis 单线程指的是「接收客户端请求 -&gt; 解析请求 -&gt; 进行数据读写等操作 -&gt; 发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li></ul><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很<strong>耗时</strong>的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生<strong>阻塞</strong>，这样就无法处理后续的请求了。</p><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240710224954.png"></p><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li><li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li><li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 &#x2F; free(dict) 删除数据库所有对象 &#x2F; free(skiplist) 释放跳表对象；</li></ul><h2 id="Redis-单线程模式是怎样的？"><a href="#Redis-单线程模式是怎样的？" class="headerlink" title="Redis 单线程模式是怎样的？"></a>Redis 单线程模式是怎样的？</h2><p>Redis 6.0 版本之前的单线模式如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240710225225.png"></p><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p><ul><li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li><li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ul><p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p><ul><li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li><li>接着，调用 epoll_wait 函数等待事件的到来：<ul><li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li><li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li><li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li></ul><div class="note  info simple"><p>值得注意的是，发送 write 并不总是能一次性发送完的。假如要发送的结果太大，而系统为每个 socket 设置的发送缓存区又是有限的。</p><p>在这种情况下，clientHasPendingReplies 判断仍然有未发送完的数据的话，就需要注册一个写事件处理函数到 epoll 上。等待 epoll 发现该 socket 可写的时候再次调用 sendReplyToClient进行发送。</p></div><p>以上就是 Redis 单线模式的工作方式，如果你想看源码解析，可以参考这一篇：<a href="https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw">为什么单线程的 Redis 如何做到每秒数万 QPS ？</a></p><br><h1 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h1><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W&#x2F;每秒</strong>，如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240710225320.png"></p><p>之所以 Redis 采用单线程（网络 I&#x2F;O 和执行命令）那么快，有如下几个原因：</p><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 **I&#x2F;O 多路复用机制 **处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><div class="note  info simple"><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B">9.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll | 小林coding (xiaolincoding.com)</a></p></div><br><h1 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h1><p>我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I&#x2F;O 和执行命令）为什么还要使用单线程呢？Redis官方给出的<a href="https://link.juejin.cn/?target=https://redis.io/topics/faq">FAQ</a>中核心意思是：<strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p><p>除了上面的官方回答，选择单线程的原因也有下面的考虑。</p><p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</p><br><h1 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h1><p>虽然 Redis 的主要工作（网络 I&#x2F;O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p><p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。但是<strong>对于命令的执行，Redis 仍然使用单线程</strong>来处理，所以大家不要误解 Redis 有多线程同时执行命令。</p><p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong>。</p><p>Redis 6.0 版本支持的 I&#x2F;O 多线程特性，默认情况下 I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 线程 </tag>
            
            <tag> I/O多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】29 (live)【歌手2024】</title>
      <link href="/p/a964a243/"/>
      <url>/p/a964a243/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/29.jpg"></p><p>已灌词</p><p>BPM：84</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 许钧</p><p>作曲 : 许钧</p><p>原唱 : 许钧</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：荒井十一</p><p>改编编曲：许钧&#x2F;胡晨&#x2F;郭亮&#x2F;弋洋</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：陈任佑</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：JQ Whitcomb</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1qH8dDMODVwIpYYvQuBIIMQ">https://pan.baidu.com/s/1qH8dDMODVwIpYYvQuBIIMQ</a></p><p>提取码: p54b</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>越过山川</p><p>前路虽不盎然</p><p>五彩斑斓</p><p>看起来缺少</p><p>可惜遗憾</p><p>只是一根筋两下思绪</p><p>都怪言语虽突破天际</p><p>但未曾飞起</p><p>转过头空有情怀止步发呆</p>  <br><p>未涉险滩</p><p>孤单不孤单</p><p>也不曾仰望</p><p>贴地行走表示沉默</p><p>惺惺念念惴惴不安</p><p>羞于言说品尝寂寞</p><p>未来若遇到美好光景</p><p>记得告诉我</p>  <br><p>没有答案</p><p>没有硝烟弥漫</p><p>固执己见</p><p>一头扎进灯火阑珊</p><p>过于紧张举止奇怪</p><p>闭口不谈左顾右盼</p><p>最终气急败坏假以自在</p>  <br><p>没有答案</p><p>没有硝烟弥漫</p><p>愿你酷得像风</p><p>野得像狗</p><p>扎进灯火阑珊</p><p>没有答案</p><p>只有硝烟弥漫</p><p>愿你酷得像风</p><p>野得像狗</p><p>扎进灯火阑珊</p>  <br><p>愿你酷得像风</p><p>野得像狗</p><p>扎进灯火阑珊</p>  <br><p>愿你酷得像风</p><p>野得像狗</p><p>扎进灯火阑珊</p>  <br><p>没有答案</p><p>没有答案</p><p>没有答案</p><p>不会有答案</p> <br><p>越过山川</p><p>前路若不盎然</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 许钧 </tag>
            
            <tag> 歌手2024 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】常见数据类型和应用场景</title>
      <link href="/p/a06e9899/"/>
      <url>/p/a06e9899/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/redis/data_struct/command.html#string">Redis 常见数据类型和应用场景 | 小林coding (xiaolincoding.com)</a></p><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片集群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p><div class="note  flat info"><p>为什么用 Redis 作为 MySQL 的缓存？</p></div><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><p><em><strong>1、Redis 具备高性能</strong></em></p><p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p><p>如果 MySQL 中的对应数据改变了之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。</p><p><em><strong>2、Redis 具备高并发</strong></em></p><p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数）是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><br><p>我们都知道 Redis 提供了丰富的数据类型，常见的有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</p><p>每种数据对象都各自的应用场景，你能说出它们各自的应用场景吗？</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/9fa26a74965efbf0f56b707a03bb9b7f-20230309232459468.png" alt="img"></p><br><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/string.png" alt="img"></p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p><p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/string%25E7%25BB%2593%25E6%259E%2584.png" alt="img"></p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为<code>int</code>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/int.png" alt="img"></p><p>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/embstr.png" alt="img"></p><p>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code>：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/raw.png" alt="img"></p><p>注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：</p><ul><li>redis 2.+ 是 32 字节</li><li>redis 3.0-4.0 是 39 字节</li><li>redis 5.0 是 44 字节</li></ul><p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过<strong>一次</strong>内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用<strong>两次</strong>内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处：</p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li><li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul><p>但是 embstr 也有缺点的：</p><ul><li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>使用 String 来缓存对象有两种方式：</p><ul><li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li><li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li></ul><h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁（一般而言，还会对分布式锁加上过期时间）：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><h3 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h3><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p><p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p><p>分布式系统单独存储 Session 流程图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Session1.png" alt="img"></p><p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到哪台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p><p>分布式系统使用同一个 Redis 存储 Session 流程图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Session2.png" alt="img"></p><br><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p><p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素。</p><h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，再详细说说 Stream。</p><p><em>1、如何满足消息保序需求？</em></p><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/list%25E6%25B6%2588%25E6%2581%25AF%25E9%2598%259F%25E5%2588%2597.png" alt="img"></p><ul><li>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li><li>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</li></ul><p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p><p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E6%25B6%2588%25E6%2581%25AF%25E9%2598%259F%25E5%2588%2597.png" alt="img"></p><p><em>2、如何处理重复的消息？</em></p><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p><ul><li>每个消息都有一个全局的 ID。</li><li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li></ul><p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPUSH mq <span class="string">&quot;111000102:stock:99&quot;</span></span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><em>3、如何保证消息可靠性？</em></p><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p><p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p><p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p><ul><li>消息保序：使用 LPUSH + RPOP；</li><li>阻塞读取：使用 BRPOP；</li><li>重复消息处理：生产者自行实现全局唯一 ID；</li><li>消息的可靠性：使用 BRPOPLPUSH</li></ul><blockquote><p>List 作为消息队列有什么缺陷？</p></blockquote><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p><p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p><p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h3><p>生产者通过 XADD 命令插入一条消息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 xiaolin</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XADD mymq * name xiaolin</span></span><br><span class="line">&quot;1654254953808-0&quot;</span><br></pre></td></tr></table></figure><p>插入成功后会返回全局唯一的 ID：”1654254953808-0”。消息的全局唯一 ID 由两部分组成：</p><ul><li>第一部分“1654254953808”是数据插入时，以毫秒为单位计算的当前服务器时间；</li><li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1654254953808-0”就表示在“1654254953808”毫秒内的第 1 条消息。</li></ul><p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入ID的消息）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 ID 号为 1654254953807-0 的消息开始，读取后续的所有消息（示例中一共 1 条）。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREAD STREAMS mymq 1654254953807-0</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure><p>如果<strong>想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项</strong>，实现类似于 BRPOP 的阻塞读取操作。</p><p>比如，下面这命令，设置了 BLOCK 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令最后的“$”符号表示读取最新的消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREAD BLOCK 10000 STREAMS mymq $</span></span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure><p>Stream 的基础方法，使用 xadd 存入消息和 xread 循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Stream%25E7%25AE%2580%25E6%2598%2593.png" alt="img"></p><blockquote><p>前面介绍的这些操作 List 也支持的，接下来看看 Stream 特有的功能。</p></blockquote><h4 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h4><p>Stream 可以以使用 <strong>XGROUP 创建消费组</strong>，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p><p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group1 0-0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group2 0-0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure><p><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息</strong>。</p><p>比如说，我们执行完刚才的 XREADGROUP 命令后，再执行一次同样的命令，此时读到的就是空值了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>但是，<strong>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</strong>。</p><p>比如说，刚才 group1 消费组里的 consumer1 消费者消费了一条 id 为 1654254953808-0 的消息，现在用 group2 消费组里的 consumer1 消费者消费消息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure><p>因为我创建两组的消费组都是从第一条消息开始读取，所以可以看到第二组的消费者依然可以消费 id 为 1654254953808-0 的这一条消息。因此，不同的消费组的消费者可以消费同一条消息。</p><p>使用消费组的目的是<strong>让组内的多个消费者共同分担读取消息</strong>，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p><p>例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654256265584-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolincoding&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654256271337-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;Tom&quot;</span><br></pre></td></tr></table></figure><blockquote><p>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p></blockquote><h4 id="消息留存"><a href="#消息留存" class="headerlink" title="消息留存"></a>消息留存</h4><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E6%25B6%2588%25E6%2581%25AF%25E7%25A1%25AE%25E8%25AE%25A4.png" alt="img"></p><p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，<strong>消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息</strong>。</p><p>例如，我们来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XPENDING mymq group2</span><br><span class="line">1) (integer) 3</span><br><span class="line">2) &quot;1654254953808-0&quot;  # 表示 group2 中所有消费者读取的消息最小 ID</span><br><span class="line">3) &quot;1654256271337-0&quot;  # 表示 group2 中所有消费者读取的消息最大 ID</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br><span class="line">   2) 1) &quot;consumer2&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br><span class="line">   3) 1) &quot;consumer3&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 group2 里 consumer2 已从 mymq 消息队列中读取了哪些消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XPENDING mymq group2 - + 10 consumer2</span></span><br><span class="line">1) 1) &quot;1654256265584-0&quot;</span><br><span class="line">   2) &quot;consumer2&quot;</span><br><span class="line">   3) (integer) 410700</span><br><span class="line">   4) (integer) 1</span><br></pre></td></tr></table></figure><p>可以看到，consumer2 已读取的消息的 ID 是 1654256265584-0。</p><p><strong>一旦消息 1654256265584-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除</strong>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XACK mymq group2 1654256265584-0</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XPENDING mymq group2 - + 10 consumer2</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><blockquote><p>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</p></blockquote><p>一个专业的消息队列，必须要做到两大块：</p><ul><li>消息不丢。</li><li>消息可堆积。</li></ul><p><em>1、Redis Stream 消息会丢失吗？</em></p><p>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E6%25B6%2588%25E6%2581%25AF%25E9%2598%259F%25E5%2588%2597%25E4%25B8%2589%25E4%25B8%25AA%25E9%2598%25B6%25E6%25AE%25B5.png" alt="img"></p><p>Redis Stream 消息队列能不能保证三个环节都不丢失数据？</p><ul><li><p>Redis 生产者会不会丢消息？生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。 从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</p></li><li><p>Redis 消费者会不会丢消息？不会，因为 Stream （ MQ 中间件）会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，但是未被确认的消息。消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。等到消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失。</p></li><li><p>Redis 消息中间件会不会丢消息？</p><p>会</p><p>，Redis 在以下 2 个场景下，都会导致数据丢失：</p><ul><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，<a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">主从切换时，也存在丢失数据的可能 (opens new window)</a>。</li></ul></li></ul><p>可以看到，Redis 在队列中间件环节无法保证消息不丢。像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p><p><em>2、Redis Stream 消息可堆积吗？</em></p><p>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</p><p>所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p><p>当指定队列最大长度时，队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p><p>但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在<strong>磁盘</strong>上，当消息积压时，无非就是多占用一些磁盘空间。</p><p>因此，把 Redis 当作队列来使用时，会面临的 2 个问题：</p><ul><li>Redis 本身可能会丢数据；</li><li>面对消息挤压，内存资源会紧张；</li></ul><p>所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：</p><ul><li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li><li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li></ul><br><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p><p>Hash 与 String 对象的区别如下图所示:</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/hash.png" alt="img"></p><h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p><p>我们以用户信息为例，它在关系型数据库中的结构是这样的：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E7%2594%25A8%25E6%2588%25B7%25E4%25BF%25A1%25E6%2581%25AF.png" alt="img"></p><p>我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表uid:1的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMSET uid:1 name Tom age 15</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表uid:2的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMSET uid:2 name Jerry age 13</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表用户<span class="built_in">id</span>为1中所有的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGETALL uid:1</span></span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;15&quot;</span><br></pre></td></tr></table></figure><p>Redis Hash 存储其结构如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/hash%25E5%25AD%2598%25E5%2582%25A8%25E7%25BB%2593%25E6%259E%2584.png" alt="img"></p><p>在介绍 String 类型的应用场景时有所介绍，String + Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？</p><p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E8%25B4%25AD%25E7%2589%25A9%25E8%25BD%25A6.png" alt="img"></p><p>涉及的命令如下：</p><ul><li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li><li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li><li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li><li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li><li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li></ul><p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p><br><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/set.png" alt="img"></p><h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p><p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p>但是要提醒一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>获取 article:1 文章所有点赞用户 :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span></span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure><p>获取 article:1 文章的点赞用户数量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span></span><br><span class="line">(integer) 0  # 返回0说明没点赞，返回1则说明点赞了</span><br></pre></td></tr></table></figure><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户id，value 则是已关注的公众号的id。</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户关注公众号 <span class="built_in">id</span> 为 5、6、7、8、9</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:1 5 6 7 8 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2  用户关注公众号 <span class="built_in">id</span> 为 7、8、9、10、11</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:2 7 8 9 10 11</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取共同关注</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTER uid:1 uid:2</span></span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;9&quot;</span><br></pre></td></tr></table></figure><p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFF uid:1 uid:2</span></span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:1 5</span></span><br><span class="line">(integer) 1 # 返回0，说明关注了</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:2 5</span></span><br><span class="line">(integer) 0 # 返回0，说明没关注</span><br></pre></td></tr></table></figure><h3 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 1 个一等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 1</span></span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 2 个二等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 2</span></span><br><span class="line">1) &quot;Mark&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 3 个三等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 3</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure><p>如果不允许重复中奖，可以使用 SPOP 命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取一等奖1个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 1</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取二等奖2个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 2</span></span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;Mark&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取三等奖3个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 3</span></span><br><span class="line">1) &quot;John&quot;</span><br><span class="line">2) &quot;Sean&quot;</span><br><span class="line">3) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure><br><h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/zset.png" alt="img"></p><h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表（zskiplist）</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构，跳表的优势是能支持平均 O(logN) 复杂度的节点查找；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p><p><img src="https://camo.githubusercontent.com/859135bec96e9f88d19bfa235d237ee863e8ba0a5e79b47019b75f454ded6901/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f32616530656437393063376537343033663231356163623262643832653838342e706e67"></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；</li><li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li><li>L2 层级只有 1 个节点，也就是节点 3。</li></ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p><p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p><p>跳表的数据结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的 level 数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p><p><img src="https://camo.githubusercontent.com/895329b0ad82c61f2194bb23ce47d622f6f7a7c43b320e54053acc4b6a97be19/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545362539352542302545362538442541452545372542312542422545352539452538422f332545352542312538322545382542372542332545382541312541382d2545382542372541382545352542412541362e706e67"></p><p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L2），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。</p><p>另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都没有用到，所以图中省略了这部分。</p><p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表结构里包含了：</p><ul><li>跳表的头尾节点，便于在 O(1) 时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在 O(1) 时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在 O(1) 时间复杂度获取跳表中层高最大的那个节点的层数量；</li></ul><h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点指向的下一个节点(forward指向的节点)的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点指向的下一个节点(forward指向的节点)的权重「等于」要查找的权重时，并且下一个节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p><p>举个例子，下图有个 3 层级的跳表。</p><p><img src="https://camo.githubusercontent.com/4ca2655dde400edd5379a79de6dc5465e043e3cdb3f781f022b8f2ab0c0b4d59/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545362539352542302545362538442541452545372542312542422545352539452538422f332545352542312538322545382542372542332545382541312541382d2545382542372541382545352542412541362e64726177696f2e706e67"></p><p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p><ul><li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li><li>但是该层的下一个节点是空节点（leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li><li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li><li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li></ul><h3 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL 树、红黑树等）？</p><p>主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p><ul><li>它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。</li><li>Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li><li>它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis master 中），其中扩展了跳表，在 O(log(N)) 中实现了 ZRANK。它只需要对代码进行少量修改。</li></ul><p>我再详细补充点：</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis 里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li></ul><h2 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h2><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:1 文章获得了200个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 200 arcticle:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:2 文章获得了40个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 40 arcticle:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:3 文章获得了100个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 100 arcticle:3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:4 文章获得了50个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 50 arcticle:4</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:5 文章获得了150个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 150 arcticle:5</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:xiaolin:ranking 1 arcticle:4</span></span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:xiaolin:ranking arcticle:4</span></span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORES 表示把 score 也显示出来</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure><h3 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h3><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p><p><strong>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong></p><p><em>1、电话排序</em></p><p>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13100111100 0 13110114300 0 13132110901</span> </span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13200111100 0 13210414300 0 13252110901</span> </span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13300111100 0 13310414300 0 13352110901</span> </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>获取所有号码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone - +</span></span><br><span class="line">1) &quot;13100111100&quot;</span><br><span class="line">2) &quot;13110114300&quot;</span><br><span class="line">3) &quot;13132110901&quot;</span><br><span class="line">4) &quot;13200111100&quot;</span><br><span class="line">5) &quot;13210414300&quot;</span><br><span class="line">6) &quot;13252110901&quot;</span><br><span class="line">7) &quot;13300111100&quot;</span><br><span class="line">8) &quot;13310414300&quot;</span><br><span class="line">9) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure><p>获取 132 号段的号码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone [132 (133</span></span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br></pre></td></tr></table></figure><p>获取132、133号段的号码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone [132 (134</span></span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br><span class="line">4) &quot;13300111100&quot;</span><br><span class="line">5) &quot;13310414300&quot;</span><br><span class="line">6) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure><p><em>2、姓名排序</em></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua</span> </span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><p>获取所有人的名字:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names - +</span></span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br><span class="line">3) &quot;Bluetuo&quot;</span><br><span class="line">4) &quot;Gaodeng&quot;</span><br><span class="line">5) &quot;Jake&quot;</span><br><span class="line">6) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure><p>获取名字中大写字母A开头的所有人：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names [A (B</span></span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br></pre></td></tr></table></figure><p>获取名字中大写字母 C 到 Z 的所有人：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names [C [Z</span></span><br><span class="line">1) &quot;Gaodeng&quot;</span><br><span class="line">2) &quot;Jake&quot;</span><br><span class="line">3) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure><br><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><h2 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h2><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/bitmap.png" alt="img"></p><h2 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h2><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h2 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h2><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p><h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p><p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p><p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p><p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT uid:sign:100:202206 2 1</span><br></pre></td></tr></table></figure><p>第二步，检查该用户 6 月 3 日是否签到。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GETBIT uid:sign:100:202206 2 </span><br></pre></td></tr></table></figure><p>第三步，统计该用户在 6 月份的签到次数。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITCOUNT uid:sign:100:202206</span><br></pre></td></tr></table></figure><p>这样，我们就知道该用户在 6 月份的签到情况了。</p><blockquote><p>如何统计这个月首次打卡时间呢？</p></blockquote><p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p><p>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID &#x3D; 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">BITPOS uid:sign:100:202206 1</span><br></pre></td></tr></table></figure><p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。</p><h3 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h3><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p><p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。 5000 万用户只需要 6 MB 的空间。</p><p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p><p>第一步，执行以下指令，表示用户已登录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure><p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure><p>第三步，登出，将 offset 对应的 value 设置成 0。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure><h3 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h3><p>如何统计出这连续 7 天连续打卡用户总数呢？</p><p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p><p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p><p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p><ul><li><code>operation</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li></ul><p>假设要统计 3 天连续打卡的用户数，则是将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计，如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与操作</span></span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计 bit 位 =  1 的个数</span></span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure><p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p><br><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><h2 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h2><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p><p>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</p><p>HyperLogLog 的优点是，在输入元素的数量或者体积<strong>非常非常大</strong>时，计算基数所需的内存空间总是固定的、并且是很小的。</p><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>这什么概念？举个例子给大家对比一下。</p><p>用 Java 语言来说，一般 long 类型占用 8 字节，而 1 字节有 8 位，即：1 byte &#x3D; 8 bit，即 long 数据类型最大可以表示的数是：<code>2^63-1</code>。对应上面的<code>2^64</code>个数，假设此时有<code>2^63-1</code>这么多个数，从 <code>0 ~ 2^63-1</code>，按照<code>long</code>以及<code>1k = 1024 字节</code>的规则来计算内存总数，就是：<code>((2^63-1) * 8/1024)K = 72,057,594,037,927,935.992 KB = 65535 PB</code>，这是很庞大的一个数，存储空间远远超过<code>12K</code>，而 <code>HyperLogLog</code> 却可以用 <code>12K</code> 就能统计完。</p><p>缺点：</p><ol><li>存在一定误差、误差难以确定具体范围</li><li>不支持支持动态数据更新、不适合频繁变化的数据</li><li>数据合并的复杂性：合并操作可能引入误差，这是因为合并过程中也涉及到概率计算，可能会导致误差的累积；合并操作需要考虑数据分布，如果数据分布不均匀，合并后的结果可能会受到较大影响。</li></ol><h2 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h2><p>HyperLogLog 的实现涉及到很多数学问题，太费脑子了，我也没有搞懂，如果你想了解一下，可以看看这个：<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>。</p><h2 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="百万级网页-UV-计数"><a href="#百万级网页-UV-计数" class="headerlink" title="百万级网页 UV 计数"></a>百万级网页 UV 计数</h3><div class="note  info simple"><p>UV：Unique Visitor一天内访问网站的人数（是以cookie为依据），一天内同一访客的多次访问只计算为1，一台电脑不同的浏览器的cookie值不同。</p></div><p>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>所以，非常适合统计百万级以上的网页 UV 的场景。</p><p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFADD page1:uv user1 user2 user3 user4 user5</span><br></pre></td></tr></table></figure><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFCOUNT page1:uv</span><br></pre></td></tr></table></figure><p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><p>这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p><br><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><h2 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h2><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><h2 id="内部实现-7"><a href="#内部实现-7" class="headerlink" title="内部实现"></a>内部实现</h2><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p><h2 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="滴滴叫车"><a href="#滴滴叫车" class="headerlink" title="滴滴叫车"></a>滴滴叫车</h3><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p><p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure><p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p><p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】地心 (live)【歌手2024】</title>
      <link href="/p/ef9a99de/"/>
      <url>/p/ef9a99de/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%9C%B0%E5%BF%83.jpg"></p><p>已灌词</p><p>BPM：128</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 汪峰</p><p>作曲 : 汪峰</p><p>原唱 : 汪峰</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：张亦江</p><p>改编编曲：黄仙农</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：陈任佑</p><p>鼓：Chris Trzcinski</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：JQ Whitcomb</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1eeD6Qh--2AwH6QSSUXCt_Q">https://pan.baidu.com/s/1eeD6Qh--2AwH6QSSUXCt_Q</a></p><p>提取码: gprf</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>忽然间黄昏像雨落下</p><p>夕阳飘洒金黄了我的忐忑</p><p>在眼前你就像溪流</p><p>像团火焰像星辰像一个迷</p><p>我是如此地爱着你</p><p>几乎已经彻底忘却这个世界</p><p>你充满了我的全部思绪</p><p>像紫罗兰香般挥之不去</p><p>这感觉就像是完全地淹没</p><p>爱已将我深埋地心</p><p>我该拿什么留住你</p><p>给你穷瘠的街巷破碎的星星</p><p>给你绝望的彩虹还是</p><p>永恒凝望孤星圣徒的叹息</p><p>我是这样地爱着你</p><p>几乎已经彻底抛弃那个自己</p><p>你充满了我的辽阔心底</p><p>像深冬的雪般铺天漫地</p><p>这思念就像是无情地掩埋</p><p>你已将我深埋地心</p><p>你充满了我的辽阔心底</p><p>像深冬的雪般铺天漫地</p><p>这思念就像是无情地掩埋</p><p>你已将我深埋地心</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 孙楠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【IP】断网了，还能 ping 通 127.0.0.1 吗？</title>
      <link href="/p/108f7c52/"/>
      <url>/p/108f7c52/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/network/4_ip/ping_lo.html">5.3 断网了，还能 ping 通 127.0.0.1 吗？ | 小林coding (xiaolincoding.com)</a></p><br><h1 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h1><p>可以</p><br><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>有网的情况下，ping 最后是<strong>通过网卡</strong>将数据发送出去的。那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c1019a8be584b27c4fc8b8abda9d3cf1.png" alt="图片"></p><p>从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现<strong>目标IP是外网IP</strong>时，会从”真网卡”发出。</p><p>当发现<strong>目标IP是回环地址</strong>时，就会选择<strong>本地网卡</strong>。</p><p>ping 回环地址和<strong>通过TCP等各种协议发送数据到回环地址</strong>都是走这条路径。整条路径从发到收，都没有经过”真网卡”。<strong>之所以127.0.0.1叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，在本机打个转就又回来了。</strong>所以断网，依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><br><h1 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/50cd584f9f82aee8d3d9bfaf7d910cb8.png" alt="图片"></p><p>可以看到 ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的 <strong>lo0</strong>，本地回环接口，也就是前面提到的**”假网卡”**。</p><p>只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p><h1 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h1><p>首先 <code>localhost</code> 是一个域名，只不过默认会把它解析为 <code>127.0.0.1</code> ，当然这可以在 <code>/etc/hosts</code> 文件下进行修改。</p><p>所以默认情况下，使用 <code>localhost</code> 跟使用 <code>127.0.0.1</code> 确实是没区别的。</p><p>其次就是 <code>0.0.0.0</code>，执行 <code>ping 0.0.0.0</code> ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 0.0.0.0</span></span><br><span class="line">PING 0.0.0.0 (0.0.0.0): 56 data bytes</span><br><span class="line">ping: sendto: No route to host</span><br><span class="line">ping: sendto: No route to host</span><br></pre></td></tr></table></figure><p>但它还是很有用处的，回想下，我们启动服务器的时候，一般会 <code>listen</code> 一个 IP 和端口，等待客户端的连接。</p><p>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> , 那么它表示本机上的<strong>所有IPV4地址</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Address to accept any incoming messages. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    INADDR_ANY      ((unsigned long int) 0x00000000) <span class="comment">/* 0.0.0.0   */</span></span></span><br></pre></td></tr></table></figure><p>举个例子。刚刚提到的 <code>127.0.0.1</code> 和 <code>192.168.31.6</code> ，都是本机的IPV4地址，如果监听 <code>0.0.0.0</code> ，那么用上面两个地址，都能访问到这个服务器。</p><p>当然， 客户端 <code>connect</code> 时，不能使用 <code>0.0.0.0</code> 。必须指明要连接哪个服务器IP。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> ICMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】人间道 (live)【歌手2024】</title>
      <link href="/p/a91c1846/"/>
      <url>/p/a91c1846/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E4%BA%BA%E9%97%B4%E9%81%93.jpg"></p><p>已灌词</p><p>BPM：变速</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 唐恬</p><p>作曲 : 彭飞</p><p>原唱 : 刘欢</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘迦宁@共维音乐</p><p>改编编曲：王嘉敏&#x2F;周杰&#x2F;刘迦宁</p><p>弦乐编写：高子超@Talent Union</p><p>混音：林梦洋</p><p>南箫&#x2F;弓笛：杨明川</p><p>吉他：刘迦宁&#x2F;大迪</p><p>贝斯：周冠辰</p><p>鼓手：王澜</p><p>键盘：高做</p><p>PGM混音：朱睿杰&#x2F;罗子涵</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1PnnS4rgLdni2nznaykjrTw">https://pan.baidu.com/s/1PnnS4rgLdni2nznaykjrTw</a></p><p>提取码: 77a6</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>我要走穿这条命去看雪兰花</p><p>我要踏破这双鞋光脚平风沙</p><p>我要白日见云霞夜里举火把</p><p>我要这朗朗乾坤下事事有王法</p><br><p>苦雨江头风波恶</p><p>做人一生坎坷多</p><p>兄弟我心头上有件事啊</p><p>不见孟婆不得过</p><p>自古黑白分颜色</p><p>别扯放下就成佛</p><p>好人都未必能有好报啊</p><p>那坏人凭啥享安乐</p><br><p>为一口气为一个理</p><p>为一场祭老子走到底</p><br><p>我要出了门的人再晚也归家</p><p>我要天上落的雨又回到天上</p><p>我要吃这一口饭守这一野荒</p><p>我要这人间所有道都在青天下</p><br><p>嫩草怕霜霜怕日</p><p>恶人还需犟人磨</p><p>我是你杀生得来的报啊</p><p>也是你重生的因果</p><br><p>为一口气为一个理</p><p>为一场祭老子走到底</p><br><p>我要走穿这条命去看雪兰花</p><p>我要踏破这双鞋光脚平风沙</p><p>我要白日见云霞夜里举火把</p><p>我要这朗朗乾坤下事事有王法</p><br><p>我要出了门的人再晚也归家</p><p>我要天上落的雨又回到天上</p><p>我要吃这一口饭守这一野荒</p><p>我要这人间所有道都在青天下</p><br><p>我要凿过井的人兜里有盐巴</p><p>我要那亏过心的鬼目中有王法</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 谭维维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP】TCP 和 UDP 可以使用同一个端口吗？</title>
      <link href="/p/413576cf/"/>
      <url>/p/413576cf/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97">4.18 TCP 和 UDP 可以使用同一个端口吗？ | 小林coding (xiaolincoding.com)</a></p><br><h1 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h1><p>答案：<strong>可以的</strong>。</p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网络层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img"></p><p>因此， TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>简单写个 TCP 和 UDP 服务端的程序，它们都绑定同一个端口号 8888。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F.png" alt="img"></p><p>运行这两个程序后，通过 netstat 命令可以看到，TCP 和 UDP 是可以同时绑定同一个端口号的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/1.png" alt="img"></p><br><h1 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h1><p><strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”</strong>。</p><p>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p><p>这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。</p><br><h1 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h1><p>客户端在执行 connect 函数的时候，会在内核里随机选择一个端口（32768 ~ 61000，共 28232 个），然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E7%BC%96%E7%A8%8B.png" alt="img"></p><p>那么还可以继续使用该端口发起连接吗？</p><p>答案是可以的。</p><p><strong>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的</strong>。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元组信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p><p>比如下面这张图，有 2 个 TCP 连接，左边是客户端，右边是服务端，客户端使用了相同的端口 50004 与两个服务端建立了 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/6.jpeg" alt="img"></p><p>仔细看，上面这两条 TCP 连接的四元组信息中的「目的 IP 地址」是不同的，一个是 180.101.49.12 ，另外一个是 180.101.49.11。</p><p>以上两个问题其实可以说是同一个问题，都是四元组相关的问题~</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP/HTTP】TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</title>
      <link href="/p/9ee60c65/"/>
      <url>/p/9ee60c65/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html#http-%E7%9A%84-keep-alive">4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding (xiaolincoding.com)</a></p><br><h1 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h1><p>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p><ul><li>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</li><li>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</li></ul><br><h1 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h1><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d6f6757c02e3afbf113d1048c937f8ee-20230309230800711.png" alt="HTTP 短连接"></p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，HTTP&#x2F;1.1 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong> 技术提供了可实现的基础。</p><p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/b3fa409edd8aa1dea830af2a69fc8a31.png" alt="右边为 HTTP 流水线机制"></p><p>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。</p><p>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。</p><p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p><p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p><p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/7e995ecb2e42941342f97256707496c9-20230309230749794.png" alt="HTTP 长连接超时"></p><br><h1 id="TCP-的-Keepalive（保活）"><a href="#TCP-的-Keepalive（保活）" class="headerlink" title="TCP 的 Keepalive（保活）"></a>TCP 的 Keepalive（保活）</h1><p>TCP 的 Keepalive 这东西其实就是<strong>TCP 的保活机制</strong>。</p><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/87e138ae9f2438c8f4e2c9c46ec40b95.png" alt="TCP 保活机制"></p><p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP】TCP 协议有什么缺陷？</title>
      <link href="/p/e74db628/"/>
      <url>/p/e74db628/</url>
      
        <content type="html"><![CDATA[<p>摘自：<a href="https://xiaolincoding.com/network/3_tcp/tcp_problem.html#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E8%BF%9F">4.16 TCP 协议有什么缺陷？ | 小林coding (xiaolincoding.com)</a></p><br><h1 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h1><p>主要有四个方面：</p><ul><li>升级 TCP 的工作很困难；</li><li>TCP 建立连接的延迟；</li><li>TCP 存在队头阻塞问题；</li><li>网络迁移需要重新建立 TCP 连接；</li></ul><br><h1 id="升级-TCP-的工作很困难"><a href="#升级-TCP-的工作很困难" class="headerlink" title="升级 TCP 的工作很困难"></a>升级 TCP 的工作很困难</h1><p>TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核。</p><p>而升级内核这个工作是很麻烦的事情，麻烦的事情不是说升级内核这个操作很麻烦，而是由于内核升级涉及到底层软件和运行库的更新，我们的服务程序就需要回归测试是否兼容新的内核版本，所以服务器的内核升级也比较保守和缓慢。</p><p>很多 TCP 协议的新特性，都是需要客户端和服务端<strong>同时支持</strong>才能生效的，比如 TCP Fast Open 这个特性，虽然在2013 年就被提出了，但是 Windows 很多系统版本依然不支持它，这是因为 PC 端的系统升级滞后很严重，Windows Xp 现在还有大量用户在使用，尽管它已经存在快 20 年。</p><p>所以，即使 TCP 有比较好的特性更新，也很难快速推广，用户往往要几年或者十年才能体验到。</p><br><h1 id="TCP-建立连接的延迟"><a href="#TCP-建立连接的延迟" class="headerlink" title="TCP 建立连接的延迟"></a>TCP 建立连接的延迟</h1><p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。</p><p>TCP 三次握手和 TLS 握手延迟，如图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/TCP%2BTLS.gif" alt="img"></p><p>TCP 三次握手的延迟被 TCP Fast Open （快速打开）这个特性解决了，这个特性可以在「第二次建立连接」时减少 TCP 连接建立的时延。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/45.jpg" alt="常规 HTTP 请求 与 Fast  Open HTTP 请求"></p><p>过程如下：</p><ul><li>在第一次建立连接的时候，服务端在第二次握手产生一个 <code>Cookie</code> （已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 <code>Cookie</code>，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个 RTT 的时延；</li><li>在下次请求的时候，客户端在 SYN 包带上 <code>Cookie</code> 发给服务端，就提前可以跳过三次握手的过程，因为 <code>Cookie</code> 中维护了一些信息，服务端可以从 <code>Cookie</code> 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</li></ul><p>TCP Fast Open 这个特性是不错，但是它需要服务端和客户端的操作系统同时支持才能体验到，而 TCP Fast Open 是在 2013 年提出的，所以市面上依然有很多老式的操作系统不支持，而升级操作系统是很麻烦的事情，因此 TCP Fast Open 很难被普及开来。</p><p>还有一点，针对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</p><p>也正是 TCP 是在内核实现的，所以 TLS 是无法对 TCP 头部加密的，这意味着 TCP 的序列号都是明文传输，所以就存安全的问题。</p><h2 id="安全问题例子"><a href="#安全问题例子" class="headerlink" title="安全问题例子"></a>安全问题例子</h2><p>一个典型的例子就是攻击者伪造一个的 RST 报文强制关闭一条 TCP 连接，而攻击成功的关键则是 TCP 字段里的序列号位于接收方的滑动窗口内，该报文就是合法的。</p><p>为此 TCP 也不得不进行三次握手来同步各自的序列号，而且初始化序列号时是采用随机的方式（不完全随机，而是随着时间流逝而线性增长，到了 2^32 尽头再回滚）来提升攻击者猜测序列号的难度，以增加安全性。</p><p>但是这种方式只能避免攻击者预测出合法的 RST 报文，而无法避免攻击者截获客户端的报文，然后中途伪造出合法 RST 报文的攻击的方式。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/A*po6LQIBU7zIAAAAAAAAAAAAAARQnAQ.png" alt="img"></p><p>大胆想一下，如果 TCP 的序列号也能被加密，或许真的不需要三次握手了，客户端和服务端的初始序列号都从 0 开始，也就不用做同步序列号的工作了，但是要实现这个要改造整个协议栈，太过于麻烦，即使实现出来了，很多老的网络设备未必能兼容。</p><br><h1 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h1><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p><p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><br><h1 id="TCP-存在队头阻塞问题"><a href="#TCP-存在队头阻塞问题" class="headerlink" title="TCP 存在队头阻塞问题"></a>TCP 存在队头阻塞问题</h1><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据（必须等待丢失的数据包重传后才能读取）。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif" alt="img"></p><p>这就是 TCP 队头阻塞问题，但这也不能怪 TCP ，因为只有这样做才能保证数据的有序性。</p><p>HTTP&#x2F;2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求，所以 HTTP&#x2F;2 队头阻塞问题就是因为 TCP 协议导致的。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/v2-2dd2a9fb8693489b9a0b24771c8a40a1_1440w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】来自天堂的魔鬼（Cover：Faouzia）【Sheena】【歌手2024】</title>
      <link href="/p/888c8bf3/"/>
      <url>/p/888c8bf3/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/来自天堂的魔鬼_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【Sheena】来自天堂的魔鬼_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《来自天堂的魔鬼》</p><p>翻唱：Sheena</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>双厨狂喜 更喜亚乐</p><br><p>第八期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1sb421n7T4/">BV1sb421n7T4</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1M_UGh5QR3MaXIfhQM28HyQ">https://pan.baidu.com/s/1M_UGh5QR3MaXIfhQM28HyQ</a></p><p>提取码: mqvf</p><p>BPM：136</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1ob421H7jM">【简醇品牌大使】凡希亚Faouzia《来自天堂的魔鬼》</a></p><p>作词：G.E.M.邓紫棋</p><p>作曲：G.E.M.邓紫棋</p><p>原唱：G.E.M.邓紫棋</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：陈牧荻@TalentUnion</p><p>改编编曲：吴铭然@TalentUnion&#x2F;冒振瑶@TalentUnion</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>弦乐：曜爆甘弦乐团</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>夜里做了美丽的噩梦</p><p>想清醒我却抵不过心动</p><p>梦里你是无底的黑洞</p><p>我无力抗拒失重</p> <br><p>我的意识自控脉搏流动</p><p>全被你神秘引力操控</p><p>亲爱的你是危险的迷宫</p><p>我找不到出口</p><br><p>You took my heart away</p><p>away away away</p><p>My head is blown away</p><p>away away away</p><p>你就是传说来自天堂的魔鬼</p><p>Cause you took my heart away</p><p>away away away</p><p>away away away</p><br><p>拜托别对我细心问候</p><p>这是你也不察觉的阴谋</p><p>我讨厌你无心的微笑</p><p>我快无可救药</p><br><p>你像一个漩涡慢慢让我</p><p>无法抽离一直地坠落</p><p>亲爱的你是优雅的恶魔</p><p>一点一点把我吞没</p><br><p>You took my heart away</p><p>away away away</p><p>My head is blown away</p><p>away away away</p><p>你就是传说来自天堂的魔鬼</p><p>Cause you took my heart away</p><p>away away away</p><p>away away away</p><br><p>如果你是蛇的诱惑</p><p>你存心迷惑 我才能软弱</p><p>但你是牛顿头上那颗</p><p>若无其事的苹果</p><br><p>away away away</p><p>You took my heart away</p><p>away away away</p><br><p>My head is blown away</p><p>away away away</p><br><p>你就是传说来自天堂的魔鬼</p><p>Cause you took my heart away</p><p>away away away</p><p>away away away</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Faouzia </tag>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> Sheena </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】兰花花儿 (live)【歌手2024】</title>
      <link href="/p/477dbe08/"/>
      <url>/p/477dbe08/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%85%B0%E8%8A%B1%E8%8A%B1%E5%84%BF.jpg"></p><p>已灌词</p><p>BPM：126</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 董玉方&#x2F;舟也</p><p>作曲 : 舟也</p><p>原唱 : 谭维维</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：舟也</p><p>编曲：舟也</p><p>混音：林梦洋</p><p>PGM：杨阳</p><p>录音吉他：高飞</p><p>和声编写：舟也</p><p>PGM混音：Kay</p><p>吉他：刘迦宁&#x2F;大迪</p><p>贝斯：周冠辰</p><p>鼓手：王澜</p><p>键盘：高做</p><p>二胡：檀一&#x2F;邹晖</p><p>中音板胡：郭劼姝</p><p>高音板胡：李超</p><p>原生态助唱：丁文军</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1wuWxXKYz0ZXg4XgFlb-RhA">https://pan.baidu.com/s/1wuWxXKYz0ZXg4XgFlb-RhA</a></p><p>提取码: w286</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>兰花花我问你个事啊</p><p>你的性子咋楞个的倔呀</p><p>兰花花我问你个事啊</p><p>你这辈子他图了个啥吗</p> <br><p>得势的鱼儿它天上飞呀</p><p>落魄的凤凰它水里栖呀</p><p>黄河的水呀它流不尽呀</p><p>西北的风呀它倒着刮呀</p> <br><p>这不求人的性格是爹妈教的</p><p>这不认输的性格是娘胎里带的</p><p>这不弯腰的性格是老天给练的</p><p>这不回头的性格是骨头里长的</p> <br><p>这喊破天的声音是自己喊的</p><p>这道破天的道理是自己悟的</p><p>这撕破脸的人生是自己造的</p><p>这撞破头的出路是自己找的</p> <br><p>我咬碎个牙顶一个天</p><p>让你们都看一哈</p><p>我剩了个啥 我剩了个啥</p><p>我剩了一腔血气 留给你呀</p> <br><p>天上的月亮它不会掉啊</p><p>泥里的野草它不会倒啊</p><p>谢了的花儿又开满山啊</p><p>咱家的娃娃又满街跑啊</p> <br><p>这喊破天的声音是自己喊的</p><p>这道破天的道理是自己悟的</p><p>这撕破脸的人生是自己造的</p><p>这撞破头的出路是自己找的</p> <br><p>我咬碎个牙顶一个天</p><p>让你们都看一哈</p><p>我图了个啥 我图了个啥呀</p><p>我图个干干净净 送给你呀</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 谭维维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】Close To You (live)【歌手2024】</title>
      <link href="/p/38e8a510/"/>
      <url>/p/38e8a510/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Close+To+You.jpg"></p><p>已灌词</p><p>BPM：132</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>词曲 : Burt Bacharach&#x2F;Hal David</p><p>原唱 : Carpenters</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：YELLOW黄宣&#x2F;余佳伦</p><p>改编编曲：YELLOW黄宣&#x2F;余佳伦</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Ben Pelletier</p><p>萨克斯&#x2F;长笛：Paulo Levi</p><p>小号：JQ Whitcomb</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1lOI2ccbzUFN4E3noXsngaQ">https://pan.baidu.com/s/1lOI2ccbzUFN4E3noXsngaQ</a></p><p>提取码: 5wkp</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>Why do birds suddenly appear</p><p>Everytime you are near</p><p>Just like me</p><p>They long to be</p><p>Close to you</p> <br><p>Why do stars fall down from the sky</p><p>Everytime you walk by</p><p>Just like me</p><p>They long to be</p><p>Close to you</p> <br><p>On the day that you were born</p><p>The angels got together</p><p>And decided to create a dream come true</p><p>So they sprinkled moon dust in your hair of gold</p><p>And starlight in your eyes of blue</p> <br><p>But only blue only blue</p><p>没有人能像你</p><p>我的心我的心蓝蓝的</p> <br><p>That is why all the boys in town</p><p>Follow you and all around</p><p>Just like me</p><p>They long to be</p><p>Close to you</p> <br><p>That is why all the boys in town</p><p>Follow you and all around</p><p>Just like me</p><p>They long to be</p><p>Close to you</p> <br><p>Only blue only blue</p><p>爱让人好忧郁</p><p>我的心我的心蓝蓝的</p> <br><p>但我真的想找一条船</p><p>能远远离开这片沙滩</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 黄宣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】一颗星的夜 (live)【歌手2024】</title>
      <link href="/p/dfb41864/"/>
      <url>/p/dfb41864/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E4%B8%80%E9%A2%97%E6%98%9F%E7%9A%84%E5%A4%9C.jpg"></p><p>已灌词</p><p>BPM：140</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 金灿灿</p><p>作曲 : 钱雷</p><p>原唱 : 尤长靖</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：钱雷&#x2F;刘卓</p><p>改编编曲：钱雷</p><p>录音和音：樊竹青&#x2F;王笑文&#x2F;朱江&#x2F;宋豪</p><p>录音吉他：高飞</p><p>吉他录音：付威@Legend（来真的•北京）Recording Studio</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein 杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1ayo68By7H1HcwTswma8T6w">https://pan.baidu.com/s/1ayo68By7H1HcwTswma8T6w</a></p><p>提取码: df6r</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>我对我的梦有种迷恋</p><p>大于痛苦大于这世界</p><p>就像只有一颗星的夜</p><p>它的闪耀 它的孤单</p><p>不用被看见</p> <br><p>谁又能生来拥有一切</p><p>一无所有 不是命中</p><p>注定的预言</p><p>所以我要自由的明天</p><p>也许灿烂 也许平淡</p><p>我不会改变</p> <br><p>选择孤独 不可以哭</p><p>再多的伤痛我也不认输</p><p>选择孤独 不可以哭</p><p>所有付出换我自由的路</p> <br><p>所有付出换我梦中的路</p> <br><p>路过的繁华不是终点</p><p>也会相遇后各自走远</p><p>当我跨过冰川和火焰</p><p>跨过流言 许多成长</p><p>就在一瞬间</p> <br><p>也许明天 也许明天</p><p>我带着伤疤兑现了诺言</p><p>就在明天 告诉世界</p><p>告诉自己没辜负这黑夜</p> <br><p>自由的路</p> <br><p>告诉自己没辜负这世界</p><p>就像只有那一颗星的夜</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 尤长靖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】Never Enough (live)【歌手2024】</title>
      <link href="/p/b0e3506b/"/>
      <url>/p/b0e3506b/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Never+Enough.jpg"></p><p>已灌词</p><p>BPM：132</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>词曲 : BENJ PASEK&#x2F;JUSTIN PAUL</p><p>原唱 : Loren Allred</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：Nick Pyo</p><p>人声设计&#x2F;和声：Kim Heeyoung</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1OAEQK4Jh61x0yjcp9niLYg">https://pan.baidu.com/s/1OAEQK4Jh61x0yjcp9niLYg</a></p><p>提取码: uez9</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>I’m trying to hold my breath</p><p>Let it stay this way</p><p>Can’t let this moment end</p><p>You set off a dream in me</p><p>Getting louder now</p><p>Can you hear it echoing</p> <br><p>Take my hand</p><p>Will you share this with me</p><p>‘Cause darling without you</p> <br><p>All the shine of a thousand spotlights</p><p>All the stars we steal from the night sky</p><p>Will never be enough</p><p>Never be enough</p> <br><p>Towers of gold are still too little</p><p>These hands could hold the world</p><p>But it’ll never be enough</p><p>Never be enough</p><p>For me</p><p>Never never</p><p>Never never</p><p>Never</p><p>For me for me</p> <br><p>Never enough</p><p>Never enough</p><p>Never enough</p><p>For me for me</p><p>For me</p> <br><p>All the shine of a thousand spotlights</p><p>All the stars we steal from the night sky</p><p>Will never be enough</p><p>Never be enough</p> <br><p>Towers of gold are still too little</p><p>These hands could hold the world</p><p>Butit’ll never be enough</p><p>Never be enough</p> <br><p>For me</p> <br><p>Never never</p><p>Never never</p><p>Never</p><p>For me for me</p> <br><p>Never enough</p><p>Never enough</p><p>Never enough</p><p>For me for me</p><p>For me</p> <br><p>For me</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Chanté Moore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】愚人歌（和声付）【银临×李常超】【山色有无中】</title>
      <link href="/p/e17fd725/"/>
      <url>/p/e17fd725/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%e3%80%90%e9%93%b6%e4%b8%b4%c3%97%e6%9d%8e%e5%b8%b8%e8%b6%85%e3%80%91%e5%81%9a%e7%97%9b%e5%bf%ab%e7%9a%84%e5%82%bb%e4%ba%8b%ef%bc%8c%e4%bd%9c%e5%bf%ab%e6%84%8f%e7%9a%84%e6%84%9a%e4%ba%ba%ef%bd%9c%e3%80%8a%e6%84%9a%e4%ba%ba%e6%ad%8c%e3%80%8b%e2%80%94%e2%80%94+%e5%9b%9b%e4%b8%93%e3%80%8c%e5%b1%b1%e8%89%b2%e6%9c%89%e6%97%a0%e4%b8%ad%e3%80%8d%e7%ac%ac%e5%9b%9b%e6%9b%b2.jpg"></p><div style="text-align:center;">做痛快的傻事，作快意的愚人。</div><div style="text-align:right;">——题记</div><br><p>已灌词</p><p>BPM：102</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/video/BV12b4y1L7ER/?spm_id_from=333.999.0.0&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【银临×李常超】做痛快的傻事，作快意的愚人｜《愚人歌》—— 四专「山色有无中」第四曲</a></p><p>作词 : 慕清明</p><p>作曲 : 银临</p><p>编曲 : 1AN孙毅然</p><p>制作人 : 银临</p><p>混音&amp;母带 : 郭子敬</p><p>和声编唱 : 银临</p><p>吉他 : RK</p><p>统筹 : 旺仔</p><p>OP : 银临工作室</p><p>SP : 万象凡音</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1eTOplusUV8dnMS-u4BnWsQ">https://pan.baidu.com/s/1eTOplusUV8dnMS-u4BnWsQ</a></p><p>提取码: hers</p><h2 id="试听"><a href="#试听" class="headerlink" title="试听"></a>试听</h2><iframe class="bvideo" width="100%" height="600" src="//player.bilibili.com/player.html?autoplay=0&bvid=BV19i421e76Q" border="0" frameBorder="no" framespacing="0" allowFullScreen="true"></iframe><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>银临:</p><p>明知翌日终究要逝入夜凉</p><p>只余片刻灰白的绝响</p><p>看天星看至盲 追山月追断肠</p><p>心火更与劫火相仿</p> <br><p>却要螳臂当车放肆那荒唐</p><p>泼辣的梦攥住了刀光</p><p>如天翻如来掌 千重山千里瘴</p><p>烧不尽的顽劣生长</p><br><p>李常超:</p><p>长风倒挂悬九霄 尘世何处不寂寥</p><p>将一生快意倾壶浇 孤注残阳照</p><br><p>合唱:</p><p>曾有一人追逐烈日痛饮山海</p><p>葬于青林万壑哀</p><p>天地皆被拥入最浩阔胸怀</p><p>八荒六合生生不息几万载</p><br><p>曾有一人长舞干戚云澎湃</p><p>断首折脊只为这场败</p><p>你听今夜命运落下雪皑皑</p><p>风吹巉崖竟自刹那生春苔</p><br><p>（music）</p><br><p>银临:</p><p>束缚的爱都抛下任其荒凉</p><p>只去摘落烫手的妄想</p><p>遍身处遍地霜 无尽梦无尽唱</p><p>不走旁人给的远方</p><br><p>从此逆水行舟一万里诗行</p><p>像风一样张狂地流淌</p><p>枕烟雨枕黄粱 在人群在穹苍</p><p>方寸之间亦可无疆</p><br><p>李常超:</p><p>长风倒挂悬九霄 尘世何处不寂寥</p><p>将一生快意倾壶浇 孤注残阳照</p><br><p>合唱：</p><p>曾有一人信誓要将太行掀开</p><p>单凭此身尚未埋</p><p>抬眼望去皎洁秋月宴孤槐</p><p>一场好梦也算圆满鬓上白</p><br><p>曾有一人衔石沉入浪千拍</p><p>浩歌当哭等结局到来</p><p>万箭穿心犹然还不知悔改</p><p>见你付之一笑泥尘里盛开</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 银临 </tag>
            
            <tag> 李常超 </tag>
            
            <tag> 山色有无中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】星辰大海 (live)【歌手2024】</title>
      <link href="/p/e1fe458c/"/>
      <url>/p/e1fe458c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7.jpg"></p><p>已灌词，可能会不准确，使用请注意！</p><p>BPM：变速</p><hr><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240626175447400.png" alt="image-20240626175447400"></p><p>《星辰大海》</p><p>词Lyrics：瞿子千&#x2F;刘涛&#x2F;温莨</p><p>曲Music：瞿子千&#x2F;刘涛</p><p>原唱：黄霄雲</p><p>《人鱼之歌》</p><p>曲：闫骁男&#x2F;刘思情@骁Studio<br>原唱：朵莉亚<br>特别鸣谢：Sam Yang<br>原曲制作：TIMI Audlo Lab<br>原曲出品：天美工作室群<br>音乐总监：陈建骐<br>音响总监：何飚<br>音乐设计：Erlc<br>改编编曲：马克<br>混音：林梦洋<br>乐队队长&#x2F;键盘：吴加恩<br>盘：Euywein杨展鸿<br>古他：金冬显&#x2F;谭鑫<br>贝斯：陈任佑<br>鼓：李彦超<br>打击乐：Cody Byassee<br>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音<br>PGM：杨阳<br>长号：Terence Hsieh谢燕辉<br>萨克斯&#x2F;长笛：苏圣育<br>小号：JQ Whitcomb<br>弦乐：曜爆甘弦乐团</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/14FVEGsZoLWZ1cPo-ibvITw">https://pan.baidu.com/s/14FVEGsZoLWZ1cPo-ibvITw</a></p><p>提取码: 8hbc</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>我愿变成一颗恒星</p><p>守护海底的蜂鸣</p><p>It’s my dream it’s magic</p><p>照亮你的心</p><p>To your eyes 有多远的距离</p><p>穿过人海 别停下来</p><p>趁现在还有期待</p> <br><p>会不会我们的爱</p><p>会被风吹向大海</p><p>不再回来</p><p>每当你向我走来</p><p>告诉我星辰大海</p> <br><p>（人鱼之歌）</p> <br><p>漫漫长夜 不曾离开</p><p>我向你奔赴而来</p><p>趁现在还有期待</p> <br><p>遥遥微光 与我同行</p><p>盛开在黎明</p><p>To your eyes 有多远的距离</p><p>穿过人海 别停下来</p><p>趁现在还有期待</p> <br><p>会不会我们的爱</p><p>会被风吹向大海</p><p>不再回来</p><p>每当你向我走来</p><p>告诉我星辰大海</p> <br><p>星辰大海</p> <br><p>你就是星辰大海</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 黄霄雲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】傻瓜 (live)【歌手2024】</title>
      <link href="/p/636cfdea/"/>
      <url>/p/636cfdea/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%82%BB%E7%93%9C.jpg"></p><p>已灌词</p><p>BPM：120</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 吴克群</p><p>作曲 : 吴克群</p><p>原唱 : 温岚</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人: 汪苏泷</p><p>改编编曲: 谷粟</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1S8yVxVSIYzoHjCdI5UxjyA">https://pan.baidu.com/s/1S8yVxVSIYzoHjCdI5UxjyA</a></p><p>提取码: 6fg7</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>其实他做的坏事我们都懂</p><p>没有什么不同</p><p>眼光闪烁 暧昧流动</p><p>闭上眼当作听说</p> <br><p>其实别人的招数我们都懂</p><p>没有什么不同</p><p>故作软弱 撒娇害羞</p><p>只是有一点别扭</p> <br><p>傻瓜也许单纯得多</p><p>爱得没那么做作</p><p>爱上了我不保留</p> <br><p>傻瓜 我们都一样</p><p>被爱情伤了又伤</p><p>相信这个他不一样</p><p>却又再一次受伤</p> <br><p>傻瓜 我们都一样</p><p>受了伤却不投降</p><p>相信付出会有代价</p><p>代价只是一句傻瓜</p> <br><p>其实别人的招数我们都懂</p><p>没有什么不同</p><p>故作软弱 撒娇害羞</p><p>只是有一点别扭</p> <br><p>傻瓜也许单纯得多</p><p>爱得没那么做作</p><p>爱上了我不保留</p> <br><p>傻瓜 我们都一样</p><p>被爱情伤了又伤</p><p>相信这个他不一样</p><p>却又再一次受伤</p> <br><p>傻瓜 我们都一样</p><p>受了伤却不投降</p><p>相信付出会有代价</p><p>代价只是一句傻瓜 傻瓜</p> <br><p>傻瓜 我们都一样</p><p>被爱情伤了又伤</p><p>相信这个他不一样</p><p>却又再一次受伤</p> <br><p>傻瓜 我们都一样</p><p>受了伤却不投降</p><p>相信付出会有代价</p><p>代价只是一句傻瓜</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 汪苏泷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】说谎 (live)【歌手2024】</title>
      <link href="/p/7b854cb7/"/>
      <url>/p/7b854cb7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E8%AF%B4%E8%B0%8E.jpg"></p><p>已灌词</p><p>BPM：94</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 徐哲纬</p><p>作曲 : 徐伟铭</p><p>原唱 : 张信哲</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：陈牧荻@TalentUnion</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/17a--x8j9I2HxYjxWVwwfPQ">https://pan.baidu.com/s/17a--x8j9I2HxYjxWVwwfPQ</a></p><p>提取码: gztw</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>这次我又担心到天亮</p><p>现在你靠在谁身旁</p><p>窗外透进来的光</p><p>照得心发慌</p><p>熬过了失眠的晚上</p> <br><p>每次你的理由都一样</p><p>其实我都懂只是不讲</p><p>把自己弄得很忙</p><p>其实是假装</p><p>看你这次要怎么收场</p> <br><p>我说我会是你可以依靠的肩膀</p><p>而你却站在离我最远的地方</p><p>我爱你的心一样</p><p>总是选择原谅</p><p>你有多少借口</p><p>除了说谎</p> <br><p>如果我不是你可以停靠的地方</p><p>我们就到此为止不必再勉强</p><p>现在开始不一样</p><p>像路人经过身旁</p><p>你也不必装模作样</p><p>我会遗忘</p><p>别再说谎</p> <br><p>每次你的理由都一样</p><p>其实我都懂只是不讲</p><p>把自己弄得很忙</p><p>其实是假装</p><p>看你这次要怎么收场</p> <br><p>我说我会是你可以</p><p>依靠的肩膀</p><p>而你却站在离我</p><p>最远的地方</p><p>我爱你的心一样</p><p>总是选择原谅</p><p>你有多少借口</p><p>除了说谎</p> <br><p>如果我不是你可以停靠的地方</p><p>我们就到此为止不必再勉强</p><p>现在开始不一样</p><p>像路人经过身旁</p><p>你也不必装模作样</p><p>我会遗忘</p><p>别再说谎</p> <br><p>我说我会是你可以</p><p>依靠的肩膀</p><p>而你却站在离我</p><p>最远的地方</p><p>我爱你的心一样</p><p>总是选择原谅</p><p>你有多少借口</p><p>除了说谎</p> <br><p>如果我不是你可以</p><p>停靠的地方</p><p>我们就到此为止</p><p>不必再勉强</p><p>现在开始不一样</p><p>像路人经过身旁</p><p>你也不必装模作样</p> <br><p>我会遗忘</p><p>别再说谎</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 张信哲 </tag>
            
            <tag> 张远 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】有一种悲伤 (live)【歌手2024】</title>
      <link href="/p/b3a61240/"/>
      <url>/p/b3a61240/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%9C%89%E4%B8%80%E7%A7%8D%E6%82%B2%E4%BC%A4.jpg"></p><p>已灌词</p><p>BPM：80</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 林孝谦</p><p>作曲 : 张简君伟</p><p>原唱 : 黄丽玲</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：张亦江</p><p>改编编曲：张亦江&amp;AST</p><p>混音：林梦洋</p><p>乐队队长&#x2F;钢琴：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>黑管：苏圣育</p><p>弦乐：曜爆甘弦乐团</p><p>第一小提琴：蔡曜宇</p><p>第二小提琴：黄雨柔</p><p>中提琴：潘自琦</p><p>大提琴：吴玟錤</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1XMhrD24c8rUYFvmwKo2ifg">https://pan.baidu.com/s/1XMhrD24c8rUYFvmwKo2ifg</a></p><p>提取码: si8c</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>我不羡慕太阳</p><p>照不亮你过往</p><p>有些黑暗我们都一样</p><p>我太嫉妒时光</p><p>能离开得大方</p><p>不用开口也就无需躲藏</p> <br><p>有一种悲伤</p><p>是你的名字停留在我的过往</p><p>陪伴我呼吸决定我微笑模样</p><p>无法遗忘</p><p>有一种悲伤</p><p>是笑着与你分开</p><p>思念却背对背张望</p><p>剩下倔强剩下合照一张</p> <br><p>我太嫉妒时光</p><p>能离开得大方</p><p>不用开口也就无需躲藏</p> <br><p>有一种悲伤</p><p>是你的名字停留在我的过往</p><p>陪伴我呼吸决定我微笑模样</p><p>无法遗忘</p><p>有一种悲伤</p><p>是笑着与你分开</p><p>思念却背对背张望</p><p>剩下倔强剩下合照一张</p> <br><p>成为彼此的路多向往</p><p>怎会失去方向</p> <br><p>有一种悲伤</p><p>是你的名字停留在我的过往</p><p>陪伴我呼吸决定我微笑模样</p><p>无法遗忘</p> <br><p>有一种悲伤</p><p>是你义无反顾让爱成为我身上的光</p><p>给我温暖却不准我遗忘</p> <br><p>剩下倔强剩下合照一张</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 孙楠 </tag>
            
            <tag> 黄丽玲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】突然想念 (live)【歌手2024】</title>
      <link href="/p/64f43fb4/"/>
      <url>/p/64f43fb4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E7%AA%81%E7%84%B6%E6%83%B3%E5%BF%B5.jpg"></p><p>已灌词</p><p>BPM：102</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>作词 : 王耀光</p><p>作曲 : 崔万平</p><p>原唱 : 金志文</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：崔万平@维伴音乐&#x2F;崔迪&#x2F;刘卓@维伴音乐</p><p>改编编曲：崔万平@维伴音乐&#x2F;王智超&#x2F;刘卓@维伴音乐</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：陈任佑</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：JQ Whitcomb</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/15CQnMRAdvNaNJ-jJdwo6yg">https://pan.baidu.com/s/15CQnMRAdvNaNJ-jJdwo6yg</a></p><p>提取码: 22ir</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>辗转一整夜</p><p>习惯性失眠</p><p>蓝色的光线透过窗帘边缘</p><p>街灯都熄灭</p> <br><p>但心中此刻燃起</p><p>莫名其妙的想念</p><p>乱了时间</p><p>就在这瞬间</p><p>多想有你在我身边</p> <br><p>突然想念</p><p>那些时间</p><p>对你的眷恋最后才发现</p><p>却转眼 已遥远</p> <br><p>翻阅着从前</p><p>照片和留言</p><p>舍不得删除关于你的一切</p><p>恨不够坚决</p> <br><p>我始终无法停止</p><p>对你无尽的想念</p><p>乱了时间</p><p>就在这瞬间</p><p>多想有你在我身边</p> <br><p>突然想念</p><p>那些时间</p><p>对你的眷恋最后才发现</p><p>却转眼 已遥远</p> <br><p>突然想念</p><p>那些时间</p><p>对你的眷恋最后才发现</p><p>却转眼</p> <br><p>突然想念</p><p>乱了时间</p><p>就在这瞬间</p><p>多想有你在我身边</p> <br><p>突然想念</p><p>那些时间</p><p>对你的眷恋最后才发现</p><p>却转眼 已遥远</p><br><p>对你的眷恋已遥远</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】归途有风（Cover: 尚雯婕）【东方栀子Nectar】【歌手2024】</title>
      <link href="/p/800f9a11/"/>
      <url>/p/800f9a11/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/归途有风_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【东方栀子Nectar】归途有风_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《归途有风》</p><p>翻唱：东方栀子Nectar·晌</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：CCrystael</p><p>B站版PV：結月林</p><br><p>第一次调栀子 被ACE咬字气晕.jpg</p><p>感谢CC的混音！！！</p><br><p>第六期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1Er421F7Q9/">BV1Er421F7Q9</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1M5C15d8ud8h0RD-cZcYkrw">https://pan.baidu.com/s/1M5C15d8ud8h0RD-cZcYkrw</a></p><p>提取码: 7t77</p><p>BPM：76</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>本家：<a href="https://www.bilibili.com/video/BV1Ti421e75F/">【歌手2024】《归途有风》冲榜赛直播|尚雯婕”不问得失 无悔对错”_哔哩哔哩_bilibili</a></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240618130201.png" alt="字那么小是在给谁看啊啊啊啊"></p><p>作词：唐恬@勇士音乐</p><p>作曲：钱雷@勇士音乐</p><p>原唱：王菲</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：孔潇一K.I.X</p><p>改编编曲：余威</p><p>人声设计：王馨卉&#x2F;？？</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：张梦斌</p><p>鼓：陈志昆</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;胡维纳@爱之音&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>要 穿过那 世间的火</p><p>要 尝过一生 炙热的默</p><p>有多少 不得已 来不及 还流浪在梦里</p><p>才可明白 为何而来</p><br><p>要 放开过 勿放的手</p><p>要 千山万水 懂得泪流</p><p>要风起 要别离 要万里 要归期不由你</p><p>才可明白 为何回头</p><p>谁在唤我</p><p>唤我的名字 我的远走</p><p>我没说的 爱与歉疚</p><p>请让风声 带我回家</p><p>让它告诉我</p><p>抉择多难 都已做过</p><p>不问得失 无悔对错</p><p>让月光 带我回家</p><p>让来路 带我回家吧 归途中</p><br><p>别睡 要走向篝火 满身风沙的人呐</p><p>把行囊 都烧了 爱仅需空着两手</p><p>别退 要走向脆弱 听见哭声的人呐</p><p>门背后 是谁呢 拥抱着 你的噩梦</p><p>Wu</p><p>离开的 会重逢</p><br><p>谁在唤我</p><p>唤我的名字 我的远走</p><p>我没说的 爱与歉疚</p><p>一声声 带我回家</p><p>记得告诉我</p><br><p>该我赴的约 都已赴过</p><p>不问得失 无悔对错</p><p>让月光 带我回家 牵着我的手</p><p>让来路 带我回来吧 归途上 总有风</p><p>泪与泪重逢</p><p>唯有爱证明活着</p><br><p>唤我的名字 我的远走</p><p>我没说的 爱与歉疚</p><p>一声声 带我回家</p><p>记得告诉我</p><br><p>该我赴的约 都已赴过</p><p>不问得失 无悔对错</p><p>让月光 带我回家 牵着我的手</p><p>让来路 带我回来吧 回来吧</p><br><p>听见了吗 要走向篝火</p><p>别睡着了 这不是尽头</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌手2024 </tag>
            
            <tag> ACE Studio </tag>
            
            <tag> 尚雯婕 </tag>
            
            <tag> 东方栀子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】人是_【周深】【孙楠】【歌手2024】</title>
      <link href="/p/4a48b34c/"/>
      <url>/p/4a48b34c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/d8bb3404c4568b327bf3b2f456843c3f4b6c3f3d.jpg"></p><p>BPM：106</p><p>已灌词</p><p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%e5%ad%99%e6%a5%a0+-+%e4%ba%ba%e6%98%af_.jpg"></p><p>BPM：104（变速）</p><p>已灌词</p><br><h1 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h1><p>链接: <a href="https://pan.baidu.com/s/1oDH4neFCYi91672egWjcgQ">https://pan.baidu.com/s/1oDH4neFCYi91672egWjcgQ</a></p><p>提取码: nkxu</p><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><h2 id="周深版"><a href="#周深版" class="headerlink" title="周深版"></a>周深版</h2><p>本家：<a href="https://www.bilibili.com/video/BV1bY41197mq/?spm_id_from=333.788.recommend_more_video.-1&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">《流浪地球2》定义主题曲《人是_》MV！纵使光亮微茫，依然奋力前行！命运打不败活着！_哔哩哔哩_bilibili</a></p><p>作词 : 唐恬</p><p>作曲 : 钱雷</p><p>编曲 : 钱雷</p><p>制作人 : 钱雷</p><p>配唱编写 : 钱雷@勇士音乐</p><p>主唱录音&#x2F;编辑：徐威@52Hz Studio</p><p>主唱录音棚：55Tec Beijing</p><p>弦乐编写：胡静成</p><p>弦乐：国际首席爱乐乐团</p><p>中提琴：毕芳</p><p>弦乐录音：王小四@金田录音棚</p><p>混音&amp;母带：姚海毅@勇士音乐</p><p>统筹执行：王山山@勇士音乐</p><p>词曲版权管理方：索尼音乐版权代理（北京）有限公司</p><p>特别鸣谢：周深工作室</p><p>监制：高航、大晶</p><p>音乐统筹及营销：奔跑怪物</p><br><h2 id="孙楠版"><a href="#孙楠版" class="headerlink" title="孙楠版"></a>孙楠版</h2><p>本家：<a href="https://www.mgtv.com/b/645759/21162852.html">孙楠《人是_》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>作词 : 唐恬</p><p>作曲 : 钱雷</p><p>原唱 : 周深</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：张亦江</p><p>改编编曲：郭晓峰&#x2F;张亦江</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F;谭鑫</p><p>贝斯：张梦斌</p><p>鼓：陈志昆</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;胡维纳@爱之音&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：苏圣育</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>去往所有命运 风暴之中的盲童</p><p>你来自火山炙热与苦寒的深海</p><p>生本就是意外 硬币反选为尘埃</p><p>为侥幸可以相爱造了船移着山</p><p>出征是古老的宿命 人将赤足踏入夜晚</p><p>只有我可以来决定我以何种姿态</p><br><p>让死亡觊觎我</p><p>让恐惧亲吻我</p><p>来摧毁我深爱的一切</p><p>可仍夺不走我的选择</p><p>弹指间湮灭我</p><p>但命运打不败活着</p><p>让生命如剧烈的烟火</p><p>璀璨熄灭前也将点亮</p><p>孩童的双眸</p><br><p>未知摊开棋局舍弃昨日才可破</p><p>再见了我的月光我的蓝我的爱</p><p>钢铁的巨兽在轰鸣 我们拒绝走入夜晚</p><p>破碎是新生的约定我便愿为尘埃</p><br><p>让死亡觊觎我</p><p>让恐惧亲吻我</p><p>来摧毁我深爱的一切</p><p>可仍夺不走我的选择</p><p>弹指间湮灭我</p><p>但命运打不败活着</p><p>让生命如剧烈的烟火</p><p>璀璨熄灭前也将点亮</p><p>孩童的双眸</p><br><p>若巨浪已淹没了来路 我是帆亦是舟</p><p>是微渺的希望 我们依然前行没有光指引</p><p>往前吧失去吧不要停留</p><br><p>让时空消亡我</p><p>你无需记得我</p><p>来摧毁我深爱的一切</p><p>可仍夺不走我的选择</p><p>弹指间湮灭我</p><p>但命运打不败活着</p><p>是微茫中高歌的族类</p><p>生命像烟火那就点亮</p><p>孩童的双眸</p><p>未来的瞳孔</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 孙楠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SyncTV &amp; AList 配置教程</title>
      <link href="/p/b3641215/"/>
      <url>/p/b3641215/</url>
      
        <content type="html"><![CDATA[<p>此处默认宝塔已安装，不会的朋友可以翻翻我前面不知道多少篇教程（</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>确保端口<code>8080</code>没有被别的什么东西占用！！！有的话改成别的！</p><p>因为<code>SyncTV</code>会默认占用<code>8080</code>端口，而且也找不到哪里可以改（</p><p>全网肯定找不到第二篇说这个的，三连吧还等什么（不是</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>点击宝塔面板左侧的<code>Docker</code>，如果还没安装过，直接点击安装即可</p><h1 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>然后点击<code>镜像</code>-<code>搜索镜像</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240616232728976.png" alt="image-20240616232728976"></p><p>搜索：<code>synctvorg/synctv</code>，点击<code>拉取</code>即可</p><h2 id="创建容器-1"><a href="#创建容器-1" class="headerlink" title="创建容器"></a>创建容器</h2><p>点击<code>容器</code>-<code>创建容器</code>，名称随便输，镜像选择刚刚拉取的，端口添加一组映射：自定义端口→8080</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240616233516700.png" alt="image-20240616233516700"></p><p>别忘了在防火墙开放自定义端口！</p><h1 id="访问SyncTV"><a href="#访问SyncTV" class="headerlink" title="访问SyncTV"></a>访问SyncTV</h1><p>然后就可以访问了</p><p>默认的账密都是<code>root</code></p><h2 id="注册相关"><a href="#注册相关" class="headerlink" title="注册相关"></a>注册相关</h2><p>注册的话目前没找到可以从哪里点进去，但是是有这么一个页面的，可以输地址访问（<code>.../web/auth/register</code>）</p><p>然后相应的设置也别忘了开</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240616234013521.png" alt="image-20240616234013521"></p><p>不过小范围用的话没必要了，直接后台添加就可以</p><h2 id="播放相关"><a href="#播放相关" class="headerlink" title="播放相关"></a>播放相关</h2><h3 id="视频直链"><a href="#视频直链" class="headerlink" title="视频直链"></a>视频直链</h3><p>需要保证链接是自己可以通过地址栏输入访问到的，但是因为大部分都有防盗链的，这个基本没啥用</p><p>而且自定义header也是摆设，加不了一点，官方的回复是：有些header会被浏览器限制的，使用代理功能</p><p>然而使用代理也无法避免403的问题，所以这个功能很难评 我祝他成功吧</p><h3 id="直播流"><a href="#直播流" class="headerlink" title="直播流"></a>直播流</h3><p>目前测试下来，播B站的会有比较<strong>频繁</strong>的卡住的问题，需要取消再播放才可以，也约等于摆设。。。</p><p>其他的直播源未测试</p><h1 id="AList配置"><a href="#AList配置" class="headerlink" title="AList配置"></a>AList配置</h1><p>直接在宝塔的软件商店里面搜索<code>alist</code>安装即可</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240616234838980.png" alt="image-20240616234838980"></p><p>点击设置里面的链接即可访问（别忘了开放端口）</p><p>登录后点击左侧的<code>存储</code>-<code>添加</code>，选择对应的盘添加即可，详细看官方文档吧，很详细</p><p><a href="https://alist.nn.ci/zh/guide/drivers/local.html">本地存储 | AList文档 (nn.ci)</a></p><h2 id="使用AList"><a href="#使用AList" class="headerlink" title="使用AList"></a>使用AList</h2><p>在<code>SyncTV</code>个人中心处绑定后即可使用</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240616235335619.png" alt="image-20240616235335619"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://it.zaojiamao.vip/index.php/2024/06/13/synctv%E5%92%8C%E4%BD%A0%E7%9A%84%E5%BC%82%E5%9C%B0%E6%81%8B%E5%B0%8F%E5%A5%B3%E5%8F%8B%E7%9C%8B%E5%B0%8F%E8%A7%86%E9%A2%91%E7%9A%84%E7%B3%BB%E7%BB%9F/">SyncTV和你的异地恋小女友看小视频的系统-狗哥论坛-网络技术 (zaojiamao.vip)</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SyncTV </tag>
            
            <tag> AList </tag>
            
            <tag> 宝塔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【永夜Minus】呼吸决定（Cover：Fine乐团）【歌手2024】</title>
      <link href="/p/53bc1fc9/"/>
      <url>/p/53bc1fc9/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/呼吸决定_cover1.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【永夜Minus】呼吸决定_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《呼吸决定》</p><p>翻唱：永夜Minus</p><p>扒谱：磷元素</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>这次调点简单的！</p><br><p>第五期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1YJ4m1g7uR/">BV1YJ4m1g7uR</a></p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 刘冠南</p><p>作曲 : 刘冠南</p><p>原唱 : Fine乐团</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：赖伟哲</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：甯子达（阿达）</p><p>鼓：李定楠</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><p>Fine乐团主唱：乔西</p><p>Fine乐团吉他：刘冠南</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>嗨 怎么那么坏</p><p>才两天就深爱</p><p>说得好像真爱</p><p>我对你说嗨</p><br><p>今天有没有恋爱</p><p>是否谈了又甩</p><p>还说难遇真爱</p><p>我要你现在</p><p>把丑事都说出来 oh</p><p>才会听你表白</p><p>听你说你是真的喜欢我</p><p>真的想谈恋爱了</p><br><p>那就让情绪决定</p><p>听呼吸频率</p><p>跟感觉旅行</p><p>大不了不谈感情</p><p>just do what I suppose to do</p><p>（就做我该做的）</p><br><p>你也不用再演戏</p><p>怪我不爱你</p><p>是你的决定</p><p>每句话在我心里</p><p>清清楚楚地说你想离去</p><br><p>我要你现在</p><p>把丑事都说出来 oh</p><p>才会听你表白</p><p>听你说你是真的喜欢我</p><p>真的想谈恋爱了</p><br><p>那就让情绪决定</p><p>听呼吸频率</p><p>跟感觉旅行</p><p>大不了不谈感情</p><p>just do what I suppose to do</p><p>（就做我该做的）</p><br><p>你也不用再演戏</p><p>怪我不爱你</p><p>是你的决定</p><p>每句话在我心里</p><p>清清楚楚的说你想离去</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 永夜Minus </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Fine乐团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue+Vite+TypeScript+Electron 项目打包</title>
      <link href="/p/fc02f9ee/"/>
      <url>/p/fc02f9ee/</url>
      
        <content type="html"><![CDATA[<h1 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h1><p>以下配置请<strong>认真检查，认真对比</strong>，不要以为自己肯定是对的，问就是血泪经历（（</p><h2 id="vite-config-ts"><a href="#vite-config-ts" class="headerlink" title="vite.config.ts"></a>vite.config.ts</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">base</span>:<span class="string">&#x27;./&#x27;</span>, <span class="comment">//默认是绝对路径，改成相对路径</span></span><br></pre></td></tr></table></figure><h2 id="router-index-ts"><a href="#router-index-ts" class="headerlink" title="router&#x2F;index.ts"></a>router&#x2F;index.ts</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br></pre></td></tr></table></figure><p>此处默认是<code>createWebHistory</code>，需要改成Hash！！！！！！！！！！！！！！！！！！！</p><p>同时<code>import</code>处也记得改！！！！</p><h2 id="plugins-vite-electron-build-ts"><a href="#plugins-vite-electron-build-ts" class="headerlink" title="plugins&#x2F;vite.electron.build.ts"></a>plugins&#x2F;vite.electron.build.ts</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     打包</span></span><br><span class="line">            electronBuilder.<span class="title function_">build</span>(&#123;</span><br><span class="line">                <span class="attr">config</span>:&#123;</span><br><span class="line">                    <span class="attr">directories</span>:&#123;</span><br><span class="line">                        <span class="attr">output</span>:path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;release&#x27;</span>),</span><br><span class="line">                        <span class="attr">app</span>:path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">files</span>:[<span class="string">&#x27;**/*&#x27;</span>],</span><br><span class="line">                    <span class="attr">asar</span>:<span class="literal">true</span>, <span class="comment">// 压缩</span></span><br><span class="line">                    <span class="comment">// appId:&#x27;com.example.app&#x27;,</span></span><br><span class="line">                    <span class="attr">productName</span>:<span class="string">&#x27;media-transformer&#x27;</span>,</span><br><span class="line">                    <span class="attr">nsis</span>:&#123;</span><br><span class="line">                        <span class="attr">oneClick</span>:<span class="literal">false</span>, <span class="comment">// 取消一键安装</span></span><br><span class="line">                        <span class="attr">allowToChangeInstallationDirectory</span>: <span class="literal">true</span>, <span class="comment">//允许用户选择安装目录</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>检查一下<code>files:[&#39;**/*&#39;]</code>有没有写上！！！！</p><p>没有写上的话，打包之后的<code>...../resources/app.asar</code>打开之后你会发现里面没有我们本来<code>dist</code>目录下的那些文件！！</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>运行<code>npm run build only</code>即可（看<code>package.json</code>的<code>scripts</code>，这里我的<code>build</code>需要进行类型检查，但是报错，所以懒得检查了）</p><p>大概率此时你会发现他在下载某几个东西的时候超时，即使你已经魔法了</p><p>网上有一些方法是让你修改用户目录下的<code>.npmrc</code>，增加镜像，但是我试了，无事发生</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELECTRON_MIRROR=https://npmmirror.com/mirrors/electron/</span><br><span class="line">ELECTRON_BUILDER_BINARIES_MIRROR=https://npmmirror.com/mirrors/electron-builder-binaries/</span><br></pre></td></tr></table></figure><p>所以还是老老实实用一些蠢办法罢（（</p><p>那就是，报错的那个下载项目点一下链接自己下载，然后解压缩到（记得带上文件夹）：</p><p><code>C:\Users\你的用户名\AppData\Local\electron-builder\Cache\winCodeSign</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240611230244318.png"></p><p>然后再<code>build</code>（（</p><p>最后在<code>release\win-unpacked</code>文件夹里面找到<code>exe</code>运行就可以了！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/9822e358ca11ee46f7fb233fbdcdb0d.png" alt="9822e358ca11ee46f7fb233fbdcdb0d"></p><h1 id="附赠调试小技巧"><a href="#附赠调试小技巧" class="headerlink" title="附赠调试小技巧"></a>附赠调试小技巧</h1><h2 id="部署网页到云服务器"><a href="#部署网页到云服务器" class="headerlink" title="部署网页到云服务器"></a>部署网页到云服务器</h2><p>用来检查网页（Vite部分）本身是否有问题，具体教程可以看我前不知道多少篇的教程：</p><p><a href="https://rean-schwarze.github.io/p/c677e75e/">Vue.js(Vite)项目部署云服务器 | Rean’s Blog (rean-schwarze.github.io)</a></p><h2 id="在开发环境下默认打开开发者工具"><a href="#在开发环境下默认打开开发者工具" class="headerlink" title="在开发环境下默认打开开发者工具"></a>在开发环境下默认打开开发者工具</h2><p>有些情况我们ban掉了快捷键或者常规我们调出开发者工具的手段用不了的时候，就让它默认打开一下就好了（</p><p>在<code>background.ts</code>里面添加<code>win.webContents.openDevTools()</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> win=<span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;)</span><br><span class="line">win.<span class="property">webContents</span>.<span class="title function_">openDevTools</span>()</span><br></pre></td></tr></table></figure><p>如果<code>files:[&#39;**/*&#39;]</code>没写上，这时候打开开发者工具看一下源代码里面的<code>index.html</code>等你会发现是空的（（（或者是一些别的东西，总之不是<code>dist</code>目录下的那些！</p><h2 id="开发环境下读取编译文件"><a href="#开发环境下读取编译文件" class="headerlink" title="开发环境下读取编译文件"></a>开发环境下读取编译文件</h2><p>手动<code>build</code>完毕后，修改<code>background.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">argv</span>[<span class="number">2</span>])&#123;</span><br><span class="line">        win.<span class="title function_">loadFile</span>(<span class="string">&#x27;./index.html&#x27;</span>) <span class="comment">// 开发环境</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果此时还是白屏，恭喜你，99.9999%是没有修改<code>router/index.ts</code></p><p>真的亲测，别问为什么</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/9a29db7af5e2">electron打包引入dist&#x2F;index.html页面空白问题解决 - 简书 (jianshu.com)</a></p><p><a href="https://github.com/hunter-ji/Blog/issues/54">Vite+Electron快速构建一个VUE3桌面应用(三)——打包 · Issue #54 · hunter-ji&#x2F;Blog (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vite </tag>
            
            <tag> TypeScript </tag>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vite】如何解决 SyntaxError: Identifier ‘Buffer’ has already been declared</title>
      <link href="/p/25b929f6/"/>
      <url>/p/25b929f6/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>本来想用一个<code>sharp</code>库来进行图像处理，写了一点之后运行一下，哦吼，直接整个页面寄掉了</p><p>图忘截了，总之就是这样一个报错，来源显示是在<code>node_modules\.vite\deps\chunk_xxxxxxx.js</code>，说里面的一个<code>function Buffer(....)</code>名字重复了，此时页面无法正常渲染</p><p>我寻思，不是哥们，这关我p事啊？？</p><p>总之在经历了一番折腾（包括但不限于删掉刚写的代码，更换Vite版本，<code>node_modules</code>删掉再<code>cnpm i</code>…）之后，发现可以这样</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先安装<code>buffer</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm i buffer</span><br></pre></td></tr></table></figure><p>然后在<code>src</code>目录下新建<code>nodespecific.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Buffer</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;buffer&#x27;</span></span><br><span class="line">globalThis.<span class="property">Buffer</span>=<span class="title class_">Buffer</span></span><br></pre></td></tr></table></figure><p>然后在<code>index.html</code>下新增对这个脚本的引用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 前面省略</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/nodespecific.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再运行，你就会发现页面可以正常渲染了！</p><p>但是先别急，此时停止运行，再把刚刚这些新增的部分删掉，再运行，你就会发现，页面仍然正常渲染。。。。。</p><p>不是哥们，你逗我玩呢？？</p><p>总之虽然很离谱，但好歹还是解决了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div style="color:red; font-size:50px; text-align:center;">别用Sharp库</div><p>总之还是老老实实用canvas吧……</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://techblog.inplayer.com/p/migrating-our-react-setup-to-vite">Migrating our React setup to Vite - by Darko Atanasovski (inplayer.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】悬崖 (live)【声生不息·宝岛季】【歌手2024】</title>
      <link href="/p/dd30b42/"/>
      <url>/p/dd30b42/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%82%AC%E5%B4%96.jpg"></p><p>已灌词</p><p>孙楠版BPM：130（变速）</p><p>张信哲&amp;那英版BPM：128</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><h2 id="孙楠版"><a href="#孙楠版" class="headerlink" title="孙楠版"></a>孙楠版</h2><p>本家：<a href="https://www.mgtv.com/b/645759/21123129.html">孙楠《悬崖》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>作词 : 许常德</p><p>作曲 : 季忠平</p><p>原唱 : 齐秦</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：张亦江</p><p>改编编曲：黄仙农</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F; 谭鑫</p><p>贝斯：甯子达（阿达）</p><p>鼓：李定楠</p><p>打击乐：Cody Byassee</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳&#x2F;施森铭</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>弦乐：曜爆甘弦乐团</p><br><h2 id="张信哲-那英版"><a href="#张信哲-那英版" class="headerlink" title="张信哲&amp;那英版"></a>张信哲&amp;那英版</h2><p>本家：<a href="https://www.mgtv.com/b/528466/18486892.html?fpa=se&lastp=so_result">纯享版：张信哲那英《悬崖》-综艺-高清视频在线观看-芒果TV (mgtv.com)</a></p><p>作词 : 许常德</p><p>作曲 : 季忠平</p><p>原唱 : 齐秦</p><p>词SP：索尼音乐版权代理（北京）有限公司</p><p>曲SP：Universal Music Publishing CHINA</p><p>音乐总监：谷粟@牛班NEWBAND</p><p>音响总监：何飚</p><p>舞台总监：李柯</p><p>音乐监制：陈美威</p><p>音乐设计：王皓@WONDERWALL</p><p>制作人：汤佩弦@牛班NEWBAND</p><p>改编编曲：赖暐哲</p><p>混音：林梦洋</p><p>乐队队长：倪方来@牛班NEWBAND</p><p>键盘：董音@牛班NEWBAND&#x2F;洪信杰@牛班NEWBAND</p><p>吉他：倪方来@牛班NEWBAND&#x2F;毕赫宸@牛班NEWBAND</p><p>贝斯：邱培荣@牛班NEWBAND</p><p>鼓：郝稷伦@牛班NEWBAND</p><p>打击乐：荣辰初@牛班NEWBAND</p><p>和音：王梓琼@牛班NEWBAND &#x2F;杨画画@牛班NEWBAND</p><p>海洋@牛班NEWBAND &#x2F;张石荻@牛班NEWBAND</p><p>PGM：郭锦阳@牛班NEWBAND</p><p>弦乐：李琪弦乐团</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1AVHgpWCYmwTaSUBZlqIq_g?pwd=thm2">https://pan.baidu.com/s/1AVHgpWCYmwTaSUBZlqIq_g?pwd=thm2</a></p><p>提取码: thm2</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><h2 id="孙楠版-1"><a href="#孙楠版-1" class="headerlink" title="孙楠版"></a>孙楠版</h2><p>我不管爱葬身何处</p><p>我只求陪你直到末路</p><p>月已残灯已尽</p><p>夜黑人模糊</p><p>这一生因为爱你才清楚</p><br><p>再一步爱就会粉身碎骨</p><p>坠入无尽的孤独</p><p>世界太冷酷梦太投入</p><p>早习惯不能回头的付出</p><p>风在哭当我走到悬崖停驻</p><p>发觉泪也有温度</p><p>生命太短促痛太清楚</p><p>才让你让我爱到无退路</p><br><p>我不管爱落向何处</p><p>我只求今生今世共度</p><p>天已荒海已枯</p><p>心留一片土</p><p>连泪水都能灌溉这幸福</p><p>我不管爱葬身何处</p><p>我只求陪你直到末路</p><p>月已残灯已尽</p><p>夜黑人模糊</p><p>这一生因为爱你才清楚</p><br><p>风在哭当我走到悬崖停驻</p><p>发觉泪也有温度</p><p>生命太短促痛太清楚</p><p>才让你让我爱到无退路</p><br><p>我不管爱葬身何处</p><p>我只求今生今世共度</p><p>天已荒海已枯</p><p>心留一片土</p><p>连泪水都能灌溉这幸福</p><br><p>我不管爱葬身何处</p><p>我只求陪你直到末路</p><p>月已残灯已尽</p><p>夜黑人模糊</p><p>这一生因为爱你才清楚</p><br><h2 id="张信哲-那英版-1"><a href="#张信哲-那英版-1" class="headerlink" title="张信哲&amp;那英版"></a>张信哲&amp;那英版</h2><p>张信哲：</p><p>再一步爱就会粉身碎骨</p><p>坠入无尽的孤独</p><p>世界太冷酷梦太投入</p><p>早习惯不能回头的付出</p><br><p>风在哭当我走到悬崖停驻</p><p>发觉泪也有温度</p><p>生命太短促痛太清楚</p><p>才让你让我爱到无退路</p><br><p>我不管爱落向何处</p><p>我只求今生今世共度</p><p>天已荒海已枯</p><p>心留一片土</p><p>连泪水都能灌溉这幸福</p><br><p>我不管爱葬身何处</p><p>我只求陪你直到末路</p><p>月已残灯已尽</p><p>夜黑人模糊</p><p>这一生因为爱你才清楚</p><br><p>那英：</p><p>我不管爱落向何处</p><p>我只求今生今世共度</p><p>合唱：</p><p>天已荒海已枯</p><p>心留一片土</p><p>连泪水都能灌溉这幸福</p><p>我不管爱葬身何处</p><p>我只求陪你直到末路</p><p>月已残灯已尽</p><p>夜黑人模糊</p><p>这一生因为爱你才清楚</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声生不息·宝岛季 </tag>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 孙楠 </tag>
            
            <tag> 张信哲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】灿烂的你 (live)【歌手2024】</title>
      <link href="/p/3aa261db/"/>
      <url>/p/3aa261db/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E7%81%BF%E7%83%82%E7%9A%84%E4%BD%A0.jpg"></p><p>已灌词</p><p>BPM：112</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/645759/21123123.html">那英《灿烂的你》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>作词 : 汪峰</p><p>作曲 : 汪峰</p><p>原唱 : 汪峰</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：贾轶男&#x2F;郭小峰@耳肆山白</p><p>混音：林梦洋</p><p>和音：刘芳&#x2F;林灵&#x2F;宋赫伦@爱之音&#x2F;李郡洲@爱之音</p><p>PGM：杨阳</p><p>弦乐：曜爆甘弦乐团</p><p>吉他：金天@维伴音乐&#x2F;崔万平@维伴音乐</p><p>贝斯：李九君@维伴音乐</p><p>鼓：卢炜@维伴音乐</p><br><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/19hhfWw8OM6JIqtA9uMSD7w?pwd=s93q">https://pan.baidu.com/s/19hhfWw8OM6JIqtA9uMSD7w?pwd=s93q</a></p><p>提取码: s93q</p><br><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>习惯了逃避的那些日子吗</p><p>你在取悦带你入黑暗的人</p><p>那所有暗流的泪水换来的</p><p>只是荒谬世界的一丝不屑</p><br><p>奋不顾身吧 跃入深渊吧</p><p>苟延残喘才明白 光明的意义</p><p>那卑微的闪亮的无畏的</p><p>才是真正灿烂的你</p><p>噢 灿烂的你</p><br><p>从没舍身忘死地飞翔过</p><p>所以你不知道你还有翅膀</p><p>你知道你最不该屈服的</p><p>就是这世间所有的苦难</p><br><p>义无反顾吧 粉身碎骨吧</p><p>伤痕累累才能够 顶天的重生</p><p>那渺小的坚强的怒放的</p><p>才是真正灿烂的你</p><p>噢 灿烂的你</p><br><p>你不是讨厌恐惧吗</p><p>你不是厌倦顺从吗</p><p>从现在起彻底抛弃吧</p><p>你那从不犯错的生活</p><br><p>奋不顾身吧 跃入深渊吧</p><p>奄奄一息才明白 光明的意义</p><p>那卑微的闪亮的无畏的</p><p>才是真正灿烂的你</p><p>噢 灿烂的你</p><br><p>义无反顾吧 粉身碎骨吧</p><p>伤痕累累才能够 顶天的重生</p><p>那渺小的坚强的无畏的</p><p>才是真正闪耀的你</p><p>噢 灿烂的你</p><p>噢 灿烂的你</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 汪峰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】归零（Cover：黄绮珊/华晨宇）【东方栀子/JUN】</title>
      <link href="/p/fc078742/"/>
      <url>/p/fc078742/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/归零_cover3.jpg">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【栀子、JUN】归零_small.mov" type="video/mp4" >      </video></p><hr><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>《归零》</p><p>翻唱：东方栀子Blossom·馨、JUN</p><p>扒谱：Rean__</p><p>调教：CCryolite、Rean__</p><p>混音：某只泽</p><p>封面：CCryolite</p><br><h2 id="无参配布"><a href="#无参配布" class="headerlink" title="无参配布"></a>无参配布</h2><p>链接: <a href="https://pan.baidu.com/s/1_fRczFOCz5qvakFiu6ne4Q?pwd=n5ax">https://pan.baidu.com/s/1_fRczFOCz5qvakFiu6ne4Q?pwd=n5ax</a></p><p>提取码: n5ax</p><p>BPM：110</p><p>已灌词，华晨宇part副歌有个别音扒错了，使用请注意！</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 常石磊</p><p>作曲 : 常石磊</p><p>编曲 : 常石磊&#x2F;郑楠</p><p>原唱 : 林忆莲</p><p>SP：北京风向乐动数字音乐文化传播有限公司</p><p>音乐总监：谷粟@牛班NEWBAND</p><p>音响总监：何飚</p><p>舞台总监：李柯</p><p>音乐监制：陈美威</p><p>音乐设计：王皓@WONDERWALL</p><p>制作人：郑楠（SBMS）</p><p>改编编曲：郑楠（SBMS）</p><p>和声编写：郑楠（SBMS）</p><p>混音：赵靖（SBMS）</p><p>乐队队长：倪方来@牛班NEWBAND</p><p>键盘：洪信杰@牛班NEWBAND</p><p>吉他：倪方来@牛班NEWBAND&#x2F;毕赫宸@牛班NEWBAND</p><p>贝斯：邱培荣@牛班NEWBAND</p><p>鼓：郝稷伦@牛班NEWBAND</p><p>和音：王梓琼@牛班NEWBAND 杨画画@牛班NEWBAND</p><p>海洋@牛班NEWBAND 张石荻@牛班NEWBAND</p><p>PGM：郭锦阳@牛班NEWBAND</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><div style="color: #9400D3; text-align:center;">黄绮珊：<div>这世界 从来没有如果</div><div>在后悔之前 让懵懂承受</div><div>这世界 从来都在改变</div><div>在明亮之前 跟黑暗蔓延</div></div><br><div style="color: #FFD700; text-align:center;">华晨宇：<div>还有什么能再回来</div><div>还有什么人在未来</div></div><br><div style="text-align:center;">合：<div>既然 未知 是唯一的期待</div><div>索性将平淡劈成干柴</div><div>Reset Reset Reset（重置 重置 重置）</div><div>点燃眼前的徘徊</div><br><div>如果重生 能真实的存在</div><div>此刻将一切归零再来</div><div>Reset Reset Reset（重置 重置 重置）</div><div>梦想就等于未来 未来 未来</div></div><br><div style="color: #9400D3; text-align:center;">黄绮珊：<div>这世界 从来没有如果</div><div>在后悔之前 让懵懂承受</div></div><br><div style="color: #FFD700; text-align:center;">华晨宇：<div>这世界 从来都在改变</div><div>在明亮之前 跟黑暗蔓延</div></div><div style="color: #9400D3; text-align:center;">黄绮珊：<div>还有什么能再回来</div></div><div style="color: #FFD700; text-align:center;">华晨宇：<div>回来</div></div><div style="color: #9400D3; text-align:center;">黄绮珊：<div>还有什么人在未来</div></div><br><div style="text-align:center;">合：<div>既然 未知 是唯一的期待</div><div>索性将平淡劈成干柴</div><div>Reset Reset Reset（重置 重置 重置）</div><div>点燃眼前的徘徊</div><br><div>如果重生 能真实的存在</div><div>此刻将一切归零再来</div><div>Reset Reset Reset（重置 重置 重置）</div><div>梦想就等于未来</div><div>未来 未来 未来</div></div>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声生不息·宝岛季 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 东方栀子 </tag>
            
            <tag> 黄绮珊 </tag>
            
            <tag> 华晨宇 </tag>
            
            <tag> JUN </tag>
            
            <tag> 林忆莲 </tag>
            
            <tag> UTAU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】雨天雨天（Cover：汪苏泷）【奥斯卡】【歌手2024】</title>
      <link href="/p/22c9d1d0/"/>
      <url>/p/22c9d1d0/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/雨天雨天_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/【奥斯卡】雨天雨天.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《雨天雨天》</p><p>翻唱：奥斯卡（Synthesizer V）</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><br><p>我又来了 这次让奥斯卡唱点情歌！</p><p>混音上也有小小设计了一下！</p><br><p>第四期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV12Z421H7K6/">BV12Z421H7K6</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1r44T9pHyXgO4cAHm_IxLMA?pwd=sh6q">https://pan.baidu.com/s/1r44T9pHyXgO4cAHm_IxLMA?pwd=sh6q</a></p><p>提取码: sh6q</p><p>BPM：126&#x2F;124&#x2F;122&#x2F;…（变速）</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 小寒&#x2F;汪苏泷</p><p>作曲 : 李伟菘&#x2F;汪苏泷</p><p>原唱 : 孙燕姿&#x2F;戚薇</p><p>SP：Universal Music Publishing CHINA&#x2F;Warner Chappell Music Publishing Agency (Beijing) Ltd.</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：汪苏泷</p><p>改编编曲：金若晨&#x2F;冒振瑶</p><p>吉他编写：王迪&#x2F;黄炜皓</p><p>和声编写：徐杰</p><p>改编监制：金若晨</p><p>混音：林梦洋</p><p>乐队队长&#x2F;钢琴：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：金冬昱&#x2F; 劳国贤</p><p>贝斯：张梦斌</p><p>鼓：李定楠</p><p>打击乐：Cody Byassee</p><p>和音：窦颖&#x2F;刘芳&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：刘晓光</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><p>大提琴：吴玟錤</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>我记得 你最讨厌道别</p><p>我也不敢 主动说再见</p><p>那屋檐 你笑的多甜</p><p>雨都舍不得 淋湿你双眼</p> <br><p>但好时光 好像只能纪念</p><p>当我又再次 在这个屋檐</p><p>脚步声 和雨声都没变</p><p>只是你 已不在我身边</p> <br><p>多讨厌的雨天 总让人想起那画面</p><p>你走后的时间 那种幸福再也不见</p><p>回忆像重重一拳</p><p>击打在我的内心中间</p><p>疼痛多强烈 却忍住不让你看见</p> <br><p>但好时光好像只能纪念</p><p>当我又再次在这个屋檐</p><p>脚步声和雨声都没变</p><p>只是你已不在我身边</p> <br><p>你能体谅 我有雨天</p><p>偶尔胆怯 你都了解</p><p>过去那些 大雨落下的瞬间</p><p>我突然发现</p> <br><p>谁能体谅 我的雨天</p><p>所以情愿 回你身边</p><p>此刻脚步 会慢一些</p><p>如此坚决</p><p>你却越来越远</p> <br><p>谁能体谅 我的雨天</p><p>此刻脚步 会慢一些</p><p>如此坚决</p><br><p>至少还有雨天</p><p>能让我想起些画面</p><p>你和我的时间</p><p>那种幸福有多强烈</p><p>回忆像一碗热汤 温暖了我某一个雨天</p><p>却温暖不了 伴随身体的怀念</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奥斯卡 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 汪苏泷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】搁浅 (live)【歌手2024】</title>
      <link href="/p/33fc02d2/"/>
      <url>/p/33fc02d2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/003shjzfgy1hq927jr1h0j63pc2gynpg02.jpg"></p><p>已灌词</p><p>BPM：124</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/645759/21075041.html">那英《搁浅》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>词：宋健彰</p><p>曲：周杰伦</p><p>编曲：钟兴民</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240604223501392.png" alt="image-20240604223501392"></p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/19Wtggd_THIhSm7hY5yS9Sw?pwd=753s">https://pan.baidu.com/s/19Wtggd_THIhSm7hY5yS9Sw?pwd=753s</a></p><p>提取码: 753s</p><p>附赠原唱（周杰伦）版本的无参~</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>久未放晴的天空</p><p>依旧留着你的笑容</p><p>哭过却无法掩埋歉疚</p><br><p>风筝在阴天搁浅</p><p>想念还在等待救援</p><p>我拉着线复习你给的温柔</p><br><p>曝晒在一旁的寂寞</p><p>笑我给不起承诺</p><p>怎么会怎么会你竟原谅了我</p><br><p>我只能永远读着对白</p><p>读着我给你的伤害</p><p>我原谅不了我</p><p>就请你当作我已不在</p><br><p>我睁开双眼看着空白</p><p>忘记你对我的期待</p><p>读完了依赖</p><p>我很快就离开</p><br><p>风筝在阴天搁浅</p><p>想念还在等待救援</p><p>我拉着线复习你给的温柔</p><br><p>曝晒在一旁的寂寞</p><p>笑我给不起承诺</p><p>怎么会怎么会你竟原谅了我</p><br><p>我只能永远读着对白</p><p>读着我给你的伤害</p><p>我原谅不了我</p><p>就请你当作我已不在</p><br><p>我睁开双眼看着空白</p><p>忘记你对我的期待</p><p>读完了依赖</p><p>我很快就离开</p><br><p>我只能永远读着对白</p><p>读着我给你的伤害</p><p>我原谅不了我</p><p>就请你当作我已不在</p><br><p>我睁开双眼看着空白</p><p>忘记你对我的期待</p><p>读完了依赖</p><br><p>我只能永远读着对白</p><p>读着我给你的伤害</p><p>我原谅不了我</p><p>就请你当作我已不在</p><br><p>我睁开双眼看着空白</p><p>忘记你对我的期待</p><p>读完了依赖</p><p>我很快就离开</p><p>读完了依赖</p><p>我很快就离开</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 周杰伦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】Whataya Want From Me (Cover: Adam Lambert)【Hayden】【歌手2024】</title>
      <link href="/p/70335ae0/"/>
      <url>/p/70335ae0/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/Whataya%20Want%20From%20Me_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%E3%80%90Hayden%E3%80%91Whataya%20Want%20From%20Me.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Whataya Want From Me》</p><p>翻唱：Hayden</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>B站版PV：結月林</p><p>非常好亚当，使我火速翻调并随便整个G5（</p><p>然后选了个美丽（？）的截图当封面 感谢pvman</p><p>第三期虚拟歌手Cover合集：<a href="https://www.bilibili.com/video/BV1Km421N7L4/">BV1Km421N7L4</a></p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p>链接: <a href="https://pan.baidu.com/s/1TcV0h81ZXBoLwKk9D1ZNiQ?pwd=yv6n">https://pan.baidu.com/s/1TcV0h81ZXBoLwKk9D1ZNiQ?pwd=yv6n</a></p><p>提取码: yv6n</p><p>BPM：95</p><p>已灌词，但是<code>Whataya want from me</code>的<code>want</code>好像都灌错了（（，以及<code>When I would let you slip away</code>的<code>slip</code>也灌错了</p><p>最后的转音就开摆了没扒，请自由发挥（不是</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : MARTIN, MAX&#x2F;MOORE, ALECIA&#x2F;SCHUSTER, JOHAN</p><p>作曲 : P!nk&#x2F;Max Martin&#x2F;Shallbeck</p><p>原唱 : Adam Lambert</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>改编编曲：鲁纲宇</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：张梦斌</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：胡维纳@爱之音&#x2F;刘郡格&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>Hey slow it down</p><p>Whataya want from me</p><p>Whataya want from me</p><p>Yeah I’m afraid</p><p>Whataya want from me</p><p>Whataya want from me</p><br><p>There might’ve been a time</p><p>When I would give myself away</p><p>Oh once upon a time</p><p>I didn’t give a damn</p><p>But now here we are</p><p>So whataya want from me</p><p>Whataya want from me</p><br><p>Just don’t give up</p><p>I’m workin’ it out</p><p>Please don’t give in</p><p>I won’t let you down</p><p>It messed me up</p><p>Need a second to breathe</p><p>Just keep coming around</p><p>Hey whataya want from me</p><p>Whataya want from me</p><p>Whataya want from me</p><br><p>Yeah it’s plain to see</p><p>That baby you’re beautiful</p><p>And there’s nothing wrong with you</p><p>It’s me I’m a freak</p><p>But thanks for loving me</p><p>Cause you’re doing it perfectly</p><br><p>Yeah there might’ve been a time</p><p>When I would let you slip away</p><p>I wouldn’t even try</p><p>But I think you could save my life</p><br><p>Just don’t give up</p><p>I’m workin’ it out</p><p>Please don’t give in</p><p>I won’t let you down</p><p>It messed me up</p><p>Need a second to breathe</p><p>Just keep coming around</p><p>Hey whataya want from me</p><p>Whataya want from me</p><p>Whataya want from me</p><br><p>Just don’t give up on me</p><p>I won’t let you down</p><br><p>Just don’t give up</p><p>I’m workin’ it out</p><p>Please don’t give in</p><p>I won’t let you down</p><p>It messed me up</p><p>Need a second to breathe</p><p>Just keep coming around</p><p>Hey whataya want from me</p><p>Whataya want from me</p><p>Whataya want from me</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> Adam Lambert </tag>
            
            <tag> 亚当·兰伯特 </tag>
            
            <tag> Hayden </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot + JavaFx 项目起步</title>
      <link href="/p/f32ef110/"/>
      <url>/p/f32ef110/</url>
      
        <content type="html"><![CDATA[<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>创建常规<code>Spring</code>项目即可，此处使用<code>Maven</code>构建</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240529195000091.png" alt="image-20240529195000091"></p><p><code>SQL</code>方面看自己使用哪种数据库</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240529195255227.png" alt="image-20240529195255227"></p><h1 id="修改pom-xml"><a href="#修改pom-xml" class="headerlink" title="修改pom.xml"></a>修改pom.xml</h1><p>在<code>dependencies</code>里面添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-controls<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-fxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dlsc.formsfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>formsfx-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kordamp.ikonli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ikonli-javafx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kordamp.bootstrapfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bootstrapfx-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后更新一下依赖即可</p><h1 id="新建application-yml"><a href="#新建application-yml" class="headerlink" title="新建application.yml"></a>新建application.yml</h1><p>在<code>resources</code>目录下新建<code>application.yml</code>（以<code>MySQL</code>为例，其他的自己查询（（）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/你的数据库名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">你的账号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">你的密码</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#开启驼峰命名和下划线命名的自动转换</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h1 id="新建JavaFx相关文件"><a href="#新建JavaFx相关文件" class="headerlink" title="新建JavaFx相关文件"></a>新建JavaFx相关文件</h1><h2 id="新建fxml"><a href="#新建fxml" class="headerlink" title="新建fxml"></a>新建fxml</h2><p>在<code>resources</code>目录下新建<code>fxml</code>文件夹，里面放置自己的<code>fxml</code>文件</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240529195941044.png" alt="image-20240529195941044"></p><h2 id="新建application"><a href="#新建application" class="headerlink" title="新建application"></a>新建application</h2><p>在自己的包内新建<code>application</code>包，里面新建一个<code>MyApplication.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage stage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FXMLLoader</span> <span class="variable">fxmlLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FXMLLoader</span>(MainApplication.class.getResource(<span class="string">&quot;/fxml/hello-view.fxml&quot;</span>));</span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(fxmlLoader.load(), <span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">        stage.setTitle(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">        stage.setScene(scene);</span><br><span class="line">        stage.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新建controller"><a href="#新建controller" class="headerlink" title="新建controller"></a>新建controller</h2><p>和上一步同理，放置对应的<code>controller</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">private</span> Label welcomeText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FXML</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHelloButtonClick</span><span class="params">()</span> &#123;</span><br><span class="line">        welcomeText.setText(<span class="string">&quot;Welcome to JavaFX Application!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="修改main文件"><a href="#修改main文件" class="headerlink" title="修改main文件"></a>修改main文件</h1><p>在<code>main</code>方法内，<code>SpringApplication.run()</code>下面添加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Application.launch(MyApplication.class,args);</span><br></pre></td></tr></table></figure><p>最后点击运行，就可以了~</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240529200356271.png" alt="image-20240529200356271"></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><div class="note  flat"><p>2024&#x2F;08&#x2F;03 补充</p></div><p><a href="https://rean-schwarze.github.io/p/a440b512/">SpringBoot + JavaFx 注入为空怎么办？</a></p><h1 id="插播一下"><a href="#插播一下" class="headerlink" title="插播一下"></a>插播一下</h1><p>网上有一个<code>springboot-javafx-support</code>的依赖，看似很美好，实际操作跑起来各种运行不了（（</p><p>也没有更详细的教程，这个依赖也已经<strong>6年</strong>没有更新了，可能得用各种老版本才可以吧，懒得试了！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaFx </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】到时见 (live)【歌手2024】</title>
      <link href="/p/f756486c/"/>
      <url>/p/f756486c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%88%B0%E6%97%B6%E8%A7%81.jpg"></p><p>已灌词</p><p>BPM：128（变速）</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/645759/21031880.html">那英《到时见》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>作词 : 小寒</p><p>作曲 : 钱雷</p><p>原唱 : 尤长靖</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘卓@维伴音乐&#x2F;崔迪</p><p>改编编曲：郭小峰@耳肆山白&#x2F;刘卓@维伴音乐</p><p>混音：林梦洋</p><p>乐队队长&#x2F;键盘：吴加恩</p><p>键盘：Euywein杨展鸿</p><p>吉他：黄仲贤&#x2F;金冬昱</p><p>贝斯：张梦斌</p><p>鼓：李彦超</p><p>打击乐：Cody Byassee</p><p>和音：胡维纳@爱之音&#x2F;刘郡格&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>PGM：杨阳&#x2F;施森铭</p><p>长号：Terence Hsieh谢燕辉</p><p>萨克斯&#x2F;长笛：Alex Cummings</p><p>小号：何浩诚</p><p>弦乐：曜爆甘弦乐团</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接:<a href="https://pan.baidu.com/s/1qooI5FIheIlJTYFK7xV7eg?pwd=a1nk">https://pan.baidu.com/s/1qooI5FIheIlJTYFK7xV7eg?pwd=a1nk</a></p><p>提取码:a1nk</p><p>（附赠原唱版的无参）</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>到时见你没明说但我都懂</p><p>这期间我会好好地保重</p><p>一旦我忙完关于你我的梦</p><p>很快的相信我们能重逢</p><br><p>到时候你可还记得我脸孔</p><p>带我到你住下来的时空</p><p>你那么爱我我要活得让你感动</p><p>准备好笑容随时和你相拥</p><br><p>感觉你从没离开</p><p>换个方式存在</p><p>就如飘浮的尘埃</p><p>就如指引我的路牌</p><br><p>你一定不曾离开</p><p>换个方式存在</p><p>思念里陪我等待</p><p>等你重回我的胸怀</p><p>宇宙或是人海</p><p>请把我认出来</p><br><p>感觉你从没离开</p><p>换个方式存在</p><p>生命有过你的爱</p><p>不止有回忆可依赖</p><br><p>你一定不曾离开</p><p>换个方式存在</p><p>但我的心不会更改</p><p>等你重回我的胸怀</p><p>宇宙或是人海</p><p>请把我认出来</p><br><p>到时候你可还记得我脸孔</p><p>带我到你住下来的时空</p><p>你那么爱我我要活得让你感动</p><p>准备好笑容随时和你相拥</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
            <tag> 尤长靖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】挣脱 (live)【歌手2024】</title>
      <link href="/p/8dd4b91f/"/>
      <url>/p/8dd4b91f/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%8C%A3%E8%84%B1.jpg"></p><p>已灌词</p><p>BPM：100</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/645759/20989618.html">纯享版：那英《挣脱》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>演唱 : 那英</p><p>作词 : 王海涛</p><p>作曲 : 崔迪</p><p>原唱 : 崔迪</p><p>音乐总监：陈建骐</p><p>音响总监：何飚</p><p>音乐设计：Eric</p><p>制作人：刘卓@维伴音乐</p><p>改编编曲：张星@耳肆山白</p><p>混音：林梦洋</p><p>PGM：杨阳&#x2F;刘阿洛</p><p>现场和音：窦颖&#x2F;胡维纳@爱之音&#x2F;宋赫伦@爱之音&#x2F;鱼椒盐</p><p>吉他：金天@维伴音乐&#x2F;崔万平@维伴音乐</p><p>贝斯：李九君@维伴音乐</p><p>鼓：卢炜@维伴音乐</p><p>合音：崔迪&#x2F;石行&#x2F;马思莹</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接:<a href="https://pan.baidu.com/s/1oElv0DNaUw_2jNjboiByrg?pwd=ecig">https://pan.baidu.com/s/1oElv0DNaUw_2jNjboiByrg?pwd=ecig</a></p><p>提取码:ecig</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>人生要多迂回</p><p>要几次错与对</p><p>才走到了这里</p><p>前行不退</p><p>不撒手的痛苦</p><p>整夜不睡</p><br><p>早应该了来放开</p><p>自由得像阵风</p><p>够了有些爱</p><p>要留给自己</p><p>不要枉费</p><p>忠于自我的机会</p><br><p>挣脱了夜的黑</p><p>用力打碎</p><p>暗地里的魔鬼</p><p>垂头崩溃</p><p>挣脱了心的灰</p><p>让自由得到拯救</p><br><p>挣脱了他的嘴</p><p>挣脱是非</p><p>伤口洒出蔷薇</p><p>倔强的花蕊</p><p>生命只这一回</p><p>别再违心的讨好谁</p><br><p>忘掉苦涩的泪</p><p>告别了错与对</p><p>我站在了这里</p><p>无惧无悔</p><p>曾经历的痛苦</p><p>格外珍贵</p><br><p>早应该了来放开</p><p>自由得像阵风</p><p>够了有些爱</p><p>要留给自己</p><p>不要枉费</p><p>忠于自我的机会</p><br><p>挣脱了夜的黑</p><p>用力打碎</p><p>暗地里的魔鬼</p><p>垂头崩溃</p><p>挣脱了心的灰</p><p>让自由得到拯救</p><br><p>挣脱了夜的黑</p><p>挣脱是非</p><p>伤口长出蔷薇</p><p>倔强的花蕊</p><p>生命只这一回</p><p>别再违心的讨好谁</p><br><p>逆着风浪不停往前飞</p><p>我的每个未来已准备</p><p>哪怕被猛烈的雨浇透</p><p>也无所谓</p><p>带着勇气努力往前飞</p><p>带着一颗永不冷却的心走</p><br><p>挣脱了夜的黑</p><p>挣脱了心的灰</p><p>挣脱眼泪</p><p>挣脱 挣脱 挣脱了心的黑</p><p>挣脱 挣脱 挣脱了心的灰</p><p>生命就这一回</p><p>无惧无悔往前走</p><p>生命就这一回</p><p>无惧无悔往前走</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 歌手2024 </tag>
            
            <tag> 那英 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】月半小夜曲 (live)【容祖儿】【我是歌手·第四季】</title>
      <link href="/p/a290d941/"/>
      <url>/p/a290d941/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%9C%88%E5%8D%8A%E5%B0%8F%E5%A4%9C%E6%9B%B2.jpg"></p><p>*使用了sv的转midi（因为变速给我变麻了（（，已校对，已灌词</p><p>BPM：70（变速）</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/290525/2996085.html">容祖儿动情吟唱《月半小夜曲》 天后妙音如泣似诉-综艺-高清视频在线观看-芒果TV (mgtv.com)</a></p><p>作词 : 吉元由美</p><p>作曲 : 河合奈保子</p><p>填词 : 向雪怀</p><p>编曲 : 褚镇东&#x2F;舒文</p><p>原唱：李克勤</p><p>双簧管：叶乃坚</p><p>钢琴：褚镇东</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1oTN0Akv8uvdyoIbJK8T0-A?pwd=zfzu">https://pan.baidu.com/s/1oTN0Akv8uvdyoIbJK8T0-A?pwd=zfzu</a></p><p>提取码: zfzu</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>仍然倚在失眠夜</p><p>望天边星宿</p><p>仍然听见小提琴</p><p>如泣似诉再挑逗</p><br><p>为何只剩一弯月</p><p>留在我的天空</p><p>这晚以后音讯隔绝</p><br><p>人如天上的明月</p><p>是不可拥有</p><p>情如曲过只遗留</p><p>无可挽救再分别</p><br><p>为何只是失望</p><p>填密我的空虚</p><p>这晚夜没有吻别</p><br><p>仍在说永久</p><p>想不到是借口</p><p>从未意会要分手</p><br><p>但我的心每分每刻</p><p>仍然被她占有</p><p>她似这月儿</p><p>仍然是不开口</p><br><p>提琴独奏独奏着</p><p>明月半倚深秋</p><p>我的牵挂 我的渴望</p><p>直至以后</p><br><p>人如天上的明月</p><p>是不可拥有</p><p>情如曲过只遗留</p><p>无可挽救再分别</p><br><p>人若只是失望</p><p>填密我的空虚</p><p>这晚夜没有吻别</p><br><p>仍在说永久</p><p>想不到是借口</p><p>从未意会要分手</p><br><p>但我的心每分每刻</p><p>仍然被她占有</p><p>她似这月儿</p><p>仍然是不开口</p><br><p>提琴独奏独奏着</p><p>明月半倚深秋</p><p>我的牵挂 我的渴望</p><p>直至以后</p><br><p>仍在说永久</p><p>想不到是借口</p><p>从未意会要分手</p><br><p>但我的心每分每刻</p><p>仍然被她占有</p><p>她似这月儿</p><p>仍然是不开口</p><br><p>提琴独奏独奏着</p><p>明月半倚深秋</p><p>我的牵挂 我的渴望</p><p>直至以后</p><br><p>我的牵挂 我的渴望</p><p>直至以后</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 容祖儿 </tag>
            
            <tag> 我是歌手·第四季 </tag>
            
            <tag> 李克勤 </tag>
            
            <tag> 粤语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】李香兰【G.E.M.邓紫棋】</title>
      <link href="/p/61a8a4ef/"/>
      <url>/p/61a8a4ef/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%9D%8E%E9%A6%99%E5%85%B0.jpg"></p><p>已灌词</p><p>BPM：86（变速）</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/577868/19903891.html">纯享：《李香兰》G.E.M.邓紫棋-综艺-高清视频在线观看-芒果TV (mgtv.com)</a></p><p>作词 : 松井五郎</p><p>作曲 : 玉置浩二</p><p>改编词 : 周礼茂</p><p>制作人 : G.E.M.邓紫棋&#x2F;T-Ma</p><p>编曲 : Euywein 杨展鸿&#x2F;Derrick Sepnio</p><p>混音 : T-Ma</p><p>母带 : T-Ma</p><p>OP : Fujipacific Music Inc.</p><p>SP : Fujipacific Music (S.E. Asia) Ltd.</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1Dyx-oPxT4LO2DB26Rtg8RA?pwd=73dc">https://pan.baidu.com/s/1Dyx-oPxT4LO2DB26Rtg8RA?pwd=73dc</a></p><p>提取码: 73dc</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>恼春风</p><p>我心因何恼春风</p><p>说不出 借酒相送</p> <br><p>夜雨冻</p><p>雨点透射到照片中</p><p>回头似是梦</p><p>无法弹动</p><p>迷住凝望你</p><p>褪色照片中</p> <br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p> <br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p> <br><p>照片中</p><p>哪可以投照片中</p><p>盼找到 时间裂缝</p> <br><p>夜放纵</p><p>告知我难寻你影踪</p><p>回头也是梦</p><p>仍似被动</p><p>逃避凝望你</p><p>却深印脑中</p> <br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p> <br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p> <br><p>啊… 像花虽未红</p><p>如冰虽不冻</p><p>却像有无数说话</p><p>可惜我听不懂</p> <br><p>啊… 是杯酒渐浓</p><p>或我心真空</p><p>何以感震动</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 粤语 </tag>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> T.I.M.E. </tag>
            
            <tag> 时光音乐会·老友记 </tag>
            
            <tag> 张学友 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SpringBoot】如何获取请求的IP地址？</title>
      <link href="/p/c2d0bb20/"/>
      <url>/p/c2d0bb20/</url>
      
        <content type="html"><![CDATA[<p>在 Java Web 应用中，想要在接口中获取到发送请求的客户端 IP 地址，需要依赖请求对象 —— HttpServletRequest。</p><p>那么，首先就是要先获取到请求的对象。</p><p>在 Spring Boot 中，只需在接口方法上加上 HttpServletRequest 或 HttpServletResponse 参数，Spring Boot 就会自动绑定这两个对象，然后可以直接使用。如果你的方法有其他参数，只需把这两个加到后面即可。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getSomething&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSomething</span><span class="params">(..., HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最常用的一种方法，当然除了这种方式，在 Spring Boot 中还可以使用注解 <code>@Autowired</code> 注入或通过 RequestContextHolder 来获取请求对象，这里就不展开叙述了。</p><p>在得到请求对象 HttpServletRequest 对象后，一般的，我们可以使用 <code>request.getRemoteAddr()</code> 来获取到客户端对应的 IP 地址。</p><p>但是，如果使用了 Nginx 等反向代理软件，则不能只简单地通过上述代码来获取 IP；并且，如果使用了多级反向代理的话，那么在获取 X-Forwarded-For 的值时，得到的应是一串 IP 地址，此种情况下，X-Forwarded-For 中第一个非 <code>unknown</code> 的有效 IP 字符串，则为真实 IP 地址。</p><h1 id="获取IP的工具类"><a href="#获取IP的工具类" class="headerlink" title="获取IP的工具类"></a>获取IP的工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIpAddr</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAddress</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ipAddress = request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="literal">null</span> || ipAddress.isEmpty() || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="literal">null</span> || ipAddress.isEmpty() || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="literal">null</span> || ipAddress.isEmpty() || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getRemoteAddr();</span><br><span class="line">                <span class="keyword">if</span> (ipAddress.equals(<span class="string">&quot;127.0.0.1&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 根据网卡取本机配置的IP</span></span><br><span class="line">                    <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inet = InetAddress.getLocalHost();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (inet != <span class="literal">null</span>) &#123;</span><br><span class="line">                        ipAddress = inet.getHostAddress();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP，多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">            <span class="keyword">if</span> (ipAddress != <span class="literal">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123; <span class="comment">// &quot;***.***.***.***&quot;.length()</span></span><br><span class="line">                <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ipAddress = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h2><h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a><strong>X-Forwarded-For</strong></h3><p>格式为 <code>X-Forwarded-For:client1,proxy1,proxy2</code>，一般情况下，第一个 ip 为客户端真实 ip，后面的为经过的代理服务器 ip。现在大部分的代理都会加上这个请求头。</p><h3 id="Proxy-Client-IP-WL-Proxy-Client-IP"><a href="#Proxy-Client-IP-WL-Proxy-Client-IP" class="headerlink" title="Proxy-Client-IP&#x2F;WL- Proxy-Client-IP"></a><strong>Proxy-Client-IP&#x2F;WL- Proxy-Client-IP</strong></h3><p>这个一般是经过 apache http 服务器的请求才会有，用 apache http 做代理时一般会加上 <code>Proxy-Client-IP</code> 请求头，而 <code>WL-Proxy-Client-IP</code> 是他的 weblogic 插件加上的请求头。</p><p>需要注意几点：</p><ul><li>这些请求头都不是 http 协议里的标准请求头，也就是说这是各个代理服务器自己规定的表示客户端地址的请求头。如果哪天有一个代理服务器软件用 <code>xxx-client-ip</code> 这个请求头代表客户端请求，那上面的代码就不行了。</li><li>这些请求头不是代理服务器一定会带上的，网络上的很多匿名代理就没有这些请求头，所以获取到的客户端 ip 不一定是真实的客户端 ip。代理服务器一般都可以自定义请求头设置。</li><li>即使请求经过的代理都会按自己的规范附上代理请求头，上面的代码也不能确保获得的一定是客户端 ip。不同的网络架构，判断请求头的顺序是不一样的。</li><li>最重要的一点，请求头都是可以伪造的。如果一些对客户端校验较严格的应用（比如投票）要获取客户端 ip，应该直接使用 <code>request.getRemoteAddr()</code>，虽然获取到的可能是代理的 ip 而不是客户端的 ip，但这个获取到的 ip 基本上是不可能伪造的，也就杜绝了刷票的可能。</li></ul><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> HttpServletRequest servletRequest;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> IpUtil.getIpAddr(servletRequest);</span><br></pre></td></tr></table></figure><h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><p>在配置里加上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240519201910916.png" alt="image-20240519201910916"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cloud.tencent.com/developer/article/2182781">Java 实战系列·获取请求 IP 地址-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://www.cnblogs.com/CoderGeshu/p/15395136.html">通过 HttpServletRequest 获取客户端 IP 地址 - CoderGeshu - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SpringBoot】插入数据后返回数据库自增id</title>
      <link href="/p/9770d71c/"/>
      <url>/p/9770d71c/</url>
      
        <content type="html"><![CDATA[<p>转载自：</p><p><a href="https://blog.csdn.net/ju_362204801/article/details/103578668">SpringBoot整合Mybatis插入数据返回数据库自增id_springboot sqllite executeupdate 返回新增id-CSDN博客</a></p><br><p>SpringBoot整合Mybatis插入数据返回数据库自增id非常简单，通过一个注解就可以搞定了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;, keyColumn=&quot;id&quot;)</span></span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/2019121713174485.png" alt="img"></p><p>插入一条数据测试下</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20191217131959589.png" alt="img"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20191217132022196.png" alt="img"></p><p>加上这个注解后，自增的id已经给我们返回了</p><p>吗？</p><p>请看报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error getting generated key or setting result to parameter object. Cause: org.apache.ibatis.executor.ExecutorException: Could not determine which parameter to assign generated keys to. Note that when there are multiple parameters, &#x27;keyProperty&#x27; must include the parameter name (e.g. &#x27;param.id&#x27;). Specified key properties are [id] and available parameters are [param7, param8, param5, param6, sub_id, param9, pubTime, isPreSale, isNew, param3, param4, param1, param2, brand_id, svd_name, category_id, name, param10, param11, param12, isOnSale, sub_id2, seller_id, desc]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into goods(name,`desc`,brand_id,category_id,sub_category_id,sub_category_id2,&quot; +</span></span><br><span class="line"><span class="meta">            &quot;isPreSale,is_new,is_on_sale,svd_name,pubTime,add_seller) values(#&#123;name&#125;,#&#123;desc&#125;,#&#123;brand_id&#125;,&quot; +</span></span><br><span class="line"><span class="meta">            &quot;#&#123;category_id&#125;,#&#123;sub_id&#125;,#&#123;sub_id2&#125;,#&#123;isPreSale&#125;,#&#123;isNew&#125;,#&#123;isOnSale&#125;,#&#123;svd_name&#125;,#&#123;pubTime&#125;,#&#123;seller_id&#125;)&quot;)</span></span><br></pre></td></tr></table></figure><p>反转了，是因为别人都是用一个类传参的。。。。</p><p>所以这个注解是将自增的id传给传入的参数的，而Mapper本身返回的是成功插入的行数。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> MyBatis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【明日方舟】《巴别塔》单核攻略搜集及评价</title>
      <link href="/p/41bd2aed/"/>
      <url>/p/41bd2aed/</url>
      
        <content type="html"><![CDATA[<h1 id="普通关"><a href="#普通关" class="headerlink" title="普通关"></a>普通关</h1><h2 id="BB-10"><a href="#BB-10" class="headerlink" title="BB-10"></a>BB-10</h2><p><a href="https://www.bilibili.com/video/BV1vF4m1K7jY/?spm_id_from=444.41.top_right_bar_window_history.content.click">【明日方舟】 BB-10 低配 单核令 巴别塔_手机游戏热门视频 (bilibili.com)</a></p><p>核心：令3</p><p>人数：2</p><p>低配度：★★★★★</p><p>操作复杂度：★★★★★</p><p>推荐度：★★☆☆☆</p><h3 id="个人通关截图"><a href="#个人通关截图" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p>忘了截</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>一遍过 注意微尘吧 还没尽量多带些快活帮小龙挡一下 虽然小杯操作手忙脚乱阿米娅差点进点 但还是带的人多有惊无险 纯新人的话可能因为游戏理解不高非常容易翻车（照抄只带2个人 不带别的）</p><h1 id="EX关"><a href="#EX关" class="headerlink" title="EX关"></a>EX关</h1><h2 id="BB-EX-1"><a href="#BB-EX-1" class="headerlink" title="BB-EX-1"></a>BB-EX-1</h2><p><a href="https://www.bilibili.com/video/BV1Ur421372W?p=9&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-EX-1 突袭（令+伊桑）_哔哩哔哩_bilibili</a></p><p>核心：令3+伊桑2</p><p>人数：2</p><p>低配度：★★★☆☆</p><p>操作复杂度：★★★☆☆</p><p>推荐度：★★★★☆</p><h3 id="个人通关截图-1"><a href="#个人通关截图-1" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240430104913179.png" alt="image-20240430104913179"></p><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><p>第一关还是比较简单滴 主打一个看着办轴</p><h2 id="BB-EX-2"><a href="#BB-EX-2" class="headerlink" title="BB-EX-2"></a>BB-EX-2</h2><p><a href="https://www.bilibili.com/video/BV1Ur421372W?p=10&spm_id_from=pageDriver&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-EX-2 突袭_哔哩哔哩_bilibili</a>（没错还是上一个视频（（）</p><p>核心：令3</p><p>人数：1</p><p>低配度：★★★★★</p><p>操作复杂度：★☆☆☆☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-2"><a href="#个人通关截图-2" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240430233930931.png" alt="image-20240430233930931"></p><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h3><p>非常简单 照着摆 开技能就结束了 稳得很</p><h2 id="BB-EX-3"><a href="#BB-EX-3" class="headerlink" title="BB-EX-3"></a>BB-EX-3</h2><p><a href="https://www.bilibili.com/video/BV1Ur421372W?p=11&spm_id_from=pageDriver&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-EX-3 突袭_哔哩哔哩_bilibili</a>（没错还是上一个视频（（）</p><p>核心：令3</p><p>人数：1</p><p>低配度：★★★★★</p><p>操作复杂度：★☆☆☆☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-3"><a href="#个人通关截图-3" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240430235959213.png" alt="image-20240430235959213"></p><h3 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h3><p>也很简单 只要不连线就不怕那个怪（</p><h2 id="BB-EX-4"><a href="#BB-EX-4" class="headerlink" title="BB-EX-4"></a>BB-EX-4</h2><p><a href="https://www.bilibili.com/video/BV1Ur421372W?p=12&spm_id_from=pageDriver&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-EX-4 突袭（令+伊桑）_哔哩哔哩_bilibili</a>（没错还是上一个视频（（）</p><p>核心：令3+伊桑2</p><p>人数：2</p><p>低配度：★★★☆☆</p><p>操作复杂度：★★★★☆</p><p>推荐度：★★★★☆</p><h3 id="个人通关截图-4"><a href="#个人通关截图-4" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240501003134284.png" alt="image-20240501003134284"></p><h3 id="备注-4"><a href="#备注-4" class="headerlink" title="备注"></a>备注</h3><p>虽然一堆卡其脱离太看上去很哈人 但是大龙非常能抗 我这里伊桑没精二所以多带了一些人（</p><h2 id="BB-EX-5"><a href="#BB-EX-5" class="headerlink" title="BB-EX-5"></a>BB-EX-5</h2><p>核心：令3</p><p>人数：1</p><p>低配度：★★★★★</p><p>操作复杂度：★★★★☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-5"><a href="#个人通关截图-5" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240501005323690.png" alt="image-20240501005323690"></p><h3 id="备注-5"><a href="#备注-5" class="headerlink" title="备注"></a>备注</h3><p>这关大号做挂机攻略的时候就汗流浃背了 6部署 倒是令单人没想象中那么难（好吧还是有点蓟县的</p><h2 id="BB-EX-6"><a href="#BB-EX-6" class="headerlink" title="BB-EX-6"></a>BB-EX-6</h2><p><a href="https://www.bilibili.com/video/BV1PH4y1T7Tc/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【明日方舟】 突袭 BB-EX-6 低配 单核玛恩纳 巴别塔_哔哩哔哩bilibili_明日方舟_攻略</a></p><p>核心：玛恩纳3</p><p>人数：8</p><p>低配度：★★★★☆</p><p>操作复杂度：★★★★★</p><p>推荐度：★★★★☆</p><h3 id="个人通关截图-6"><a href="#个人通关截图-6" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240501011825372.png" alt="image-20240501011825372"></p><h3 id="备注-6"><a href="#备注-6" class="headerlink" title="备注"></a>备注</h3><p>开局费用可能会卡（如果用上位） 需要精准卡位 最后我没照抄 属于是看着办轴（（</p><h2 id="BB-EX-7"><a href="#BB-EX-7" class="headerlink" title="BB-EX-7"></a>BB-EX-7</h2><p><a href="https://www.bilibili.com/video/BV1XC4113756/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-EX-7突袭蚀刻章镀层 锏单核低配 (bilibili.com)</a></p><p>核心：锏3</p><p>人数：6</p><p>低配度：★★★★☆</p><p>操作复杂度：★★★★★</p><p>推荐度：★★★☆☆</p><h3 id="个人通关截图-7"><a href="#个人通关截图-7" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240501235721501.png" alt="image-20240501235721501"></p><h3 id="备注-7"><a href="#备注-7" class="headerlink" title="备注"></a>备注</h3><p>可以多带一个快活链一下巨人 防翻车 以及一个很重要的点就是下砾骗贝斯手之前一定要先下一个高台 因为中间贝斯手会平A一下 如果只下砾 他就会打到奶 就寄了</p><h2 id="BB-EX-8"><a href="#BB-EX-8" class="headerlink" title="BB-EX-8"></a>BB-EX-8</h2><p>[<a href="https://www.bilibili.com/video/BV1RC4113785/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">巴别塔] BB-EX-8 突袭 简单锏单核：巴别塔恶灵？哦，我是三冠王 (bilibili.com)</a></p><p>核心：锏3</p><p>人数：6</p><p>低配度：★★★★☆</p><p>操作复杂度：★★★★★★★</p><p>推荐度：★★★☆☆</p><h3 id="个人通关截图-8"><a href="#个人通关截图-8" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240502004006166.png" alt="image-20240502004006166"></p><h3 id="备注-8"><a href="#备注-8" class="headerlink" title="备注"></a>备注</h3><p>已经会了 我是调箱高手之用维神全秒了 用维神的话开局压力会有点大 这里是用古米+讯使硬抗（（</p><h1 id="S关"><a href="#S关" class="headerlink" title="S关"></a>S关</h1><p>突袭不打了 ddl战士（（</p><h2 id="BB-S-1-普通"><a href="#BB-S-1-普通" class="headerlink" title="BB-S-1 普通"></a>BB-S-1 普通</h2><p>[<a href="https://www.bilibili.com/video/BV1vJ4m1J7GV/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">巴别塔] BB-S-1 锏单核 简单好抄 语音详解|浅予_哔哩哔哩_bilibili</a></p><p>核心：锏3</p><p>人数：8</p><p>低配度：★★★★☆</p><p>操作复杂度：★★★★★★</p><p>推荐度：★★★☆☆</p><h3 id="个人通关截图-9"><a href="#个人通关截图-9" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503010244257.png" alt="image-20240503010244257"></p><h3 id="备注-9"><a href="#备注-9" class="headerlink" title="备注"></a>备注</h3><p>继续用维神替了 银灰不开技能 注意第一个隐身怪需要拖一下驮兽对位置再开技能 打完驮兽关 第二次同理 打完剪刀怪再关 可能需要高练一点 不然剪刀怪就把链剪断了 然后提前放logos等第三个隐身怪进入银灰范围开 同时开伊桑 拖出维神技能 然后就结束了</p><h2 id="BB-S-2-普通"><a href="#BB-S-2-普通" class="headerlink" title="BB-S-2 普通"></a>BB-S-2 普通</h2><p>[<a href="https://www.bilibili.com/video/BV1Vu4m1c7ZT/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">巴别塔] BB-S-2 突袭 锏单核 轻松好抄 语音详解|浅予 (bilibili.com)</a>（没错还是上一个（（</p><p>核心：锏3</p><p>人数：8</p><p>低配度：★★★★☆</p><p>操作复杂度：★★☆☆☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-10"><a href="#个人通关截图-10" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503012416332.png" alt="image-20240503012416332"></p><h3 id="备注-10"><a href="#备注-10" class="headerlink" title="备注"></a>备注</h3><p>这关就尊重原著了 但是没练松果用logos+寒克替一下</p><h2 id="BB-S-3-普通"><a href="#BB-S-3-普通" class="headerlink" title="BB-S-3 普通"></a>BB-S-3 普通</h2><p>[<a href="https://www.bilibili.com/video/BV1iZ421n7Xy/?spm_id_from=333.788&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">巴别塔] BB-S-3 突袭 令单核 简单好抄 语音详解|浅予_哔哩哔哩_bilibili</a>（没错还是上一个（（</p><p>核心：令3</p><p>人数：3</p><p>低配度：★★★★★</p><p>操作复杂度：★★★★☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-11"><a href="#个人通关截图-11" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503013428608.png" alt="image-20240503013428608"></p><h3 id="备注-11"><a href="#备注-11" class="headerlink" title="备注"></a>备注</h3><p>发现没有近战位的小车 尬住了 于是中途一转看着办轴</p><h2 id="BB-S-4-普通"><a href="#BB-S-4-普通" class="headerlink" title="BB-S-4 普通"></a>BB-S-4 普通</h2><p><a href="https://www.bilibili.com/video/BV1Xr421G7Ud/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-S-4 水陈单核_手机游戏热门视频 (bilibili.com)</a></p><p>核心：水陈3</p><p>人数：13</p><p>低配度：★★★★☆</p><p>操作复杂度：★★★★★</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-12"><a href="#个人通关截图-12" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503020115402.png" alt="image-20240503020115402"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503022802058.png" alt="image-20240503022802058"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240503022902343.png" alt="image-20240503022902343"></p><h3 id="备注-12"><a href="#备注-12" class="headerlink" title="备注"></a>备注</h3><p>继续维神 流程和视频差不多 理论上一套技能1发先打小怪 剩下5发就能把隐身怪干掉 巨人用快活链两次就行 只剩最后3个剪刀怪出来时撤维神 拖到再部署技能一开就结束了</p><h2 id="BB-MO-1"><a href="#BB-MO-1" class="headerlink" title="BB-MO-1"></a>BB-MO-1</h2><p><a href="https://www.bilibili.com/video/BV1ME421T7mi/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">BB-MO-1玛恩纳单核低配 简单好抄 明日方舟巴别塔_明日方舟_攻略 (bilibili.com)</a></p><p>核心：玛恩纳3</p><p>人数：10</p><p>低配度：★★★★★</p><p>操作复杂度：★★★☆☆</p><p>推荐度：★★★★★</p><h3 id="个人通关截图-13"><a href="#个人通关截图-13" class="headerlink" title="个人通关截图"></a>个人通关截图</h3><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240430002639706.png" alt="image-20240430002639706"></p><h3 id="备注-13"><a href="#备注-13" class="headerlink" title="备注"></a>备注</h3><p>真是简简又单单啊 我们玛宝男！</p><p>记录一下几个轴：</p><p>48&#x2F;66左右卡其脱离太进入叔范围就可以开</p><p>注意90杀及时开叔叔技能 防止贝斯手把人都喷死了</p><p>125杀左右注意开伊桑技能和奶技能 两个卡其脱离太进入叔范围开</p><p>149杀撤干员重新连线</p><p>151杀开叔技能</p><p>161杀开伊桑技能 然后叔好了开</p><p>175杀冲刺手过第一条线后撤先锋 开伊桑技能</p><p>182杀开叔技能</p><p>187杀贝斯手出来撤伊桑</p><p>然后就是看着办轴啦 轻松过关（不是</p>]]></content>
      
      
      <categories>
          
          <category> 攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 明日方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】庆长生（和声付）【2024星穹铁道生日会】</title>
      <link href="/p/bfebe40b/"/>
      <url>/p/bfebe40b/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%BA%86%E9%95%BF%E7%94%9F.jpg"></p><p>已灌词，和声仅供参考！</p><p>BPM：126</p><br><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/festival/honkaistarrail2024birthday3?bvid=BV1QE421L7YL&spm_id_from=444.41.top_right_bar_window_default_collection.content.click">2024星穹铁道生日会-仙舟 (bilibili.com)</a></p><p>总策划&#x2F;导演：浮玉酱</p><p>作曲：1AN孙毅然&#x2F;塔库</p><p>作词：司隶示皇</p><p>编曲：1AN孙毅然</p><p>演唱：祖娅纳惜</p><p>和声：周弦&#x2F;CZT_吃枕头</p><p>混音：圈太Studio</p><p>脚本&#x2F;文案：学渣、莓良心的怠惰</p><p>分镜：可伊可</p><p>美术监督：浮玉酱、坚果、包子</p><p>人物设定：坚果</p><p>前期美术：芦苇、包子</p><p>画面绘制：浮玉酱、坚果、包子、北椴、妄猫、Clear-water、令羽小燕、高速旋转三文鱼、ovosaki_シリカP、-柏南-、饼喵松风、zcing、 煜标</p><p>后期：像素山海（系豆沙、玉米）</p><p>动画：柠檬猹</p><p>标题：歪头</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1Fd16pmyCMYdUtWVuZwzVtg?pwd=2e9j">https://pan.baidu.com/s/1Fd16pmyCMYdUtWVuZwzVtg?pwd=2e9j</a></p><p>提取码: 2e9j</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>冰冷的</p><p>空寂中隐恻</p><p>星河间 施无上恩泽</p><p>祛无穷病厄 至生机磅礴</p> <br><p>久闻说</p><p>请垂怜面目</p><p>即令我诸生不灭</p><p>照见万物焕活</p> <br><p>枯竭的 生命能否 再填满</p><p>所过之处 生机重焕焰火</p><p>重燃 驱散了一切病痛 与苦难</p> <br><p>浇灌给 生命花朵 正婆娑</p><p>（休生伤杜惊开景）</p><p>榨取 欲望沟壑</p><p>浇注贪婪与罪恶</p><p>（眼耳鼻舌身与意）</p> <br><p>野心催生邪火</p><p>竭力去 撕扯银河 才挣脱</p><p>（喜怒忧思悲恐惊）</p><p>戳破 善恶自作</p><p>颠倒是非与对错</p><p>（皆 长生无穷之炼狱）</p> <br><p>崭新的 生命能否 更绚烂</p><p>涉足之地 生灵无患神迹</p><p>广传 驱散了一切病痛 与苦难</p> <br><p>浇灌给 生命花朵 正婆娑</p><p>（休生伤杜惊开景）</p><p>榨取 欲望沟壑</p><p>浇注贪婪与罪恶</p><p>（眼耳鼻舌身与意）</p> <br><p>野心催生邪火</p><p>竭力去 撕扯银河 才挣脱</p><p>（喜怒忧思悲恐惊）</p><p>戳破 善恶自作</p><p>颠倒是非与对错</p><p>（皆 长生无穷之炼狱）</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 崩坏：星穹铁道 </tag>
            
            <tag> 祖娅纳惜 </tag>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】寰宇记书（和声付）【2024星穹铁道生日会】</title>
      <link href="/p/6b4006e6/"/>
      <url>/p/6b4006e6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%AF%B0%E5%AE%87%E8%AE%B0%E4%B9%A6.jpg"></p><p>已灌词，和声可能会扒错（叔叔的音质 唉），使用请注意！</p><p>BPM：134</p><hr><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/festival/honkaistarrail2024birthday?spm_id_from=444.41.list.card_archive.click">2024星穹铁道生日会-空间站 (bilibili.com)</a></p><p>企划：心碎奈奈</p><p>作曲：TalanTara</p><p>作词：冉语优</p><p>编曲：JAMES YEO 杨奋郁</p><p>调校：Creuzer</p><p>协力：炖汤</p><p>演唱：星尘infinity</p><p>美术监督：三文鱼火锅</p><p>美术：芋圆西米露、笼茸、TT、黑鹤、漏安能吉、魔法少女图波列夫、4WHYX、Ailk、MIKOKO、夜霖、乐风、封鸟、春下昼、Wall_brick、脑子、阿书_qxs、SENTTER</p><p>视频：爱猫甜</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1uWI9vCXBEuIAUi0njQoPkQ?pwd=4ern">https://pan.baidu.com/s/1uWI9vCXBEuIAUi0njQoPkQ?pwd=4ern</a></p><p>提取码: 4ern</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>请在万众集群里 落座一隅</p><p>随我默记 这同谐颂曲</p><p>强和弱皆当守序 永恒的戒律</p><p>生与死相系再不分离</p><br><p>比律知理更独一</p><p>比奶酒蜜更珍稀</p><p>诸世解体 永存惟记忆</p><p>离群索居远避 这一番混沌絮语</p><p>宇宙是未瓦解的 虚无之地</p> <br><p>庸人一般造星壁</p><p>哲人般筑城基</p><p>天外银河决堤 火与光吞覆寰宇</p><p>此际的黎明静谧 坚不可逾</p><p>守护万纪如一 存世即真理</p> <br><p>垂目四方莞然听 信徒低语</p><p>长生只需 以血肉祝祭</p><p>怜惜世人皆凡躯 有情皆哀戚</p><p>丰饶应许你一切所祈</p> <br><p>拭着血迹开火狱</p><p>披着丧袍唱安息</p><p>物质是种文明的恶癖</p><p>让末日的气息 去宣告众星死期</p><p>赐万宙满目疮痍 以熵之名</p> <br><p>彼时箭镞已扬起</p><p>麾领万军千骑</p><p>将军万死不惜 开弓万战至捐躯</p><p>夕阳熔血铸锋镝 光曜万里</p><p>巡星海猎孽迹 下一个是你</p> <br><p>愿你的 坟墓会是欢愉</p><p>愿你在 大笑当中死去</p><p>神祇是群诙谐的物体</p><p>而我不过是它们 其中之一</p> <br><p>世界不过是一句</p><p>重构的谜语</p><p>彼此多位一体 万物间势均力敌</p><p>谁迈步走向真理 那一刻起</p><p>就已占据智者 不败的高地</p> <br><p>时空切片了寰宇</p><p>命途如此瑰丽</p><p>最远的是过去 最苍白的是恐惧</p><p>在这无限夜色里 列车穿行</p><p>此世开拓之旅 终将抵群星</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 崩坏：星穹铁道 </tag>
            
            <tag> 星尘Infinity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Spring】Mapper 返回为 null 解决方法</title>
      <link href="/p/b5696360/"/>
      <url>/p/b5696360/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>Mapper</code>在执行查询语句时，能查询出正确结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from seller_categories where seller_id=#&#123;seller_id&#125;&quot;)</span></span><br><span class="line">   List&lt;Seller_categories&gt; <span class="title function_">getSellCategory</span><span class="params">(Integer seller_id)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240423234356004.png" alt="image-20240423234356004"></p><p>然而map到返回值时，却全是<code>null</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/aad7b7b4c31b8255d91ca3e5b894999.png" alt="aad7b7b4c31b8255d91ca3e5b894999"></p><p>其中，<code>Seller_categories</code>类定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Seller_categories</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer seller_id;</span><br><span class="line">    <span class="keyword">private</span> Integer category_id;</span><br><span class="line">    <span class="keyword">private</span> Integer sub_category_id;</span><br><span class="line">    <span class="keyword">private</span> Integer is_all_sub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驼峰转换已开启</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>看了最后付的那篇文章，我突然灵光一闪，将<code>Seller_categories</code>类小改一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Seller_categories</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sellerId;</span><br><span class="line">    <span class="keyword">private</span> Integer category_id;</span><br><span class="line">    <span class="keyword">private</span> Integer sub_category_id;</span><br><span class="line">    <span class="keyword">private</span> Integer is_all_sub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您猜怎么着，还真可以</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240423234908194.png" alt="image-20240423234908194"></p><p>我的母语是无语。。。</p><p>所以猜测：驼峰转换转的是数据库的，而类中的不会转，所以类如果用的是下划线，查询时数据库的转成了驼峰，此时就map不上</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>定义类时使用驼峰命名即可。</p><p>顺便，如果需要使用类去接收<code>Json</code>的传参（特指<code>boolean</code>类型的），需要使用<code>@JsonProperty</code>进行注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonProperty(&quot;isDefault&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> isDefault;</span><br></pre></td></tr></table></figure><p>因为这个参数方法也是<code>isDefault()</code>，<code>RPC</code>框架在反向解析的时候，会误判deleted才是属性名称，导致属性获取不到，进而产生抛出异常或者传参失败等情况。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/hbcdeeee/article/details/82591418">Mapper返回为NULL的问题(Springboot2.0.4+Mybatis3.4.6+MySQL)_查找usermapper可以是null的原因-CSDN博客</a></p><p><a href="https://blog.csdn.net/Coder_Cola/article/details/124817961">一文让你明白@RequestBody接收不到boolean值的原因_前端传boolean传入不进去-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】ThreadLocal 简介</title>
      <link href="/p/53ab7115/"/>
      <url>/p/53ab7115/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在面试环节中，考察”ThreadLocal”也是面试官的家常便饭，所以对它理解透彻，是非常有必要的.</p><p>有些面试官会开门见山的提问：</p><ul><li>“知道ThreadLocal吗？”</li><li>“讲讲你对ThreadLocal的理解”</li></ul><p>当然了，也有面试官会慢慢引导到这个话题上，比如提问“在多线程环境下，如何防止自己的变量被其它线程篡改”，将主动权交给你自己，剩下的靠自己发挥。</p><h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>首先，它是一个数据结构，有点像HashMap，可以保存”key : value”键值对，但是一个ThreadLocal只能保存一个，并且<strong>各个线程的数据互不干扰</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/2-CFHd4NU8.png" alt="ThreadLocal数据结构"></p><p>看看<code>set(T value)</code>和<code>get()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/6-DAaW6e2T.png" alt="ThreadLocal.set()"></p><p>可以发现，每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行set方法中，是从当前线程的<code>threadLocals</code>变量获取。</p><p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p><p>那每个线程中的<code>ThreadLocalMap</code>究竟是什么？</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h3 id="ThreadLocalMap-的-Hash-算法"><a href="#ThreadLocalMap-的-Hash-算法" class="headerlink" title="ThreadLocalMap 的 Hash 算法"></a>ThreadLocalMap 的 Hash 算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前 key 在散列表中对应的数组下标位置。</p><p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当创建一个<code>ThreadLocal</code>对象，这个<code>ThreadLocal.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p><p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><h3 id="ThreadLocalMap-的-Hash-冲突"><a href="#ThreadLocalMap-的-Hash-冲突" class="headerlink" title="ThreadLocalMap 的 Hash 冲突"></a>ThreadLocalMap 的 Hash 冲突</h3><p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分割数</strong>来作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p><p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p><p>而 <code>ThreadLocalMap</code> 中并没有链表结构，所以这里不能使用 <code>HashMap</code> 解决冲突的方式了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/7-VC1KCijc.png" alt="Hash冲突"></p><div class="note  flat info no-icon"><p><strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p></div><p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过 <code>hash</code> 计算后应该落入槽位 4 中，而槽位 4 已经有了 <code>Entry</code> 数据。</p><p>此时就会线性向后查找，一直找到 <code>Entry</code> 为 <code>null</code> 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 <code>Entry</code> 不为 <code>null</code> 且 <code>key</code> 值相等的情况，还有 <code>Entry</code> 中的 <code>key</code> 值为 <code>null</code> 的情况等等都会有不同的处理，后面会一一详细讲解。</p><p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry&#x3D;2 的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>ThreadLocal可能导致内存泄漏，为什么？</p><p>(GC相关内容先跳过，以后再补充！)</p><h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><p>待补充</p><h1 id="ThreadLocalMap-set-详解"><a href="#ThreadLocalMap-set-详解" class="headerlink" title="ThreadLocalMap.set() 详解"></a>ThreadLocalMap.set() 详解</h1><p>待补充</p><h1 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a>ThreadLocalMap.get()详解</h1><p>待补充</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/377bb840802f">Java面试必问，ThreadLocal终极篇 - 简书 (jianshu.com)</a></p><p><a href="https://javaguide.cn/java/concurrent/threadlocal.html">ThreadLocal 详解 | JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 项目部署云服务器</title>
      <link href="/p/e6fa9b9/"/>
      <url>/p/e6fa9b9/</url>
      
        <content type="html"><![CDATA[<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><h2 id="修改application-yml（可选）"><a href="#修改application-yml（可选）" class="headerlink" title="修改application.yml（可选）"></a>修改application.yml（可选）</h2><p>将<code>datasource</code>里面的<code>username</code>和<code>password</code>改为待会部署后要用的，当然也可以保持不动</p><p>注意密码的安全性！</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421233211710.png" alt="image-20240421233211710"></p><p>双击<code>package</code>即可打包，打包完成后即可在项目的<code>target</code>文件夹中找到打包好的<code>jar</code>文件</p><h2 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h2><p>打开<code>Workbench</code>，进入数据库，点击<code>Data Export</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421234045330.png" alt="image-20240421234045330"></p><p>选择要导出的数据库，选择导出到单个文件</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421234151202.png" alt="image-20240421234151202"></p><p>然后导出就可以了</p><h1 id="部署到云服务器"><a href="#部署到云服务器" class="headerlink" title="部署到云服务器"></a>部署到云服务器</h1><h2 id="添加网站"><a href="#添加网站" class="headerlink" title="添加网站"></a>添加网站</h2><p>首先在宝塔的文件中，一个合适的位置（<code>/www/wwwroot/项目名</code>）上传打包好的<code>jar</code>文件</p><p>来到宝塔面板的<code>网站</code>，选择<code>Java项目</code>，添加</p><p>初次使用时，需要先安装<code>JDK</code>，安装对应版本即可</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421224234894.png" alt="image-20240421224234894"></p><p>安装完之后重新打开添加面板，选择<code>jar</code>路径，填写端口（别忘了在防火墙放行）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421224446732.png" alt="image-20240421224446732"></p><p>以及别忘了安装<code>Redis</code>（如果项目中用到了的话）</p><h2 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h2><p>宝塔中MySQL版本需要和我们实际用的版本一致（比如8.0），默认安装时是5.7，如果不一致，可以卸载重装（极速安装（好吧一点也不极速 慢死了！）</p><p>放一个网上的方法（没试过行不行），在服务器的远程控制台中执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.bt.cn/install/1/mysql.sh;</span><br><span class="line">bash mysql.sh install 5.7</span><br></pre></td></tr></table></figure><p>请注意：如果你已经安装了数据库，上面的命令会卸载删除当前数据库及数据</p><p>添加数据库（数据库名、用户名和密码要和项目设置<code>application.yml</code>保持一致）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421224656951.png" alt="image-20240421224656951"></p><p>注意密码&#x2F;权限！有朋友数据库被黑过的！</p><p>然后就是上传，导入（数据库版本不一致可能会导入失败！）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240421224844222.png" alt="image-20240421224844222"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 宝塔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奥斯卡/永夜Minus】《如果可以》我想和你回到那天相遇（Cover：韦礼安/蔡依林）【Synthesizer V Cover】</title>
      <link href="/p/866abf45/"/>
      <url>/p/866abf45/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%E3%80%90%E5%A5%A5%E6%96%AF%E5%8D%A1%E3%80%81%E6%B0%B8%E5%A4%9CMinus%E3%80%91%E3%80%8A%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%20Red%20Scarf%E3%80%8Bsmall.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《如果可以》</p><p><em>电影《月老》主题曲</em></p><p>本家：<a href="https://www.bilibili.com/video/BV1qP411v7Cm/">BV1qP411v7Cm</a></p><p>翻唱：奥斯卡Oscar、永夜Minus</p><p>和声：岸晓、奥斯卡Oscar、永夜Minus</p><p>扒谱：墨小墨P、Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><p>非常好歌曲，使我火速摸了</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>演唱Performer：韋禮安WeiBird、蔡依林 Jolin Tsai</p><p>詞Lyricist：九把刀Giddens</p><p>曲Composer：WeiBird 韋禮安／JerryC</p><p>製作人Producer：JerryC</p><p>編曲Arrangement：JerryC</p><p>吉他Guitar：JerryC</p><p>弦樂編寫Strings Arrangement：游政豪Roger Yo</p><p>弦樂監製Strings Supervisor：李朋 Li Peng</p><p>弦樂Strings：國際首席愛樂樂團International Master Philharmonic Orchestra</p><p>和聲編寫Backing Vocal Arrangement：韋禮安WeiBird／JerryC</p><p>和聲Backing Vocals：韋禮安WeiBird</p><p>錄音工程師Recording Engineer：JerryC</p><p>錄音室Recording Studio：Awesome Music Studio／Yellout Studio</p><p>混音工程師Mixing Engineer：康小白Shiro Kou</p><p>混音錄音室Mixing Studio：白帕斯混音工作室BYPASS Mixing Studio</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>你的声音 解开了故事的谜语</p><p>落下一万年的约定</p><p>大树下的你 红色围巾 手心里捧的雨</p><p>哭了笑了 除了你还是你</p><br><p>我们 如果又一次错过 不敢牵起你的手</p><p>我会多么寂寞 等待红线来的时候</p><br><p>如果可以 我想和你回到那天相遇</p><p>让时间停止 那一场雨</p><p>只想拥抱 你在身边的证据 吻你的呼吸</p><p>一眨眼 一瞬间 你说好就是永远</p><p>不会变</p> <br><p>大树下的你 红色围巾 手心里捧的雨</p><p>哭了笑了 除了你还是你</p><br><p>我们 如果又一次错过 不敢牵起你的手</p><p>如果没有如果 等到红线来的时候</p><br><p>如果可以 我想和你回到那天相遇</p><p>让时间停止 那一场雨</p><p>只想拥抱 你在身边的证据 吻你的呼吸</p><p>一眨眼 一瞬间 你说好就是永远</p><br><p>如果可以 茫茫人海千年一眼相遇</p><p>月光下转身 那就是你</p><p>红线划过 深藏轮回的秘密 我挥霍运气</p><p>因为你 才让我 背对命运不害怕</p><br><p>靠近了 相信了 到底我们爱得有多狼狈</p><p>暴雨狂风也不想防备</p><p>爱了 就爱了 只刻在我们泪光的约定 火开出了花</p><br><p>如果可以 我想和你回到那天相遇</p><p>让时间停止 那一场雨</p><p>只想拥抱 你在身边的证据 吻你的呼吸</p><p>一眨眼 一万年 留给我别困住你</p><br><p>如果可以 茫茫人海千年一眼相遇</p><p>月光下转身 那就是你</p><p>红线划过 深藏轮回的秘密 我花光运气</p><p>你是我 赌上世界的 决定</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奥斯卡 </tag>
            
            <tag> SynthV </tag>
            
            <tag> 永夜Minus </tag>
            
            <tag> 韦礼安 </tag>
            
            <tag> 蔡依林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vite+Vue】如何使用FFMpeg &amp; FFMpeg 常用命令</title>
      <link href="/p/b718b92a/"/>
      <url>/p/b718b92a/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install @ffmpeg/ffmpeg @ffmpeg/util</span><br></pre></td></tr></table></figure><p>配置<code>vite.config.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">exclude</span>: [<span class="string">&#x27;@ffmpeg/ffmpeg&#x27;</span>, <span class="string">&#x27;@ffmpeg/util&#x27;</span>]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>2024&#x2F;06&#x2F;16 更新</p><h2 id="初始化（在线加载）"><a href="#初始化（在线加载）" class="headerlink" title="初始化（在线加载）"></a>初始化（在线加载）</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FFmpeg</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/ffmpeg&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">LogEvent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/ffmpeg/dist/esm/types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchFile, toBlobURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseURL = <span class="string">&#x27;https://unpkg.com/@ffmpeg/core-mt@0.12.6/dist/esm&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ffmpeg = <span class="keyword">new</span> <span class="title class_">FFmpeg</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">initFFMpeg</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        ffmpeg.<span class="title function_">on</span>(<span class="string">&#x27;log&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ffmpeg.<span class="title function_">load</span>(&#123;</span><br><span class="line">            <span class="attr">coreURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`<span class="subst">$&#123;baseURL&#125;</span>/ffmpeg-core.js`</span>, <span class="string">&#x27;text/javascript&#x27;</span>),</span><br><span class="line">            <span class="attr">wasmURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`<span class="subst">$&#123;baseURL&#125;</span>/ffmpeg-core.wasm`</span>, <span class="string">&#x27;application/wasm&#x27;</span>),</span><br><span class="line">            <span class="attr">workerURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`<span class="subst">$&#123;baseURL&#125;</span>/ffmpeg-core.worker.js`</span>, <span class="string">&#x27;text/javascript&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;FFMpeg 已加载&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中这里是通过网络加载<code>FFMpeg</code>的核心等等，开发环境下配置<code>vite.config.ts</code>可以正常加载，但是生产环境（打包后）将会<strong>无法加载</strong></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Cross-Origin-Opener-Policy&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Cross-Origin-Embedder-Policy&#x27;</span>: <span class="string">&#x27;require-corp&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>原因：这里面要获取的<code>wasm</code>比较大（ps：获取两个js没问题），需要用到<code>SharedArrayBuffer</code>，而<code>SharedArrayBuffer</code>需要<strong>开启了跨域隔离</strong>才能正常使用（在控制台中输入 <code>crossOriginIsolated</code> 回车，为 false，则说明并没有开启跨域隔离），而上面的设置仅对开发环境有效，生产环境不起作用。或许在<code>Nginx</code>里面配置可以解决，但是这里不作研究了，因为我这里要做的是一个桌面应用程序，而不是网站</p><h2 id="初始化（静态资源加载）"><a href="#初始化（静态资源加载）" class="headerlink" title="初始化（静态资源加载）"></a>初始化（静态资源加载）</h2><p>把加载过程中用到的三个文件放到<code>public</code>文件夹</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/841106e2f7ed4f6da5f194a5b36f589b.png" alt="img"></p><p>然后加载就可以了</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FFmpeg</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/ffmpeg&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">LogEvent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/ffmpeg/dist/esm/types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchFile, toBlobURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@ffmpeg/util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ffmpeg = <span class="keyword">new</span> <span class="title class_">FFmpeg</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">initFFMpeg</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        ffmpeg.<span class="title function_">on</span>(<span class="string">&#x27;log&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ffmpeg.<span class="title function_">load</span>(&#123;</span><br><span class="line">            <span class="attr">coreURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`./ffmpeg-core.js`</span>, <span class="string">&#x27;text/javascript&#x27;</span>),</span><br><span class="line">            <span class="attr">wasmURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`./ffmpeg-core.wasm`</span>, <span class="string">&#x27;application/wasm&#x27;</span>),</span><br><span class="line">            <span class="attr">workerURL</span>: <span class="keyword">await</span> <span class="title function_">toBlobURL</span>(<span class="string">`./ffmpeg-core.worker.js`</span>, <span class="string">&#x27;text/javascript&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">success</span>(<span class="string">&#x27;FFMpeg 已加载&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这么做的话开发环境和生产环境都没问题，只是打包后体积会变大一点</p><p>还有一个缺点的话，亲测如果非要部署到服务器上当一个网站来用，加载的时候会<strong>非 常 慢</strong>（但也总比获取不了<code>wasm</code>好（（（</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">raw</span>:<span class="title class_">File</span>=audioList.<span class="property">value</span>.<span class="title function_">find</span>(<span class="function"><span class="params">obj</span>=&gt;</span>obj.<span class="property">name</span>===row.<span class="property">name</span>)?.<span class="property">raw</span></span><br><span class="line"><span class="keyword">await</span> ffmpeg.<span class="title function_">writeFile</span>(row.<span class="property">name</span>, <span class="keyword">await</span> <span class="title function_">fetchFile</span>(raw))</span><br><span class="line"><span class="keyword">await</span> ffmpeg.<span class="title function_">exec</span>([<span class="string">&#x27;-i&#x27;</span>,row.<span class="property">name</span>,<span class="string">&#x27;-ar&#x27;</span>,row.<span class="property">sample</span>,<span class="string">&#x27;-acodec&#x27;</span>,row.<span class="property">bit</span>,exportName])</span><br><span class="line"><span class="keyword">const</span> data=<span class="keyword">await</span> ffmpeg.<span class="title function_">readFile</span>(exportName)</span><br><span class="line"><span class="keyword">const</span> exportPath=<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([(data <span class="keyword">as</span> <span class="title class_">Uint8Array</span>).<span class="property">buffer</span>],&#123;<span class="attr">type</span>:<span class="string">&#x27;audio/wav&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure><p><code>fetchFile</code>里面可以传入File对象，也可以传入一个URL</p><p><code>exec</code>为<code>FFMpeg</code>执行命令的函数，与平常使用差不多，但是这里是通过数组将参数分开的</p><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><p>目前我在使用中遇到的问题有：</p><ul><li>转换视频时<code>-s</code>参数无效（或者说和改变分辨率参数相关的都无效，总之就是无法改变视频分辨率）</li><li>转换视频时速度巨慢</li></ul><p>这两个问题在使用<code>真·FFMpeg</code>时是没有问题的，可能是插件的bug吧~</p><p>2024&#x2F;07&#x2F;02更新：</p><p>编码速度慢这个问题，其实在官网的FAQ就有（</p><h3 id="Why-ffmpeg-wasm-is-so-slow-comparing-to-ffmpeg"><a href="#Why-ffmpeg-wasm-is-so-slow-comparing-to-ffmpeg" class="headerlink" title="Why ffmpeg.wasm is so slow comparing to ffmpeg?"></a>Why ffmpeg.wasm is so slow comparing to ffmpeg?</h3><p>As of now, WebAssembly is still a lot slower than native, it is possible to further speed up using WebAssembly intrinsic, which is basically writing assembly code. It is something we are investigating and hope to introduce in the future.</p><p>If you are OK with more unstable version of ffmpeg.wasm, using ffmpeg.wasm multithread (mt) version can have around 2x speed comparing to single thread (but consume a lot more memory and cpu)</p><h1 id="FFMpeg-常用命令"><a href="#FFMpeg-常用命令" class="headerlink" title="FFMpeg 常用命令"></a>FFMpeg 常用命令</h1><h2 id="抽取音频"><a href="#抽取音频" class="headerlink" title="抽取音频"></a>抽取音频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -c:a copy output.aac</span><br></pre></td></tr></table></figure><p><code>-vn</code>表示no video，<code>-c:a</code> 是<a href="https://so.csdn.net/so/search?q=codec&spm=1001.2101.3001.7020">codec</a> of audio的意思，<code>copy</code>是直接拷贝视频中的原始的音频，这里不会涉及音频的编解码，速度会很快。</p><p>也可以指定格式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -b:a 128k -ar 44k -c:a mp3 output.mp3</span><br></pre></td></tr></table></figure><h2 id="抽取视频"><a href="#抽取视频" class="headerlink" title="抽取视频"></a>抽取视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v copy output.mp4</span><br></pre></td></tr></table></figure><p><code>-an</code>表示no audio，其他关于视频的参数都可以使用</p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>主要用到<code>ffprobe</code>，但是这个插件似乎并没有提供</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffprobe video.mp4</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffprobe -show_format ~/Downloads/2018121051.mp4</span><br></pre></td></tr></table></figure><p>上述命令可以输出格式信息format_name、时间长度duration、文件大小size、比特率bit_rate、流的数目nb_streams等。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams 2018121051.mp4</span><br></pre></td></tr></table></figure><p>上述命令可以以JSON格式的形式输出具体每一个流最详细的信息，视频中会有视频的宽高信息、是否有b帧、视频帧的总数目、视频的编码格式、显示比例、比特率等信息，音频中会有音频的编码格式、表示格式、声道数、时间长度、比特率、帧的总数目等信息</p><h2 id="转换编码"><a href="#转换编码" class="headerlink" title="转换编码"></a>转换编码</h2><p>转换编码格式（transcoding）指的是， 将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器<code>libx264</code>，所以只需指定输出文件的视频编码器即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [input.file] -c:v libx264 output.mp4</span><br></pre></td></tr></table></figure><h2 id="转换容器"><a href="#转换容器" class="headerlink" title="转换容器"></a>转换容器</h2><p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4 转 webm 的写法。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c copy output.webm</span><br></pre></td></tr></table></figure><h2 id="使用预设-preset"><a href="#使用预设-preset" class="headerlink" title="使用预设 -preset"></a>使用预设 -preset</h2><p><strong>–preset</strong>的参数主要调节编码速度和质量的平衡，有ultrafast（转码速度最快，视频往往也最模糊）、superfast、veryfast、<a href="https://so.csdn.net/so/search?q=faster&spm=1001.2101.3001.7020">faster</a>、fast、medium、slow、slower、veryslow、placebo这10个选项，从快到慢。</p><h2 id="音频常用命令"><a href="#音频常用命令" class="headerlink" title="音频常用命令"></a>音频常用命令</h2><ul><li><code>-ar[:stream_specifier] freq</code> (<em>input&#x2F;output,per-stream</em>)</li></ul><p>设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅对音频抓取设备和原始解复用器有意义，并映射到相应的解复用器选项。</p><ul><li><code>-aq q</code> (<em>output</em>)</li></ul><p>设置音频质量（特定于编解码器、VBR）。这是 -q:a 的别名。</p><ul><li><code>-ac[:stream_specifier] channels</code> (<em>input&#x2F;output,per-stream</em>)</li></ul><p>设置音频通道数。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅对音频抓取设备和原始解复用器有意义，并映射到相应的解复用器选项。</p><ul><li><code>-acodec codec</code> (<em>input&#x2F;output</em>)</li></ul><p>设置音频编解码器。这是 <code>-codec:a</code> 的别名。</p><ul><li><code>-sample_fmt[:stream_specifier] sample_fmt</code> (<em>output,per-stream</em>)</li></ul><p>设置音频样本格式。用于<code>-sample_fmts</code>获取支持的示例格式的列表。</p><h2 id="视频常用命令"><a href="#视频常用命令" class="headerlink" title="视频常用命令"></a>视频常用命令</h2><ul><li><code>-r[:stream_specifier] fps</code> (<em>input&#x2F;output,per-stream</em>)</li></ul><p>设置帧速率（Hz 值、分数或缩写）。</p><p>作为输入选项，忽略文件中存储的任何时间戳，而是假设恒定帧速率fps生成时间戳。这与-帧率用于某些输入格式的选项，如 image2 或 v4l2（在旧版本的 FFmpeg 中曾经是相同的）。如果有疑问，请使用-帧率而不是输入选项-r。</p><ul><li><code>-fpsmax[:stream_specifier] fps</code> (<em>output,per-stream</em>)</li></ul><p>设置最大帧速率（Hz 值、分数或缩写）。</p><p>当输出帧率自动设置且高于此值时，钳位输出帧率。在批处理或输入帧速率被错误地检测为非常高时很有用。不能与 一起设置<code>-r</code>。在流复制期间它被忽略。</p><ul><li><code>-s[:stream_specifier] size</code> (<em>input&#x2F;output,per-stream</em>)</li></ul><p>设置帧大小。</p><p>作为输入选项，这是视频大小私有选项，被一些解复用器识别，其帧大小要么不存储在文件中，要么是可配置的——例如原始视频或视频采集器。</p><p>作为输出选项，这会将<code>scale</code>视频过滤器插入到 相应过滤器图的<em>末尾</em>。请直接使用<code>scale</code>过滤器将其插入开头或其他位置。</p><p>格式为 ‘宽x高’（默认 - 与源相同）。</p><ul><li><code>-aspect[:stream_specifier] aspect</code> (<em>output,per-stream</em>)</li></ul><p>设置由aspect指定的视频显示宽高比。</p><p>spect可以是浮点数字符串，也可以是num : den形式的字符串，其中num和den是纵横比的分子和分母。例如，“4:3”、“16:9”、“1.3333”和“1.7777”是有效的参数值。</p><p>如果与一起使用-vcodec复制，它将影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</p><ul><li><code>-vcodec codec</code> (<em>output</em>)</li></ul><p>设置视频编解码器。这是 <code>-codec:v</code> 的别名。</p><ul><li><code>-b:v rate</code></li></ul><p>主要是控制平均码率。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -b:v 2000k output.mp4</span><br></pre></td></tr></table></figure><h3 id="控制码率"><a href="#控制码率" class="headerlink" title="控制码率"></a>控制码率</h3><p>除了<code>-b:v</code>，还有其他两种方法</p><ul><li><h3 id="qp（constant-quantizer恒定量化器模式）"><a href="#qp（constant-quantizer恒定量化器模式）" class="headerlink" title="-qp（constant quantizer恒定量化器模式）"></a><code>-qp</code>（constant quantizer恒定量化器模式）</h3></li></ul><p>所谓的量化器就是利用特殊算法将画质转化为数字，这样的话每一帧的画质都可以通过量化参数来判定。在qp模式下，画质被分为0…20…40…51个级别，0就是无损的画质。用qp压制视频，每一帧的画面都能达到该级别的质量，严格的遵循量化参数来编码，这么一来他的画质是最好的，体积也是最大的，大到你无法想象，所以我们都不采用这种码率控制模式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mkv -vcodec libx264 -preset ultrafast -qp 0 output.mkv</span><br></pre></td></tr></table></figure><ul><li><h3 id="crf（constant-rate-factor恒定速率因子模式）"><a href="#crf（constant-rate-factor恒定速率因子模式）" class="headerlink" title="-crf（constant rate factor恒定速率因子模式）"></a><code>-crf</code>（constant rate factor恒定速率因子模式）</h3></li></ul><p>crf其实是一个浮动的qp模式，他按照特定的标准，根据人体肉眼的特点，给予每帧画面不同的量化参数，有些画面画质低一点，有些画面画质高一点其实人眼是很难识别的。所以我们可以降低一点码率，然后把这些码率用到视觉敏感的画面里，这么一来，画质的变化几乎看不出来，码率却降低了不少，文件体积自然也变小了.</p><p>在优先保证画面质量（也不太在乎转码时间）的情况下，使用-crf参数来控制转码是比较适宜的。这个参数的取值范围为0——51，其中0为无损模式，数值越大，画质越差，生成的文件却越小。从主观上讲，18——28是一个合理的范围。18被认为是视觉无损的（从技术角度上看当然还是有损的），它的输出视频质量和输入视频相当。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\src.mov -c:v libx264 -preset veryslow -crf 18 -c:acopy D:\dest1.mp4</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;input.mp4&quot; -ss 00:21:15 -to 00:24:50 -c copy -c:a copy &quot;output.mp4&quot;</span><br></pre></td></tr></table></figure><p><code>-ss</code>：起始时间</p><p><code>-to</code>：终止时间</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/xindoo/article/details/121482547">使用ffmpeg从视频中提取纯音频&amp;纯视频_ffmpeg提取音频-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/fd3c6d02a625">FFmpeg、FFprobe、FFplay命令行使用 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/JineD/article/details/125304570">FFmpeg 转码语句的preset、tune参数说明_ffmpeg preset-CSDN博客</a></p><p><a href="https://ffmpeg.github.net.cn/ffmpeg.html">ffmpeg 文档_ FFmpeg中文网 (github.net.cn)</a></p><p><a href="https://ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg 视频处理入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://blog.csdn.net/ETalien_/article/details/102931065">ffmpeg：码率控制模式、编码方式_ffmpeg bitrate-CSDN博客</a></p><p>[<a href="https://www.cnblogs.com/frost-yen/p/5848781.html">FFmpeg] ffmpeg 常用命令 - 晏过留痕 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_45902692/article/details/135032429">FFmpeg——在Vue项目中使用FFmpeg（安装、配置、使用、SharedArrayBuffer、跨域隔离、避坑…）_vue ffmpeg-CSDN博客</a></p><p><a href="https://ffmpegwasm.netlify.app/docs/faq/#why-ffmpegwasm-is-so-slow-comparing-to-ffmpeg">FAQ | ffmpeg.wasm (ffmpegwasm.netlify.app)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vite </tag>
            
            <tag> FFMpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vite+Vue】获取歌曲元数据</title>
      <link href="/p/d26f4c21/"/>
      <url>/p/d26f4c21/</url>
      
        <content type="html"><![CDATA[<p>项目环境：Vite + Vue3 +TypeScript</p><h1 id="使用music-metadata-browser"><a href="#使用music-metadata-browser" class="headerlink" title="使用music-metadata-browser"></a>使用<code>music-metadata-browser</code></h1><p>Github地址：<a href="https://github.com/Borewit/music-metadata-browser">Borewit&#x2F;music-metadata-browser: Browser version of music-metadata parser Supporting a wide range of audio and tag formats. (github.com)</a></p><div class="note  flat info no-icon"><p><a href="https://github.com/Borewit/music-metadata-browser">music-metadata-browser</a> is a metadata parser, supporting virtual any audio format and tag header around.</p></div><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install music-metadata-browser</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> musicMetadata <span class="keyword">from</span> <span class="string">&#x27;music-metadata-browser&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>提供<code>Blob</code>或<code>File</code>类型的对象： <a href="https://github.com/Borewit/music-metadata-browser#parseblob-function">parseBlob function</a>.</li><li>提供<code>URL</code>： <a href="https://github.com/Borewit/music-metadata-browser#fetchurl-function">fetch the audio track from</a>.</li></ol><h3 id="parseBlob-function"><a href="#parseBlob-function" class="headerlink" title="parseBlob function"></a>parseBlob function</h3><p>Parse an audio file from a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">File</a>.</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blob;</span><br><span class="line"></span><br><span class="line">musicMetadata.<span class="title function_">parseBlob</span>(blob).<span class="title function_">then</span>(<span class="function"><span class="params">metadata</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// metadata has all the metadata found in the blob or file</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>Or with async&#x2F;await if you prefer:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> blob; <span class="comment">// File or Blob</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> metadata = <span class="keyword">await</span> musicMetadata.<span class="title function_">parseBlob</span>(blob);</span><br><span class="line">  <span class="comment">// metadata has all the metadata found in the blob or file</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="fetchUrl-function"><a href="#fetchUrl-function" class="headerlink" title="fetchUrl function"></a>fetchUrl function</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> metadata = <span class="keyword">await</span> musicMetadata.<span class="title function_">fetchFromUrl</span>(audioTrackUrl, options);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h1><p>好了，官网的介绍很美好，使用看起来也很方便，可是我实际上使用的时候，就是各种<code>undefined</code>，包括buffer等等一些很底层的东西。。。。</p><p>首先我这里是通过<code>element-ui</code>的<code>upload</code>拿到的文件，里面的<code>raw</code>本身就是<code>File</code>类型的，在log里面可以看到（此处没图），然后我试着转<code>Blob</code>类型，还是不行</p><p>然后看到这么一句：If you prefer to parse files or streams server (node.js) side, you should use <a href="https://github.com/Borewit/music-metadata">music-metadata</a> instead.</p><p>虽然好像不太符合，但好歹试试吧，结果还是不行</p><p>然后我又去找有没有其他方案，比如看到了<code>jsmediatags</code>，还是不行，而且配置和使用上更加复杂</p><p>然后我又去<code>issues</code>里面找找看有没有希望</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>结果还真有，但是是已经close的issue：<a href="https://github.com/Borewit/music-metadata-browser/issues/836">Can’t use this package with vite 3 · Issue #836 · Borewit&#x2F;music-metadata-browser (github.com)</a></p><p>（所以为什么close掉呢，明明完全没解决，也没有在readme上注明 神金</p><blockquote><p>just one plugin: <a href="https://github.com/grikomsn/vite-plugin-ngmi-polyfill">https://github.com/grikomsn/vite-plugin-ngmi-polyfill</a></p></blockquote><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install vite vite-plugin-ngmi-polyfill -D</span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>修改<code>vite.config.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NgmiPolyfill</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vite-plugin-ngmi-polyfill&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title class_">NgmiPolyfill</span>()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就可以了，就是这么简单</p><h2 id="插播一下"><a href="#插播一下" class="headerlink" title="插播一下"></a>插播一下</h2><p>拿到元数据后，可以发现里面的封面图片，是一个<code>uint8array</code>的数组，那么如何显示呢？（利用<code>img</code>标签，<code>audio</code>和<code>video</code>同理）</p><p>网上方法不止一种，但是花里胡哨的感觉不如直接用<code>Blob</code>，虽然缺点是重启一下就没了，但是这里也只是一个小工具，一次性的用，管他呢</p><p>321上代码</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Blob 对象</span></span><br><span class="line">      <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([common?.<span class="property">picture</span>?.[<span class="number">0</span>].<span class="property">data</span>], &#123; <span class="attr">type</span>: <span class="string">&#x27;image/jpeg&#x27;</span> &#125;);</span><br><span class="line">      <span class="comment">// 创建一个 Blob URL</span></span><br><span class="line">      <span class="keyword">const</span> blobUrl = <span class="keyword">typeof</span> common.<span class="property">picture</span>===<span class="string">&#x27;undefined&#x27;</span>?<span class="string">&#x27;&#x27;</span>:<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br></pre></td></tr></table></figure><p>然后把这个<code>url</code>储存起来，后面直接调用即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column prop=&quot;cover&quot; label=&quot;封面&quot; align=&quot;center&quot;&gt;</span><br><span class="line">       &lt;!-- 图片的显示 --&gt;</span><br><span class="line">       &lt;template   #default=&quot;scope&quot;&gt;</span><br><span class="line">         &lt;img :src=&quot;scope.row.cover&quot;  min-width=&quot;90&quot; height=&quot;90&quot; /&gt;</span><br><span class="line">       &lt;/template&gt;</span><br><span class="line">     &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>这里的<code>img</code>在创建时，<code>cover</code>已经存在了，直接显示没问题，不需要别的操作</p><p>那么如果是组件先出来的，<code>src</code>在后面才有的呢？其实也很简单，给组件绑定一个<code>ref</code>对象，通过<code>ref</code>对象赋<code>src</code>就可以了</p><p>321上代码</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放音频</span></span><br><span class="line"><span class="keyword">const</span> audioRef=<span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handlePlay</span>=<span class="keyword">async</span> (<span class="params">index:<span class="built_in">number</span>,row:&#123;name:<span class="built_in">string</span>&#125;</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">raw</span>:<span class="title class_">File</span>=audioList.<span class="property">value</span>.<span class="title function_">find</span>(<span class="function"><span class="params">obj</span>=&gt;</span>obj.<span class="property">name</span>===row.<span class="property">name</span>)?.<span class="property">raw</span></span><br><span class="line">  <span class="keyword">const</span> blob=<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([raw],&#123;<span class="attr">type</span>:raw.<span class="property">type</span>&#125;)</span><br><span class="line">  audioRef.<span class="property">value</span>.<span class="property">src</span>=<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">ref</span>=<span class="string">&quot;audioRef&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">style</span>=<span class="string">&quot;height:40px; width:90%;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>哈哈 没想到吧 又卡了这么久 真的很无语</p><p>下篇稍微没那么精彩 但是也很精彩（（（（</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】非父子组件通信方法</title>
      <link href="/p/bc5d6bbe/"/>
      <url>/p/bc5d6bbe/</url>
      
        <content type="html"><![CDATA[<h1 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h1><p><a href="https://rean-schwarze.github.io/p/18cda1b3/">【Vue】父子组件通信方法整理 | Rean’s Blog (rean-schwarze.github.io)</a></p><p>我们都知道在Vue里面，父子组件通信有非常多方法，也都挺好用的，那么问题来了，如果两个组件不是父子关系，又要怎么办呢？</p><h1 id="踩坑实录"><a href="#踩坑实录" class="headerlink" title="踩坑实录"></a>踩坑实录</h1><p>是的没错，我又来给大家排雷了，这个问题乍一看好像也不是一个很偏的问题，网上一搜也有很多文章，但是里面绝大部分方法我都试过了，就是不行，哈哈</p><h2 id="利用事件总线"><a href="#利用事件总线" class="headerlink" title="利用事件总线"></a>利用事件总线</h2><p>据说这个是官网就有的一个方法，还有图有真相</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1430985-11f7e296be088d3d.png" alt="img"></p><p>然而我在官方文档（<a href="https://cn.vuejs.org/guide/introduction.html">简介 | Vue.js (vuejs.org)</a>）中，其实并没有找到这段</p><p>大家也不用试了，我试过了，真不行，而且这个一看还用<code>var</code>的，一看就很老了！（后来一看那个教程是17年的草。。。。。。。。。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>下面有请第二位嘉宾：<code>Vuex</code></p><p>官网是这么说的：</p><div class="note  flat info"><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol></div><div class="note  flat info"><p>Vuex本质上也是一种本地存储，比<code>localStorage</code>的单纯值传递多了方法、属性、异步方法等功能。但是因为是将内容本地化，所以就会被在浏览器中获取到。</p></div><p>看上去也很美好，但大家也不用试了，我试过了，反正就是也是各种问题（后面一看这个插件最后更新是21年了，虽然也说不上很老，但是在我这里就是不行！</p><p>应该还有其他，但是这里就不一一列举了！</p><h1 id="真神降临"><a href="#真神降临" class="headerlink" title="真神降临"></a>真神降临</h1><p>总之卡了很久，终于在一篇文章中看到了——PubSubJS 库（醒了很久还是很感动（（</p><p>pubsub的优点：组件之间的通信没有任何位置的限制</p><p>首先安装：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">cnpm install pubsub-js -D</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>首先引入：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PubSub</span> <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在负责发送信息的函数中：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;handleCollapse&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>publish</code>内的内容根据自己需要写就好，如果还有别的参数，就在后面跟着传就行<code>PubSub.publish(&#39;userEvent&#39;,this.msg); //发布消息</code></p><h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><p>处理接收的函数中：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PubSub</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;userEvent&#x27;</span>,<span class="function">(<span class="params">name,data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>然后在<code>onMounted()</code>里面hook一下</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span><span class="title function_">handleCollapse</span>())</span><br></pre></td></tr></table></figure><p>就可以了，真是简简又单单啊</p><h2 id="没踩的坑"><a href="#没踩的坑" class="headerlink" title="没踩的坑"></a>没踩的坑</h2><p>还有一种方法（Vue.observable），我没有试过，如果有朋友无聊，可以试试</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js 文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建响应式对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = <span class="title class_">Vue</span>.<span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = <span class="title class_">Vue</span>.<span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span><br><span class="line">    state.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 vue 文件中使用</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increaseCount&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; num &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; state, mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/index&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">num</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> state.<span class="property">count</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">increaseCount</span>: mutations.<span class="property">increase</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>真是一场精彩刺激的踩坑啊！</p><p>下篇更精彩！（没错又卡了很久（（（</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/d3036001f6d3">Vue 进阶教程之：非父子组件通信方法（包含三个实际使用案例） - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/weixin_40187450/article/details/108264436">VUE非父子组件之间通信的几种方式_vue非父子组件通信最高效的方法-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44727080/article/details/115163037">vuex的传值步骤，详细_若依vuex传值-CSDN博客</a></p><p><a href="https://blog.csdn.net/muzidigbig/article/details/103163371">vue组件通信—非父子组件（bus）&#x2F;任意组件间的通信（pubsub）_vue 深入了解 pubsub-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Electron】无边框窗口实现 &amp; 自定义最小化、关闭</title>
      <link href="/p/5a18917b/"/>
      <url>/p/5a18917b/</url>
      
        <content type="html"><![CDATA[<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240404205840117.png" alt="image-20240404205840117"></p><h1 id="实现无边框窗口"><a href="#实现无边框窗口" class="headerlink" title="实现无边框窗口"></a>实现无边框窗口</h1><p>在创建窗口时，参数中加上：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">titleBarStyle</span>: <span class="string">&#x27;hidden&#x27;</span>,</span><br></pre></td></tr></table></figure><p>顺便如果要禁止对窗口大小进行更改，再加上：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">resizable</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">maximizable</span>:<span class="literal">false</span>,</span><br></pre></td></tr></table></figure><h2 id="禁用滚动条"><a href="#禁用滚动条" class="headerlink" title="禁用滚动条"></a>禁用滚动条</h2><p>在全局css中，<code>body</code>处加上：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure><h2 id="拖拽窗口"><a href="#拖拽窗口" class="headerlink" title="拖拽窗口"></a>拖拽窗口</h2><ul><li>在 CSS 中指定 <code>-webkit-app-region: drag</code> 来告诉 Electron 哪些区域是可拖拽的</li><li>在可拖拽区域内部使用 <code>-webkit-app-region: no-drag</code> 则可以将其中部分区域排除</li></ul><h1 id="自定义最小化、关闭"><a href="#自定义最小化、关闭" class="headerlink" title="自定义最小化、关闭"></a>自定义最小化、关闭</h1><p>主要是靠 Electron 的 ipc 通信，但是我跟网上的教程很多都不行（理论上他们的方法都是没问题的），最后发现竟然是因为……</p><p>此处需要使用preload，因为Electron在（忘了哪个版本）不给直接调用ipcRenderer了（网上很多教程都过时了，我在这上面也卡了很久（（</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>新建一个<code>preload.ts</code>，放哪看个人：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; contextBridge,ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line">contextBridge.<span class="title function_">exposeInMainWorld</span>(<span class="string">&#x27;myApi&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 这里注意避免将ipcRenderer等致命api直接挂载在window上，可能会导致安全问题</span></span><br><span class="line">    <span class="attr">sendMsg</span>: <span class="function">(<span class="params">msg:<span class="built_in">string</span></span>) =&gt;</span> ipcRenderer.<span class="title function_">send</span>(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在创建窗口处的<code>webPreferences</code>加上（路径按个人实际改）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预加载脚本</span></span><br><span class="line"><span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;preload.js&#x27;</span>),</span><br></pre></td></tr></table></figure><p>同时将<code>contextIsolation</code>改为<code>true</code></p><p>然后在创建完窗口代码后面加上（其中<code>win</code>就是创建的窗口）（别忘了import）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭窗口</span></span><br><span class="line">    ipcMain.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        win.<span class="title function_">close</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小化窗口</span></span><br><span class="line">    ipcMain.<span class="title function_">on</span>(<span class="string">&#x27;minimize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        win.<span class="title function_">minimize</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>引号之间的字可以根据个人习惯改~</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在组件中负责最小化&#x2F;关闭的函数中，直接使用：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">myApi</span>.<span class="title function_">sendMsg</span>(<span class="string">&#x27;minimize&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="个人踩坑"><a href="#个人踩坑" class="headerlink" title="个人踩坑"></a>个人踩坑</h2><p>好了，网上大部分教程到这里就结束了（至少我看了那么那么多都是这样的），但是我个人怎么样都无法成功通信，搜了一堆又一堆，也没有找到解决方法，甚至看视频教程，别人用起来也是丝般顺滑，到底是为什么呢？小编也很好奇</p><p>看看vue页面的控制台有没有什么信息。点击按钮，可以看到这个报错：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ%E6%88%AA%E5%9B%BE20240404120810.png" alt="QQ截图20240404120810"></p><p>说是<code>sendMsg</code>没有定义，但是<code>window.myApi.sendMsg(&#39;minimize&#39;);</code>，说明<code>myApi</code>应该能读到（其实并不能）</p><p>再看Electron的<code>dev tool</code>，发现他的报错竟然不太一样：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ%E6%88%AA%E5%9B%BE20240404120751.png" alt="QQ截图20240404120751"></p><p>看一眼，这下破案了，他读的是<code>dist</code>目录下的&#96;preload.js&#96;&#96;</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这不就简单了，直接在<code>vite.electron.dev.ts</code>还有<code>vite.electron.build.ts</code>里面的<code>buildBackground()</code>加上：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;esbuild&#x27;</span>).<span class="title function_">buildSync</span>(&#123;</span><br><span class="line">        <span class="attr">entryPoints</span>:[<span class="string">&#x27;src/preload.ts&#x27;</span>],</span><br><span class="line">        <span class="attr">bundle</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">outfile</span>:<span class="string">&#x27;dist/preload.js&#x27;</span>,</span><br><span class="line">        <span class="attr">platform</span>:<span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;node12&#x27;</span>,</span><br><span class="line">        <span class="attr">external</span>:[<span class="string">&#x27;electron&#x27;</span>]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>这下就没问题了！</p><p>就这么一个小小的功能，真的卡了我很久，感觉把这路上能踩的坑都踩了一遍（（（</p><p>下一篇精彩继续（没错又卡了很久（（</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.electronjs.org/zh/docs/latest/tutorial/window-customization#%E5%88%9B%E5%BB%BA%E6%97%A0%E8%BE%B9%E6%A1%86%E7%AA%97%E5%8F%A3">自定义窗口 | Electron (electronjs.org)</a></p><p><a href="https://blog.csdn.net/liuzehn/article/details/106825420">Electron常见问题 14 - 窗口禁用滚动条_electron 滚动条-CSDN博客</a></p><p><a href="https://blog.csdn.net/fukaiit/article/details/91351448">Electron无边框窗口（最小化、最大化、关闭、拖动）以及动态改变窗口大小_electron ,动态配置应用参数-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1Vj411Y7QJ/?spm_id_from=444.41.top_right_bar_window_custom_collection.content.click">【electron】无边框窗口_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue + Vite + TypeScript + Electron 项目起步</title>
      <link href="/p/5f2b1e2f/"/>
      <url>/p/5f2b1e2f/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init vue</span><br><span class="line">cnpm install</span><br><span class="line">cnpm i electron electron-builder -D</span><br></pre></td></tr></table></figure><p>在<code>src</code>目录下新建<code>background.ts</code>（electron主进程文件）</p><p>在根目录下新建文件夹<code>plugins</code>，在里面新建<code>vite.electron.dev.ts</code>以及<code>vite.electron.build.ts</code>（避免启动两个终端分别启动vue和electron）</p><h1 id="配置开发环境electron"><a href="#配置开发环境electron" class="headerlink" title="配置开发环境electron"></a>配置开发环境electron</h1><p>编辑<code>vite.electron.dev.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">Plugin</span>&#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">AddressInfo</span>&#125; <span class="keyword">from</span> <span class="string">&quot;net&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;spawn&#125; <span class="keyword">from</span> <span class="string">&#x27;child_process&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">buildBackground</span>=(<span class="params"></span>)=&gt;&#123;&#123;</span><br><span class="line">    <span class="comment">// vite的开发环境使用esbuild，打包环境使用rollup, 将ts编译为js</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;esbuild&#x27;</span>).<span class="title function_">buildSync</span>(&#123;</span><br><span class="line">        <span class="attr">entryPoints</span>:[<span class="string">&#x27;src/background.ts&#x27;</span>],</span><br><span class="line">        <span class="attr">bundle</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">outfile</span>:<span class="string">&#x27;dist/background.js&#x27;</span>,</span><br><span class="line">        <span class="attr">platform</span>:<span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;node12&#x27;</span>,</span><br><span class="line">        <span class="attr">external</span>:[<span class="string">&#x27;electron&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> electronDevPlugin=():<span class="function"><span class="params">Plugin</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;electron-dev&#x27;</span>,</span><br><span class="line">        <span class="title function_">configureServer</span>(<span class="params">server</span>)&#123;</span><br><span class="line">            <span class="title function_">buildBackground</span>()</span><br><span class="line">            server?.<span class="property">httpServer</span>?.<span class="title function_">once</span>(<span class="string">&#x27;listening&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 读取vite服务的信息</span></span><br><span class="line">                <span class="keyword">const</span> addressInfo=server.<span class="property">httpServer</span>?.<span class="title function_">address</span>() <span class="keyword">as</span> <span class="title class_">AddressInfo</span></span><br><span class="line">                <span class="comment">// 拼接ip地址</span></span><br><span class="line">                <span class="keyword">const</span> <span class="variable constant_">IP</span>=<span class="string">`http://localhost:<span class="subst">$&#123;addressInfo.port&#125;</span>`</span></span><br><span class="line">                <span class="comment">// 利用进程传递参数, 第0个参数：require()返回路径（electron的入口文件），electron不认识ts文件，第1个参数：路径，第2个参数：IP</span></span><br><span class="line">                <span class="keyword">let</span> electronProcess = <span class="title function_">spawn</span>(<span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>),[<span class="string">&#x27;dist/background.js&#x27;</span>,<span class="variable constant_">IP</span>])</span><br><span class="line">                <span class="comment">// 监控文件，热更</span></span><br><span class="line">                fs.<span class="title function_">watchFile</span>(<span class="string">&#x27;src/background.ts&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    electronProcess.<span class="title function_">kill</span>()</span><br><span class="line">                    <span class="title function_">buildBackground</span>()</span><br><span class="line">                    electronProcess=<span class="title function_">spawn</span>(<span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>),[<span class="string">&#x27;dist/background.js&#x27;</span>,<span class="variable constant_">IP</span>])</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 监听日志</span></span><br><span class="line">                electronProcess.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑<code>tsconfig.node.json</code>，在<code>include</code>加上：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;plugins/**/*.ts&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>编辑<code>background.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// electron 主进程</span></span><br><span class="line"><span class="keyword">import</span> &#123;app,<span class="title class_">BrowserWindow</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;electron&#x27;</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> win=<span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>:<span class="number">1280</span>,</span><br><span class="line">        <span class="attr">height</span>:<span class="number">720</span>,</span><br><span class="line">        <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">            <span class="attr">nodeIntegration</span>:<span class="literal">true</span>, <span class="comment">// 可以在渲染进程中使用node的api</span></span><br><span class="line">            <span class="attr">contextIsolation</span>:<span class="literal">false</span>, <span class="comment">// 关闭渲染进程的沙箱</span></span><br><span class="line">            <span class="attr">webSecurity</span>:<span class="literal">false</span> <span class="comment">// 关闭CORS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(process.<span class="property">argv</span>[<span class="number">2</span>])&#123;</span><br><span class="line">        win.<span class="title function_">loadURL</span>(process.<span class="property">argv</span>[<span class="number">2</span>]) <span class="comment">// 开发环境</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        win.<span class="title function_">loadFile</span>(<span class="string">&#x27;index.html&#x27;</span>) <span class="comment">// 生产环境</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编辑<code>vite.config.ts</code>，导入并添加开发环境插件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;electronDevPlugin&#125; <span class="keyword">from</span> <span class="string">&quot;./plugins/vite.electron.dev&quot;</span>;</span><br></pre></td></tr></table></figure><p>在<code>plugins</code>处加入</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">electronDevPlugin</span>(),</span><br></pre></td></tr></table></figure><h1 id="配置生产环境electron"><a href="#配置生产环境electron" class="headerlink" title="配置生产环境electron"></a>配置生产环境electron</h1><p>编辑<code>vite.electron.build.ts</code></p><p>2024&#x2F;06&#x2F;11更新：取消注释<code>files:[&#39;**/*&#39;],</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">Plugin</span>&#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> electronBuilder <span class="keyword">from</span> <span class="string">&#x27;electron-builder&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&quot;node:path&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止没有npm run dev，直接npm run build而找不到js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">buildBackground</span>=(<span class="params"></span>)=&gt;&#123;&#123;</span><br><span class="line">    <span class="comment">// vite的开发环境使用esbuild，打包环境使用rollup, 将ts编译为js</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;esbuild&#x27;</span>).<span class="title function_">buildSync</span>(&#123;</span><br><span class="line">        <span class="attr">entryPoints</span>:[<span class="string">&#x27;src/background.ts&#x27;</span>],</span><br><span class="line">        <span class="attr">bundle</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">outfile</span>:<span class="string">&#x27;dist/background.js&#x27;</span>,</span><br><span class="line">        <span class="attr">platform</span>:<span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;node12&#x27;</span>,</span><br><span class="line">        <span class="attr">external</span>:[<span class="string">&#x27;electron&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> electronBuildPlugin=():<span class="function"><span class="params">Plugin</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;electron-build&#x27;</span>,</span><br><span class="line">        <span class="comment">// 等vite打包完成</span></span><br><span class="line">        <span class="title function_">closeBundle</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">buildBackground</span>()</span><br><span class="line">            <span class="comment">// electron-builder需要指定package.json</span></span><br><span class="line">            <span class="keyword">const</span> packageJson=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;package.json&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            packageJson.<span class="property">main</span>=<span class="string">&#x27;background.js&#x27;</span></span><br><span class="line">            fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;dist/package.json&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(packageJson,<span class="literal">null</span>,<span class="number">4</span>))</span><br><span class="line">            fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;dist/node_modules&#x27;</span>) <span class="comment">// 弄一个空的文件夹防止bug</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//     打包</span></span><br><span class="line">            electronBuilder.<span class="title function_">build</span>(&#123;</span><br><span class="line">                <span class="attr">config</span>:&#123;</span><br><span class="line">                    <span class="attr">directories</span>:&#123;</span><br><span class="line">                        <span class="attr">output</span>:path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;release&#x27;</span>),</span><br><span class="line">                        <span class="attr">app</span>:path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(),<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">files</span>:[<span class="string">&#x27;**/*&#x27;</span>],</span><br><span class="line">                    <span class="attr">asar</span>:<span class="literal">true</span>, <span class="comment">// 压缩</span></span><br><span class="line">                    <span class="comment">// appId:&#x27;com.example.app&#x27;,</span></span><br><span class="line">                    <span class="attr">productName</span>:<span class="string">&#x27;media-transformer&#x27;</span>,</span><br><span class="line">                    <span class="attr">nsis</span>:&#123;</span><br><span class="line">                        <span class="attr">oneClick</span>:<span class="literal">false</span>, <span class="comment">// 取消一键安装</span></span><br><span class="line">                        <span class="attr">allowToChangeInstallationDirectory</span>: <span class="literal">true</span>, <span class="comment">//允许用户选择安装目录</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑<code>vite.config.ts</code>，导入并添加生产环境插件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;electronBuildPlugin&#125; <span class="keyword">from</span> <span class="string">&quot;./plugins/vite.electron.build&quot;</span>;</span><br></pre></td></tr></table></figure><p>在<code>plugins</code>处加入</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">electronBuildPlugin</span>()</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.bilibili.com/video/BV1dS4y1y7vd/?p=54&spm_id_from=444.41.top_right_bar_window_history.content.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">小满Vue3（第三十九章 electron桌面程序）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vite </tag>
            
            <tag> TypeScript </tag>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奥斯卡】身骑白马（Cover：张杰）【Synthesizer V Cover】</title>
      <link href="/p/2532a2ee/"/>
      <url>/p/2532a2ee/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E8%BA%AB%E9%AA%91%E7%99%BD%E9%A9%AC_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%E3%80%90Oscar%E3%80%91%E8%BA%AB%E9%AA%91%E7%99%BD%E9%A9%AC%EF%BC%88Cover%EF%BC%9A%E5%BC%A0%E6%9D%B0%EF%BC%89.mov" type="video/mp4" >      </video></p><hr><p>2024&#x2F;04&#x2F;16 编辑：</p><p>被官方pick了！好耶！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/628ac3a43c1ceff0ae0b77600e8d3ba8.jpg"></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《身骑白马》</p><p>翻唱：奥斯卡Oscar（Synthesizer V AI）</p><p>部分和声：未抒</p><p>调校：Rean__</p><p>混音：Rean__</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 徐佳莹</p><p>作曲 : 徐佳莹&#x2F;苏通达</p><p>原唱 : 徐佳莹</p><p>SP：丰华音乐经纪股份有限公司</p><p>《传说》</p><p>作词：简远信</p><p>作曲：杨昊东</p><p>原唱：杨昊东 韩元元</p><p>SP：山西发声计划文化传媒有限公司</p><p>音乐总监：谷粟@牛班NEWBAND</p><p>音响总监：何飚</p><p>舞台总监：李柯</p><p>音乐监制：陈美威</p><p>音乐设计：王皓@WONDERWALL</p><p>制作人：汤佩弦@牛班NEWBAND</p><p>改编编曲：陈牧荻</p><p>混音：林梦洋</p><p>戏剧指导：赵月红</p><p>乐队队长：倪方来@牛班NEWBAND</p><p>键盘：董音@牛班NEWBAND&#x2F;洪信杰@牛班NEWBAND</p><p>吉他：倪方来@牛班NEWBAND&#x2F;毕赫宸@牛班NEWBAND</p><p>贝斯：章谋圣@牛班NEWBAND</p><p>鼓：郝稷伦@牛班NEWBAND</p><p>打击乐：荣辰初@牛班NEWBAND</p><p>和音：王梓琼@牛班NEWBAND 杨画画@牛班NEWBAND</p><p>海洋@牛班NEWBAND 张石荻@牛班NEWBAND</p><p>PGM：郭锦阳@牛班NEWBAND</p><p>弦乐：李琪弦乐团</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>我爱谁跨不过 从来也不觉得错</p><p>自以为抓着痛 就能往回忆里躲</p><p>偏执相信着 受诅咒的水晶球</p><p>阻挡可能 心动的理由</p><p>而你却靠近了 逼我们视线交错</p><p>原地不动或向前走 突然在意这分钟</p><p>眼前荒沙弥漫了等候 耳边传来孱弱的呼救</p><p>追赶要我爱得不保留</p><p>我身骑白马走三关</p><p>我改换素衣回中原</p><p>放下西凉无人管</p><p>我一心只想王宝钏</p><p>而你却靠近了逼我们视线交错</p><p>原地不动或向前走突然在意这分钟</p><p>眼前荒沙弥漫了等候耳边传来孱弱的呼救</p><p>追赶要我爱得不保留</p><p>我身骑白马走三关</p><p>我改换素衣回中原</p><p>放下西凉无人管</p><p>我一心只想王宝钏</p><p>满身伤痕累累也来不及痛</p><p>那是指引我走向你的清楚感受</p><p>不管危不危险</p><p>都要放下一切跟你走</p><p>只要一起承担</p><p>只要你不放手</p><p>一马离了西凉关</p><p>赶回寒窑见宝钏</p><p>相府算粮大登殿</p><p>欢欢喜喜再团圆</p><p>我身骑白马走三关</p><p>我改换素衣回中原</p><p>放下西凉无人管</p><p>我一心只想王宝钏</p><p>（我身骑白马走三关</p><p>我改换素衣回中原）</p><p>放下西凉无人管</p><p>我一心只想王宝钏</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奥斯卡 </tag>
            
            <tag> 张杰 </tag>
            
            <tag> 声生不息·宝岛季 </tag>
            
            <tag> 徐佳莹 </tag>
            
            <tag> SynthV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP】TCP 如何优化？</title>
      <link href="/p/4337b2c0/"/>
      <url>/p/4337b2c0/</url>
      
        <content type="html"><![CDATA[<p>接下来，将以三个角度来阐述提升 TCP 的策略，分别是：</p><ul><li>TCP 三次握手的性能提升；</li><li>TCP 四次挥手的性能提升；</li><li>TCP 数据传输的性能提升；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/3.jpg" alt="本节提纲"></p><h1 id="TCP三次握手的性能提升"><a href="#TCP三次握手的性能提升" class="headerlink" title="TCP三次握手的性能提升"></a>TCP三次握手的性能提升</h1><p>三次握手的过程在一个 HTTP 请求的平均时间占比 10% 以上，在网络状态不佳、高并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握手中的参数，就会对性能产生很多的影响。</p><p>如何正确有效的使用这些参数，来提高 TCP 三次握手的性能，这就需要理解「三次握手的状态变迁」，这样当出现问题时，先用 <code>netstat</code> 命令查看是哪个握手阶段出现了问题，再来对症下药，而不是病急乱投医。</p><p>客户端和服务端都可以针对三次握手优化性能。主动发起连接的客户端优化相对简单些，而服务端需要监听端口，属于被动连接方，其间保持许多的中间状态，优化方法相对复杂一些。</p><p>所以，客户端（主动发起连接方）和服务端（被动连接方）优化的方式是不同的，接下来分别针对客户端和服务端优化。</p><h2 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h2><p>客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 <code>SYN_SENT</code> 状态。</p><p>客户端在等待服务端回复的 ACK 报文，正常情况下，服务器会在几毫秒内返回 SYN+ACK ，但如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/7.jpg" alt="img"></p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手。</p><p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/8.jpg" alt="SYN 超时重传"></p><p>你可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p><h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><p>当服务端收到 SYN 包后，服务端会立马回复 SYN+ACK 包，表明确认收到了客户端的序列号，同时也把自己的序列号发给对方。</p><p>此时，服务端出现了新连接，状态是 <code>SYN_RCV</code>。在这个状态下，Linux 内核就会建立一个「半连接队列」来维护「未完成」的握手信息，当半连接队列溢出后，服务端就无法再建立新的连接。</p><p>要想增大半连接队列，<strong>不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大 accept 队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</strong></p><p>增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/11.jpg" alt="img"></p><p>增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/12.jpg" alt="img"></p><p>最后，改变了如上这些参数后，要重启 Nginx 服务，因为 SYN 半连接队列和 accept 队列都是在 <code>listen()</code> 初始化的。</p><div class="note  flat info no-icon"><p>如果 SYN 半连接队列已满，只能丢弃连接吗？</p><br><p>并不是这样，<strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong>。</p><p>syncookies 的工作原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/13.jpg" alt="开启 syncookies 功能"></p><p>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><p>那么在应对 SYN 攻击时，只需要设置为 1 即可：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/14.jpg" alt="img"></p></div><h3 id="SYN-RCV-状态的优化"><a href="#SYN-RCV-状态的优化" class="headerlink" title="SYN_RCV 状态的优化"></a>SYN_RCV 状态的优化</h3><p>当客户端接收到服务器发来的 SYN+ACK 报文后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建立成功。</p><p>服务器端连接成功建立的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变为 ESTABLISHED。</p><p>如果服务器没有收到 ACK，就会重发 SYN+ACK 报文，同时一直处于 SYN_RCV 状态。</p><p>当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。<strong>修改重发次数的方法是，调整 tcp_synack_retries 参数</strong>：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/15.jpg" alt="img"></p><p>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、16 秒，最后一次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。</p><p>服务器收到 ACK 后连接建立成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</p><p>如果进程不能及时地调用 accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建立好的 TCP 连接被丢弃。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/16.jpg" alt=" accept 队列溢出"></p><h2 id="如何绕过三次握手？"><a href="#如何绕过三次握手？" class="headerlink" title="如何绕过三次握手？"></a>如何绕过三次握手？</h2><p>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/22.jpg" alt="开启 TCP Fast Open 功能"></p><p>在客户端<strong>首次建立连接</strong>时的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li><li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li><li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li></ol><p>所以，第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。</p><p>之后，如果客户端再次向服务器建立连接时的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含「数据」（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 Cookie；</li><li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li><li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li><li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li><li>此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。</li></ol><p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。</p><p>开启了 TFO 功能，cookie 的值是存放到 TCP option 字段里的：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/TCP%20option%E5%AD%97%E6%AE%B5%20-%20TFO.png" alt="TCP option 字段 - TFO"></p><p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为 Cookie 无效（通常为过期）。</p><h1 id="TCP四次挥手的性能提升"><a href="#TCP四次挥手的性能提升" class="headerlink" title="TCP四次挥手的性能提升"></a>TCP四次挥手的性能提升</h1><h2 id="主动方的优化"><a href="#主动方的优化" class="headerlink" title="主动方的优化"></a>主动方的优化</h2><p>关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭。</p><p>如果进程收到 RST 报文，就直接关闭连接了，不需要走四次挥手流程，是一个暴力关闭连接的方式。</p><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p><h3 id="FIN-WAIT1-状态的优化"><a href="#FIN-WAIT1-状态的优化" class="headerlink" title="FIN_WAIT1 状态的优化"></a>FIN_WAIT1 状态的优化</h3><p>主动方发送 FIN 报文后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动方的 ACK，则会很快变为 FIN_WAIT2 状态。</p><p>但是当迟迟收不到对方返回的 ACK 时，连接就会一直处于 FIN_WAIT1 状态。此时，<strong>内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制</strong>（注意，orphan 虽然是孤儿的意思，该参数却不只对孤儿连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/27.jpg" alt="img"></p><p>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当重传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。</p><p>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报文根本无法发送出去，这由 TCP 两个特性导致的：</p><ul><li>首先，TCP 必须保证报文是有序发送的，FIN 报文也不例外，当发送缓冲区还有数据没有发送时，FIN 报文也不能提前发送。</li><li>其次，TCP 有流量控制功能，当接收方接收窗口为 0 时，发送方就不能再发送数据。所以，当攻击者下载大文件时，就可以通过接收窗口设为 0 ，这就会使得 FIN 报文都无法发送出去，那么连接会一直处于 FIN_WAIT1 状态。</li></ul><p>解决这种问题的方法，是<strong>调整 tcp_max_orphans 参数，它定义了「孤儿连接」的最大数量</strong>：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/29.jpg" alt="img"></p><p>当进程调用了 <code>close</code> 函数关闭连接，此时连接就会是「孤儿连接」，因为它无法再发送和接收数据。Linux 系统为了防止孤儿连接过多，导致系统资源长时间被占用，就提供了 <code>tcp_max_orphans</code> 参数。如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。</p><h3 id="FIN-WAIT2-状态的优化"><a href="#FIN-WAIT2-状态的优化" class="headerlink" title="FIN_WAIT2 状态的优化"></a>FIN_WAIT2 状态的优化</h3><p>当主动方收到 ACK 报文后，会处于 FIN_WAIT2 状态，就表示主动方的发送通道已经关闭，接下来将等待对方发送 FIN 报文，关闭对方的发送通道。</p><p>这时，<strong>如果连接是用 shutdown 函数关闭的，连接可以一直处于 FIN_WAIT2 状态，因为它可能还可以发送或接收数据。但对于 close 函数关闭的孤儿连接，由于无法再发送和接收数据，所以这个状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长</strong>，默认值是 60 秒：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/30.jpg" alt="img"></p><p>它意味着对于孤儿连接（调用 close 关闭的连接），如果在 60 秒后还没有收到 FIN 报文，连接就会直接关闭。</p><p>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后面我们再来说说为什么是 60 秒。</p><h3 id="TIME-WAIT-状态的优化"><a href="#TIME-WAIT-状态的优化" class="headerlink" title="TIME_WAIT 状态的优化"></a>TIME_WAIT 状态的优化</h3><p>当收到被动方发来的 FIN 报文后，主动方会立刻回复 ACK，表示确认对方的发送通道已经关闭，接着就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进入关闭状态。</p><p>TIME_WAIT 状态的连接，在主动方看来确实快已经关闭了。然后，被动方没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果这个 ACK 报文没有到达被动方，被动方就会重发 FIN 报文。重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p><p>TIME-WAIT 的状态尤其重要，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><p>详见：<a href="https://rean-schwarze.github.io/p/85f11265/">【TCP】三次握手与四次挥手)</a> 或者 <a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-time-wait-%E7%8A%B6%E6%80%81">4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)</a></p><p>为什么 TIME_WAIT 状态要保持 60 秒呢？</p><p>这与孤儿连接 FIN_WAIT2 状态默认保留 60 秒的原理是一样的，<strong>因为这两个状态都需要保持 2MSL 时长。MSL 全称是 Maximum Segment Lifetime，它定义了一个报文在网络中的最长生存时间</strong>（报文每经过一次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报文就被丢弃，这就限制了报文的最长存活时间）。</p><p>为什么是 2 MSL 的时长呢？这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p><p><strong>因此，TIME_WAIT 和 FIN_WAIT2 状态的最大时长都是 2 MSL，由于在 Linux 系统中，MSL 的值固定为 30 秒，所以它们都是 60 秒。</strong></p><div class="tabs" id="timewait"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#timewait-1">优化方式一</button></li><li class="tab"><button type="button" data-href="#timewait-2">优化方式二</button></li><li class="tab"><button type="button" data-href="#timewait-3">优化方式三</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="timewait-1"><p><strong>Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭：</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/33.jpg" alt="img"></p><p>当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调大 <code>tcp_max_tw_buckets</code> 参数，减少不同连接间数据错乱的概率。tcp_max_tw_buckets 也不是越大越好，毕竟系统资源是有限的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="timewait-2"><p><strong>有一种方式可以在建立新连接时，复用处于 TIME_WAIT 状态的连接，那就是打开 tcp_tw_reuse 参数。但是需要注意，该参数是只用于客户端（建立连接的发起方），因为是在调用 connect() 时起作用的，而对于服务端（被动连接方）是没有用的。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/34.jpg" alt="img"></p><p>网上很多博客都说在服务端开启 tcp_tw_reuse 参数来优化 TCP，我信你个鬼，糟老头坏的很！<strong>tcp_tw_reuse 只作用在 connect 函数，也就是客户端，跟服务端一毛关系的没有</strong>。</p><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持（对方也要打开 ）：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/35.jpg" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="timewait-3"><p>我们可以在程序中设置 socket 选项，来设置调用 close 关闭连接行为。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/37.jpg" alt="img"></p><p>如果 <code>l_onoff</code> 为非 0， 且 <code>l_linger</code> 值为 0，<strong>那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。</strong></p><p>这种方式只推荐在客户端使用，服务端千万不要使用。因为服务端一调用 close，就发送 RST 报文的话，客户端就总是看到 TCP 连接错误 “connnection reset by peer”。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h2 id="被动方的优化"><a href="#被动方的优化" class="headerlink" title="被动方的优化"></a>被动方的优化</h2><p>当被动方收到 FIN 报文时，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>内核没有权利替代进程去关闭连接，因为如果主动方是通过 shutdown 关闭连接，那么它就是想在半关闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。</p><p>当然，大多数应用程序并不使用 shutdown 函数关闭连接。所以，<strong>当你用 netstat 命令发现大量 CLOSE_WAIT 状态。就需要排查你的应用程序，因为可能因为应用程序出现了 Bug，read 函数返回 0 时，没有调用 close 函数。</strong></p><p>处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文关闭发送通道，同时连接进入 LAST_ACK 状态，等待主动方返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，内核就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与主动方重发 FIN 报文的优化策略一致。</p><p>还有一点我们需要注意的，<strong>如果被动方迅速调用 close 函数，那么被动方的 ACK 和 FIN 有可能在一个报文中发送，这样看起来，四次挥手会变成三次挥手，这只是一种特殊情况，不用在意。</strong></p><h2 id="如果连接双方同时关闭连接，会怎么样？"><a href="#如果连接双方同时关闭连接，会怎么样？" class="headerlink" title="如果连接双方同时关闭连接，会怎么样？"></a>如果连接双方同时关闭连接，会怎么样？</h2><p>由于 TCP 是双全工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 FIN 报文。</p><p>此时，上面介绍的优化策略仍然适用。两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态，FIN 报文的重发次数仍由 tcp_orphan_retries 参数控制。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/38.jpg" alt="同时关闭"></p><p>接下来，<strong>双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态</strong>。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/39.jpg" alt="四次挥手的优化策略"></p><h1 id="TCP-传输数据的性能提升"><a href="#TCP-传输数据的性能提升" class="headerlink" title="TCP 传输数据的性能提升"></a>TCP 传输数据的性能提升</h1><p>TCP 连接是由内核维护的，内核会为每个连接建立内存缓冲区：</p><ul><li>如果连接的内存配置过小，就无法充分使用网络带宽，TCP 传输效率就会降低；</li><li>如果连接的内存配置过大，很容易把服务器资源耗尽，这样就会导致新连接无法建立；</li></ul><p>因此，我们必须理解 Linux 下 TCP 内存的用途，才能正确地配置内存大小。</p><h2 id="滑动窗口是如何影响传输速度的？"><a href="#滑动窗口是如何影响传输速度的？" class="headerlink" title="滑动窗口是如何影响传输速度的？"></a>滑动窗口是如何影响传输速度的？</h2><p>TCP 会保证每一个报文都能够抵达对方，它的机制是这样：报文发出去后，必须接收到对方返回的确认报文 ACK，如果迟迟未收到，就会超时重发该报文，直到收到对方的 ACK 为止。</p><p><strong>所以，TCP 报文发出去后，并不会立马从内存中删除，因为重传时还需要用到它。</strong></p><p>发送方可以随心所欲的发送报文吗？<strong>当然这不现实，我们还得考虑接收方的处理能力。</strong></p><p>当接收方硬件不如发送方，或者系统繁忙、资源紧张时，是无法瞬间处理这么多报文的。于是，这些报文只能被丢掉，使得网络效率非常低。</p><p><strong>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。</strong></p><p>接收方根据它的缓冲区，可以计算出后续能够接收多少字节的报文，这个数字叫做接收窗口。当内核接收到报文时，必须用缓冲区存放它们，这样剩余缓冲区空间变小，接收窗口也就变小了；当进程调用 read 函数后，数据被读入了用户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报文，接收窗口就会变大。</p><p>因此，接收窗口并不是恒定不变的，接收方会把当前可接收的大小放在 TCP 报文头部中的<strong>窗口字段</strong>，这样就可以起到窗口大小通知的作用。</p><p>发送方的窗口等价于接收方的窗口吗？如果不考虑拥塞控制，发送方的窗口大小「约等于」接收方的窗口大小，因为窗口通知报文在网络传输是存在时延的，所以是约等于的关系。</p><p>这个窗口大小最大值，在当今高速网络下，很明显是不够用的。所以后续有了扩充窗口的方法：<strong>在 TCP 选项字段定义了窗口扩大因子，用于扩大 TCP 通告窗口，其值大小是 2^14，这样就使 TCP 的窗口大小从 16 位扩大为 30 位（2^16 * 2^ 14 &#x3D; 2^30），所以此时窗口的最大值可以达到 1GB。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/TCP%20option%E5%AD%97%E6%AE%B5-%E7%AA%97%E5%8F%A3.png" alt="TCP option 选项 - 窗口扩展"></p><p>Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1（默认打开）：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/43.jpg" alt="img"></p><p>要使用窗口扩大选项，通讯双方必须在各自的 SYN 报文中发送这个选项：</p><ul><li>主动建立连接的一方在 SYN 报文中发送这个选项；</li><li>而被动建立连接的一方只有在收到带窗口扩大选项的 SYN 报文之后才能发送这个选项。</li></ul><p>这样看来，只要进程能及时地调用 read 函数读取数据，并且接收缓冲区配置得足够大，那么接收窗口就可以无限地放大，发送方也就无限地提升发送速度。</p><p><strong>这是不可能的，因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。</strong></p><h2 id="如何确定最大传输速度？"><a href="#如何确定最大传输速度？" class="headerlink" title="如何确定最大传输速度？"></a>如何确定最大传输速度？</h2><p>在前面我们知道了 TCP 的传输速度，受制于发送窗口与接收窗口，以及网络设备传输能力。其中，窗口大小由内核缓冲区大小决定。如果缓冲区与网络传输能力匹配，那么缓冲区的利用率就达到了最大化。</p><p>问题来了，如何计算网络的传输能力呢？</p><p>相信大家都知道网络是有「带宽」限制的，带宽描述的是网络传输能力，它与内核缓冲区的计量单位不同:</p><ul><li>带宽是单位时间内的流量，表达是「速度」，比如常见的带宽 100 MB&#x2F;s；</li><li>缓冲区单位是字节，当网络速度乘以时间才能得到字节数；</li></ul><p>这里需要说一个概念，就是带宽时延积，它决定网络中飞行报文的大小，它的计算方式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/44.jpg" alt="img"></p><p>比如最大带宽是 100 MB&#x2F;s，网络时延（RTT）是 10ms 时，意味着客户端到服务端的网络一共可以存放 100MB&#x2F;s * 0.01s &#x3D; 1MB 的字节。</p><p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「飞行中」的 TCP 报文大小，它们就在网络线路、路由器等网络设备上。如果飞行报文超过了 1 MB，就会导致网络过载，容易丢包。</p><p><strong>由于发送缓冲区大小决定了发送窗口的上限，而发送窗口又决定了「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」。</strong></p><p>发送缓冲区与带宽时延积的关系：</p><ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；</li><li>如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率。</li></ul><p>所以，发送缓冲区的大小最好是往带宽时延积靠近。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/49.jpg" alt="数据传输的优化策略"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_optimize.html">4.5 如何优化 TCP? | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】支持LaTeX公式 &amp; 文章加密 教程</title>
      <link href="/p/e042d029/"/>
      <url>/p/e042d029/</url>
      
        <content type="html"><![CDATA[<h1 id="支持LaTex公式"><a href="#支持LaTex公式" class="headerlink" title="支持LaTex公式"></a>支持LaTex公式</h1><p>前情提要：Hexo使用的是Butterfly主题，Next主题等等看别的（</p><ol><li>卸载原来的渲染插件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm un hexo-renderer-marked</span><br></pre></td></tr></table></figure><ol start="2"><li>安装hexo-renderer-pandoc渲染器</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure><ol start="3"><li>安装pandoc</li></ol><p>到官网下载：<a href="https://pandoc.org/installing.html">Pandoc - Installing pandoc</a></p><p>安装完记得重启一下bash（安装程序也会提醒的</p><ol start="4"><li>修改<code>_config.yml</code>，直接添加：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="5"><li>接着添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pandoc:</span></span><br><span class="line">  <span class="attr">extensions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-implicit_figures&#x27;</span></span><br></pre></td></tr></table></figure><p>因为这个渲染插件会将图片标题也会渲染出来，所以关掉！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20210322232830.png" alt="20210322232830"></p><ol start="6"><li>在使用的LaTeX公式的文章头的信息加上：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><h1 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h1><ol><li>安装插件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>_config.yml</code>，添加：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">silent:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">这是一篇加密文章，需要输入正确的密码才能继续阅读。</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">当前文章暂不对外可见，请输入访问密码后查看！</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="comment"># 设置指定 tags 为加密文章，当文章设置了指定 tags 后自动加密</span></span><br><span class="line">    <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">private</span>, <span class="attr">password:</span> <span class="string">hello</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉，您输入的密码错误，请检查后重新输入。</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">当前文章不能被校验,</span> <span class="string">不过您还是可以看看解密后的内容。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在需要加密的文章头部添加：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">password: 你的密码</span><br><span class="line">description: 文章摘要</span><br></pre></td></tr></table></figure><p>description一定要加，不然就是一堆加密过的东西在摘要了，当然你就想要这样也可以不加（</p><p>然后注意保管密码，如果不想保管直接看回markdown的话注意单引号<code>&#39;</code>、双引号<code>&quot;</code>会进行转义，直接复制就会出问题了</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_52466006/article/details/126924064">Hexo显示Latex公式最新解决方案_hexo latex-CSDN博客</a></p><p><a href="https://fanlumaster.github.io/2021/03/22/Hexo-NexT-%E4%BD%BF%E7%94%A8-pandoc-%E6%8F%92%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/">Hexo NexT 使用 pandoc 插件渲染图片问题 - Flyan Lu’s Blog (fanlumaster.github.io)</a></p><p><a href="https://blog.misaka.rest/2023/06/14/hexo-blog-encrypt/">使用 hexo-blog-encrypt 插件，加密在基于 Hexo 博客的文章 | MisakaNo の 小破站</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> LaTex </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240322 | 记录</title>
      <link href="/p/9b4a91e5/"/>
      <url>/p/9b4a91e5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="734e64d4e08fcc9935873ea3c5353f5cb66ef386c7143282e34af56a6b7a8746">35111bd01449708c0b797ca3b7e8823851f3b0405adadcad3abefd13c0d3fcbd4555d40b4ed6e1b5cad58892a453b40ad25532fa8cdb36b9211bd2266c963aca0a9f10dba7ad12e515a2e3a23b602b8ab7181ca3cadea5e237d078265af8f3ebec64e30e6011a9e8b43cab6fc03b2dc21d8eaac635a56be0efe7a70c667f90ce7da5f1a2fe2f025f00028c15b52ffa115613e84104de5565cdd8045f66661e79b940cb287a40e7e4a3a7c0ccd77b8ce06bf07222b9d8271fb418bbe6d1968f276bd322ebb9e071939fc12b573c906d66eac5ccdf37fdc361d5b56952e8e4f80484d85b310797edb2f8329c59d8b019b7abcff20e1aec2541edc24cd2ed4c280ade48b978b10e5900c1101235f34ef243395da73a80bb465f533b6d3085e2de39862d3dfe3d1263eee68ee3ba3f63f488d8838e9ce7a3dce7ed5439c804787dda917dbdd87580d59abe8a6c5b7665b61f31d7c1e7ea864f0af575c2ea26662e8403ede8ed39a3c2be5486f1f0b9b8f47f1756b429370bed44ce9a9a93ed26e78475f33dced9969676003813f29cf6ab1a00f60f70408fb6d47bc3017c0fa9887722a1fd0c5efabc300793f08dde00cd2ce8f0d4fe234dba76420602cdfd7f1e2743529a8501069fc7646e91865bebfdf133b93f44369cb69dabd7f1c9cc00204788d896985e8cd3f5f91c83481bca4bf928406ff8b34109f2deb712495c434a61f5bfea01b071a8e780e75986fff25728c74dbd2237bb5bb4181fffd5fcb4dc28cc3589596a7e0eafec16b8b929be4d5ee50b7dd6f67bd50e6bc03deb1d9c19d50b616a7e52b7e4bb2a19820552f72ae146865301a949986af80349efedcb832569f1cb0317e6658d2e4bb462264cd2155658f564cd4fc59184ed3c2d076b779460c71cc03a503555a5c86ae4b2df7b36d422473d7787dc039d16acb0dc8d4cbc285114af5dfb8d4a3e7f59220844697991394df251b5f059e2ff5a4b0e20fc79cca120b372d8808f89308389ad9bc23203054a9e108c5efade1752ecccb46509678c86badb698d175a32a1620898c54bfa84f26576adcf139308f9419b733d34b6a8bcb576bdb0c142eaf4a67d4da51a4cff9163e5628ce1e927d471d8083eca3e4230ed9d41850d48856b390bb34aa81a472b0fd56f7fc85fadbe92ef8bd9c5a46168b1f8bb22d89af3f9dd1ca61f84c4a1ff51dc41da637e57090fcce5a78f2965ca6840d6b72e57a682a2adc5494cd779cb97c94b9af6d2b0327446c7c9ca48707f469934c47ca251cfe319f984cf8cab7c5a543ac5a6b7e01cd86e83f75bcb48c6427b29d83fc23e6461b9943d8407c50b3461391fc00b3c7999cb0a2c73060cec6bffc058c27ecf9d580e502a2358bbf15e89c0e5580b87ccab11f813feb5510af503d78183b4828c4dd1a7ac7bfc57737d25742b19aea15bcf3ebea15b019fb82d2deea83d8f815207c64eb5c81311ae4d156ef8439e9edd431239eee45958355aff60fb53f3df4f7292d016ddbc113771f042d67e4c2400fd1aa69469c1c9a5d2cf3df839e1cf850d7274e1323962c632e2997b0bc4546181886a539135b417eef6d42436f158eb7643923536abdbd4a8f4653f7b40b4cfaf4b84e526edecc3916521ddb82c7c63b52e8970c76cd601472e7bd18864d28b1c8a94adabee931acd29194e8db482394ee438b426ed9b7228ff99007ac789ed500665bd0bdf2a764410bd6d97c465158df39f13816ce66b552cf0ebb044185ad51ea65785d7dd5c669ec694dd111ed83c9c46917cda1ba1fd0e920c769c3953f15d26579445a355f3e7e0ec78e0d1618e4acd4bab9533e1f0a287dc981efdcc5d9b4fee7a68544ae848de233f7c58672cf1199161bfd51ecf207ea7661f81c3dff5a4f08a7d0ec40384fd13fb983583dd848f86dda10415556efd3a32b98bcff0f337b6b858f84de18d76e4773512caa2f885e35a764ff480ea2a8b95b2d1060db232aea57c8b1b7cb4af136f2978e63059f6dbfaeea1bc9def83dd76e1b5dc9806dec7edfcc2bbbef3bac095d5827f3e9ec436730deafe528a7252fa6912df0ade08ba8bd74758141b30549305d9ecc1bf040a7d388da3ebc3ef8045c8cdbc247adfb05c46664a914c97ef34f190310b41af8c43e4b047b3402db028ec48ac8f96de06585d8aca132f6f4b4db6e9a381eb54fbe453249ff559395a6f0899d1665213a6bff9a57dca3205e49fcd7fd3669e48f530ff5953687bf4dfdb3e2f2354a82c09561fc5af74b3fd891fe8836f5984d9e018d50213cca209fd3a564f9f3b742dc59344ba5950cf3791d9ebf9211887e120be4ef1bb59f88bf51aff54fe1ad518cd6137e88054399db18fdd995223fff5b739400332dee5a44b5ff8d975e452f755664217d38f83920a322d4234bf7046258179e1e5f72250d4052138bd43538c0b528fda2de5fc2be2bc557e902051d0c5c46e5a7082b5fb16559f0bf1f9336cec2cee806087c7374aae6f4033d965caeee334bc87a90d3aeaa680fa766a5aa7ca2fad17167d16d52b689636b7547e0b1d31db8cb201ccb7a4a37c9b3aa429fe70451c7133e7f95edca7c9ffc7d7bd70547207dd05ee886f4274fab8dc69b9722955eaf99f858929de483290fa49acaf146504088744922ca72a8c19c16edbbfbb2f3707afab07df2b7cbe44a1d48f2aa2fd0a227ea4ffd1dc55ef2e8c1ab1c5559bf05b75728241cb1bc49aaffbe1c7e30fa4e0e89159ebd4aff31b979300fc487407c755a14a998b9e54c8e9b7828ab85d6c37f5eae6ebca355b3a99374b7ba7fc7f08607ea9f54cc10f5f3ddd0627e992e7112e952710d26fa3094074edacd427915d1a4d3ba80bcf7e3d47a33bc5ffbf494ecc95fd1ffecca4f6db1614128ee5cb442573a31b4785e7a2727fe02dab5e90ded5394a008ab4553f51f50183d8434c067c53b4b7dedd692fc67679519ffcd4bcfeff3d70e10246f0983b9a969ddcc0f633dc33b7f5db5bb5205c3867e4a2952e66f3a563f0881b9625d39627d621c30bea502be4db2541b02d3cdec457153653db29cb0df3328f19bc09206b57075f622c7352d5665cb97f55319f1fd487151842d03b15b53ad77ef2c0eee318f323868e93219ac2b658057bb21b48e98d1272863b21ca8dfb7f984373159ad134de27ada8555c18d2e2d13837882a4cb92296c17d2743a30c3739647607ad1a4c79d4125cc3611bc5e1b2da0d005b7d764242641bd832d54b7bec6fa10c19413e22cf7b8e5e8a360848e41d1bfb330a649487e49899fa0fce6b389571ec37b5339885619591c1aa13a28e69d51d2ebf191373679620465a1a1e886f85b4c0a1ec528f635af221d3abfe52b14496dd225b8f10cb82d930cfb176a606a83e111a7e3b0d3680ea220ab2b78b9698022143211a90ecc888b4c2d8b72ba1352659b3335213dcb1aa56f984cdf0454a68eb54d19acfe8470ecc1ca528a957f903176b90ae252b19d310cbbc76036ee39d799aed2b049f242fa320fe98015a9c67c1f084a64ff873ffaf2d61550106fe05c426d5f1278cad550b79ded433aa7158e7f75b6484760259a1f6bca67587ccbf5fca9943f4bb40c057e7ba27be10db2d8acd0518a2d137939f6dbb2181317b759af0e1e309bd082eed78726ca34ccba08afe7df09b8dd778ad0e8ef93ca84dc36f2cf416a1fe0bd14da2cd8f2f537e4bee26cdcdcdb2faecbee9f0146fa2814bf812352bd372ba85ece0be6d22bac2f7025791e322add224f613ef94f006cfb2f88dd2074eb6d5c151cb867af4ee1758e5efeb72f24606287672ec373185d9364e388fc09749c63d868503ee290644efcae0c8ce21190b492b0d4acf50b76fe5139f2535a7132e5dbf395750c53c13e19abdae932e1f18ea61c88a34cd61ea42bc0a5271c5a5a97a2a595e6c22b7c18f305a1c8f592e0547a87189b46b2afcf11a838497bb5e5097246a0a61f3ac838c0cf395bc73545675204d1fbd956215c1e0da3607e2d66a21d4837220852b8d84f4439dc31d02a72324387016d8bb735a26581a9fc768fe967fa7ed50b09503ec0bfe75a80fc3099fade542f58b6dff13913287f2011625a7c054f38fff9f6d0a489a7b7f369bcbc415a3175350372e81036ccf7c5ccf63a658396a6b75852a010908ca7587d09e71740e59dacb569caafcdaea6354f732cc7192d88b5a3757851bfaf83026d970c0a021cca57b3d38741ef42f142eb64b04584677abd8c3199107913d3cf076cb7b401984df8c0c3ed90eb84e2f29bee6468738ae0a50a84a5776e6507d00bc9748e0cb16595716ae9786879e7d34793b76b73a46dc61e986478e2c65a8679ba540600a3b780946b7b44af99950923680c1fb3218d40553e6d245bd4f362b61ac4cf281fd0efe62c0fc25111f6480ee365456a6327315505dc188d58fd126086c4fbbbfb9dd09e1010b2908fc4851c2dcfcf0872f95734ff5a7d7cefefe9c06f7a100c43de8cc0622bc379dade0c5324869d6316b7477f207033457bbbda7bf5bd47ce894f8bcc5ee758ec10205e2dc39369c87d7650456a92f980de8fa82fdaac065cd74e1bdce8b49d5b12fe448f5f6152eb46b4784dd6cb735422760d5e797f0ac41775df1ade3e7b46889faa33fa9dddf0b17c0b5dc6faf9b3f0d77c7d487fe8fd2d3924c7b08813e72f3ea3b83b59ded725506a68a629dcdee808ab1d8a62106cf05b2dce000fc74034329e27ecb4f55c29474b3f42e14174ae5bde63cb9ca60bb09d479d8be988b1d4cf3f6b3736323f429138499a6d70e987e9cc6623412873b09e93ff0569ede07aeb8949eaa7731375b11386c290a3a8fe56e7ec687613ec008ab6d7fdea83e32a6104fdcc7b287c032f43b2c8d896d67e5ad05059080fe380e0ff2eea961e374a7e7dd173ced3539093dc207ae232cd76b44ba0376266c55772852c7c1374d1958ef0fd665951e0f2aabace18873bc34e9319303b538662a4c650f2af1226caecae0864186297efe3a7f5a05fce0551db7f7029d0cdb3d2218f2760329e834cad2f5e46d859d598500e531da415ec74fb3724bf2c88387b59857d0d6153da94be79c0d0bd61c0dbae72e9f1a6852cb24d0265319811fbd5f780f11219adae2be8bc052bab6cfc3ddd4afde5c62339066cc26b952b9f07710390aa74bdc43914fc9a69d22a6d9244f01ec9b175e276488554ee061440173430ac70e940f86cc92babd3ef8bc0a0f5932ddb57b48d9ac3f3e5ae945c5317cd8fedec9b9e7283f92f7adda84dcaf45ecaf87aee51778f522ce1e5027ff129e1090eead17e44114df5498553768495f066c967a7aad7fdf5c556e76ed40f3a67e878f5f9ac5b32e60058dbad7173fc3460e2c7eb995d144a14ee5f1a368735a3e7802bfc6f1da20ed7743208dd3306d0ada10ad0cd2c16315d56d3824efab74bfea78e24ec9c6a3c433e6a9d3f26d8a5c90b05449403ded5fc4dfe5a8feb275d4a54a22142cb324511e06d5d570108c529f504b7abe863d7c9968a4a34ce826f896d2b9b0b6d94d631ab5a4ac7f7815a02007dedcb07229fe61bf27aae269bcdfbe1bc41505cae39545ca18b9e02e9901a209b5fcde385cafba371df495dfda7ae7587034f4c2892e8d9ce177c531e34a98bd12e6050048303db9c9160c52df4b10e1fd3b8822b04bf82f649d0f3157dfe727857e2385a6c34cf400860ecbdebd647c3af3812f67d60fef0b48a54b92e4f0ff65c0b46668568fb3f632c40e875e163cef9ad42a672441494dc513c4c19c5062147bbe72559d2abaca3e8141174f090addfbd72f30bd52ecda3b89c2d60e87f36769f993c7e5da67415b61e1c180e33faed183671cf349ab96de820f459cdb241d2afa16f548f5061adb4ebadf53d3e1417b93fa1a3fed461f25022628b05356fa9146b266c23cfdc218b9be6daca6464163be6a3e02a097cf984327ff5c198abd396e56953e8efd908961488ba36958d197b7ff46d05becbdaac24afec3bd3288f27c731a581d88cec0120c5ad94be5c14949196b0fab6b2a2a0ba2bd0b854b4fe4c409ad2d474cedeb1d2ac34d838009094ece1721a16f296a73ae56ca24f2ca1213d7bda907a54136bd355a6125bd5b1d0ea9e6da6b5370395853fe0f45d7cc93b1eff564fbca92127229a35917b3e15c76c378f7d6c50b8e489c9348e530d57f1c3d726d6b39a88264ec59297de9284eb74572e20c89d5a94ee2381096f143f29f37850083acf9297b2ebfaee1445fcc38d104f8cf23a5df4684b8cfa02d84100ea9a2594328420609b543fd78e438a6d5c1670748252853224904f8eba6ebfc677fdb21d2f73676adf78512a3ad99848ede8c2adad2626830fafcdba6135895c181d21f5fa0433f1f3d30a539cc9e3cd2ca620146a2ad1bff6aae8655a95bd59054338e1c27a1b623b46cf9238d963d7f12d07f0ccc935fc6ed7fcac9ed8ee67d57386a3300035aa64a3f58669eeb6c61f7a63740ad03cb5d0d833a34ad2bdae271fd90e53b4c8cb6737e3a58bc13c02baa385df0595f130bbdff662f61c4cc6040808450a2320fea461f1474b061a34dca1ef13bf2356f6daa885e230f6aa6b4ce9a0b3c257254e5d656c322f2690b8b04e5c9a4c453803178c1d45b89ab84162ccd7de03f3524f92d14e7cfbff4702a0f92bad980beca62e4bdac38ee6eaec6ee623d15084532a358619ae42ba43c8e9ee9b1ca66b2cfbe5790b41549682fed58f6fd6a1b7d3b733e126fea09123ae831386f3c93ff3f1e89f2bc906277b3e47136d69f4e78c19edcf43e9ed0ecc45d714444e5c8679aad1e5de511e59958dd33c38966f4b99f686beeb246cd42455c86e5a94d54b60cf6b7b27c1a5f6d845540c1805b9589fde18118ff1447c95391f2015c8d78cd4fa61e8842200adb71ae7be05d2c7281dbf8d95120986aed4bb5128d5d7acd11ab89f31dfc7297b943053de86cbd890dc5cbd4bc4e222788bba2ed30cee324c2699c8e7c9b4cdb54d83c5d14a51a8cee52310bb30d4a529f6c08d3bf85e225ce526371a24e9053567815d46fb6868295fce173ce97a6d7d28c1edaaa4b6247df9e0fb5e4d29470a035f8dd1723e37b4417145e84461fcb4a01bd1f36a16c3c5b3516e11040a69928536b3b2204d68eeaca2b3572d255cf485da46b22d4622eb92db48f8fb623d6f4a50b6e5b756c161c3452bdf69ad890ae7030c990027112437e0ff6057562b11daa7302cc9158e02f424209396cf0fb2c6b996ba03ff7b7a0fe9ddfc7597300eaeb0816cd7c64033e58397dd8604dc73f1b046c55fb5538abb7d4ef58b17354455e65c19a5f3931c22175058edd8de932771fab414bf39ab8da9662b6c24fb56268246303d06d127d1cb79870fe3aa82585925804ad492af70d6b6bfc8a7bafdfac994b3dcf36289a891674dfa2caaa80bbf339c5c201e5ac1963eb368bd0a86602d7d4ddc5d6a286474a67c277e85653a1b2a10329bd8d091f3ad2b6925a5298e7fc439a948045291174aab00455a93ef6e399e1409ef67e236568ed7bbb644cb25c9537f828ebe41de0fc21782e24887c7bbebebca85e99f4dd156abf31f776208ab81852f9567ee35549a2c94c1fb09dc0bd5c8dbe7bce96c4a3d13b527bd5afc218a898385f1c98e5309a4a62eb8005295e91f38f310f830815eaae2940de1d8860c495d1901511a138a58e5f492c2f7d711893c78c66826eff49f8fcd76baa4532726fc6e9e382f09e07289889bf1dce1b836049c5c87240d00cfaf313f8234c28956965995a8a98a4529e7d2acb95e895b262a96791ed51821f2719a80bbb4d7010d3922ff85ca44ab423426d8ba169e5b21c08cf65ddb0f84aeb0f60c5f71296f7d3f4978d448a35b60165ec95d7b77cbee5326a2c7a21d9b98ae70190e52b9152cd408b1666ecb1a57989265f7c17c8b1e40c2d9672b713fdd5a270e3423f63c7d3d2b8b5ef3d960646859d7a5007213a748b73be1d5145151aa4204decbb81062674e4abe885249715c5f69351a84dfa0633cdf32446e6486731ca70d8223016ce3a445cd5eac84886413a4040e1abbd1ab95a0454446c0a02679d3bc41715966be0d75e4e1664d230f69163ea508ee9709c88ed61ecab875c5eb4f175967e692a06f3c695e7764ac0b104baf5859d598024857c5b57e35dbdde10a7c6d19c573e209577ef68a845c378ff5e9bbb6890f9aced2751d0146ad85eeb8ae9e16acfa0c346536aa656fc9e26a86a1d0e37fbbb529ae9fb568e0d056096750f8211c2e7ab55fd396984d0dc42bdd791336fc7fb1bb058cde2f96e3a49f96f6e3d816ee24e7648995c37eeebfafcfe0ade063b4deb046e25ef2138c069f6b1314c06edb5f6c6abbc08c6b68f485aa9bc2d48037f2f07bbc4713110634b29e7468fb5e359408e514247be5c9b55428028efe4d5e9d88cc551f72c654e4fd39c42e4cab6c91b35a0c68d2d7870102bdde1df6abe2d1027b030b272c3ed7731446cbb2975cfafe7d0f6533e4a68e2fa540495a7be5ddf0b73b3f4d031a519a17aea8997dc1045366acf7a52db0379e77570a10eb676548f95e9f6b74d175dab986af6b86365d140c166c20ad1a25853edae6ef221f63f21a897e3c1bc21668f94ef1ef83bff80e8e7f05cdf2da040e4f2716a0fa6b97a6eeead04d350e7b9111d9f1bad352862529121f075756b53444a29b764bbb1f48d38d209febd70a8d0963341851aed6a050ab3058a254b2282a4da72d7ce10142b1e715ba88ceb04c75ab0fa6db99236b086b7c6b42b9ce26a979c7db8b60fbc7fe5a727338b85aa7ad6a5d486ee5a7e49872aa201c1f461add563080d2dee089404b5332003e90efa376f8e239cacea43749a26d7906009a1d8c93df754454425d28b4cf6ab308c35b535d854e592249b507b10c7fd699e5ad292af3621d83c86f69932f76fdbff987051da6150c987cab6d521bd50397389de58101e7400672ba6d786bb813e416cf58c07d11db8b4fed16f7e838fa201b58770199a226f447139c2ad9342304bc99f3d6d100c9fb6a571e3d1b09bf90b20e22a05905447c93af8029a61821f192853100b577e18e12257951f83866ab6539277fdf899e558a60a96b1756deb8df6c20517c3d7ebebda3585f213889a3e32fa5b79f92f6dc287be6c7c3bdf81020016c30a448f54ce1672effc2ec1bcd0b5e8c2c83846bd0d62b6033cc1783ac00c4f9803a825eea570051c51f47e5579f16bc8c32a7cce1b41b920e8ed16b71eb5ba8c8edc58e74ef99dc0ae68bdc172cb09cb2b4d391078091d252ecd66f6761055e8160c81491b6ba52fae254bbdaec365986e8465ae287a06a231be51047d2faff1e8ffbf5563753607284f4045b83c484660a2fed99ec131c1645c13c8161ee760b51ee822328fd65fd93b50bfa686920f8cc0c49c316bc041bf3d6024fc82364966bf4aa07d9f1de06e7ee8a7f936a18f97761f3b91fee61ace2559edf46144cdbe9a0b4789efe7cf300632b5a55fe72afc12006324724da988c16dfa875a1226e0a3c5321fe1b060307f0298fe5007cd591a302a24711ff0b3f118587c256f808ad048a5d0317dde673296face4d5269dc84ba7c69537e3f61d940cfd49c98feb34d76d697a09558a5302fec5e083853476c7c8c8749abbc6e60f5f34af4dc0db52e52f47cd56abba65007d4ac1a21bcf6ceb1d7fcbb790f7a5fb2975870aecad614720cbe2782a06fc6101edabf067491e9383e85f8dad38c9720496de2038523cd194e03ca64d52fb02d611046d3d810d1372facfe9fbb191abe2fbd501ab448132bbb204c3bea975765d7dc7a4a0c8812d1a8e27e671291d6abbb5dcc152511303afba50c6d5d11568a7aecc4e9ca9bec4f891e383ea39403983bc9df27a1963801256a7f9c33616113c9633a5f739d4e2d2d872b60c4cc156fbf0473f6c400119f8154840cf9fe60eacbf785cf2831a8385afcba24a0e2afe150e94fdf59d7d26f9882933471e1d4a0fc6eb3dd90d924a2b99c5d8226dab3612ca16eccde0a6e185325566d24f92281d8dda7efb8f29f69b1e38e391573c08e1c450979ffbb1149b2f816216488e93b0dc4f3ecfb8b5ad738897da27f3d81d1b13e52c1c6e433224b73185deef327197fa024489b6e1c750ca4c4e53ceb78094313d6b5a654b71cd838effe2b1d67489ec4a97918435ef91386f693d71362439b1664a29b5ce76b3dc24f831bda23b67462a7d466de9e5464c13f6a670712f8d642540e5d84a9ca4104aab509b832443979835fd0cbb44ed08f54833782db8416db8cb59ede0cfbdd74d7165054213cef2bc962d14632e229a4e40ad36f6731847963fe79b926e9f495199c7d4461726c06cbaa0a4300219f51b121ae9a5e9d3468c5ddefe59e52c3e1267533b56ef4055225fe0d214ae134a23849dc11739278f0694192bd50165a33631e34b671ad9475d44cf6c416e533e4f9caafbb05abf960216a3322d5790ea1161e3326d442b204e8be387521958d844fa4d499d5eec2a7461cb31a0ebe03648644939e38aa4c3f6fe11e3a325acd118c689fc807e3ddd358fb2e2004d3a0700b622136605d4694be194595a03f9313d76de580a984b983bfb799f00dd32efa8fc18fcd5a623767b42f9d435925a3aa18ac9b6287fcc5be0bc08fe81f0d6d1c3a1afa931c2c2d2f35097b75f9d7fb1525b15f829a2415451218c63b55c0e752600d4e35ed5be8e33540bbbc47e4c1c9a20ed9a726e5749db3de3a82d00d6f4bff096722ad1aad6faa40536f3d7d749cc8d9cd740dadf0d2518e1ac22b1d0bec22dbbbd24f97a084d48055ee33ecab8a3a0a588ce7c0b2d640bbf2fc5aca1d101b41c58dfbf31ea23f5d128440283165572ea9728bb3dc645657bc9256e0d23f4e780c59b8270882545865aa52dda81775d8c671bbd4d735ebc0369b10c305a0cb2a8a6721798ff7fc5e693e4de65136ee7e8e696403cc7036026b138558df2f43786c3b22d4b369429ac0df74b1572109d677b03a5c97acbd868893cfb3a658fbe5474b3d75e7d21b048e713cc85c6f18e34dbe08b45175cbe700eeeff04ac1234371a970df127dcb842faac84ccaba152226ba1620fb9f4748ad514de8a5c594c113a0eaabd75b08d54486f5297a489bd0cc0b74baaf1a69e1166f5a8f27c688533e62b6ea6766101c2cf962760d625e9f10bd59f9c37505156710ac813e8ce44f40369723b4506d3e905664351a6f0148a896e54a9512d1f5a89009c5c32491ff6faa096f3ce7d513b5ce96777e37f8efc06de20715d207bf73f73ce151fffac004ae8275cf483a451f1ac52c0f067e3e584a1acd578f6dbbfdfc074db6f4b595ffbf443db780ea112a9cd4d06bcf6affa1b99f47aea1f0fb59b2f1bedfe21d3f448d0c2d099bcf039fa606c496617914a449a55a6d2705a5e23c73570734a9ebfbe4f25f27d8efeef2605e2945e110947b7d814d9d37abf722e53d36e073532f782faf4ad44c4ad153818ab01d3b07f1363e7943f230908a188975ac5fb2f1b1fd77b498b427ac53d00feba6f72062debd39436603b531ded3cefd9c703d7f2657ad07118f56723c855bf91f0e9c68bf6455d2dfea9771a371235bf2b176d093d3e0e4eba1bffdfe6492a2d0c350905c51ff952c6d6104668f773bf72684084424dcb8a37c7d39c38b1ac272f94746e21ab1927b2c613620a8ae8ea3766a11aed28839ba9bbd1bf0679b024c3879fec688aa3750b2576a6fd23e522ab98be2723df057fc568a11c3889192b4fce0bd216d08a71a22e7f776fd670ac5d2e6bdae371203398ec6d932b178a0940240513d8b53bec4624458880d7c745da7e77d62336234d97240a65192fb4b0a7d90e2ea8bbca940cca1e957644e5312e929caa8605a7d6326e1cc0c839ae52532ae871e98886c25a0bb04a08e03ece58786cd727e183d242943cfed2aedf4ccb43c5243589ccf7a867c5120ed0cdba59d32d18799ff7b4a368310cc1107786b6f8fa3a85c8162bf7ef55274241059e116ba4890640b36be8d90768adaf1d5d13bc2fea955610373e600f1f2ec7ff64d0a3fc1e2735a54cdb8b4970697e76d0d46394dbb6d5cabef5daa09a1e1cd6716c94251903a60b7dc556d4a829cc8972378f12687026b7433b3306ddd5ae654e2796b108848fedae793debac81ed5627abd5b5886c065fca68cc3b069dcb91b612d016c69584ad4457c5b33832d44386585de89d55de651e3792942581b495e1d9009cdc866e7697d103bd6485e71e07ddb56445022e5d73587e48e3fdba367c24fb28d860f0c6cdd33c125ec784b4302f1f2833e9168301c0c876e825ecf0e32d239ab4e8a4063dc812dd9389117c00a4807acb58636a04c710842c877edf9dc51bc796909efb6d1ac8003fd0a781d7ec211b1b0104c10028e379ce53abbf7c16073eae7e471e0e9787abdc2303b4c7d89ebe0ad8c6a1a8ffd0730922f70e45678f6dde7485ce6c520028c72df340ffea67b70c8ee12193506eb1d36e99c25caf91c3a6f27f92e439292d29045d2b83e03385902f09d3956279705a1caec40f8f79ab403b0181c6273d85cae41ae0880ca00c3fa7dd720600720ac19a171b8cad10c0ad588a829db5b4a3bfaff28fb3510b49c213144aff83544826bb593ea35da73669e7ff3c898cf2a3656c70f858e401652f3d18275aa4102597be9ffd2e33d7180b6402e9491911d10a2cfbba12f74c80a61c20932451b235cbf84c41e799d6f04aff44416a8c18e00a599a4da92ae7b9f1c562f2329f144626bc0756a86d86538462cad510810cb4d5550f2996deaa9c118ff70b1939f9a85df1d8a58a95ea62647dea6b2c61b109dffc9e98b2ac7d816b04d76f70f5bd0888315c886dd2fbfb051da2abd869a8ef4bb9b2f8aa0d8ef1fead7207c982afbe2c55f6108e88afd5d446254da4e04c6b8733abff5b66dc0dea540e58c809be523f2e0874ac1a453f52416f88c05537f4372b44d387fa3275cb42cee97135888e154491f7c95b73f016145dd4fd5497b63419b0abda3ee0ba7926d696b485801b0d7ea8010d4185c6c7e61acf2aaa64b672c10272e529fdcd10d1226fd4ea7203241b880adaf6af5281b5161565985132c05b740cfe8b5e7f3008d00f40ac5dbdc289b635062febbc84044d4301c7ccd58a35d9b2d043ad0bca850699e705a4d9f58da95b7763ac8c3ffed5293bd66576b40fe7ebfeb438d35c51d79f0e90353aad934b8045de8b86ebdb83a8f95c6042c18a03f33122bd1e1a06d050d52ebdd654f2feb1437034b8af1ab241953c5bdf04571b8d2e04dc50864a415292b214a1cedb0ade24f6292cefcb1c337741c0ce52fa001229ec942bd98ab8e719f9cc2d9e89ca7f5e3666d4d247eb22ca525887ae88a57b79d461efa8afcd1574d59f4ef35782b91fa6bb8a02bf49872cc6d956664aa070162be33c8da0423cb7739cbb83bd4c745eefba05b12db1ad89ac10e66aadfed5ce3474d0765d657f7df00971794998a0fb3f95baf046a11dc60d7ce0cc31bab1835571d3fe611d61731aa6be41621bff14b57aa20c956d43f2ac54308036d6799984ef7b84414d659efb6b6a28891cb3aad60c881baead7fa657b510b887f638244465ad8d86dc52f9f37b0e3f2acb9edda6bc26baae8c38beb6bf8c54dd0dfc8e969a300e7c65b6ac0b82e8be495deda15fb9c519e5361499c312181125d3bcefda648a0c8d09e39f479123919decaaaafd9d833185bc10d50e8f7a96b1014b0a058e3946a5c0beb5e8ec1f8b7fcb6effd957ffbc02c2609be686a6562c558d08b07afd297cf828866c90d3ca3d43a26b409f52eee361d5e305f442c5cf96150021bbd91d4e930a369d652689b8a28d61511ae8847d3478f8ace710cd7299a1e5fc2f9b38cfb13398ae4d0e4624ad6d1423cb890bd7c7d659d9d9ba227c9a69df6dd98b3e17bc140d5ee092b543f2f1c6b9fb61d1866c14c05db856c880574c885c8e9d0a149f9940f0a9cb616c489efb011579e5570d1e0c50aeacf2246ee562ef408b5aa840dac343744b811adeeb364c7a600b5aa90e6b3ab372d379f44d7a6d6e3f658ff0671b7c0a8b61f51496c271156577ded35e8b6b0ec356cca748244e5ca60bafec0f693a8a3d5342f6571e62d8b25d956242f71ecbff66f3c8c2762b23f67195a7e8913942aaf2ca2ac6907464de367c36ff3bb0b998d559310019a075bd2ba146f1d7c332a144ef7c23ba7798ce26aa4c4cc724c90bdac088f27103543c9cb85ce95499cdbdfc326f8948ac3ddcb73bc846b811abccacc6f46314579709cb5155f4af11f3c39903755292ccc0e7afb44736bb52f207d0f28e444751e24464546a5066ea7c18761c7b5edb0b8b6c55f9af69edfd9c257c2df2d6137070943f9e4996445c72acb9d2198c914da0644550b8eef3baa0f37564f0de7d725ac5b0f7aeee819ff46819582d49e6f8b6157e576a8fa30959dbfb6301132ef02d8262d63b8c51d916cf5505f081b1e5fcadc141f89c80fa52c43f2a9b6f12dd8b3e3006da2475daf35f23ef17790edd7056c5da673498598138016ccd88cceec1dce8b425d6599224e3f838909b81ae6394de3bb5cf22ea6ac4551ac9a4582d00a33befb3f7598144ffb9c7b36f70b5ec9671aa40faef4088d66bd2c0dc404e6ec2186c6865d8ceeaabe047882d4dfd65c133355d00635a6b2ae8bdf3a4fb74a84076f32ee9ada62f285f0d2e4399df50356275cde61b67c265f01fa6a73e7fc51d90953c653ac808085f506e25eb2bdb41ed67f661807752829f256407f9ba6f86aa386b53fe61dcb29f7a503271f3032fbe3a2f5999c598eaf5820cc6f03132cbd4234f80a7d8c79dd849665e40873658dac185b14ec1f256bb6e669fdb4edb053a00ffcdd0a54730f038fadc944b7ad0d462c6f3ca4f5f18dd92497664072e3733f79a9dc7f4c98c2ab190db3df1bfe88722345ba7761230bf1724a696a457e03cce63e4158344eec37f014bcb234f918a950976209df251aed069050a364120707b6eed3855cbb7671e166dbd6836345ef16b7ff670707b5650a4ea1abd67f0bd19298f5600b4e07d2c76dd2d59ba4d6bf641242cf99ce90495cec6eb3ae370a0d5db96d2488750e3d04e374da0bcbba4ea316181110e90214d06d2748b8339a919f8787ad1ff54ea3e9a0f69c47775b9e08632df265bf6b8bdc2c79328a05817cca302f09f71e0163d37e47e5c12692053d90a199d42e961ef412eab06c77f7d8ee5d12afe2c623cb8df5b8bde8023be5d5e90b670b6f542c26c432867f29bfd3a85c07ef11dbc10ec7b0f128bcbe2d2d15653f52ba87f8bdee042180309495194398f762b8c047160e27cca066b0fb158c21bbee01580fc2879823388cf6032a3e467103351e2ed3eeaf9df4e39bd4bfe79678c8b6abb361385d2fdec8ecda22ea0acb46bfc116e263d1274aa957ba918815961e6cd6917c0264b587247902a1223701a3dbb46e49683bb5816550ad37b75e536b6ffe1b2b5e7e59441863fa32a6d72aae3de5938659291f563257477ade427d0ca4cbc9b6f61397dbe155681e9dabbe0f8809c1f29b8dc806c9fce17853f3104aa1982a4706dcb39cc7f5d0183355a93cb89af78097ae3fcf39ca9af6006afe72f2d85ba1396a54658f802311bba7853b19b9572884dccb6e66bc96d2edec0a70fa4f4a0277eb3d71f7f52ce046b1fb2462fc801496fb95c2985625dba09eb5d43c39cd2d039aa09d11a8cb7be5f0a2b64cb027b559267c1c031f9ef1f225dc765c075bd26b2e6a6923c7728ce1fbb7b8788054b2e87c43bfc3852304a62ed3e86f4075a7b6c5be6ef1d81b2fbf2eec32ce51d8652d7880248894f839fd9e9df762625699212e0666305bffcf66cdd5451291aef2e251f420f3828995262bd94136678731b3e4b75a8a417c93328f1102176a1f7bf1636d11c08dcd3cd40eb20d0dcf06046c58a2904cb54d5991e82681babef24cb1c872ba03d34b52d86b0018eb9a63d5250f009669cdc756b00ff694ecefb802d3f9fc9a25647de9b5d1f08709f30650cb2c202158c8198841966bd41197ae3fbd328219272526ca9f1c478a4c06df43985368d030354fff8e98aa6cfc4dbef0f8b358c24bcfc2bbae619d4b7ef4b840bb3c73c737d6e86adec3c946a66ec1067cd4e184134cd79c8f0c78d3d9b25be040c380f2e85432b51250a91401d440112655d0e355866645a72ae13b8c0ad714b6f6cc8f7aca81156b66a135802aaa40616df3903e39b4406ec05c2a2b27d80c5936ebc230ad516ab6e5b8e68691915c67735e7f0d576c80695cca438094b19fe932304c94aaa1c3cb1945faaaec28757833b8c93edd33c09db40547bdb4690ef93b4672e105d5598b39b4d7f2cf7932ba7212bcc18db65e9bdb524446fa4a86843fffdb9c31627859d978caadbf6c702b2586b00eef6a38a408e96a93408fafdd85055665173853c339701ca080f7dd4531fa4df484c9e478ef8c47cd568fd9f34cb21d11585b40fa29941be4f7597cd826e6109788490d849b4696dfcdb8fd08ac50dd6782be205f087d42ee866fc4294cafc9544fa674a211922c289ac933ccd4010188e85c6dad42e3f31a3ea28f284bc546f7152418b473146bcbd2c068ea23fd29e0a2568b4a09e1da7141aa8c97643b2ed361e1491e3c61713d72f1898b8bd8a694029655492f4105e7c1f16a7ff6143037e745271fd60888a260d90ef14a2c772873c6645a6827dbd6e897508bfaf9df9930b2f78fd170b7b7f9ddf959912d8d458ccdc29a8588fea0fbac4f1a15d5dda287f4c1e5469734e8f19f5dbc92fe554be1c1bc0fb9cb83e724028f285ca84e1c2dc6b781e36cf9ba20e8a51b7bd22e1df813b439500f03f8e2496ae0285beb4954815c307e7a47a8ac93eb027e4e792a36b64ee0b906f37cb1ac79ca8e27068c49b01d6e71d4036f6c0e5fc81d1a6329b76067eb680142d4e14bf426f580b14e12778e608cc233fa74437181b555a3239f4b7c1768691cadfe3bb6ef423ae1fc2aef524ea1d51e29ffe6ea0449246e8d8523f0f0d8e999b65bc3d12821be1034157a159560bb81469f93b91dceb599d91ff37495cda99f522d26b659b376132dc1f012f1552bd4719deaca5eb30d3533d610b93d286c70de3613e3aeb267d520b0ff274c51626f8f4e7c645b25e4a3d7b2853a03a044864072673f578b24fba305f5598fe07147da83ed1166e10d4277af6ba88f6a40d6bdd8922c7515d68815deaf28fddae0a680ac5df4ec818a06247e1ce879aa81c19143c94f123d816b749ec08fa7937230a9140328d996e7a07f1f37d65443a76efe0ac13d1b7e68e3d9e2f4a7f6f78ff3d646b4ad69cfad3f61556d994c4a8bd161a2be1b14e48ac26b4882eb59135125247402e49a28f9de6917314817532174abcca8f3f744743a100177bf9736d68bf6d23d3df148931912fbebf0774c6b56a2bffaab1d52213daad4f302bcdc738ab51250a49e53788a2135efee39ee4d3a2916ad2f302053fbd08d1104a094df576fab5bba359818d523617998545046742f91043e9af00af72019b55fc3e52e0bc72b48dd76ab785d158926878cc238b962b4f200458a6649b2769001610fb010dba021ed6b02b1bcf4d74d5bea0ea6d70a4f6606fecb20d6350b4e3b7f6b5167a7eb1b38d6fe474b3bdebb7e22bc0ff6933b75ed9f8cc3eb382531156f5a98ac5b4534ef1bed1629889e3782e2eb42b1eb3077eb79cd5e2d2eeae8f454c0e97cfcd4b4a37d547f9ad5a677aef57e4275d60670d8dc05dee84e56a7d502d6e5e908214ac75c63ed382871a45dcfc64d4384f7a0546b2d522309e14e395e6d044c56629e64065c2fbcd2e50ffeb31fc25df96dcb293f8cb81252e1b133b4f3736c0d1bee9baf48702f59270c6020b3f3d757ba5f989cf67400a158ca8529af982a8f04bc7ab2f51363ba358e5e6f26a86ee98c43191a6aec9534b3aa37469f3b59139ef3a4d6e593c5771b4efbaf843727e894ec3bf238e5fd074677aa0ff6a91b429a305ac6516f2d0033dfdfd52b7d27f23dfbf766d01267990c97f190e9a1e6dae9a8ee1a049971efca92a5826f8b2a67ea1da494a7ba256fb9749609a2539320e2f75680a385ba065d3f233a8472a2982dd8b0bf25b9ad9d40a038944995cd34c1018ec9129eafebcd48a688ec658db3684a7226b056cf40e4f478153faa304a34bd97b7af2cccc7292ea29e88610bf049ba7ed0623da3b76c94d167581937de651cf399d758d3740d199b1dffc122677f634b11b3d0b8374251ca036f0dd0419cec244bf5525d1813cfbf271821f351b33f1743770d0f9b727deb4a3ecd95f1943880dee59545353e920ab438dc2015748ded9f45644bd55a07617e5d5474c170ec20312b59d72e8377d67c61d69f7412f0a70fc941e5ca550e964fb19c1782bef17e63bda5b3478e1673cf49ba538892edd9566b3c90c09a06e04dd2ee56ed0565b1d056588ec3183799c84eccbaad53671d7f27812e708aecc1c5f1864167547fcc7d351bcd69bf1f206ab99b2107af98bce6ce438937850f44ef73fc7c650187af1e22faca9d94d090a670d3388775ec69850d174d52b2d39bace3e72d55731fab35dc00155dd8668254ef81451f69024f83f7868bdbd7c70d5e8c56e1fed15b95240f72951bc3f275a7aa430750770de23e556db30018a569fe357293ed8bfb97ff8aef3e6dc1777f63f4ae82904411aa8b5e80bca375d672e8a5998fddfd1d072d63976b9e96647beb79a5237296bf50a9b9f3d2a19397dda474f3eff1425aafe11f79d344f7f437dcdcc30d7b0e4e59fd9520fc8a66539ae59c998d7373ff8bd2009ceee57bf6551824da620199cddf6147f367574ec34f2ccc50a11a2e718aac10cbde403b076d5587859eeba6fa690d783c9534c3365cbd1069285baff80777f2db580a27935808fd5213c851ccd464fda203660d2a677f80e075c793629d82c3130fb756bbfad393815b6ae3db9e36ba5307c64911dc8126ac51838d9ff4a26a17e07d7ed00c6fda2669c3e50b049e45f571be573b35a22f74bc85bed6ef7102e2ffa3d6325f07ebf39b8d0f7a93d653c24f8cd6f79140b2aa1d38276c39e917aefdcfdb66620bb2ae2e923ac80ca5b3dfb64c8abb8fc21b520f81f78be9855ec3620fbaa3b667b585b799257b72724d7142b407c44b07be245b6d5e4e0b0e73e50c159d1cab765d03f9d97f818d9a575c253a1ccde9d4566f3692d41b112fca7cfde43dfea0b8eab38cdbe64d9b80bee92c831e7d29058b6dfb7a01084e9735bb67c6f04418c23c2aa116a8b732d18395497b9c489f26ff5b55719c593e97000519c1c483abfdaeefa08b3ec510fb56f242506f9bf676f805b5db5361830ee2c2e501eb1370707ae244f091fcee2fe50f52432c818b1765458d9e55bc874e3d3d13821c76967dede364a63feced4db8c9699a0d1411b41692ac65af4a9af316b82753097951fffeae676ca2b1ad39ad8f24ce0c7f4c3b6a72213fb1e22318cc658d935cec8533db84fc915148a06e9e9d557444638acdda6efabdfea3a70304ca299b4b2fc32b071017083783a42a696c8086c8411c7a8ef4f115bacabec1cf08a26d98295fb0274294141f0d60c2f70673462ed026462b41218cc2deee2e8adfa4a80abddac238c5e710769980a7f548f75c954ddbab2f537926abdb84a2134235319514169ea3592db5ba0148ebae6ffad618d20dbca24170f18eba270dc8b7cc3dc8a08a57719b7e5c626cc380781a8dfabf8a5147c59cbe07a52d5abb93ef8a11dd34b8f714e4f53a1698336dc4580c642ff4d4720ace43796c54c55afb1ef9f04abfe688af3504a5f54d0ceccfad258f27b939b771e72ce12655bda9998d26be150c6cf9ea5b298d63e95facfee6174510984bbeacb3002e01ea8b8fe7dbb5edfee499d7a654b5b957df2eda4ed99bae179c765db29da95ffc2a0414a1248e08cb16224e417a8acd3ee4b1d83ddf91d2d3aff03577fd7252dc7b55ebb487443fba00a4ecb94850af18f71912dc31027832a212959579ea65c1d2a0e6e805c45b7c741a0af6ecf0bea94d2bc9558e57287c1418f6e87f46b1b0627a29385c3002189cc0cbc72286bf567c7cfcb5d0424b344e5aad3d8bd3377e48b7a3aed6f25d776b5e531553088973ce12ca3e81be4d9baf85ae66ed9ddb01713b3ee85b676798a3e63ea359a4d8045b265a1b264125a6cb128f190c6c2cf1c42a4053737e657df85f05c17df3519b986945ff511766a250005ee1cfc9f631ab9f6febaea86232c90cbae983556eaa310800fc43139d2f93c098230d1f73389f8458f239fe54a627aebd04c672d38a06bcb19042c05f21b6e0a7158a7d11c0c8ef6050d2c32877bcc18e4d4f71d26ff4e1a359af159e920d30235b8752f887947b5b827037fff5001c0516a9ad8e0c79d88c8b0178bb6ffdfca7e48334772bc7bd97c7729e030556524fa2cd4726b3764bee287b30d6490eb13c53c4bd877031b16fec131e9fa16fefe164f9329ba257b829388fd1ba182c30820d6b91ccb379c7e633a033ffc89da880257e621044e42c108e7a85dae65674a15d86914fa0a5d7a3888c05f0c850e88833077e557a009a00aa065ac8f6f7b035b564680a6c6a3b2c0891bed991fb56ffefc30ff9d3ea67cbda7969f0d48280ba725732eb71f9498ef49b3ab22edaa2da91cbb2411b77c52ce9e21334675c7b59945e402363481e8aaec2ad43b0fac9d18dd12a2d88d2ef81a21a6cac8e3396874d3b4fc6f3472f10af6c3e6a3087aebb95351a003c6c9f6d09095633e445bc49278a72e4b23b684004d743f244edf9b72870fd50d6d7561810279946c0573d9decc05af56b2648d48e6161674e661498ff8ad8ae95a48ab23e43ccc0acccd010bbf38137ba8e8bd25f6ff2918ed1e4efec06ff3f5670da624f7d8d3e593eca992588f345df8dae82912a4741ae71246dd547fa3d2a25a5ea42176b835329d906abfc184613a097f326ef4efc5a3e4b2e719eb839e376642a9062155f9f9fdb4bbb79330f02aa54130a9379e148d2de2c3c365bda5478e56f015548f142a963a0c9d9bb47bfdd450eba7b5cfe300138e68560eae34624120397906a82a0dd1a9e6e720fde642d49ad4c953b8132332f5560ccd6acc6080d34225c906c154c613e002f69377705cc6296b0a295c705ebdd2385c12cec8276a2684fea430b4642a3fc9a43ac50116ca7cd222801997ebd02b418f817eea402507a1da65a04122b5d37f7a83b5df1ab731ba1dbc27b9d0a7f627fb9bd83155ac2812c8794f20645cd8e3a9342320d51d8482787c2a93c5fe9f1abedcaff8afeff3814ed07bf1187d95a5f2b4957c894f6eb7cb5efded845e8e214acefc42825383f84e7bea6077540d1c5007e21305a9a8272010f4722cc6fe07683ba1cf1f13c58902ee8621fc2c7833c4eddec1b1e4e349c22f420f858399c91eedfddd2e5a4856158d9193982fe801dd64671c5e8e10fbc61215c543d3a290a48688ed3a58fccbe57e2816ac81cc468b8b5a86b35387e427065709af7c68a9c837031e2acb0f490d8f040e56d8606060ded9a20180a6e3e6f2add320eb79ad623ade53b0d5fe88259524cdcba620931b89eaac277be78e9f9f5aab828182d97fe6bea960c9eed1ea454a0be0c381b26e2e23c984f46e741ed7eb93574e37d06eed72d561ef3d5d03411b175f09da84d06f4f7f5d2e354caca4bc37b46326fbaf01f55ec7decc7f995a42cd544dd35bad7a64206583d8d7628addcacbd21b3ac412306b7bf837675485a753e397eb33991034cc5d56b81f2b5a5277e1083eb5a1788f48ff7d25012b40c250be473e0c3677a427dcee20d37c1aba3277118e9eda401fda2bd5d662f7396bab47a73f23ae1a8dfa876d85b3d73d48f08e37b9d67602e3a33c6d00b2fc3964d95295be7a750168afb2ad32710b8b2a4fb7c0e0679f65e5b46a5a82e95f31ac6bf4e96111909b1cc7ee5e2a6766c9f05a9a5befcd72e2dd0d19618b789aab0701c2924ac9198827451b950f2c41438c345a9a5501a428e33650a93b0ae3103249f3312b53b2f694cbb7ff3d54aa1915f14101c5ce23a2083e023aa975211547353a607481bb05277c98aa54d69857d803024084e48b17edf3dead0aedfe8a0d6c02e7971b4833e25662786d792a33458d9a4b1d874ecaf1d59d3afb47ef342c98cc28dd7b4bb5a255a7d2c6dfe80594525fc0d4fa7cad9b05ec4982abd42b5950612fd936b52f4624ff0b4f93ce895a64ca889fdbf09914da6cbe836b065f1aa0af08bd1088f988e052af12306fa890c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入访问密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 腾讯 </tag>
            
            <tag> 后台开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】I/O</title>
      <link href="/p/9d8ce868/"/>
      <url>/p/9d8ce868/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-O-流"><a href="#Java-I-O-流" class="headerlink" title="Java I&#x2F;O 流"></a>Java I&#x2F;O 流</h1><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="为什么要分字节流、字符流？"><a href="#为什么要分字节流、字符流？" class="headerlink" title="为什么要分字节流、字符流？"></a>为什么要分字节流、字符流？</h2><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li><li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li></ul><p>字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h2 id="BIO、NIO、AIO-有什么区别"><a href="#BIO、NIO、AIO-有什么区别" class="headerlink" title="BIO、NIO、AIO 有什么区别"></a>BIO、NIO、AIO 有什么区别</h2><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/bio-aio-nio.png" alt="BIO、NIO 和 AIO 对比"></p><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking &#x2F; New I&#x2F;O)"></a>NIO (Non-blocking &#x2F; New I&#x2F;O)</h3><p>NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.png" alt="img"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><div class="note  flat info no-icon"><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></div><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系"></p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.png" alt="img"></p><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>下面这段代码大家经常使用吧？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;Hello！&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello！&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">  <span class="comment">// 省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写模式主要有下面四种：</p><ul><li><code>r</code> : 只读模式。</li><li><code>rw</code>: 读写模式</li><li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li><li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li></ul><p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p><p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#java-io-%E6%B5%81%E4%BA%86%E8%A7%A3%E5%90%97">Java基础常见面试题总结(下) | JavaGuide</a></p><p><a href="https://javaguide.cn/java/io/io-basis.html">Java IO 基础知识总结 | JavaGuide</a></p><p><a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解 | JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】基础 &amp; 持久化</title>
      <link href="/p/a69f6a48/"/>
      <url>/p/a69f6a48/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h1><h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><p>Redis （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p><ol><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li></ol><div class="note  flat info no-icon"><p>下面这张图片总结的挺不错的，分享一下，出自 <a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?</a> 。</p></div><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/why-redis-so-fast-E21l9uI2.png" alt="why-redis-so-fast"></p><h2 id="为什么要用Redis？-为什么要用缓存？"><a href="#为什么要用Redis？-为什么要用缓存？" class="headerlink" title="为什么要用Redis？ | 为什么要用缓存？"></a>为什么要用Redis？ | 为什么要用缓存？</h2><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p><p><strong>1、高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>2、高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><div class="note  flat info no-icon"><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></div><p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li>只追加文件（append-only file, AOF）：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><h2 id="RDB-持久化（快照）"><a href="#RDB-持久化（快照）" class="headerlink" title="RDB 持久化（快照）"></a>RDB 持久化（快照）</h2><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p>快照持久化是 Redis 默认采用的持久化方式。</p><h3 id="RDB-创建快照时会阻塞主线程吗？"><a href="#RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="RDB 创建快照时会阻塞主线程吗？"></a>RDB 创建快照时会阻塞主线程吗？</h3><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li><li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，<strong>默认选项</strong>。</li></ul><div class="note  info simple"><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p></div><h3 id="生成-RDB-的时候，是如何正常处理请求的？"><a href="#生成-RDB-的时候，是如何正常处理请求的？" class="headerlink" title="生成 RDB 的时候，是如何正常处理请求的？"></a>生成 RDB 的时候，是如何正常处理请求的？</h3><div class="note  default simple"><p>2024&#x2F;07&#x2F;26 补充</p></div><p>默认情况下 Redis 生成 RDB 的过程是异步的（采用 <code>bgsave</code>），主线程会调用 fork 创建一个子线程，由子线程负责将内存的数据写入磁盘，生成 RDB 文件。</p><p>那生成 RDB 文件的时候，数据可以修改吗?</p><p>当然可以。主线程会正常处理客户端的请求，进行数据的修改。但数据被修改还叫快照吗?</p><p>此时就运用了写时复制的技术，当父进程 <code>fork</code> 出一个子进程后，并不会把父进程的所有内存数据重新复制一份给子进程，而是让主进程和子进程共享相同的内存页面。</p><p>底层的实现仅仅复制了页表，但映射的物理内存还是同一个。这样做可以加快 <code>fork</code> 的速度，减少性能损耗（<code>fork</code><br>会阻塞主线程）。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/cASYQdyk_image_mianshiya.png"></p><p>此时，父进程收到写命令，需要修改数据，那么父进程会将对应数据所在的页复制一份，对复制的副本进行修改。此时<strong>子进程</strong>指向的还是<strong>老的页</strong>，因此数据没有变化，符合快照的概念。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/HCjbjSF3_image_mianshiya.png"></p><p>通过在写的时候才触发内存的复制，可以显著地降低 Redis 实例的性能压力，最大限度的减少 RDB 对服务正常运行的影响。</p><div class="note  default simple"><p>注意</p></div><p>如果 RDB 时间长，且写并发高，因为写时复制机制，如果共享的每一页内存都被修改，会使得内存极速膨胀，最大内存可以膨胀两倍，所以要注意内存的使用量，防止内存过载。</p><p>RDB 会产生大量的磁盘 &#x2F;&#x2F;O，要注意磁盘性能导致的影响还需要注意 CPU 负载，毕竟有大量的数据需要写入。</p><p>因此如果 RDB 在高峰期可能会影响到正常业务，需要合理安排生成 RDB 的时机。</p><h2 id="AOF-持久化（只追加文件）"><a href="#AOF-持久化（只追加文件）" class="headerlink" title="AOF 持久化（只追加文件）"></a>AOF 持久化（只追加文件）</h2><p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了）。</p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（<code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png" alt="img"></p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p><h3 id="AOF-工作的基本流程"><a href="#AOF-工作的基本流程" class="headerlink" title="AOF 工作的基本流程"></a>AOF 工作的基本流程</h3><p>AOF 持久化功能的实现可以简单分为 5 步：</p><ol><li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li><li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li><li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li><li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/aof-work-process.png" alt="AOF 工作基本流程"></p><h3 id="AOF-持久化方式有哪些？"><a href="#AOF-持久化方式有哪些？" class="headerlink" title="AOF 持久化方式有哪些？"></a>AOF 持久化方式有哪些？</h3><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code> 策略），它们分别是：</p><ol><li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li><li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li><li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img"></p><p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p><p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p><ul><li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li><li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li><li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li></ul><h3 id="AOF-为什么是在执行完命令之后记录日志？"><a href="#AOF-为什么是在执行完命令之后记录日志？" class="headerlink" title="AOF 为什么是在执行完命令之后记录日志？"></a>AOF 为什么是在执行完命令之后记录日志？</h3><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/redis-aof-write-log-disc.png" alt="AOF 记录日志过程"></p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/aof-rewrite.png" alt="AOF 重写"></p><p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b-20230309232257343.png" alt="img"></p><p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p><p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p><div class="note  flat info no-icon"><p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p></div><p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p><p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png" alt="img"></p><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p><p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p><ul><li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li><li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li></ul><p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p><p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的<a href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从 Redis7.0 发布看 Redis 的过去与未来open in new window</a> 这篇文章。</p><h3 id="AOF-校验机制"><a href="#AOF-校验机制" class="headerlink" title="AOF 校验机制"></a>AOF 校验机制</h3><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p><p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p><h2 id="如何选择-RDB-和-AOF？"><a href="#如何选择-RDB-和-AOF？" class="headerlink" title="如何选择 RDB 和 AOF？"></a>如何选择 RDB 和 AOF？</h2><p><strong>RDB 比 AOF 优秀的地方</strong>：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong>：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><p><strong>综上</strong>：</p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul><h2 id="为什么会有混合持久化？"><a href="#为什么会有混合持久化？" class="headerlink" title="为什么会有混合持久化？"></a>为什么会有混合持久化？</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617-20230309232312657.png" alt="img"></p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h2 id="大-Key-对持久化有什么影响？"><a href="#大-Key-对持久化有什么影响？" class="headerlink" title="大 Key 对持久化有什么影响？"></a>大 Key 对持久化有什么影响？</h2><h3 id="大-Key-对-AOF-日志的影响"><a href="#大-Key-对-AOF-日志的影响" class="headerlink" title="大 Key 对 AOF 日志的影响"></a>大 Key 对 AOF 日志的影响</h3><p>首先回顾一下 AOF 日志三种写回磁盘的策略：</p><ul><li>Always：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li>Everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li>No：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><p>这三种策略只是在控制 fsync() 函数的调用时机。当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/def7d5328829470c9f3cfd15bbcc6814.png" alt="img"></p><p>因此，对应的影响则是：</p><ul><li>在使用 Always 策略的时候，主线程在执行完命令后，会把数据写入到 AOF 日志文件，然后会调用 fsync() 函数，将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。<strong>如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</strong>。</li><li>当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。</li><li>当使用 No 策略的时候，由于永不执行 fsync() 函数，所以大 Key 持久化的过程不会影响主线程。</li></ul><h3 id="大-Key-对-AOF-重写和-RDB-的影响"><a href="#大-Key-对-AOF-重写和-RDB-的影响" class="headerlink" title="大 Key 对 AOF 重写和 RDB 的影响"></a>大 Key 对 AOF 重写和 RDB 的影响</h3><p>当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大，那么很快就会触发 <strong>AOF 重写机制</strong>。</p><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。</p><p>在创建子进程的过程中，操作系统会把父进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/06657cb93ffa4a24b8fc5b3069cb29bf.png" alt="img"> 这样</p><p>一来，子进程就共享了父进程的物理内存数据了，这样能够节约物理内存资源，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存，对应的页表就会越大。</p><p>在通过 <code>fork()</code> 函数创建子进程的时候，虽然不会复制父进程的物理内存，但是<strong>内核会把父进程的页表复制一份给子进程，如果页表很大，那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象</strong>。</p><p>而且，fork 函数是由 Redis 主线程调用的，如果 fork 函数发生阻塞，那么意味着就会阻塞 Redis 主线程。由于 Redis 执行命令是在主线程处理的，所以当 Redis 主线程发生阻塞，就无法处理后续客户端发来的命令。</p><p>如果 fork 耗时很大，比如超过1秒，则需要做出优化调整：</p><ul><li>单个实例的内存占用控制在 10 GB 以下，这样 fork 函数就能很快返回。</li><li>如果 Redis 只是当作纯缓存使用，不关心 Redis 数据安全性问题，可以考虑关闭 AOF 和 AOF 重写，这样就不会调用 fork 函数了。</li><li>在主从架构中，要适当调大 repl-backlog-size，避免因为 repl_backlog_buffer 不够大，导致主节点频繁地使用全量同步的方式，全量同步的时候，是会创建 RDB 文件的，也就是会调用 fork 函数。</li></ul><blockquote><p>那什么时候会发生物理内存的复制呢？</p></blockquote><p>当父进程或者子进程在向共享内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个「写保护中断」是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为「**写时复制(Copy On Write)**」。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/451024fe10374431aff6f93a8fed4638.png" alt="img"></p><p>写时复制顾名思义，在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><p>如果创建完子进程后，<strong>父进程对共享内存中的大 Key 进行了修改，那么内核就会发生写时复制，会把物理内存复制一份，由于大 Key 占用的物理内存是比较大的，那么在复制物理内存这一过程中，也是比较耗时的，于是父进程（主线程）就会发生阻塞</strong>。</p><p>所以，有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li></ul><h3 id="其他影响"><a href="#其他影响" class="headerlink" title="其他影响"></a>其他影响</h3><p>大 key 除了会影响持久化之外，还会有以下的影响。</p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><h3 id="如何避免大-Key-呢？"><a href="#如何避免大-Key-呢？" class="headerlink" title="如何避免大 Key 呢？"></a>如何避免大 Key 呢？</h3><p>最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis">Redis常见面试题总结(上) | JavaGuide</a></p><p><a href="https://javaguide.cn/database/redis/redis-persistence.html#aof-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97">Redis持久化机制详解 | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/database-system.html#id28">数据库系统 — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#rdb-%E5%BF%AB%E7%85%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库】索引</title>
      <link href="/p/f9b9edb2/"/>
      <url>/p/f9b9edb2/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈你对索引的理解"><a href="#谈谈你对索引的理解" class="headerlink" title="谈谈你对索引的理解"></a>谈谈你对索引的理解</h1><p>索引的出现是为了提高数据的查询效率，就像书的目录一样。</p><p>同样索引也会带来很多负面影响：</p><ul><li>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加。</li><li>索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间。</li><li>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</li></ul><p>建立索引的原则：</p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><p>不适合建立索引的情况：</p><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><ul><li>按「数据结构」分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h2 id="从数据结构角度"><a href="#从数据结构角度" class="headerlink" title="从数据结构角度"></a><strong>从数据结构角度</strong></h2><ul><li>B &#x2F; B+ 树索引</li><li>Hash 索引</li><li>Full-text 索引</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923210708.png"></p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><h3 id="B-B-树索引"><a href="#B-B-树索引" class="headerlink" title="B &#x2F; B+ 树索引"></a>B &#x2F; B+ 树索引</h3><p>看上一篇文章：<a href="https://rean-schwarze.github.io/p/cbe55d0">【数据结构】树 | Rean’s Blog (rean-schwarze.github.io)</a></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923210829.png"></p><p>这些行数据，存储在 B+Tree 索引时是长什么样子的？</p><p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。</p><h4 id="通过主键查询数据"><a href="#通过主键查询数据" class="headerlink" title="通过主键查询数据"></a>通过主键查询数据</h4><p>主键索引的 B+Tree 如图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923210853.png" alt="主键索引 B+Tree"></p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4 次。</strong></p><h4 id="通过二级索引查询数据"><a href="#通过二级索引查询数据" class="headerlink" title="通过二级索引查询数据"></a>通过二级索引查询数据</h4><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的<strong>叶子节点存放的是实际数据</strong>，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的<strong>叶子节点存放的是主键值</strong>，而不是实际数据。</li></ul><p>我这里将前面的商品表中的 product_no（商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图，其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923210940.png" alt="二级索引 B+Tree"></p><p>会先检查二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。如下图：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923210958.png" alt="回表"></p><p>不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再去主键索引中查寻了。</p><p><strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p><h4 id="为什么-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 InnoDB 选择 B+tree 作为索引的数据结构？</h4><p><em><strong>1、B+Tree vs B Tree</strong></em></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的<strong>非叶子节点也要存储数据</strong>，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><em><strong>2、B+Tree vs 二叉树</strong></em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中，d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数<strong>只能是 2 个</strong>，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p><p><em><strong>3, B+Tree vs Hash</strong></em></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p><h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><p>InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+ Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。</p><h2 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a><strong>从物理存储角度</strong></h2><ul><li>聚集索引</li><li>非聚集索引</li></ul><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。</p><p>特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。</p><p>聚簇索引和非聚簇索引的区别：聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><h3 id="聚集索引-聚簇索引"><a href="#聚集索引-聚簇索引" class="headerlink" title="聚集索引 &#x2F; 聚簇索引"></a>聚集索引 &#x2F; 聚簇索引</h3><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>优点</strong>：</p><ul><li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="非聚集索引-非聚簇索引"><a href="#非聚集索引-非聚簇索引" class="headerlink" title="非聚集索引 &#x2F; 非聚簇索引"></a>非聚集索引 &#x2F; 非聚簇索引</h3><p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><p><strong>优点</strong>：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong>:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><h2 id="从逻辑-字段特性角度"><a href="#从逻辑-字段特性角度" class="headerlink" title="从逻辑&#x2F;字段特性角度"></a><strong>从逻辑&#x2F;字段特性角度</strong></h2><ul><li>普通索引</li><li>唯一索引</li><li>主键索引</li><li>前缀索引</li></ul><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><h2 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h2><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><p>比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_product_no_name ON product(product_no, name);</span><br></pre></td></tr></table></figure><p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923211026.png" alt="联合索引"></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p><p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1.</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3.</li><li>where a&#x3D;1 and b&#x3D;2.</li><li>where a&#x3D;1 and c&#x3D;3.</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效：</p><ul><li>where b&#x3D;2.</li><li>where c&#x3D;3.</li><li>where b&#x3D;2 and c&#x3D;3.</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><h3 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h3><p>这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from order where status = 1 order by create_time asc</span><br></pre></td></tr></table></figure><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。</p><br><h1 id="MySQL-的索引下推是什么？"><a href="#MySQL-的索引下推是什么？" class="headerlink" title="MySQL 的索引下推是什么？"></a>MySQL 的索引下推是什么？</h1><p>索引下推（Index Condition Pushdown, ICP）是一种减少回表查询，提高查询效率的技术。通过将部分带有索引的条件交由<strong>存储引擎层</strong>进行过滤操作，从而减少了 IO（本该由 Server 层做操作，交由存储引擎层因此叫做 “下推” ） 。</p><p><strong>注意：索引下推是是应用在联合索引上的。</strong></p><h1 id="为什么-InnoDB-选用-B-树而不是-B-树"><a href="#为什么-InnoDB-选用-B-树而不是-B-树" class="headerlink" title="为什么 InnoDB 选用 B+ 树而不是 B 树"></a>为什么 InnoDB 选用 B+ 树而不是 B 树</h1><p>用 B+ 树不用 B 树考虑的是 IO 对性能的影响，B 树的每个节点都存储数据，而 B+ 树只有叶子节点才存储数据，所以查找相同数据量的情况下，B 树的高度更高，IO 更频繁。</p><p>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</p><div class="note  flat info"><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul></div><h1 id="谈谈你对覆盖索引的认识"><a href="#谈谈你对覆盖索引的认识" class="headerlink" title="谈谈你对覆盖索引的认识"></a>谈谈你对覆盖索引的认识</h1><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><p>我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><h1 id="谈谈你对最左前缀原则的理解"><a href="#谈谈你对最左前缀原则的理解" class="headerlink" title="谈谈你对最左前缀原则的理解"></a>谈谈你对最左前缀原则的理解</h1><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code></strong> ）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><ul><li><code>=</code> 和 <code>in</code> 可以乱序，比如：<code>a=1 and b=2 and c=3</code> 建立 <code>(a, b ,c)</code> 索引可以任意顺序，MySQL 的优化器会优化成索引可以识别的形式。</li></ul><p>相关阅读：<a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引的最左匹配原则全网都在说的一个错误结论</a>。</p><br><h1 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h1><p>想详细了解的可以去看这篇文章：<a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢？</a></p><p><strong>索引列参与表达式计算</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">WHERE</span> <span class="string">&#x27;age&#x27;</span> <span class="operator">+</span> <span class="number">10</span> <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><strong>函数运算</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;date&#x27;</span>,<span class="number">4</span>) <span class="operator">&lt;</span> <span class="number">1990</span>;</span><br></pre></td></tr></table></figure><p><strong>模糊查询</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;manong&#x27;</span> <span class="keyword">WHERE</span> `uname` <span class="keyword">LIKE</span> <span class="string">&#x27;码农%&#x27;</span>  <span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;manong&#x27;</span> <span class="keyword">WHERE</span> `uname` <span class="keyword">LIKE</span> <span class="string">&#x27;%码农%&#x27;</span> <span class="comment">-- 不走索引</span></span><br></pre></td></tr></table></figure><p><strong>字符串与数字比较不走索引</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;a&#x27;</span> (<span class="string">&#x27;a&#x27;</span> <span class="type">char</span>(<span class="number">10</span>));</span><br><span class="line"> `EXPLAIN` <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">WHERE</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span>&quot;1&quot;;  <span class="comment">-- 不走索引</span></span><br><span class="line"> `EXPLAIN` <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;a&#x27;</span><span class="keyword">WHERE</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span><span class="number">1</span>;     <span class="comment">-- 不走索引</span></span><br></pre></td></tr></table></figure><p><strong>查询条件中有 or</strong></p><p>换言之，就是要求使用的所有字段，都必须建立索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> <span class="keyword">or</span> loc<span class="operator">=</span><span class="string">&#x27;xx&#x27;</span> <span class="keyword">or</span> deptno <span class="operator">=</span> <span class="number">45</span>;</span><br></pre></td></tr></table></figure><p><strong>正则表达式不使用索引</strong></p><p>MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。</p><h1 id="怎么知道创建的索引有没有被使用到"><a href="#怎么知道创建的索引有没有被使用到" class="headerlink" title="怎么知道创建的索引有没有被使用到"></a>怎么知道创建的索引有没有被使用到</h1><p>使用 <code>EXPLAIN</code> 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。</p><p>可以通过其中和索引有关的信息来分析是否命中了索引，例如：<code>possilbe_key</code>、<code>key</code>、<code>key_len</code> 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p><p>这种方法也是分析 SQL 语句执行很慢的原因的方法。</p><br><h1 id="MySQL-中的索引数量是否越多越好？为什么？"><a href="#MySQL-中的索引数量是否越多越好？为什么？" class="headerlink" title="MySQL 中的索引数量是否越多越好？为什么？"></a>MySQL 中的索引数量是否越多越好？为什么？</h1><p>先说结论，<strong>索引并不是越多越好</strong>。因为索引<strong>不论从时间还是空间上都是有一定成本的</strong></p><p>1）从时间上</p><p>每次对表中的数据进行增删改查的时候，都需要维护对应索引的数据，例如删除了一个 name 为面试鸭的记录，不仅主键索引上需要修改，如果为 name 也生成了索引，那么 name 索引也需要修改，所以<strong>索引越多需要修改的地方也就越多</strong>，并且 B+ 树可能会有页分裂、合并等操作，时间开销就会更大。</p><p>2）从空间上</p><p>每建立一个二级索引，都需要新建一个 B+ 树，默认每个数据页都是 16kb，如果数据量很大，索引又很多，占用的空间可不小。 并且 MySQL 有个查询优化器，它需要分析当前的查询，选择最优的计划，这过程就需要考虑选择哪个索引的查询成本低。如果索引过多，那么会导致优化器耗费更多的时间在选择上，甚至可能因为数据的不准确而选择了次优的索引。</p><br><h1 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h1><p>这里说一下几种常见优化索引的方法：</p><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的；</li><li>防止索引失效；</li></ul><h2 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h2><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h2 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h2><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品 ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作。</p><h2 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h2><p>我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？</p><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>举个例子，假设某个数据页中的数据是 1、3、5、9，且数据页满了，现在准备插入一个数据 7，则需要把数据页分割为两个数据页。出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p><p>而如果记录是顺序插入的，例如插入数据 11，则只需开辟新的数据页，也就不会发生页分裂。</p><p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h2 id="索引最好设置为-NOT-NULL"><a href="#索引最好设置为-NOT-NULL" class="headerlink" title="索引最好设置为 NOT NULL"></a>索引最好设置为 NOT NULL</h2><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为 NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式<code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表，如下图的黄色部分：<img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/20240923211054.png"></li></ul><br><h1 id="请详细描述-MySQL-的-B-树中查询数据的全过程"><a href="#请详细描述-MySQL-的-B-树中查询数据的全过程" class="headerlink" title="请详细描述 MySQL 的 B+ 树中查询数据的全过程"></a>请详细描述 MySQL 的 B+ 树中查询数据的全过程</h1><p>数据从根节点找起，根据键值的大小确定左子树还是右子树，从上到下最终定位到叶子节点。定位到叶子节点后，因为一片叶子默认有 16k 大小，所以理论上可以存多条记录。叶子节点的实际构造如下图所示：</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Iaqi7kAa_image.png"></p><p>从上图可以知晓，叶子节点有<strong>页目录</strong>结构，它其实就是一个索引，通过它可以快速找到记录。</p><p>页目录分为了多个槽，每个槽都指向对应一个分组内的最大记录，每个分组内都会包含若干条记录。</p><p>通过<strong>二分查询</strong>，利用槽就能直接定位到记录所在的组，从而就能获取到对应的记录。</p><p>举个例子，现在有 5 个槽，如果想查找主键为 3 的记录，此时的流程是：</p><p>1）通过二分得到槽的中间位置，（0+4)&#x2F;2 &#x3D; 2; </p><p>2）通过槽定位到第二个分组中的主键为 4 的记录，4 大于 3，因此得知主键 3 的记录在这个分组中。由于记录是通过单向链表串起来的，因此需要从槽 1 找到主键 2 的记录，再往下遍历定位到主键 3 的记录。</p><p>以上就是利用二分查询的定位流程。通过槽可找到对应记录所在的组，或能直接定位到记录，或还需通过链表遍历找到对应的数据。</p><p>实际上，每个分组的记录数是有规定的，图中做了省略只画了两条，InnoDB 规定：</p><ul><li>第一个分组只有一条记录</li><li>中间的分组 4-8 条记录</li><li>最后一个分组 1-8 条记录</li></ul><p>因此不必担心遍历很长的链表导致性能问题。</p><p>这题的重点是先简单提下从根节点遍历到子节点的过程，然后提到叶子节点默认大小为 16KB ，所以理论上能存储很多记录，从而引出页目录，再通过二分查找才能对应记录。</p><br><h1 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h1><p>当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，但是 count 函数传入的参数有很多种，比如 count(1)、count(<code>*</code>)、count(字段) 等。</p><p>到底哪种效率是最好的呢？是不是 count(<code>*</code>) 效率最差？</p><h2 id="哪种-count-性能最好？"><a href="#哪种-count-性能最好？" class="headerlink" title="哪种 count 性能最好？"></a>哪种 count 性能最好？</h2><p><img src="https://camo.githubusercontent.com/26f62627ca24d3093c943517f199e342381de11cfe71b5b0cbf1e28b0e28893b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f61663731313033336161333432333333306433613462633662616562393533322e706e67"></p><p>要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。</p><h3 id="count-是什么？"><a href="#count-是什么？" class="headerlink" title="count() 是什么？"></a>count() 是什么？</h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p><p>假设 count() 函数的参数是字段名，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(name) from t_order;</span><br></pre></td></tr></table></figure><p>这条语句是统计「t_order 表中，<strong>name 字段不为 NULL</strong> 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。</p><p>再来假设 count() 函数的参数是数字 1 这个表达式，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(1) from t_order;</span><br></pre></td></tr></table></figure><p>这条语句是统计「t_order 表中，<strong>1 这个表达式不为 NULL</strong> 的记录」有多少个。</p><p>1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录。</p><h3 id="count-主键字段-执行过程是怎样的？"><a href="#count-主键字段-执行过程是怎样的？" class="headerlink" title="count(主键字段) 执行过程是怎样的？"></a>count(主键字段) 执行过程是怎样的？</h3><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</p><p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</p><p>InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>用下面这条语句作为例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//id 为主键值</span><br><span class="line">select count(id) from t_order;</span><br></pre></td></tr></table></figure><p>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</p><p><img src="https://camo.githubusercontent.com/a4a4f4536edc67c71182fa9c2a384e9d6a022b6484cd7ce8314624c5a3ad4c93/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f39626234663332616338343334363736383461323636346434646236316165332e706e67"></p><p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。</p><p><img src="https://camo.githubusercontent.com/79674393ac10e59443f4cc91f3335a7b23cfdd251adc6e7be22b38664de5d3fd/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f61616335353036303265663130323265306234353032306462653066373136612e706e67"></p><p>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I&#x2F;O 成本比遍历聚簇索引的 I&#x2F;O 成本小，因此「优化器」优先选择的是二级索引。</p><h3 id="count-1-执行过程是怎样的？"><a href="#count-1-执行过程是怎样的？" class="headerlink" title="count(1) 执行过程是怎样的？"></a>count(1) 执行过程是怎样的？</h3><p>如果表里只有主键索引，没有二级索引：</p><p><img src="https://camo.githubusercontent.com/4482cd80107210bd6dd473c1f82f3d9ac0f34b8444efca38d1a2fbcabaa75bd0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f65363330666463353839376235633564626333333265383833386166613166632e706e67"></p><p>那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p><p>可以看到，count(1) 相比 count(主键字段) <strong>少一个步骤，就是不需要读取记录中的字段值</strong>，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p><p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。</p><h3 id="count-执行过程是怎样的？"><a href="#count-执行过程是怎样的？" class="headerlink" title="count(*) 执行过程是怎样的？"></a>count(*) 执行过程是怎样的？</h3><p>看到 <code>*</code> 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？</p><p>对于 <code>select *</code> 这条语句来说是这个意思，但是在 count(*) 中并不是这个意思。</p><p>**count(<code>\*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p><p><img src="https://camo.githubusercontent.com/47d4cc4e334fee8d60404cd5d7a0b1270de0323b3c43017c440d981dd23aaeff/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f32376232323966303439623237383938663361383663376461376532363131342e706e67"></p><p>所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p><p>而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用 key_len 最小的二级索引进行扫描。</p><p>只有当没有二级索引的时候，才会采用主键索引来进行统计。</p><h3 id="count-字段-执行过程是怎样的？"><a href="#count-字段-执行过程是怎样的？" class="headerlink" title="count(字段) 执行过程是怎样的？"></a>count(字段) 执行过程是怎样的？</h3><p>count(字段) 的执行效率相比前面的 count(1)、count(*)、count(主键字段) 执行效率是最差的。</p><p>用下面这条语句作为例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// name不是索引，普通字段</span><br><span class="line">select count(name) from t_order;</span><br></pre></td></tr></table></figure><p>对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。</p><p><img src="https://camo.githubusercontent.com/7272fd1571b05c2ff3bf3632cb6b6a1a664179c11d49cdf911ae605d3a66fc1d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f66323464666562383565326366636530653464633361313762383933623366352e706e67"></p><h2 id="如何优化-count-？"><a href="#如何优化-count-？" class="headerlink" title="如何优化 count(*)？"></a>如何优化 count(*)？</h2><p>如果对一张大表经常用 count(*) 来做统计，其实是很不好的。</p><p>比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 <code>select count(*) from t_order</code> 要花费差不多 5 秒！</p><p><img src="https://camo.githubusercontent.com/78219b4557a0eaf28cc9eacc68cb404839f1a8fe9ee5f738ccba35fa12c450c1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f37346134333539623538646336656434316132343165343235663433373634642e706e67"></p><p>面对大表的记录统计，我们有没有什么其他更好的办法呢？</p><h3 id="第一种，近似值"><a href="#第一种，近似值" class="headerlink" title="第一种，近似值"></a>第一种，近似值</h3><p>如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。</p><p>这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。</p><p>执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。</p><p><img src="https://camo.githubusercontent.com/0964477c9b8073164a2cec7bcb6e83e02144ba6aa230d310be343e967154789e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f37353930363233343433653866323235653536353231303965366439653364322e706e67"></p><h3 id="第二种，额外表保存计数值"><a href="#第二种，额外表保存计数值" class="headerlink" title="第二种，额外表保存计数值"></a>第二种，额外表保存计数值</h3><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p><p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">MySQL索引详解 | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/database-system.html#id3">数据库系统 — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95">索引常见面试题 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/index/count.html#%E5%93%AA%E7%A7%8D-count-%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD">count(*) 和 count(1) 有什么区别？哪个性能最好？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树</title>
      <link href="/p/cbe55d0/"/>
      <url>/p/cbe55d0/</url>
      
        <content type="html"><![CDATA[<p>有关树的查找、插入、删除等等这里先不复制了（</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p><p>一棵树具有以下特点：</p><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li>一棵树不包含回路。</li></ol><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p><p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对[节点深度的定义）。</p><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/full-binary-tree.png" alt="满二叉树"></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p><p>具有<em>n</em>个结点的完全二叉树的深度为：<br>$$<br>\left \lfloor log_{2}n \right \rfloor +1<br>$$<br><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/complete-binary-tree.png" alt="完全二叉树"></p><p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p><p>细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点。</p><h2 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树 BST"></a>二叉查找树 BST</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树、二叉搜索树。</p><p>它或者是一棵空树，或者是具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ul><p>原理：</p><ul><li>若根结点的关键字值等于查找的关键字，成功。</li><li>否则，若小于根结点的关键字值，递归查左子树。</li><li>若大于根结点的关键字值，递归查右子树。</li><li>若子树为空，查找不成功。</li></ul><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="图片有点丑别在意，重点是对于二叉搜索树的理解"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p><p>AVL 树是一种改进版的二叉搜索树，其引入平衡因子（左子支高度与右子支高度之差的绝对值），通过旋转使其尽量保持平衡。</p><h1 id="B树-B-树"><a href="#B树-B-树" class="headerlink" title="B树 &#x2F; B-树"></a>B树 &#x2F; B-树</h1><p>B-树是一种平衡的多路查找树（并非二叉的），注意： <strong>B树就是B-树，”-“是个连字符号，不是减号</strong> 。</p><p>一棵<strong>m阶的非空B-树具有如下性质</strong>：</p><p>① 树中每个结点至多有<em>m</em> 棵子树；</p><p>② 若根结点不是叶子结点，则至少有两棵子树；</p><p>③ 除根之外的所有非叶子结点至少有子树的数量为：<br>$$<br>\left \lceil \frac{m}{2}  \right \rceil<br>$$<br>④ 所有的非叶子结点中包含下列信息数据：(P0, K1, P1, K2, P2, …, Kn, Pn)，其中，Ki（1≤<em>i</em>≤<em>n</em>）为关键字，且<em>Ki</em>＜<em>Ki</em>+1，Pi（1≤<em>i</em>≤<em>n</em>）为指向子树根结点的指针，且指针Pi–1所指子树中所有结点的关键字均小于<em>Ki</em> (<em>i</em>&#x3D;1, 2, …, <em>n</em>)，<em>Pn</em>所指子树中所有结点的关键字均大于<em>Kn</em>，<em>n</em>为关键字的个数；</p><p>其中，<br>$$<br>\left \lceil \frac{m}{2}  \right \rceil-1\le n\le m-1<br>$$<br>⑤ 所有<font color="red">叶子</font>结点都出现在同一层次上，且<font color="red">不包含任何信息</font></p><p>一棵4阶的B-树如下图所示。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240320160236640.png" alt="image-20240320160236640"></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的一种变形，它和B-树的差别在于：</p><p>①有<em>n</em>棵子树的结点中含有<em>n</em>个关键字；</p><p>②所有的<font color="red">叶子</font>结点中<font color="red">包含了全部关键字的信息及指向含这些关键字记录的指针</font>，且叶子结点本身按关键字的大小顺序链接；</p><p>③所有的分支结点可看成是索引部分，<strong>结点中仅含其子树（根结点）中最大（或最小）的关键字</strong>。</p><p>  一棵3阶的B+树如下图所示。通常，在B+树上有两个指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240320162117186.png" alt="image-20240320162117186"></p><div class="note  flat info"><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul></div><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/v2-e5840e6c94fef590c50571cf0610e87a_1440w.webp"></p><p>B*树分配新结点的概率比B+树要低，空间使用率更高。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树（Red Black Tree）是一种自平衡二叉查找树，由 2-3 树（最简单的 B-树）发展而来。</p><p>由于其自平衡的特性，保证了最坏情形下在 O(logn) 时间复杂度内完成查找、增加、删除等操作，性能表现稳定。</p><p>但相比于 AVL 树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。</p><p>在 JDK 中，<code>TreeMap</code>、<code>TreeSet</code> 以及 JDK1.8 的 <code>HashMap</code> 底层都用到了红黑树。</p><h2 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h2><ol><li>红黑树在每个节点上增加一个属性表示节点颜色，每个节点非红即黑。黑色决定平衡，红色不决定平衡。这对应了 2-3 树中一个节点内可以存放 1~2 个节点。</li><li>根节点总是黑色的。</li><li>每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）。通常这条规则也叫不会有连续的红色节点。一个节点最多临时会有 3 个节点，中间是黑色节点，左右是红色节点。</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li></ol><p>正是这些特点才保证了红黑树的平衡，让红黑树的高度不会超过 2log(n+1)。</p><p>红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。</p><h2 id="红黑树结构实现"><a href="#红黑树结构实现" class="headerlink" title="红黑树结构实现"></a>红黑树结构实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVL 树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">// 红黑树所需属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树 &#x2F; 最优二叉树"></a>哈夫曼树 &#x2F; 最优二叉树</h1><p>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。</p><p>构造方法：假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 w_1, w_2, …, w_n，则哈夫曼树的构造规则为：</p><ol><li>将 w_1, w_2, …, w_n 看成是有 n 棵树的森林（每棵树仅有一个结点）。</li><li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和。</li><li>从森林中删除选取的两棵树，并将新树加入森林。</li><li>重复 2、3 步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li></ol><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240320165716813.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/cs-basics/data-structure/tree.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB">树 | JavaGuide</a></p><p><a href="https://interview-points.readthedocs.io/en/latest/data-struct-and-algo.html">数据结构与算法 — 八股文 (interview-points.readthedocs.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/146252512">图解：什么是B树？（心中有 B 树，做人要虚心）一文读懂B-树 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/A_zhangq/article/details/99662693">B树、B-树、B+树、B*树介绍_b减树-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/98021010">一文详解 B-树，B+树，B*树 - 知乎 (zhihu.com)</a></p><p><a href="https://javaguide.cn/cs-basics/data-structure/red-black-tree.html">红黑树 | JavaGuide</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#b-%E6%A0%91-b-%E6%A0%91">MySQL索引详解 | JavaGuide</a></p><p>数据结构课程课件</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分布式】CAP理论 &amp; 分布式锁</title>
      <link href="/p/156c59d0/"/>
      <url>/p/156c59d0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分布式的-CAP-理论？"><a href="#什么是分布式的-CAP-理论？" class="headerlink" title="什么是分布式的 CAP 理论？"></a>什么是分布式的 CAP 理论？</h1><p>分布式的 CAP 理论是指在分布式系统中，<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）<strong>和分区容错性</strong>（Partition Tolerance）这三个指标无法同时满足的问题。具体来说：</p><ul><li><strong>一致性</strong>（Consistency）：指多个副本之间数据保持一致，即在一个副本上的写操作会立即同步到其他所有副本，所有副本的数据都是最新的，保持<strong>强一致性</strong>。</li><li><strong>可用性</strong>（Availability）：指系统在任何时候都能对外提供服务，即<strong>系统随时能够响应用户请求</strong>，不会因为节点故障或其他原因而导致服务中断。</li><li><strong>分区容错性</strong>（Partition Tolerance）：指系统在出现<strong>网络分区</strong>（<strong>节点之间失去联系</strong>）时，仍能够继续工作，保证数据的一致性和可用性。</li></ul><p>CAP 理论指出，<strong>一个分布式系统只能同时满足其中的两个指标，无法同时满足三个</strong>。</p><p>例如，当出现<strong>网络分区</strong>时，如果要<strong>保证一致性</strong>，就必须<strong>停止对外服务</strong>，从而<strong>失去可用性</strong>；如果要<strong>保证可用性</strong>，就必须<strong>放弃一致性</strong>，从而可能<strong>导致不同节点之间数据不一致</strong>。</p><p>因此，在设计分布式系统时，需要根据具体的场景和需求来选择合适的权衡方案，比如选择 <strong>CP（一致性和分区容错性）或者选择 AP（可用性和分区容错性）</strong>。</p><p>需要注意的是，CAP 理论只是一种理论框架，不能直接应用于实际的分布式系统设计。<strong>在实际应用中，还需要考虑系统的具体业务需求、数据访问模式、节点规模和部署环境等因素</strong>，综合权衡之后再选择合适的分布式架构和技术方案。</p><br><h1 id="分布式锁介绍"><a href="#分布式锁介绍" class="headerlink" title="分布式锁介绍"></a>分布式锁介绍</h1><p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p><p><strong>如何才能实现共享资源的互斥访问呢？</strong> 锁是一个比较通用的解决方案，更准确点来说是悲观锁。</p><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p><p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/distributed-lock.png" alt="分布式锁"></p><h2 id="分布式锁应该具备哪些条件？"><a href="#分布式锁应该具备哪些条件？" class="headerlink" title="分布式锁应该具备哪些条件？"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E6%9D%A1%E4%BB%B6">分布式锁应该具备哪些条件？</a></h2><p>一个最基本的分布式锁需要满足：</p><ul><li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。</li><li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li><li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li></ul><p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：</p><ul><li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li><li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li></ul><h2 id="分布式锁的常见实现方式有哪些？"><a href="#分布式锁的常见实现方式有哪些？" class="headerlink" title="分布式锁的常见实现方式有哪些？"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">分布式锁的常见实现方式有哪些？</a></h2><p>常见分布式锁实现方案如下：</p><ul><li>基于关系型数据库比如 MySQL 实现分布式锁。</li><li>基于分布式协调服务 ZooKeeper 实现分布式锁。</li><li>基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。</li></ul><p>关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。</p><p>基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些。</p><br><h1 id="分布式锁常见实现方案总结"><a href="#分布式锁常见实现方案总结" class="headerlink" title="分布式锁常见实现方案总结"></a>分布式锁常见实现方案总结</h1><h2 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h2><h3 id="如何基于-Redis-实现一个最简易的分布式锁？"><a href="#如何基于-Redis-实现一个最简易的分布式锁？" class="headerlink" title="如何基于 Redis 实现一个最简易的分布式锁？"></a>如何基于 Redis 实现一个最简易的分布式锁？</h3><p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p><p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DEL lockKey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p><p>选用 Lua 脚本是为了<strong>保证解锁操作的原子性</strong>。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/distributed-lock-setnx.png" alt="Redis 实现简易分布式锁"></p><p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如<strong>应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问</strong>。</p><h3 id="为什么要给锁设置一个过期时间？"><a href="#为什么要给锁设置一个过期时间？" class="headerlink" title="为什么要给锁设置一个过期时间？"></a>为什么要给锁设置一个过期时间？</h3><p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><strong>lockKey</strong>：加锁的锁名；</li><li><strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li><li><strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li><li><strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul><p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p><p>代码大概如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;REQ12343456788&quot;</span>;<span class="comment">//请求唯一编号</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span>  <span class="number">1000</span>;<span class="comment">// 1000毫秒过期，1000ms内的重复请求会认为重复</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="string">&quot;expireAt@&quot;</span> + expireAt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis key还存在的话要就认为请求是重复的</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">firstSet</span> <span class="operator">=</span> stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(KEY.getBytes(), val.getBytes(), Expiration.milliseconds(expireTime), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isConsiderDup;</span><br><span class="line"><span class="keyword">if</span> (firstSet != <span class="literal">null</span> &amp;&amp; firstSet) &#123;<span class="comment">// 第一次访问</span></span><br><span class="line">    isConsiderDup = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// redis值已存在，认为是重复了</span></span><br><span class="line">    isConsiderDup = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><p>你或许在想：<strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p><h3 id="如何实现锁的优雅续期？"><a href="#如何实现锁的优雅续期？" class="headerlink" title="如何实现锁的优雅续期？"></a>如何实现锁的优雅续期？</h3><p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：**<a href="https://github.com/redisson/redisson">Redisson</a>** 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：<a href="https://redis.io/topics/distlock%E3%80%82">https://redis.io/topics/distlock。</a></p><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/distributed-lock-redisson-renew-expiration.png" alt="Redisson 看门狗自动续期"></p><h3 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h3><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h3 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h3><p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p><p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/redis-master-slave-distributed-lock.png" alt="img"></p><p>针对这个问题，Redis 之父 antirez 设计了 Redlock（红锁） 算法 来解决。</p><p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和<strong>半数以上</strong>的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p><p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p><p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p><p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505097&idx=1&sn=5c03cb769c4458350f4d4a321ad51f5a&source=41#wechat_redirect">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p><p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p><p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个<strong>绝对可靠</strong>（强一致性）的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p><h3 id="Redis-实现分布式锁会有什么问题？"><a href="#Redis-实现分布式锁会有什么问题？" class="headerlink" title="Redis 实现分布式锁会有什么问题？"></a>Redis 实现分布式锁会有什么问题？</h3><div class="note  flat"><p>2024&#x2F;08&#x2F;02 补充</p></div><p>如果使用Redis发布&#x2F;订阅功能来通知其他客户端锁的释放，以保证其他客户端尝试能够正常获取锁，但这可能存在问题。发布&#x2F;订阅机制在Redis中是基于<strong>“尽力而为”</strong>的原则，不保证消息一定会被接收，存在消息丢失的风险。在分布式锁场景下，这种不确定性可能导致锁机制出现错误，比如客户端无法及时获取锁的释放信息，进而无法获取锁。</p><p>总结一下：</p><ol><li>业务未执行完，锁已到期：看门狗&#x2F;过期时间设置合理（使得在大多数情况下任务能够在锁过期之前完成）</li><li>单点故障问题：红锁</li><li>主从问题（因为 Redis 的主从复制过程是异步实现的，如果 Redis 主节点获取到锁之后，还没同步到其他的从节点，此时 Redis 主节点发生宕机了，这个时候新的主节点上没锁的数据，因此其他客户端可以获取锁，就会导致多个应用服务同时获取锁。）</li><li>时钟漂移：可以让所有节点的系统时钟通过 NTP 服务进行同步，减少时钟漂移的影响。</li><li>注意原子性！无论是加锁还是释放锁！</li></ol><h2 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h2><h3 id="ZooKeeper-简介"><a href="#ZooKeeper-简介" class="headerlink" title="ZooKeeper 简介"></a>ZooKeeper 简介</h3><p>ZooKeeper 是一种开源分布式协调服务，用于管理大型分布式系统中的配置、同步以及命名等信息。它通过提供一个简单的原语集合来帮助开发人员设计更加可靠和分布式的系统架构。</p><p>ZooKeeper 的主要作用包括：</p><p> 1）<strong>集中配置管理</strong>：ZooKeeper 可以用来存储配置信息，多个分布式系统实例可以通过 ZooKeeper 来获取和更新配置，从而保证配置信息的一致性。</p><p>2）<strong>命名服务</strong>：通过提供一个集中化的命名服务，ZooKeeper 使得各个分布式系统组件可以方便地找到对方。 </p><p>3）<strong>集群管理</strong>：ZooKeeper 能管理分布式系统中各个节点的状态，比如监控节点的上线、下线，并进行相应的维护。</p><p>4）<strong>分布式锁服务</strong>：用于实现分布式环境下的锁机制，保证多个客户端之间的互斥访问同一资源。</p><p>5）<strong>领导选举</strong>：在分布式系统中，通过 ZooKeeper 来进行节点的领导选举，保证系统的高可用性。</p><h3 id="ZooKeeper-在-CAP-问题上的取舍是什么？"><a href="#ZooKeeper-在-CAP-问题上的取舍是什么？" class="headerlink" title="ZooKeeper 在 CAP 问题上的取舍是什么？"></a>ZooKeeper 在 CAP 问题上的取舍是什么？</h3><p>ZooKeeper 在 CAP 问题上的取舍是偏向于一致性和分区容忍性（CP），而相对牺牲了一些可用性。也就是说，ZooKeeper 更注重数据的一致性，即便在网络分区的情况下，它也会尽量保证数据的一致和可靠。为了实现这一点，ZooKeeper 采取了一些措施来组织和管理分布式数据。</p><p>为什么这么做呢？</p><p>1）领袖选举和数据同步机制</p><p>ZooKeeper 通过选举一个主节点（Leader）来发布和管理变更，这确保了数据的一致性。任何变更必须通过这个 Leader 来操作，其他从节点（Followers）只是用来读取数据。</p><p>2）Quorum 机制</p><p>ZooKeeper 采用 Quorum（法定人数）机制，确保数据在写入时得到大多数节点的确认。这也使得它能够容忍一定的网络分区情况，并确保在多数节点确认的情况下，数据是一致的。</p><p>这样，ZooKeeper 牺牲了一些可用性。例如，在 Leader 挂掉或者无法联系到多数节点时，ZooKeeper 会暂停对外提供服务，直到新的 Leader 选举出来并同步完数据。</p><h3 id="ZooKeeper-和其他分布式锁实现的比较"><a href="#ZooKeeper-和其他分布式锁实现的比较" class="headerlink" title="ZooKeeper 和其他分布式锁实现的比较"></a>ZooKeeper 和其他分布式锁实现的比较</h3><ul><li>与 Redisson（基于 Redis）实现的分布式锁相比，ZooKeeper 不处理基于内存的数据，它的存储更持久化。然而，ZooKeeper 的性能一般不如基于内存存储的服务。</li><li>和 Etcd 比较，两者在分布式锁上的思想非常类似，但 ZooKeeper 使用更为广泛，社区支持也更强。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁介绍 | JavaGuide</a></p><p><a href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html">分布式锁常见实现方案总结 | JavaGuide</a></p><p><a href="https://cloud.tencent.com/developer/article/1798606">想避免重复请求&#x2F;并发请求？这样处理才足够优雅-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP】重传、滑动窗口、流量控制、拥塞控制</title>
      <link href="/p/d4d6f818/"/>
      <url>/p/d4d6f818/</url>
      
        <content type="html"><![CDATA[<p>TCP 为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。</p><p>那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p><p>今天，将重点介绍 TCP 的<strong>重传机制、滑动窗口、流量控制、拥塞控制。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img"></p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p><p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><p>接下来说说常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p><p>那么超时时间应该设置为多少呢？</p><div class="note  flat info"><p>先来了解一下什么是 <code>RTT</code>（Round-Trip Time 往返时延）：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg" alt="RTT"></p><p><code>RTT</code> 指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是包的往返时间。</p></div><p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p><p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="RTO 应略大于 RTT"></p><p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p><p>我们来看看 Linux 是如何计算 <code>RTO</code> 的呢？</p><p>估计往返时间，通常需要采样以下两个：</p><ul><li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li><li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li></ul><p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong></p><p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制"></p><p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack &#x3D; 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p><p>举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p><ul><li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li><li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li></ul><p>可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题。</p><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p><h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p>还有一种实现重传机制的方式叫：<code>SACK</code>（Selective Acknowledgment）， <strong>选择性确认</strong>。</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="选择性确认"></p><p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p><h2 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h2><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><p>下面举例两个栗子，来说明 <code>D-SACK</code> 的作用。</p><p><em>栗子一号：ACK 丢包</em></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="ACK 丢包"></p><ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK &#x3D; 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li><li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li></ul><p><em>栗子二号：网络延时</em></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="网络延时"></p><ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li><li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li><li><strong>所以「接收方」回了一个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li></ul><p>可见，<code>D-SACK</code> 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><div class="note  flat info"><p>引入窗口的原因</p><br><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p><p>这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p></div><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理"></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h2 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h2><p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" alt="img"></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/17.jpg" alt="可用窗口耗尽"></p><p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg" alt="32 ~ 36 字节已确认"></p><h2 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h2><p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p><ul><li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li><li>#3 是未收到数据但可以接收的数据；</li><li>#4 未收到数据并不可以接收的数据；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" alt="接收窗口"></p><p>其中三个接收部分，使用两个指针进行划分:</p><ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><h2 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h2><p>实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p><p>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p><br><p><em>我们先来看看第一个例子。</em></p><p>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。</p><p>考虑以下场景：</p><ul><li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 <code>360</code>；</li><li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img"></p><p>根据上图的流量控制，说明下每个过程：</p><ol><li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li><li>服务端收到 140 字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 260。</li><li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li><li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li><li>客户端发送 80 字节数据后，可用窗口耗尽。</li><li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 0。</li></ol><p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p><br><p><em>我们再来看看第二个例子。</em></p><p>当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img"></p><p>说明下每个过程：</p><ol><li>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</li><li><strong>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100</strong>，最后发送确认信息时，通告窗口大小给对方。</li><li>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</li><li>服务端收到了 180 字节数据时，<strong>发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。</strong></li><li>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</li></ol><p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p><p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p><h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p><div class="note  flat info"><p>潜在危险</p><br><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口关闭潜在的危险"></p><p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p></div><h3 id="TCP-是如何解决窗口关闭时，潜在的死锁现象呢？"><a href="#TCP-是如何解决窗口关闭时，潜在的死锁现象呢？" class="headerlink" title="TCP 是如何解决窗口关闭时，潜在的死锁现象呢？"></a>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</h3><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测"></p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p><h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p><p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p><p>要知道，我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了。</p><p>就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。</p><p>现举个糊涂窗口综合症的栗子，考虑以下场景：</p><p>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p><ul><li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li><li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40 个额外的字节；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="糊涂窗口综合症"></p><p>每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。</p><p>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><p>于是，要解决糊涂窗口综合症，就要同时解决上面两个问题就可以了：</p><ul><li>让接收方不通告小窗口给发送方</li><li>让发送方避免发送小数据</li></ul><h3 id="让接收方不通告小窗口给发送方"><a href="#让接收方不通告小窗口给发送方" class="headerlink" title="让接收方不通告小窗口给发送方"></a>让接收方不通告小窗口给发送方</h3><p>接收方通常的策略如下:</p><p>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。</p><p>等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p><h3 id="让发送方避免发送小数据"><a href="#让发送方避免发送小数据" class="headerlink" title="让发送方避免发送小数据"></a>让发送方避免发送小数据</h3><p>发送方通常的策略如下:</p><p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p><ul><li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li><li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li></ul><p>只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p><p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><p>慢启动算法的变化过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法"></p><p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><div class="note  flat info no-icon"><p>那慢启动涨到什么时候是个头呢？</p></div><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p>拥塞避免算法的变化过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免"></p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h2 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h2><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><div class="note  flat info"><p>怎么查看系统的 cwnd 初始化值？</p><br><p>Linux 针对每一个 TCP 连接的 cwnd 初始化值是 10，也就是 10 个 MSS，我们可以用 ss -nli 命令查看每一个 TCP 连接的 cwnd 初始化值，如下图</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/cwnd.png" alt="img"></p></div><p>拥塞发生算法的变化如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传"></p><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p>快速恢复算法的变化过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复"></p><p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><div class="note  flat info"><p><strong>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</strong></p><p><strong>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</strong></p></div><h1 id="用了-TCP-协议，数据一定不会丢吗？"><a href="#用了-TCP-协议，数据一定不会丢吗？" class="headerlink" title="用了 TCP 协议，数据一定不会丢吗？"></a>用了 TCP 协议，数据一定不会丢吗？</h1><h2 id="数据包的发送流程"><a href="#数据包的发送流程" class="headerlink" title="数据包的发送流程"></a>数据包的发送流程</h2><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/1d0a1d60ca4f720423911cf8f25c4ac3.png" alt="聊天软件三端通信"></p><p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP协议</strong>进行通信。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/7e8bae365b8d27560aac1cd28f501156.png" alt="聊天软件两端通信"></p><p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立TCP连接。</p><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过n多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/28e4d6b004530fbf75fe346d181baa81.png" alt="网络发包收包全景图"></p><h2 id="一定不会丢包吗？"><a href="#一定不会丢包吗？" class="headerlink" title="一定不会丢包吗？"></a>一定不会丢包吗？</h2><p>我们知道TCP位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的HTTP或者各类RPC协议。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c6794dd51c8780f12e4022fc964ebb0a.png" alt="四层网络协议"></p><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层TCP协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层TCP接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里TCP的任务就结束了。</p><p>TCP任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/9286ab84bcaa74576bc11c8e9322fee9.png" alt="使用TCP协议却发生丢包"></p><p><strong>虽然概率很小，但它就是发生了</strong>。</p><h2 id="建立连接时丢包"><a href="#建立连接时丢包" class="headerlink" title="建立连接时丢包"></a>建立连接时丢包</h2><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p><p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p>从现象来看就是连接建立失败。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/591d630098b4fc5316a5005f1e94b844.png" alt="图片"></p><h2 id="流量控制丢包"><a href="#流量控制丢包" class="headerlink" title="流量控制丢包"></a>流量控制丢包</h2><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p><p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p><p>还有其他类型的丢包，这里先不复制（？）了，看原文吧！</p><h2 id="这类丢包问题如何解决？"><a href="#这类丢包问题如何解决？" class="headerlink" title="这类丢包问题如何解决？"></a>这类丢包问题如何解决？</h2><p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p><strong>现在我们重新将服务器加回来。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d53659df39d64db4780d2816bd8314d1.png" alt="聊天软件三端通信"></p><p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>可以看出，<strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul><p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_drop.html#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B">4.21 用了 TCP 协议，数据一定不会丢吗？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】永久短链生成 &amp; 插入视频</title>
      <link href="/p/2574cf15/"/>
      <url>/p/2574cf15/</url>
      
        <content type="html"><![CDATA[<h1 id="永久短链生成"><a href="#永久短链生成" class="headerlink" title="永久短链生成"></a>永久短链生成</h1><p>每次从博客分享文章给别人都很苦恼，Hexo 默认生成的链接太长了，而且一旦文章名字改变，链接也跟着改变。有没有什么方法让地址尽量短小精悍，同时永久化呢？</p><p>感谢 <a href="https://github.com/rozbo/hexo-abbrlink">rozbo&#x2F;hexo-abbrlink</a>，完美解决此痛点。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code> 配置文件写入：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span> <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改 permalink 值</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">p/:abbrlink/</span></span><br></pre></td></tr></table></figure><p><font color="red">记得把原来的<code>permalink:</code>删除&#x2F;注释掉！！</font></p><p>然后记得clean一下再生成&amp;部署！</p><h2 id="关于插件设置"><a href="#关于插件设置" class="headerlink" title="关于插件设置"></a>关于插件设置</h2><p>Abbrlink插件拥有两项设置选项:</p><ul><li><code>alg</code>: 算法(目前支持<code>crc16</code>和<code>crc32</code>算法，默认值是<code>crc16</code>)</li><li><code>rep</code>: 形式(生成的链接可以是十六进制格式也可以是十进制格式，默认值是十进制格式)</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://test.com/posts/55c6.html</span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://test.com/posts/43212.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://test.com/posts/6ec16a2c.html</span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://test.com/posts/1521457752.html</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://upload-images.jianshu.io/upload_images/1099569-57c5ad550fee60fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p><p>这部分内容也补在我这里的初始配置文章里了！</p><h1 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h1><p>其实很简单，不用dplayer插件，使用HTML本身的video标签就可以实现了~（主要是因为dplayer在这里的插件似乎有问题，无法播放来自OSS的视频（正常网页上使用dplayer是可以播放的））</p><p>OSS的配置和使用这里就略过了~</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;true&quot;</span> <span class="attr">controlslist</span>=<span class="string">&quot;nodownload&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;true&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">position</span>= <span class="string">&quot;absolute&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;封面的URL&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">&quot;mp4&quot;</span> <span class="attr">src</span>=<span class="string">&quot;视频的URL&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在你需要插入视频的地方插入这段HTML代码即可~</p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>autoplay</td><td>自动播放。如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>controlslist</td><td>当浏览器显示视频底部的播放控制面板（例如，指定了 <code>controls</code> 属性）时，<a href="https://wicg.github.io/controls-list/explainer.html"><code>controlslist</code></a> 属性会帮助浏览器选择在控制面板上显示哪些控件。允许的值有 <code>nodownload</code>、<code>nofullscreen</code> 和 <code>noremoteplayback</code>。如果要禁用画中画模式（和控件），请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#disablepictureinpicture">disablePictureInPicture</a> 属性。</td></tr><tr><td>crossorigin</td><td>该枚举属性指明是否使用 CORS（跨域资源共享）来获取相关视频。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image">允许 CORS 的资源</a> 可在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">&#96;&#96;</a> 元素中被重用，而不会被<em>污染</em>。允许的值如下：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#anonymous">anonymous</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#use-credentials">use-credentials</a></td></tr><tr><td>height</td><td>设置视频播放器的高度。</td></tr><tr><td>width</td><td>设置视频播放器的宽度。</td></tr><tr><td>loop</td><td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td>muted</td><td>如果出现该属性，视频的音频输出为静音。</td></tr><tr><td>poster</td><td>规定视频正在下载时显示的图像，直到用户点击播放按钮。</td></tr><tr><td>preload</td><td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td>src</td><td>要播放的视频的 URL。</td></tr></tbody></table><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/805bd0b65d98">推荐两个 Hexo 插件：短地址与封面模式 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/169492685">SEO优化：Hexo-abbrlink插件生成永久固定链接 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/psyuhen/article/details/119783980">html5视频播放,实现防止下载（一）_前端如何禁止浏览器下载视频-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42580876/article/details/109732326">video标签设置封面图、控件的显隐_video 封面-CSDN博客</a></p><p><a href="https://ultrafish.io/post/post-video-with-oss/#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6URL%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%BA%94%E4%BB%A3%E7%A0%81%E5%88%B0%E6%96%87%E7%AB%A0">在Hexo中用Markdown通过阿里云OSS添加视频文件 - UltraFish</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 短链 </tag>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻唱·无参配布】11（Cover：G.E.M.邓紫棋）【ROSE AI】【Synthesizer V Cover】</title>
      <link href="/p/a0efc292/"/>
      <url>/p/a0efc292/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/11_cover.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%E3%80%90%E5%A4%A2%E3%83%8E%E7%B5%90%E5%94%B1%20ROSE%E3%80%9111%EF%BC%88Cover%EF%BC%9AG.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%EF%BC%89.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《11》</p><p>翻唱：夢ノ結唱 ROSE AI</p><p>和声：夢ノ結唱 ROSE AI、Mai</p><p>扒谱：Rean__</p><p>调教：Rean__</p><p>混音：Rean__</p><br><h2 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h2><p><a href="https://pan.baidu.com/s/1K12h_px08Ev1Upg1kPcczw?pwd=qnqu">https://pan.baidu.com/s/1K12h_px08Ev1Upg1kPcczw?pwd=qnqu</a></p><p>BPM：74（变速）</p><p>已灌词，和声可能有错误，使用请注意！</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 队长&#x2F;黄礼格</p><p><strong>作曲 : 队长&#x2F;黄礼格</strong></p><p>原词曲 : 队长&#x2F;黄礼格</p><p>制作人 : G.E.M.邓紫棋&#x2F;T-Ma</p><p>编曲 : T-Ma</p><p>改编词曲 : G.E.M.邓紫棋</p><p>混音：Matthew Sim</p><p>母带：Matthew Sim</p><p>OP：队长、黄礼格</p><p>SP：索尼音乐版权代理（北京）有限公司</p><br><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>就把我爱意都掩埋</p><p>但你能清楚的明白</p><p>靠近我 然后别离开</p><p>可是难过的却不是回忆</p><p>因为回忆里 哭泣的你</p> <br><p>Cause you know</p><p>爱意就像大雨落下怎么能让人不牵挂</p><p>过得好吗想说的话你能听到吗</p><p>Oh 没能陪你到最后 别再叹息皱眉头</p><p>怎么能忘掉你所有</p> <br><p>寂寞的夜 每一个夜 你总在眼前</p><p>度过的年 错过的月 我都想纪念</p><p>好久不见 我有多恨我不在你的身边</p><p>能不能 能不能 让眼泪留在昨天</p><p>能不能 别把我丢在雨天</p><p>我不愿不在你的身边</p> <br><p>一个人的凌晨时分</p><p>谁没有个思念的人</p><p>如果爱能够逆时针</p><p>Cuz I’m mad for you, sad for you, I long for you</p> <br><p>Cause you know</p><p>爱意就像大雨落下怎么能让人不牵挂</p><p>过得好吗想说的话你能听到吗</p><p>Oh 没能陪你到最后 别再叹息皱眉头</p><p>怎么能忘掉你所有</p> <br><p>多想让大雨冲掉思念</p><p>让回忆不再闪现</p><p>已经多少日夜 你总会突然浮现眼前</p><p>能否让眼泪留在昨天</p><p>Cuz I’m mad for you, sad for you, I long for you</p> <br><p>Cause you know</p><p>爱意就像大雨落下怎么能让人不牵挂</p><p>过得好吗想说的话你能听到吗</p><p>Oh 没能陪你到最后 别再叹息皱眉头</p><p>怎么能忘掉你所有</p> <br><p>没能陪你到最后</p><p>没能陪你到最后</p><p>因为你已不在 你已不在身边</p><p>我想陪你到最后</p><p>我想陪你到最后</p><p>可惜你已不在 你已不在身边</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> G.E.M.邓紫棋 </tag>
            
            <tag> T.I.M.E. </tag>
            
            <tag> 时光音乐会·老友记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【补档】【永夜Minus】最长的旅途 (live)（Cover：单依纯）【Synthesizer V Cover】</title>
      <link href="/p/ec2ecf28/"/>
      <url>/p/ec2ecf28/</url>
      
        <content type="html"><![CDATA[<p><video id="video" controls="" controlslist="nodownload" allowfullscreen="true" position= "absolute" width="100%" poster="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%9C%80%E9%95%BF%E7%9A%84%E6%97%85%E9%80%94.png">      <source id="mp4" src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/video/%E3%80%90%E6%B0%B8%E5%A4%9CMinus%E3%80%91%E6%9C%80%E9%95%BF%E7%9A%84%E6%97%85%E9%80%94%20%28live%29.mov" type="video/mp4" >      </video></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《最长的旅途》</p><p>翻唱：永夜Minus</p><p>调教：Rean__</p><br><h2 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h2><p>作词 : 龚淑均<br>作曲 : 文颖秋<br>原唱 : 李琦<br>音乐总监：刘卓@维伴音乐<br>制作人：刘卓@维伴音乐<br>改编编曲：唐森@TalentUnion<br>键盘：孙莉@维伴音乐&#x2F;孙维峰@维伴音乐<br>吉他：董珂铭@维伴音乐&#x2F;郎梓朔@维伴音乐<br>鼓：邓华龙@维伴音乐<br>打击乐：黑哥@维伴音乐<br>贝斯：娄弘荻@维伴音乐<br>弦乐现场：靳海音®️弦乐四重奏&#x2F;小提琴一：高源&#x2F;小提琴二：雷宸&#x2F;中提琴：李鹏远&#x2F;大提琴：梁松<br>弦乐录音：国际首席爱乐乐团&#x2F;监制：李朋<br>合声编写：石行@维伴音乐<br>合声：石行@维伴音乐&#x2F;马思莹@维伴音乐&#x2F;邢晏侨@维伴音乐<br>PGM：孙维峰@维伴音乐<br>人声编辑：石行@维伴音乐<br>混音：黄可爱@维伴音乐<br>音乐统筹：郎梓朔@维伴音乐<br>制作团队：北京维伴文化传媒有限公司<br>SP：天津唐人影视股份有限公司 、北京千亩稻田文化传播有限公司</p>]]></content>
      
      
      <categories>
          
          <category> VOCALOID·UTAU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SynthV </tag>
            
            <tag> 永夜Minus </tag>
            
            <tag> 剧好听的歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TCP】三次握手与四次挥手</title>
      <link href="/p/85f11265/"/>
      <url>/p/85f11265/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h1><h2 id="TCP头"><a href="#TCP头" class="headerlink" title="TCP头"></a>TCP头</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png" alt="TCP 头格式"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><h2 id="为什么需要TCP协议？TCP工作在哪一层？"><a href="#为什么需要TCP协议？TCP工作在哪一层？" class="headerlink" title="为什么需要TCP协议？TCP工作在哪一层？"></a>为什么需要TCP协议？TCP工作在哪一层？</h2><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h2 id="什么是TCP？"><a href="#什么是TCP？" class="headerlink" title="什么是TCP？"></a>什么是TCP？</h2><p>TCP 是<font color="red"><strong>面向连接的、可靠的、基于字节流</strong></font>的传输层通信协议。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230424714.png" alt="img"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h2 id="什么是TCP连接？"><a href="#什么是TCP连接？" class="headerlink" title="什么是TCP连接？"></a>什么是TCP连接？</h2><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230428466.png" alt="img"></p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h2 id="TCP和UDP的区别是？分别的应用场景是？"><a href="#TCP和UDP的区别是？分别的应用场景是？" class="headerlink" title="TCP和UDP的区别是？分别的应用场景是？"></a>TCP和UDP的区别是？分别的应用场景是？</h2><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简单，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png" alt="UDP 头部格式"></p><ul><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><h2 id="TCP和UDP可以使用同一个端口吗？"><a href="#TCP和UDP可以使用同一个端口吗？" class="headerlink" title="TCP和UDP可以使用同一个端口吗？"></a>TCP和UDP可以使用同一个端口吗？</h2><p>答案：<strong>可以的</strong>。</p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img"></p><p>因此，TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p><p>关于端口的知识点，还是挺多可以讲的，比如还可以牵扯到这几个问题：</p><ul><li>多个 TCP 服务进程可以同时绑定同一个端口吗？</li><li>重启 TCP 服务进程时，为什么会出现“Address in use”的报错信息？又该怎么避免？</li><li>客户端的端口可以重复使用吗？</li><li>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</li></ul><p>上面这些问题，可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/port.html">TCP 和 UDP 可以使用同一个端口吗？</a></p><h1 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h1><h2 id="TCP三次握手过程是怎样的？"><a href="#TCP三次握手过程是怎样的？" class="headerlink" title="TCP三次握手过程是怎样的？"></a>TCP三次握手过程是怎样的？</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><h2 id="为什么是三次握手？而不是两次-四次？"><a href="#为什么是三次握手？而不是两次-四次？" class="headerlink" title="为什么是三次握手？而不是两次&#x2F;四次？"></a>为什么是三次握手？而不是两次&#x2F;四次？</h2><p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>所以，重要的是<strong>为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。</strong></p><p>接下来，以三个方面分析三次握手的原因：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h3 id="原因一：避免历史连接"><a href="#原因一：避免历史连接" class="headerlink" title="原因一：避免历史连接"></a>原因一：避免历史连接</h3><p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p><p>看看三次握手是如何阻止历史连接的：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png" alt="三次握手避免历史连接"></p><p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li><li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li><li>服务端收到 RST 报文后，就会释放连接。</li><li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li></ul><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><div class="note  flat info"><p>如果服务端在<strong>收到 RST 报文之前</strong>，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</p><p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p><p>然后这时再收到「新 SYN 报文」时，就会回 <a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack (opens new window)</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p></div><p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p>我先直接说结论，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p><p>你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接"></p><p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p><p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p><div class="note  flat info"><p>Q：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</p><p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" alt="img"></p><p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p></div><h3 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a>原因二：同步双方初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png" alt="四次握手与三次握手"></p><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p><p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><h3 id="原因三：避免资源浪费"><a href="#原因三：避免资源浪费" class="headerlink" title="原因三：避免资源浪费"></a>原因三：避免资源浪费</h3><p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p><p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png" alt="两次握手会造成资源浪费"></p><p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h2 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h2><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><p>接下来，详细说说第一点。</p><p>假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png" alt="img"></p><p>过程如下：</p><ul><li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。</li><li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li><li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li></ul><p>可以看到，<strong>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题</strong>。</p><p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，比如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E4%B8%8D%E7%9B%B8%E5%90%8C.png" alt="img"></p><p>相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。</p><p>所以，每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了（因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文，详细看篇：<a href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">TCP 是如何避免历史报文的？ (opens new window)</a>）。</p><h2 id="初始序列号-ISN-是如何产生的？"><a href="#初始序列号-ISN-是如何产生的？" class="headerlink" title="初始序列号 ISN 是如何产生的？"></a>初始序列号 ISN 是如何产生的？</h2><p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><h2 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png" alt="MTU 与 MSS"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p><p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p><p>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p><p>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。</p><p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p><p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就<strong>不用 IP 分片</strong>了。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png" alt="握手阶段协商 MSS"></p><p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p><h2 id="SYN报文什么情况下会被丢弃？"><a href="#SYN报文什么情况下会被丢弃？" class="headerlink" title="SYN报文什么情况下会被丢弃？"></a>SYN报文什么情况下会被丢弃？</h2><p>我就给出我遇到过 SYN 报文被丢弃的两种场景：</p><ul><li>开启 tcp_tw_recycle 参数（linux），并且在 NAT 环境下，造成 SYN 报文被丢弃</li><li>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</li></ul><h3 id="tcp-tw-recycle-NAT"><a href="#tcp-tw-recycle-NAT" class="headerlink" title="tcp_tw_recycle + NAT"></a>tcp_tw_recycle + NAT</h3><p>Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：</p><ul><li>net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，<strong>如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</strong>所以该选项只适用于连接发起方。</li><li>net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；</li></ul><p>要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps&#x3D;1（默认即为 1)）。</p><p>但是<font color=#304ffe><strong>tcp_tw_recycle 在使用了 NAT 的网络下是不安全的！</strong></font></p><p>对于服务器来说，如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」。</p><div class="note  flat info"><p>什么是 per-host 的 PAWS 机制？</p><br><p>tcp_timestamps 选项开启之后， PAWS 机制会自动开启，它的作用是防止 TCP 包中的序列号发生绕回。</p><p>正常来说每个 TCP 包都会有自己唯一的 SEQ，出现 TCP 数据包重传的时候会复用 SEQ 号，这样接收方能通过 SEQ 号来判断数据包的唯一性，也能在重复收到某个数据包的时候判断数据是不是重传的。<strong>但是 TCP 这个 SEQ 号是有限的，一共 32 bit，SEQ 开始是递增，溢出之后从 0 开始再次依次递增</strong>。</p><p>所以当 SEQ 号出现溢出后单纯通过 SEQ 号无法标识数据包的唯一性，某个数据包延迟或因重发而延迟时可能导致连接传递的数据被破坏。</p><p>PAWS 就是为了避免这个问题而产生的，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p><br><p><strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查。</p><p>但是如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。</p><p>Per-host PAWS 机制利用TCP option里的 timestamp 字段的增长来判断串扰数据，而 timestamp 是根据客户端各自的 CPU tick 得出的值。</p></div><p>当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，<strong>客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包</strong>。</p><p>因此，tcp_tw_recycle 在使用了 NAT 的网络下是存在问题的，如果它是对 TCP 四元组做 PAWS 检查，而不是对「相同的 IP 做 PAWS 检查」，那么就不会存在这个问题了。</p><p>网上很多博客都说开启 tcp_tw_recycle 参数来优化 TCP，我信你个鬼，糟老头坏的很！</p><p>tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。</p><h3 id="队列满了"><a href="#队列满了" class="headerlink" title="队列满了"></a>队列满了</h3><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accepet 队列；</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><div class="tabs" id="syn"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#syn-1">半连接队列满了</button></li><li class="tab"><button type="button" data-href="#syn-2">全连接队列满了</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="syn-1"><p>当服务器造成syn攻击，就有可能导致 <strong>TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃</strong>。</p><p>但是，<strong>如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包</strong>。</p><p>syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/58e01036d1febd0103dd0ec4d5acff05.png" alt="img"></p><p>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><p>那么在应对 SYN 攻击时，只需要设置为 1 即可</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="syn-2"><p><strong>在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d1538f8d3b50da26039bc6b171a13ad1.png" alt="img"></p><p>要解决这个问题，我们可以：</p><ul><li>调大 accpet 队列的最大长度，调大的方式是通过<strong>调大 backlog 以及 somaxconn 参数。</strong></li><li>检查系统或者代码为什么调用 accept() 不及时；</li></ul><p>关于 SYN 队列和 accpet 队列，我之前写过一篇很详细的文章：<a href="https://mp.weixin.qq.com/s/2qN0ulyBtO2I67NB_RnJbg">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h2 id="第一-二-三次握手丢失了，会发生什么？"><a href="#第一-二-三次握手丢失了，会发生什么？" class="headerlink" title="第一&#x2F;二&#x2F;三次握手丢失了，会发生什么？"></a>第一&#x2F;二&#x2F;三次握手丢失了，会发生什么？</h2><p>会超时重传 SYN&#x2F;SYN-ACK 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>达到最大重传次数后，再等2倍时间，如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接，服务端同理。</p><p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><h2 id="建立连接后，再收到SYN报文会怎样？"><a href="#建立连接后，再收到SYN报文会怎样？" class="headerlink" title="建立连接后，再收到SYN报文会怎样？"></a>建立连接后，再收到SYN报文会怎样？</h2><p>大概意思是，一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p><h3 id="客户端的-SYN-报文里的端口号不同"><a href="#客户端的-SYN-报文里的端口号不同" class="headerlink" title="客户端的 SYN 报文里的端口号不同"></a><strong>客户端的 SYN 报文里的端口号不同</strong></h3><p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p><p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p><p>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。</p><p>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p><h3 id="客户端的-SYN-报文里的端口号相同"><a href="#客户端的-SYN-报文里的端口号相同" class="headerlink" title="客户端的 SYN 报文里的端口号相同"></a><strong>客户端的 SYN 报文里的端口号相同</strong></h3><p>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样，也就是处于 Established 状态的服务端收到了这个 SYN 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/est_syn.png" alt="img"></p><p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p><p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p><h2 id="服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="服务端没有 listen，客户端发起连接建立，会发生什么？"></a>服务端没有 listen，客户端发起连接建立，会发生什么？</h2><h3 id="做个实验"><a href="#做个实验" class="headerlink" title="做个实验"></a>做个实验</h3><p>这个问题，自己做个实验就知道了。</p><p>我用下面这个程序作为例子，绑定了 IP 地址 + 端口，而没有调用 listen。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******服务器程序  TCPServer.c ************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器端创建 tcp socket 描述符 */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Socket error:%s\n\a&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器端填充 sockaddr 结构 */</span></span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 绑定 ip + 端口 */</span></span><br><span class="line">    ret = bind(sockfd, (<span class="keyword">struct</span> sockaddr *)(&amp;server_addr), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Bind error:%s\n\a&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//没有调用 listen</span></span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我用浏览器访问这个地址：<a href="http://121.43.173.240:8888/">http://121.43.173.240:8888/</a></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/5bdb5443db5b97ff724ab94e014af6a5.png" alt="图片"></p><p>报错连接服务器失败。</p><p>同时，我也用抓包工具，抓了这个过程。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/a77921ffafbbff86d07983ca0db3e6e0.png" alt="图片"></p><p>可以看到，客户端对服务端发起 SYN 报文后，服务端回了 RST 报文。</p><p>所以，这个问题就有了答案，<strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><h3 id="没有-listen，可以建立-TCP-连接吗？"><a href="#没有-listen，可以建立-TCP-连接吗？" class="headerlink" title="没有 listen，可以建立 TCP 连接吗？"></a>没有 listen，可以建立 TCP 连接吗？</h3><p><strong>是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接</strong>。</p><p>内核还有个全局 hash 表，可以用于存放 sock 连接的信息。</p><p><strong>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接</strong>。</p><p>TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p><h2 id="没有-accept，能建立TCP连接吗？"><a href="#没有-accept，能建立TCP连接吗？" class="headerlink" title="没有 accept，能建立TCP连接吗？"></a>没有 accept，能建立TCP连接吗？</h2><p><strong>一般正常的情况</strong>下，如果启动服务器，会发现最后程序会<strong>阻塞在</strong><code>accept()</code>里。</p><p>这个问题其实只要在执行<code>accept()</code> 之前执行一个 <code>sleep(20)</code>，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/2cfc1d028f3e37f10c2f81375ddb998a.png" alt="不执行accept时抓包结果"></p><p>从抓包结果看来，<strong>就算不执行accept()方法，三次握手照常进行，并顺利建立连接。</strong></p><p>更骚气的是，<strong>在服务端执行accept()前，如果客户端发送消息给服务端，服务端是能够正常回复ack确认包的。</strong></p><h3 id="回顾两个队列"><a href="#回顾两个队列" class="headerlink" title="回顾两个队列"></a>回顾两个队列</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/36242c85809865fcd2da48594de15ebb.png" alt="半连接队列和全连接队列"></p><ul><li><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</li><li><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></li></ul><p>虽然都叫<strong>队列</strong>，但其实<strong>全连接队列（icsk_accept_queue）是个链表</strong>，而<strong>半连接队列（syn_table）是个哈希表</strong>。</p><p>看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要<code>accept()</code>参与， <strong>执行accept()只是为了从全连接队列里取出一条连接。</strong></p><h3 id="为什么半连接队列要设计成哈希表？"><a href="#为什么半连接队列要设计成哈希表？" class="headerlink" title="为什么半连接队列要设计成哈希表？"></a>为什么半连接队列要设计成哈希表？</h3><p>先对比下<strong>全连接队列</strong>，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为<code>O(1)</code>。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是<strong>不完整的连接</strong>，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到<code>O(1)</code>了。</p><p>因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><h3 id="全连接队列满了会怎么样？"><a href="#全连接队列满了会怎么样？" class="headerlink" title="全连接队列满了会怎么样？"></a>全连接队列满了会怎么样？</h3><p>如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。</p><p>但除了丢弃之外，还有一些附带行为，这会受 <code>tcp_abort_on_overflow</code> 参数的影响。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_abort_on_overflow</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li><code>tcp_abort_on_overflow</code>设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的<strong>半连接队列里的连接</strong>给删掉。</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/874f2fb7108020fd4dcfa021f377ec66.png" alt="tcp_abort_on_overflow为0"></p><ul><li><code>tcp_abort_on_overflow</code>设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。</li></ul><p>这个现象是不是很熟悉，服务端<strong>端口未监听</strong>时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实无法区分到底是<strong>端口未监听</strong>，还是<strong>全连接队列满了</strong>。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6a01c5df74748870a69921da89825d9c.png" alt="tcp_abort_on_overflow为1"></p><h3 id="半连接队列满了会怎么样？"><a href="#半连接队列满了会怎么样？" class="headerlink" title="半连接队列满了会怎么样？"></a>半连接队列满了会怎么样？</h3><p><strong>一般是丢弃</strong>，但这个行为可以通过 <code>tcp_syncookies</code> 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。</p><p>首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了<strong>SYN Flood攻击</strong>。</p><p>所谓<strong>SYN Flood攻击</strong>，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。</p><p>那这种情况怎么处理？有没有一种方法可以<strong>绕过半连接队列</strong>？</p><p>有，上面提到的<code>tcp_syncookies</code>派上用场了。</p><p>当它被设置为1的时候，客户端发来<strong>第一次握手</strong>SYN时，服务端<strong>不会将其放入半连接队列中</strong>，而是直接生成一个<code>cookies</code>，这个<code>cookies</code>会跟着<strong>第二次握手</strong>，发回客户端。客户端在发<strong>第三次握手</strong>的时候带上这个<code>cookies</code>，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d696b8b345526533bde8fa990e205c32.png" alt="tcp_syncookies=1"></p><h1 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h1><h2 id="TCP四次挥手过程是怎样的？"><a href="#TCP四次挥手过程是怎样的？" class="headerlink" title="TCP四次挥手过程是怎样的？"></a>TCP四次挥手过程是怎样的？</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h3 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h3><p>关闭连接的函数有两种函数：</p><ul><li>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li></ul><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><ul><li>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</li><li>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</li></ul><p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</p><h2 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h2><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p><p>但是<strong>在特定情况下，四次挥手是可以变成三次挥手的</strong>。</p><h2 id="TCP-四次挥手，可以变成三次吗？"><a href="#TCP-四次挥手，可以变成三次吗？" class="headerlink" title="TCP 四次挥手，可以变成三次吗？"></a>TCP 四次挥手，可以变成三次吗？</h2><p>在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次，如下图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/361207c2e5c34bec8708b79990ba7e99.png" alt="在这里插入图片描述"></p><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，<strong>「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d7b349efa4f94453943b433b704a4ca8.png" alt="在这里插入图片描述"></p><p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p><div class="note  flat info"><p>什么是 TCP 延迟确认机制？</p><br><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/33f3d2d54a924b0a80f565038327e0e4.png" alt="img"></p><ul><li>最大延迟确认时间是 200 ms （1000&#x2F;5）</li><li>最短延迟确认时间是 40 ms （1000&#x2F;25）</li></ul></div><h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><h2 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h2><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><h3 id="原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收"><a href="#原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收" class="headerlink" title="原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收"></a>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</h3><p>为了能更好的理解这个原因，我们先来了解序列号（SEQ）和初始序列号（ISN）。</p><ul><li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li><li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li></ul><p>给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c9ea9b844e87bcd4acd3e320403ecab3.png" alt="TCP 抓包图"></p><p>通过前面我们知道，<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" alt="TIME-WAIT 时间过短，收到旧连接的数据报文"></p><p>如上图：</p><ul><li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li></ul><p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h3 id="原因二：保证「被动关闭连接」的一方，能被正确的关闭"><a href="#原因二：保证「被动关闭连接」的一方，能被正确的关闭" class="headerlink" title="原因二：保证「被动关闭连接」的一方，能被正确的关闭"></a>原因二：保证「被动关闭连接」的一方，能被正确的关闭</h3><p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p><p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png" alt="TIME-WAIT 时间过短，没有确保连接正常关闭"></p><p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p><p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" alt="TIME-WAIT 时间正常，确保了连接正常关闭"></p><p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p><h2 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h2><p>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p><ul><li>第一个场景：HTTP 没有使用长连接</li><li>第二个场景：HTTP 长连接超时</li><li>第三个场景：HTTP 长连接的请求数量达到上限</li></ul><h3 id="第一个场景：HTTP-没有使用长连接"><a href="#第一个场景：HTTP-没有使用长连接" class="headerlink" title="第一个场景：HTTP 没有使用长连接"></a>第一个场景：HTTP 没有使用长连接</h3><p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p><p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p><p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p><p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p><p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p><h3 id="第二个场景：HTTP-长连接超时"><a href="#第二个场景：HTTP-长连接超时" class="headerlink" title="第二个场景：HTTP 长连接超时"></a>第二个场景：HTTP 长连接超时</h3><p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/7e995ecb2e42941342f97256707496c9.png" alt="HTTP 长连接超时"></p><p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p><p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p><h3 id="第三个场景：HTTP-长连接的请求数量达到上限"><a href="#第三个场景：HTTP-长连接的请求数量达到上限" class="headerlink" title="第三个场景：HTTP 长连接的请求数量达到上限"></a>第三个场景：HTTP 长连接的请求数量达到上限</h3><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p><p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p><p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p><p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p><h2 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h2><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p><p>我们先来分析一个普通的 TCP 服务端的流程：</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p>可能导致服务端没有调用 close 函数的原因，如下。</p><p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p><p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p><p><strong>第二个原因</strong>： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p><p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p><p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p><p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析(opens new window)</a></p><p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p><p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h2 id="四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="四次挥手中收到乱序的 FIN 包会如何处理？"></a>四次挥手中收到乱序的 FIN 包会如何处理？</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态？</p><p>结论：</p><p><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p><p><strong>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-20230309230147654.png" alt="img"></p><h2 id="在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/74b53919396dcda634cfd5b5795cbf16.png" alt="图片"></p><p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong>。</p><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul><p>如果双方都没有开启 TCP 时间戳机制，则只比较序列号。</p><h3 id="收到合法-SYN"><a href="#收到合法-SYN" class="headerlink" title="收到合法 SYN"></a>收到合法 SYN</h3><p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p><p>用下图作为例子，双方都启用了 TCP 时间戳机制，TSval 是发送报文时的时间戳：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/39d0d04adf72fe3d37623acff9ae2507.png" alt="图片"></p><h3 id="收到非法-SYN"><a href="#收到非法-SYN" class="headerlink" title="收到非法 SYN"></a>收到非法 SYN</h3><p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p><h3 id="收到-RST"><a href="#收到-RST" class="headerlink" title="收到 RST"></a>收到 RST</h3><p>处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p><p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p><ul><li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li><li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li></ul><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li><li>第三种，是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><h2 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><h2 id="如果没有开启保活-没有数据交互，一端进程崩溃和断电有什么区别？"><a href="#如果没有开启保活-没有数据交互，一端进程崩溃和断电有什么区别？" class="headerlink" title="如果没有开启保活&amp;没有数据交互，一端进程崩溃和断电有什么区别？"></a>如果没有开启保活&amp;没有数据交互，一端进程崩溃和断电有什么区别？</h2><p>这个问题有几个关键词：</p><ul><li>没有开启 keepalive；</li><li>一直没有数据交互；</li><li>进程崩溃；</li><li>主机崩溃；</li></ul><h3 id="主机崩溃"><a href="#主机崩溃" class="headerlink" title="主机崩溃"></a>主机崩溃</h3><p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p><p>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p><h3 id="进程崩溃"><a href="#进程崩溃" class="headerlink" title="进程崩溃"></a>进程崩溃</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p><p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><h2 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p><strong>拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？</strong></p><p>实际上，TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p><p>我在我的电脑上做了个小实验，我用 ssh 终端连接了我的云服务器，然后我通过断开 wifi 的方式来模拟拔掉网线的场景，此时查看 TCP 连接的状态没有发生变化，还是处于 ESTABLISHED 状态。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/fff358407ee92aeea1e17386191a5d18.png" alt="图片"></p><p>通过上面这个实验结果，我们知道了，拔掉网线这个动作并不会影响 TCP 连接的状态。</p><p>接下来，要看拔掉网线后，双方做了什么动作。</p><p>所以， 针对这个问题，要分场景来讨论：</p><ul><li>拔掉网线后，有数据传输；</li><li>拔掉网线后，没有数据传输；</li></ul><h3 id="拔掉网线后，有数据传输"><a href="#拔掉网线后，有数据传输" class="headerlink" title="拔掉网线后，有数据传输"></a>拔掉网线后，有数据传输</h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。</p><p>此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生。</p><p>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p><p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</p><p>此时，客户端和服务端的 TCP 连接都已经断开了。</p><h3 id="拔掉网线后，没有数据传输"><a href="#拔掉网线后，没有数据传输" class="headerlink" title="拔掉网线后，没有数据传输"></a>拔掉网线后，没有数据传输</h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html">4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/syn_drop.html">4.8 SYN 报文什么时候情况下会被丢弃？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/challenge_ack.html">4.9 已建立连接的TCP，收到SYN会发生什么？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/out_of_order_fin.html#tcp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">4.10 四次挥手中收到乱序的 FIN 包会如何处理？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html">4.11 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html">4.12 TCP 连接，一端断电和进程崩溃有什么区别？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E-%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93">4.13 拔掉网线后， 原本的 TCP 连接还存在吗？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_three_fin.html#%E7%B2%97%E6%9A%B4%E5%85%B3%E9%97%AD-vs-%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD">4.22 TCP 四次挥手，可以变成三次吗？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_no_listen.html#%E5%81%9A%E4%B8%AA%E5%AE%9E%E9%AA%8C">4.19 服务端没有 listen，客户端发起连接建立，会发生什么？ | 小林coding (xiaolincoding.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】25. K 个一组翻转链表 - 个人题解记录</title>
      <link href="/p/db95e6f5/"/>
      <url>/p/db95e6f5/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>难度：<font color="red">困难</font></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为个人不习惯用递归，所以这里先确定循环次数、循环停止条件。</p><p>外层循环次数：round&#x3D;size&#x2F;k;</p><p>好吧循环停止条件还得后面展开了才好确定（</p><p>易知（？）一组翻转后，原本最前的节点（翻转后最后的节点）的next将指向下一组的最前节点，原本最后的节点（翻转后最前的节点）作为前一组最后节点的next节点，中间则正常翻转。</p><p>所以这里先确定一个start、end节点，分别是这组的第一个节点和下一组的第一个节点（作为循环停止条件）</p><p>然后一个常用的双指针prev、cur，当cur&#x3D;&#x3D;end时组内循环停止</p><p>最后整一个prevStart，一开始作为虚拟头，后面指向翻转后上一组最后的节点。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/1710252583249.jpg"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> size=getSize(head);</span><br><span class="line">        <span class="type">int</span> round=size/k;</span><br><span class="line">        ListNode newHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode start=head;</span><br><span class="line">        ListNode end=<span class="literal">null</span>;</span><br><span class="line">        ListNode prevStart=newHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;round;i++)&#123;</span><br><span class="line">            ListNode tmp=start;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                tmp=tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            end=tmp;</span><br><span class="line"></span><br><span class="line">            ListNode prev=start;</span><br><span class="line">            ListNode cur=prev.next;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            start.next=end;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(cur!=end)&#123;</span><br><span class="line">                ListNode tmpNode=cur.next;</span><br><span class="line">                cur.next=prev;</span><br><span class="line">                prev=cur;</span><br><span class="line">                cur=tmpNode;</span><br><span class="line">            &#125;</span><br><span class="line">            prevStart.next=prev;</span><br><span class="line">            prevStart=start;</span><br><span class="line">            start=end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】凄美地 (live)【声生不息·家年华】</title>
      <link href="/p/a8296e6d/"/>
      <url>/p/a8296e6d/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%87%84%E7%BE%8E%E5%9C%B0.jpg" alt="凄美地"></p><p>已灌词~</p><p>BPM：125</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/605259/20318812.html?fpa=se&lastp=so_result">纯享：《凄美地》陈楚生&#x2F;周深-综艺-高清视频在线观看-芒果TV (mgtv.com)</a></p><p>作词 : 郭顶</p><p>作曲 : 郭顶</p><p>编曲 : 郭顶</p><p>制作人 : 郭顶</p><p>改编编曲：陈牧荻</p><p>混音：林梦洋</p><p>制作人：汤佩弦@牛班NEWBAND&#x2F;谷粟@牛班NEWBAND</p><p>音乐总监：谷粟@牛班NEWBAND</p><p>音响总监：何飚</p><p>舞台总监：李柯</p><p>舞蹈总监：莫小斐@ShowPro</p><p>艺术顾问：金兆钧</p><p>音乐设计：王皓@WONDERWALL</p><p>乐队队长：董音@牛班NEWBAND</p><p>键盘：董音@牛班NEWBAND&#x2F;洪信杰@牛班NEWBAND</p><p>吉他：黄仲贤@牛班NEWBAND&#x2F;毕赫宸@牛班NEWBAND</p><p>贝斯：宣一亨@牛班NEWBAND</p><p>鼓：郝稷伦@牛班NEWBAND</p><p>打击乐：郑瑀@牛班NEWBAND</p><p>和音：王梓琼@牛班NEWBAND&#x2F;杨画画@牛班NEWBAND</p><p>李郡洲@牛班NEWBAND&#x2F;张石荻@牛班NEWBAND</p><p>PGM：郭锦阳@牛班NEWBAND</p><p>弦乐：刘星弦乐团</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1yOfDjw963NkI3zTkZFqlzA?pwd=zbj5">https://pan.baidu.com/s/1yOfDjw963NkI3zTkZFqlzA?pwd=zbj5</a></p><p>提取码: zbj5</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>【陈楚生】</p><p>曾经我是不安河水</p><p>穿过森林误入你心</p><p>没计划扎营 搁下了是非</p><p>一去不回</p> <br><p>如今我是造梦的人呐</p><p>怅然若失流连忘返啊</p><p>等潮汐来临 我就能记起</p><p>你的样子</p>  <br><p>【合】</p><p>我没看过</p><p>平坦山丘</p><p>怎么触摸</p><p>开花沼泽</p>  <br><p>嘿 等我找到你</p><p>试探你眼睛</p><p>心无旁骛地 相拥</p><p>那是我 仅有的温柔也是我爱你的原因</p><p>在这凄美地</p>  <br><p>【周深】</p><p>曾经这里是无人之地</p><p>为何没留下有效地址</p><p>肆意的消息 迷失在十月</p><p>没有音讯</p>  <br><p>如今这里是风和日丽</p><p>等你再回来雨过迁徙</p><p>看夜幕将近 我又能记起</p><p>你的样子</p>  <br><p>【合】</p><p>我还记得</p><p>平坦山丘</p><p>如今身在</p><p>开花沼泽</p>  <br><p>嘿</p><p>【周深】</p><p>等我找到你</p><p>试探你眼睛</p><p>心无旁骛地 相拥</p><p>【合】</p><p>那是我 仅有的温柔也是我爱你的原因</p><p>在这凄美地</p>  <br> <p>在这之前</p><p>别说再见</p><p>我已再经不起离别</p>  <br><p>在这之前</p><p>别说再见</p><p>我已经开始了想念</p>  <br><p>在这之前</p><p>别说再见</p><p>请帮我停住这时间</p><p>就这样 别安慰</p>  <br><p>嘿 等我找到你</p><p>望住你眼睛</p><p>心无旁骛地 相拥</p><p>那是我 仅有的温柔也是我爱你的原因</p><p>如此不可及</p><p>如此不思议</p><p>让我坠落</p><p>在这凄美地</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
            <tag> 无参 </tag>
            
            <tag> 声生不息·家年华 </tag>
            
            <tag> 陈楚生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HTTP】HTTP/1.1 &amp; HTTPS 如何优化？</title>
      <link href="/p/4cc89a71/"/>
      <url>/p/4cc89a71/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-1-1-如何优化？"><a href="#HTTP-1-1-如何优化？" class="headerlink" title="HTTP&#x2F;1.1 如何优化？"></a>HTTP&#x2F;1.1 如何优化？</h1><p>我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：</p><ul><li><em>尽量避免发送 HTTP 请求</em>；</li><li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；</li><li><em>减少服务器的 HTTP 响应的数据大小</em>；</li></ul><p>下面，就针对这三种思路具体看看有哪些优化方法。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96http1.1%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="如何避免发送-HTTP-请求？"><a href="#如何避免发送-HTTP-请求？" class="headerlink" title="如何避免发送 HTTP 请求？"></a>如何避免发送 HTTP 请求？</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>详见上一篇「HTTP 缓存技术」（强制缓存、协商缓存）</p><h2 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h2><h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p>如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img"></p><p>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.png" alt="img"></p><h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 <code>CSS Image Sprites</code> 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/css%E7%B2%BE%E7%81%B5.png" alt="图来源于：墨染枫林的CSDN"></p><p>这种方式就是<strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销</strong>。</p><p>另外，还可以将图片的二进制数据用 <code>base64</code> 编码后，以 URL 的形式嵌入到 HTML 文件，跟随 HTML 文件一并发送.</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;image src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA ... /&gt;</span><br></pre></td></tr></table></figure><p>这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/base64%E5%9B%BE%E7%89%87.png" alt="图来源于：陈健平的CSDN "></p><p>可以看到，<strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求</strong>。</p><p>但是这样的合并请求会带来新的问题，<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。</p><h3 id="延迟发送请求（lazy-load）"><a href="#延迟发送请求（lazy-load）" class="headerlink" title="延迟发送请求（lazy load）"></a>延迟发送请求（lazy load）</h3><p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h2 id="如何减少-HTTP-响应的数据大小？"><a href="#如何减少-HTTP-响应的数据大小？" class="headerlink" title="如何减少 HTTP 响应的数据大小？"></a>如何减少 HTTP 响应的数据大小？</h2><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。</p><p>接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。</p><p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 <code>Accept-Encoding</code> 字段告诉服务器：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br></pre></td></tr></table></figure><p>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 <code>Content-Encoding</code> 字段告诉客户端该资源使用的压缩算法。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。</p><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。</p><p>可以通过 HTTP 请求头部中的 <code>Accept</code> 字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept: audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure><p>关于图片的压缩，目前压缩比较高的是 Google 推出的 <strong>WebP 格式</strong>，它与常见的 Png 格式图片的压缩比例对比如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/webp%E4%B8%8Epng.png" alt="来源于：https://isparta.github.io/compare-webp/index.html"></p><p>可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。</p><p>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。</p><p>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p><h1 id="HTTPS-如何优化？"><a href="#HTTPS-如何优化？" class="headerlink" title="HTTPS 如何优化？"></a>HTTPS 如何优化？</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96https%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="分析性能损耗"><a href="#分析性能损耗" class="headerlink" title="分析性能损耗"></a>分析性能损耗</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><p>对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。</p><p>而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p><ul><li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li><li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li><li>双方计算 Pre-Master，也就是对称加密密钥；</li></ul><p>为了大家更清楚这些步骤在 TLS 协议握手的哪一个阶段，我画出了这幅图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png" alt="img"></p><h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><p>一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。</p><p>另外，如果可以，应该选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。</p><h2 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h2><h3 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a>密钥交换算法优化</h3><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。</p><p>总之使用 <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p><p>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p><p>ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p><p>对于对称加密算法方面，如果对安全性不是特别高的要求，可以<strong>选用 AES_128_GCM</strong>，它比 AES_256_GCM 快一些，因为密钥的长度短一些。</p><h3 id="TLS优化"><a href="#TLS优化" class="headerlink" title="TLS优化"></a>TLS优化</h3><p>如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls1.2and1.3.png" alt="img"></p><p>上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p><p>怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p><p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p><p>而且，TLS1.3 对密码套件进行“减肥”了， <strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</p><h2 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h2><p>为了验证的服务器的身份，服务器会在 TLS 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。</p><p>对于证书的优化，可以有两个方向：</p><ul><li>一个是<strong>证书传输</strong>，</li><li>一个是<strong>证书验证</strong>；</li></ul><h3 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h3><p>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</p><h3 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h3><p>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL （证书吊销列表（<em>Certificate Revocation List</em>））或者 OCSP（在线证书状态协议（<em>Online Certificate Status Protocol</em>）） 数据，以此确认证书的有效性。</p><p>这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p><p>于是为了解决这一个网络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/opscp-stapling.png" alt="img"></p><p>当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</p><h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p><p>这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p><ul><li>第一种叫 Session ID；</li><li>第二种叫 Session Ticket；</li></ul><h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。</p><p>但是它有两个缺点：</p><ul><li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li><li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li></ul><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p><p>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</p><p>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</p><p>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p><p>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p><p>同时应对<strong>重放攻击</strong>（中间人）也很困难。</p><h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。</p><p>而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。</p><p>同样的，Pre-shared Key 也有重放攻击的危险。</p><p>应对重放攻击可以给会话密钥设定一个合理的过期时间，以及只针对安全的 HTTP 请求如 GET&#x2F;HEAD 使用会话重用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> HTTP/1.1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HTTP】HTTP基础</title>
      <link href="/p/d0fe2d0f/"/>
      <url>/p/d0fe2d0f/</url>
      
        <content type="html"><![CDATA[<p>根据小林coding文章省流总结~</p><h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><h2 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h2><p>HTTP 是<font color="blue">超文本</font><font color="orange">传输</font><font color="green">协议</font>，也就是<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><p><strong>HTTP 是一个在计算机世界里专门<font color="orange">在「两点」之间「传输」</font><font color="blue">文字、图片、音频、视频等「超文本」数据</font>的<font color="green">「约定和规范」</font>。</strong></p><h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式"></p><h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#code-1">1xx 提示</button></li><li class="tab"><button type="button" data-href="#code-2">2xx 成功</button></li><li class="tab"><button type="button" data-href="#code-3">3xx 重定向</button></li><li class="tab"><button type="button" data-href="#code-4">4xx 客户端错误</button></li><li class="tab"><button type="button" data-href="#code-5">5xx 服务端错误</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="code-1"><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="code-2"><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="code-3"><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>（其中301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。）</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="code-4"><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="code-5"><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h1 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h1><div class="tabs" id="ziduan"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ziduan-1">Host</button></li><li class="tab"><button type="button" data-href="#ziduan-2">Content-Length</button></li><li class="tab"><button type="button" data-href="#ziduan-3">Connection</button></li><li class="tab"><button type="button" data-href="#ziduan-4">Content-Type & Accept</button></li><li class="tab"><button type="button" data-href="#ziduan-5">Accept/Content-Encoding</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ziduan-1"><p>客户端发送请求时，用来指定服务器的域名。</p><p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="ziduan-2"><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 <code>HTTP header</code> 的边界，通过 Content-Length 字段作为<code>HTTP body</code>的边界，这两个方式都是为了解决“粘包”的问题</strong>。具体什么是 TCP 粘包，可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">如何理解是 TCP 面向字节流协议？</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="ziduan-3"><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p><p>PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="ziduan-4"><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="ziduan-5"><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据。</p><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器</strong>这边。</p><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img"></p><p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img"></p><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h1 id="HTTP演变"><a href="#HTTP演变" class="headerlink" title="HTTP演变"></a>HTTP演变</h1><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><p><em>1. 简单</em></p><p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><p><em>2. 灵活和易于扩展</em></p><p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p><ul><li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li><li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li></ul><p><em>3. 应用广泛和跨平台</em></p><p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p><p><em>1. 无状态双刃剑</em></p><p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p><p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p><p><em>2. 明文传输双刃剑</em></p><p>明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p><p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p><p><em>3. 不安全</em></p><p>HTTP 比较严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。</p><p><em>4. 其他</em></p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>队头阻塞</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>HTTP 协议是基于 <strong>TCP&#x2F;IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p><p><em>1. 长连接</em></p><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p><p>当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p><p><em>3. 队头阻塞</em></p><p>「请求 - 应答」的模式会造成 HTTP 的性能问题。为什么呢？</p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞"></p><p>总之 HTTP&#x2F;1.1 的性能一般般，后续的 HTTP&#x2F;2 和 HTTP&#x2F;3 就是在优化 HTTP 的性能。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</p><p>HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</p><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1. 混合加密"></a><em>1. 混合加密</em></h3><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="2-摘要算法-数字签名"><a href="#2-摘要算法-数字签名" class="headerlink" title="2. 摘要算法 + 数字签名"></a><em>2. 摘要算法 + 数字签名</em></h3><p>为了保证传输的内容不被篡改，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png" alt="img"></p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可泄露。</li></ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="img"></p><p>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a><em>3. 数字证书</em></h3><p>前面我们知道：</p><ul><li>可以通过哈希算法来保证消息的完整性；</li><li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li></ul><p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p><p>可以通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" alt="img"></p><p>还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。</p><p>但是我们还可以自己伪造出一对公私钥啊！</p><p>你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。</p><p>既然伪造公私钥那么随意，所以你爸把他的公钥注册到<strong>警察局</strong>，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个<strong>数字证书，也就是说这个数字证书包含你爸爸的公钥。</strong></p><p>这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。</p><p>老师拿到了数字证书后，<strong>首先会去警察局验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。</p><p><strong>由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的</strong>，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。</p><p>正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。</p><p>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><h3 id="HTTPS如何建立连接"><a href="#HTTPS如何建立连接" class="headerlink" title="HTTPS如何建立连接"></a>HTTPS如何建立连接</h3><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。</p><p>基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程"></p><p>TLS 协议建立的详细流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img"></p><p>具体过程如下：</p><ul><li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><p>如果你想详细了解记录协议是如何分片、压缩、计算 MAC 值、分组加密，可以看这篇：<a href="https://blog.csdn.net/zhanyiwp/article/details/105627799">理解SSL&#x2F;TLS系列 (四) 记录协议</a></p><h3 id="HTTPS一定安全可靠吗？"><a href="#HTTPS一定安全可靠吗？" class="headerlink" title="HTTPS一定安全可靠吗？"></a>HTTPS一定安全可靠吗？</h3><p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img"></p><p>具体过程如下：</p><ul><li>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</li><li>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</li><li>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</li><li>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</li></ul><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p><p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png" alt="img"></p><p>如果用户执意点击「继续浏览此网站」，相当于<strong>用户接受了中间人伪造的证书</strong>，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2"></p><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><h3 id="1-头部压缩"><a href="#1-头部压缩" class="headerlink" title="1. 头部压缩"></a><em>1. 头部压缩</em></h3><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p>HPACK 算法主要包含三个组成部分：</p><ul><li>静态字典；</li><li>动态字典；</li><li>Huffman 编码（压缩算法）；</li></ul><p>HTTP&#x2F;2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong>，它是写入到 HTTP&#x2F;2 框架里的，不会变化的，静态表里共有 <code>61</code> 组，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142818571.png" alt="img"></p><p>表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。</p><p>下面这个 <code>server</code> 头部字段，在 HTTP&#x2F;1.1 的形式如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">server: nghttpx\r\n</span><br></pre></td></tr></table></figure><p>算上冒号空格和末尾的<code>\r\n</code>，共占用了 17 字节，**而使用了静态表和 Huffman 编码，可以将它压缩成 8 字节，压缩率大概 47%**。</p><p>我抓了个 HTTP&#x2F;2 协议的网络包，你可以从下图看到，高亮部分就是 <code>server</code> 头部字段，只用了 8 个字节来表示 <code>server</code> 头部数据。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142843113.png" alt="image-20240105142843113"></p><p>根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP&#x2F;2 头部前 2 位固定为 <code>01</code>，所以整个头部格式如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142857712.png" alt="image-20240105142857712"></p><p>HTTP&#x2F;2 头部由于基于<strong>二进制编码</strong>，就不需要冒号空格和末尾的\r\n作为分隔符，于是改用表示字符串长度（Value Length）来分割 Index 和 Value。</p><p>接下来，根据这个头部格式来分析上面抓包的 <code>server</code> 头部的二进制数据。</p><p>首先，从静态表中能查到 <code>server</code> 头部字段的 Index 为 54，二进制为 110110，再加上固定 01，头部格式第 1 个字节就是 <code>01110110</code>，这正是上面抓包标注的红色部分的二进制数据。</p><p>然后，第二个字节的首个比特位表示 Value 是否经过 Huffman 编码，剩余的 7 位表示 Value 的长度，比如这次例子的第二个字节为 <code>10000110</code>，首位比特位为 1 就代表 Value 字符串是经过 Huffman 编码的，经过 Huffman 编码的 Value 长度为 6。</p><p>最后，字符串 <code>nghttpx</code> 经过 Huffman 编码后压缩成了 6 个字节，Huffman 编码的原理是将高频出现的信息用「较短」的编码表示，从而缩减字符串长度。</p><p>于是，在统计大量的 HTTP 头部后，HTTP&#x2F;2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，可以在 RFC7541 文档找到这张<strong>静态 Huffman 表</strong>，我就不把表的全部内容列出来了，我只列出字符串 <code>nghttpx</code> 中每个字符对应的 Huffman 编码，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142917193.png" alt="img"></p><p>通过查表后，字符串 <code>nghttpx</code> 的 Huffman 编码在下图看到，共 6 个字节，每一个字符的 Huffman 编码，我用相同的颜色将他们对应起来了，最后的 7 位是补位的。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142933915.png" alt="img"></p><p>最终，<code>server</code> 头部的二进制数据对应的静态头部格式如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105142949762.png" alt="image-20240105142949762"></p><p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 <code>62</code> 起步，会在编码解码的时候随时更新。</p><p>比如，第一次发送时头部中的「<code>User-Agent</code> 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。</p><p>所以，使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p><p>因此，随着在同一 HTTP&#x2F;2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p><p>理想很美好，现实很骨感。动态表越大，占用的内存也就越大，如果占用了太多内存，是会影响服务器性能的，因此 Web 服务器都会提供类似 <code>http2_max_requests</code> 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP&#x2F;2 连接来释放内存。</p><p>综上，HTTP&#x2F;2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240105143006681.png" alt="image-20240105143006681"></p><h3 id="2-二进制格式"><a href="#2-二进制格式" class="headerlink" title="2. 二进制格式"></a><em>2. 二进制格式</em></h3><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png" alt="HTTP/1 与 HTTP/2 "></p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p>Header: :status: 200 OK 的编码内容为：1000 1000，那么表达的含义是什么呢？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/index.png" alt="img"></p><ol><li>最前面的 1 标识该 Header 是静态表中已经存在的 KV。（至于什么是静态表，可以看这篇：<a href="https://xiaolincoding.com/network/2_http/http2.html">HTTP&#x2F;2 牛逼在哪？ (opens new window)</a>）</li><li>在静态表里，“:status: 200 ok” 静态表编码是 8，二进制即是 1000。</li></ol><p>因此，整体加起来就是 1000 1000。</p><h3 id="3-并发传输"><a href="#3-并发传输" class="headerlink" title="3. 并发传输"></a><em>3. 并发传输</em></h3><p>我们都知道 HTTP&#x2F;1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP&#x2F;2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" alt="img"></p><p>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP&#x2F;1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP&#x2F;2 最小单位，以二进制压缩格式存放 HTTP&#x2F;1 中的内容（头部和包体）。</p><p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg" alt="img"></p><h3 id="4、服务器推送"><a href="#4、服务器推送" class="headerlink" title="4、服务器推送"></a><em>4、服务器推送</em></h3><p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字 1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和 4）。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/83445581dafe409d8cfd2c573b2781ac.png" alt="img"></p><p>再比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push.png" alt="img"></p><p>如上图右边部分，在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p><p>举个例子，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif" alt="img"></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP&#x2F;2 的队头阻塞问题，是在 TCP 层面发生的。</p><p>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p>前面我们知道了 HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3"></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h3 id="1、无队头阻塞"><a href="#1、无队头阻塞" class="headerlink" title="1、无队头阻塞"></a><em>1、无队头阻塞</em></h3><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h3 id="2、更快的连接建立"><a href="#2、更快的连接建立" class="headerlink" title="2、更快的连接建立"></a><em>2、更快的连接建立</em></h3><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP&#x2F;3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT（下图的右下角）：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/4cad213f5125432693e0e2a512c2d1a1-20230309231022316.png" alt="img"></p><h3 id="3、连接迁移"><a href="#3、连接迁移" class="headerlink" title="3、连接迁移"></a><em>3、连接迁移</em></h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png" alt="TCP 四元组"></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】键入网址到网页显示，期间发生了什么？</title>
      <link href="/p/ffab2f6b/"/>
      <url>/p/ffab2f6b/</url>
      
        <content type="html"><![CDATA[<h1 id="零、究极省流版"><a href="#零、究极省流版" class="headerlink" title="零、究极省流版"></a>零、究极省流版</h1><ol><li>浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（ HTML、JS、CSS 、图像等）；</li><li>浏览器对加载到的资源（ HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构 （如 HTML 的 DOM）；</li><li>载⼊解析到的资源文件，渲染页面，完成。</li></ol><h1 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a>一、HTTP</h1><h2 id="1-1-解析URL"><a href="#1-1-解析URL" class="headerlink" title="1.1 解析URL"></a>1.1 解析URL</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg" alt="URL 解析"></p><p>浏览器<strong>查看缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤；如果资源未缓存，发起新请求</p><p>检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control：</p><ul><li>HTTP1.0提供 Expires，值为⼀个绝对时间表示缓存新鲜⽇期</li><li>HTTP1.1增加了Cache-Control: max-age&#x3D;time，值为以秒为单位的最⼤新鲜时间</li></ul><h2 id="1-2-生成HTTP请求消息（HTTP报文）"><a href="#1-2-生成HTTP请求消息（HTTP报文）" class="headerlink" title="1.2 生成HTTP请求消息（HTTP报文）"></a>1.2 生成HTTP请求消息（HTTP报文）</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式"></p><h1 id="二、DNS"><a href="#二、DNS" class="headerlink" title="二、DNS"></a>二、DNS</h1><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h2 id="2-1-域名解析的工作流程（递归查询）"><a href="#2-1-域名解析的工作流程（递归查询）" class="headerlink" title="2.1 域名解析的工作流程（递归查询）"></a>2.1 域名解析的工作流程（递归查询）</h2><ol><li>客户端首先会发出一个 DNS 请求，问<code>www.server.com</code>的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。（浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。）</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到<code> www.server.com</code>，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<code>www.server.com </code>这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <code>www.server.com</code> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责<code>www.server.com</code>区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<code>www.server.com</code>对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"></p><h1 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h1><p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p><h2 id="3-1-TCP报文格式"><a href="#3-1-TCP报文格式" class="headerlink" title="3.1 TCP报文格式"></a>3.1 TCP报文格式</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg" alt="TCP 包头格式"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg" alt="MTU 与 MSS"></p><p><code>MSS</code>：1500 - 20 (IP头) - 20 (TCP头) &#x3D; 1460 (Bytes)</p><h2 id="3-2-TCP报文"><a href="#3-2-TCP报文" class="headerlink" title="3.2 TCP报文"></a>3.2 TCP报文</h2><p>此时报文如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg" alt="TCP 层报文"></p><h2 id="3-3-三次握手"><a href="#3-3-三次握手" class="headerlink" title="3.3 三次握手"></a>3.3 三次握手</h2><ul><li>客户端发送⼀个<code>TCP</code>的<strong>SYN&#x3D;1</strong>，<strong>Seq&#x3D;X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN&#x3D;1</strong>， <strong>ACK&#x3D;X+1</strong>， <strong>Seq&#x3D;Y</strong>的响应包</li><li>客户端发送<strong>ACK&#x3D;Y+1</strong>， <strong>Seq&#x3D;Z</strong></li></ul><h2 id="3-4-传输"><a href="#3-4-传输" class="headerlink" title="3.4 传输"></a>3.4 传输</h2><ol><li><p>TCP链接建⽴后发送HTTP请求</p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>，如果验证缓存新鲜，返回304等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将响应报文通过TCP连接发送回浏览器</p></li></ol><h2 id="3-5-四次握手"><a href="#3-5-四次握手" class="headerlink" title="3.5 四次握手"></a>3.5 四次握手</h2><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握⼿如下：</p><ul><li><p>主动⽅发送Fin&#x3D;1， Ack&#x3D;Z， Seq&#x3D; X报文</p></li><li><p>被动⽅发送ACK&#x3D;X+1， Seq&#x3D;Z报文</p></li><li><p>被动⽅发送Fin&#x3D;1， ACK&#x3D;X， Seq&#x3D;Y报文</p></li><li><p>主动⽅发送ACK&#x3D;Y， Seq&#x3D;X报文</p></li></ul><h1 id="四、准备渲染"><a href="#四、准备渲染" class="headerlink" title="四、准备渲染"></a>四、准备渲染</h1><ol><li>浏览器检查响应状态码：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应<strong>进行解码</strong>（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li><strong>解析HTML文档</strong>，<strong>构件DOM树</strong>，<strong>下载资源</strong>，<strong>构造CSSOM树</strong>，<strong>执行js脚本</strong>，这些操作没有严 格的先后顺序，以下分别解释：</li></ol><h2 id="4-1-构建DOM树"><a href="#4-1-构建DOM树" class="headerlink" title="4.1 构建DOM树"></a>4.1 构建DOM树</h2><p>HTML 通过HTML解析器转成DOM Tree</p><ul><li><strong>Tokenizing</strong>：根据<code>HTML</code>规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成<code>DOM</code>树</li></ul><p>解析过程中遇到图⽚、样式表、js文件，启动<strong>下载</strong></p><h2 id="4-2-构建CSSOM树"><a href="#4-2-构建CSSOM树" class="headerlink" title="4.2 构建CSSOM树"></a>4.2 构建CSSOM树</h2><p>CSS按照CSS规则和CSS解析器转成CSSOM Tree</p><ul><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建<code>CSSOM</code>树</li></ul><h2 id="4-3-构建渲染树"><a href="#4-3-构建渲染树" class="headerlink" title="4.3 构建渲染树"></a>4.3 构建渲染树</h2><p>根据DOM树和CSSOM树构建</p><ol><li>从DOM树的根节点遍历所有可见节点（不可见节点：script&#x2F;meta等本身不可见的标签、被css隐藏的节点、……）</li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容以及计算样式</li></ol><h2 id="4-4-js解析"><a href="#4-4-js解析" class="headerlink" title="4.4 js解析"></a>4.4 js解析</h2><ul><li><p>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></p></li><li><p>HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内 或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</p></li><li><p>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它 下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问⾃⼰script和之前的文档元素</p></li><li><p>当文档完成解析，document.readState变成interactive</p></li><li><p>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()</p></li><li><p>浏览器在Document对象上触发DOMContentLoaded事件</p></li><li><p>此时文档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执行，document.readState变为complete，window触发 load事件</p></li></ul><p>然后就是显示页面了</p><p>那么数据包具体是怎么传输的呢？别急 还有呢</p><h1 id="五、IP"><a href="#五、IP" class="headerlink" title="五、IP"></a>五、IP</h1><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><h2 id="5-1-IP报文格式"><a href="#5-1-IP报文格式" class="headerlink" title="5.1 IP报文格式"></a>5.1 IP报文格式</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" alt="IP 包头格式"></p><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p><h2 id="5-2-源IP地址的选择"><a href="#5-2-源IP地址的选择" class="headerlink" title="5.2 源IP地址的选择"></a>5.2 源IP地址的选择</h2><p>我们假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg" alt="路由规则判断"></p><ol><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p><h2 id="5-3-IP报文"><a href="#5-3-IP报文" class="headerlink" title="5.3 IP报文"></a>5.3 IP报文</h2><p>此时报文如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg" alt="IP 层报文"></p><h1 id="六、MAC"><a href="#六、MAC" class="headerlink" title="六、MAC"></a>六、MAC</h1><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><h2 id="6-1-MAC报文格式"><a href="#6-1-MAC报文格式" class="headerlink" title="6.1 MAC报文格式"></a>6.1 MAC报文格式</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" alt="MAC 包头格式"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><h2 id="6-2-MAC地址确定"><a href="#6-2-MAC地址确定" class="headerlink" title="6.2 MAC地址确定"></a>6.2 MAC地址确定</h2><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址获取：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg" alt="ARP 广播"></p><h2 id="6-3-MAC报文"><a href="#6-3-MAC报文" class="headerlink" title="6.3 MAC报文"></a>6.3 MAC报文</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="MAC 层报文"></p><h1 id="七、网卡"><a href="#七、网卡" class="headerlink" title="七、网卡"></a>七、网卡</h1><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包"></p><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h1 id="八、交换机"><a href="#八、交换机" class="headerlink" title="八、交换机"></a>八、交换机</h1><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><h2 id="8-1-交换机的包接收操作"><a href="#8-1-交换机的包接收操作" class="headerlink" title="8.1 交换机的包接收操作"></a>8.1 交换机的包接收操作</h2><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg" alt="交换机的 MAC 地址表"></p><p>如果有，则直接转发+学习；如果没有，则泛洪+学习</p><h1 id="九、路由器"><a href="#九、路由器" class="headerlink" title="九、路由器"></a>九、路由器</h1><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><h2 id="9-1-路由器的包接收操作"><a href="#9-1-路由器的包接收操作" class="headerlink" title="9.1 路由器的包接收操作"></a>9.1 路由器的包接收操作</h2><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><h2 id="9-2-查询路由表确定输出端口"><a href="#9-2-查询路由表确定输出端口" class="headerlink" title="9.2 查询路由表确定输出端口"></a>9.2 查询路由表确定输出端口</h2><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="路由器转发"></p><p>找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p><h2 id="9-3-路由器的发送操作"><a href="#9-3-路由器的发送操作" class="headerlink" title="9.3 路由器的发送操作"></a>9.3 路由器的发送操作</h2><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http">2.2 键入网址到网页显示，期间发生了什么？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://blog.csdn.net/Newbie___/article/details/107212575">大厂常问：输入URL到显示页面的全过程（敲详细）_—————————message from webpage—-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/1872434">详细拆解导航流程：从输入URL到页面展示，这中间发生了什么？-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> IP </tag>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> DNS </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】野花香（DJ何鹏版）</title>
      <link href="/p/95d9f91e/"/>
      <url>/p/95d9f91e/</url>
      
        <content type="html"><![CDATA[<p><img src="/./%E3%80%90%E6%97%A0%E5%8F%82%E9%85%8D%E5%B8%83%E3%80%91%E9%87%8E%E8%8A%B1%E9%A6%99%EF%BC%88DJ%E4%BD%95%E9%B9%8F%E7%89%88%EF%BC%89/cover.png" alt="cover"></p><p>已灌词，扒得最轻松的一集</p><p>BPM：110</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>词：东方骏</p><p>曲：老猫</p><p>编曲：袁洋</p><p>吉他：袁洋</p><p>RAP：老猫</p><p>出品人：赵玉梅</p><p>制作人：赵玉梅&#x2F;东方骏</p><p>音乐总监：老猫</p><p>录音棚：摩登天空</p><p>录音师：范川哲</p><p>混音：范川哲</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1hkEIblomNRPrXvPAK9Ab5Q?pwd=as1k">https://pan.baidu.com/s/1hkEIblomNRPrXvPAK9Ab5Q?pwd=as1k</a></p><p>提取码: as1k</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>野野野 野花香</p><p>野野野 野花香</p> <br><p>每次都想装作 很倔强</p><p>但是见面自己却 缴械投降</p><p>因为爱你 我一如既往</p><p>再多压力都无法阻挡</p>  <br><p>你的炽热 我无法设防</p><p>还总是让我 心花怒放</p><p>幸亏我拥有 爱的力量</p><p>愿意陪你 满世界疯狂</p>  <br><p>请你呀 来到 我的身旁</p><p>让我的心呀 不再流浪</p><p>唱歌跳舞 我们一醉到天亮</p><p>醒来已是满地 野花香</p>  <br><p>请你呀 来到 我的身旁</p><p>让我呀 为你 卸下行装</p><p>今夜我就是 你最美的新娘</p><p>醉在这一地 野花香</p>  <br><p>野花香 野花香</p><p>这地方真美 鸟语花香</p><p>缘分带我流浪 到这个地方</p><p>美丽的姑娘 爱情芬芳</p>  <br><p>野花香 野花香</p><p>我们追逐梦想 离开故乡</p><p>温暖的怀抱 醉倒在你身旁</p><p>有你的地方就是天堂</p>  <br><p>你的炽热 我无法设防</p><p>还总是让我 心花怒放</p><p>幸亏我拥有 爱的力量</p><p>愿意陪你 满世界疯狂</p>  <br><p>请你呀 来到 我的身旁</p><p>让我的心呀 不再流浪</p><p>唱歌跳舞 我们一醉到天亮</p><p>醒来已是满地 野花香</p>  <br><p>请你呀 来到 我的身旁</p><p>让我呀 为你 卸下行装</p><p>今夜我就是 你最美的新娘</p><p>醉在这一地 野花香</p>  <br><p>醉在这一地 野花香</p><p>野野野 野花香</p><p>野野野 野花香</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参不配布】倏然梦【羊角挂书】</title>
      <link href="/p/7f869365/"/>
      <url>/p/7f869365/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%80%8F%E7%84%B6%E6%A2%A6.jpg" alt="倏然梦"></p><p>已灌词，和声可能有扒错的</p><p>BPM：97</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/video/BV1Ku4m1P7Ba/?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">“这场梦比梦醒真实吗？”《倏然梦》- 三无原创曲</a></p><p>作词：冉语优</p><p>作曲：KBShinya</p><p>编曲：1AN孙毅然</p><p>吉他实录：RK</p><p>和声编唱：橘音kitsune，三无</p><p>混音：1AN孙毅然</p><p>母带：张锦亮</p><p>视频监制：雾枝今天行不行啊</p><p>视频制作：彩虹映画</p><p>封面画师：鸭鸭搓夹夹</p><p>封面美工：茶了了</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>这个是有偿扒谱，所以不配布啦~</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>若现若隐的 那一座世界<br>默然伫立在 梦与醒边缘<br>不语也不言 有风亦有月<br>那里不过是 另一处人间</p><p>睁眼于朦胧的夜暮间<br>朝空中轻轻一跃 扑翼后便倏然化蝶<br>飞身随风去游向海天<br>浸沐着含霜的月<br>听光阴如水如烟 流经指尖</p><p>这场梦比梦醒惬意吗 别四顾彷徨<br>诞生的土壤 也许本非是故乡</p><p>浮游中谁忽然惊觉 这光阴皆可倒颠<br>问夏虫可语冰雪 昼不继夜 日不逐月<br>此间何去何从 百年虽近 刹那却已远<br>化作蝶这一去翩翩<br>振翅几千年 一念万重天</p><p>零落在摇曳的竹叶尖<br>顺朝露盈盈一跃 落地前已蘧然化蝶<br>穿过一草一叶几人间<br>凝眸看大千世界<br>见秋水化为孑孓 旋生旋灭</p><p>这场梦比梦醒真实吗 别四顾彷徨<br>人世的模样 从未拘忌于想象</p><p>浮游中谁可曾惊觉 天与地皆可倒颠<br>看群山移为桑田 沧海燃焰 水中抱月<br>此间物即是我 死而往生 生而又复灭<br>化作蝶醒也即是眠<br>梦中万万天 道书几千言</p><p>道存世间心间自然间<br>知在至理至善却至简<br>在地观天 有限观无限<br>至明而希明 至言而希言 玄之又玄<br>恐复忘言 醒觉之前 梦中书此篇</p><p>扑翼几次倏然化成蝶<br>随着风跃出海天<br>夜暮间合眼重眠于 哪一夜</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 三无Marblue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Syncthing实现跨平台设备文件同步</title>
      <link href="/p/5b246b1b/"/>
      <url>/p/5b246b1b/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>主要是为了方便听歌，因为每家的版权都不同！只想一个app听完所有的<del>，哎，版权</del></p><p>而且有一些只在b站投稿了，我自己扒音频下来听的</p><p>过去我都是手动连<code>usb</code>复制粘贴的，最近突然想偷懒了，看看有没有什么好的方案！</p><p><del>此处省略过程（</del></p><p>总之最终决定使用<code>Syncthing</code>，因为支持平台宽泛，开源，而且UI好看（？，免费（有一些方案是有一个中间商（云）的，那些基本都要付费（（</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>因为都是在PC端进行音频的下载的，所以我这里PC端的音乐库为主，进行单向同步，分发到其他设备中，保持完全一致（包括增加、删除）</p><h1 id="下载Syncthing"><a href="#下载Syncthing" class="headerlink" title="下载Syncthing"></a>下载<code>Syncthing</code></h1><p>PC：<a href="https://github.com/syncthing/syncthing">syncthing&#x2F;syncthing: Open Source Continuous File Synchronization (github.com)</a></p><p>Android：<a href="https://github.com/syncthing/syncthing-android">syncthing&#x2F;syncthing-android: Wrapper of syncthing for Android. (github.com)</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="1-PC"><a href="#1-PC" class="headerlink" title="1. PC"></a>1. PC</h2><p>在配置页面中点添加文件夹，填写文件夹标签和路径</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240222134827405.png"></p><p>版本控制这里就不需要了，反正不是双向同步（</p><p>然后文件夹类型改为<code>仅发送</code>，顺便勾上<code>忽略文件权限</code>，扫描间隔就默认即可。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240222135028855.png"></p><h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><p>点到设备，然后点右上角加号，然后点二维码，扫描PC端的设备ID即可添加设备</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240222135830558.png"></p><h2 id="3-PC"><a href="#3-PC" class="headerlink" title="3. PC"></a>3. PC</h2><p>此时在管理页面上方会出现一个请求，同意一下就可以添加远程设备了</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240222140126645.png"></p><p>然后编辑文件夹，共享给远程设备</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240222140156763.png"></p><h2 id="4-Android"><a href="#4-Android" class="headerlink" title="4. Android"></a>4. Android</h2><p>点左侧菜单，点网页管理页面，就能见到和PC端一样的页面了，我们在这里进行文件夹的设置</p><p>此时应该能在文件夹那里看到PC端共享的文件夹了（可以对比一下文件夹ID，是一致的），改一下文件夹路径为实际要同步的路径，文件夹类型为<code>仅接收</code>，同样勾上<code>忽略文件权限</code></p><p>然后就可以愉快的同步了！</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何删除接收方多余的文件"><a href="#如何删除接收方多余的文件" class="headerlink" title="如何删除接收方多余的文件"></a>如何删除接收方多余的文件</h2><p>比如在使用同步之前，两端已经都有文件了，然后接收方那里有一些多余的文件</p><p>此时只要点击一个<code>恢复本地更改</code>的红色按钮，再点确认就可以了</p><p>这下就可以完全同步了，此后的文件，在PC端删除或者增加，另一端也会自动同步</p><h2 id="如何实现一端删除文件，另一端不删除"><a href="#如何实现一端删除文件，另一端不删除" class="headerlink" title="如何实现一端删除文件，另一端不删除"></a>如何实现一端删除文件，另一端不删除</h2><p>可能会有朋友有这样的需求，这里顺便cv一下（</p><p>实际使用，发现问题：</p><ol><li>若是<strong>手机（仅发送）上的文件被删除，PC（仅接收）上的文件也会同步被删除</strong>。</li></ol><p>出于我为手机腾空间的需求，需要避免这种问题的发生。</p><h3 id="方案1：启用文件版本控制"><a href="#方案1：启用文件版本控制" class="headerlink" title="方案1：启用文件版本控制"></a>方案1：启用文件版本控制</h3><p>这是<code>Syncthing</code>的界面上摆在明显位置的功能。启用之后，在手机上的文件被删除时，PC端上的文件会被移入特别的垃圾箱。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/%25E7%2589%2588%25E6%259C%25AC%25E6%258E%25A7%25E5%2588%25B6.png" alt="使用版本控制"></p><h3 id="方案2：启用Ignore-Delete"><a href="#方案2：启用Ignore-Delete" class="headerlink" title="方案2：启用Ignore Delete"></a>方案2：启用Ignore Delete</h3><p>文件版本控制虽然能够让你的文件不被删除，但是还是太不优雅。越想越不对劲，Syncthing这看起来牛逼哄哄的软件咋可能没这功能呢？<br>经过我一番搜索，得知还有一些功能藏在高级设置里。</p><p>打开设置页右上角的操作-高级-文件夹，选择你需要配置的文件夹，找到<strong>Ignore Delete</strong>选项，将其勾选并保存。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/Ignore%2520Delete.png" alt="启用Ignore Delete"></p><p>官方对这个选项的解释：<a href="https://docs.syncthing.net/advanced/folder-ignoredelete.html#ignoredelete">IgnoreDelete</a></p><p>这样，在手机上删除文件时，就能保留PC上的文件了。</p><p>需要注意的是，这个选项只是忽略了删除命令，当文件被覆盖时，可能会引起旧文件的丢失。所以建议与版本控制一同使用，以防万一。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhouym.tech/2021/Syncthing/#%E4%BD%BF%E7%94%A8Syncthing%E5%B0%86%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%87%E4%BB%B6%E5%8D%95%E5%90%91%E5%A4%87%E4%BB%BD%E5%88%B0PC">使用Syncthing进行单向备份 - 我只会摸鱼 (zhouym.tech)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Syncthing </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm/IDEA配置Git忽略文件.gitignore</title>
      <link href="/p/a9c92fa9/"/>
      <url>/p/a9c92fa9/</url>
      
        <content type="html"><![CDATA[<p><code>IDEA</code>或者<code>Pycharm</code>在提价代码到GIt时，经常会把项目根目录下的一些编译或输出文件自动添加进来，每次都得手动去掉勾选，十分浪费时间。为了解决此问题，GIt提供了<code>.gitignore</code>文件，来过滤不想提交的文件。</p><h1 id="安装-ignore插件"><a href="#安装-ignore插件" class="headerlink" title="安装.ignore插件"></a>安装.ignore插件</h1><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/2156204-20200924145218431-1980948028.png" alt="img"></p><h1 id="配置User-Templates"><a href="#配置User-Templates" class="headerlink" title="配置User Templates"></a>配置User Templates</h1><p>在IDE的设置中，搜索ignore，在<code>版本控制 - Ignore Files Support</code>的<code>User templates</code>中添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##ignore this file##</span><br><span class="line">/target/</span><br><span class="line">/.idea/</span><br><span class="line">/.settings/</span><br><span class="line">/.vscode/</span><br><span class="line">/bin/</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.idea</span><br><span class="line"> ##filter databfile、sln file##</span><br><span class="line">*.mdb</span><br><span class="line">*.ldb</span><br><span class="line">*.sln</span><br><span class="line">##class file##</span><br><span class="line">*.com</span><br><span class="line">*.class</span><br><span class="line">*.dll</span><br><span class="line">*.exe</span><br><span class="line">*.o</span><br><span class="line">*.so</span><br><span class="line"># compression file</span><br><span class="line">*.7z</span><br><span class="line">*.dmg</span><br><span class="line">*.gz</span><br><span class="line">*.iso</span><br><span class="line">*.jar</span><br><span class="line">*.rar</span><br><span class="line">*.tar</span><br><span class="line">*.zip</span><br><span class="line">*.via</span><br><span class="line">*.tmp</span><br><span class="line">*.err</span><br><span class="line">*.log</span><br><span class="line">*.iml</span><br><span class="line"># OS generated files #</span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br><span class="line">._*</span><br><span class="line">.Spotlight-V100</span><br><span class="line">.Trashes</span><br><span class="line">Icon?</span><br><span class="line">ehthumbs.db</span><br><span class="line">Thumbs.db</span><br><span class="line">.factorypath</span><br><span class="line">/.mvn/</span><br><span class="line">/mvnw.cmd</span><br><span class="line">/mvnw</span><br></pre></td></tr></table></figure><p>还有一些自己想要排除的，也可接着往下写</p><h2 id="规则模式"><a href="#规则模式" class="headerlink" title="规则模式"></a>规则模式</h2><ol><li>空行或以#开头的行被忽略。</li><li>标准的glob模式可以工作，并将递归地应用于整个工作树。</li><li>可以使用正斜杠(&#x2F;)开始模式，以避免递归。</li><li>您可以使用正斜杠(&#x2F;)来结束模式以指定目录。</li><li>你可以用感叹号(!)来否定一个模式。</li><li>可用如下正则表达式：</li></ol><ul><li><p>Glob模式类似于shell使用的简化正则表达式。</p></li><li><p>星号(*)匹配零个或多个字符;</p></li><li><p>[abc]匹配括号内的任何字符(在本例中是a、b或c);</p></li><li><p>问号(?)匹配单个字符;</p></li><li><p>用连字符分隔的括号([0-9])匹配它们之间的任何字符(在本例中是0到9)。</p></li><li><p>A &#x2F;**&#x2F;z将匹配A &#x2F;z, A &#x2F;b&#x2F;z, A &#x2F;b&#x2F;c&#x2F;z，等等。</p></li></ul><h1 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h1><p>在IDE终端中运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -f -r --cached . </span><br></pre></td></tr></table></figure><h1 id="提交-推送"><a href="#提交-推送" class="headerlink" title="提交&#x2F;推送"></a>提交&#x2F;推送</h1><p>然后就是正常的push了~</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/manshuoli/p/13724290.html">pycharm&#x2F;git ignore忽略操作 - lms21 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/x541211190/article/details/106052777">Intellij IDEA或Pycharm配置Git忽略文件.gitignore（最简单方式）_pycharm git 忽略idea-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_38880380/article/details/119789891">Git–排除文件的推送（使用.gitignore）_git 排除-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
            <tag> IDEA </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】Springboot 参数校验与全局异常处理</title>
      <link href="/p/7d49fec0/"/>
      <url>/p/7d49fec0/</url>
      
        <content type="html"><![CDATA[<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Spring Boot Validation 提供了一系列注解，用于在实体类中定义验证规则。以下是一些常用的校验相关的注解及其功能以及用法：</p><p>1.<strong><code>@NotNull</code>：</strong> 校验元素值不能为 null。如果元素为null，则验证失败。通常用于字段级别的验证。</p><p>2.<strong><code>@NotBlank</code>：</strong> 校验字符串元素值不能为 null 或空字符串。必须包含至少一个非空格字符(即执行trim()之后不为’’)。如果元素为null或者‘‘，则验证失败。通常用于<code>String</code>类型的字段校验。</p><p>3.<strong><code>NotEmpty</code>：</strong> 校验集合元素或数组元素或者字符串是否非空。通常作用于集合字段或数组字段，此时需要集合或者数字的元素个数大于0。也可以作用于字符串，此时校验字符串不能为null或空串（可以是一个空格）。注意与<code>@NotBlank</code>的使用区别。</p><p>4.<strong><code>@Length</code>：</strong> 校验字符串元素的长度。作用于字符串。</p><p>5.<strong><code>@Size</code>：</strong> 校验集合元素个数或字符串的长度在指定范围内。在集合或字符串字段上添加 <code>@Size</code> 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Size(min = 1, max = 10, message = &quot;Number of items must be between 1 and 10&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; items;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Size(min = 5, max = 20, message = &quot;Length must be between 5 and 20 characters&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>6.<strong><code>@Min</code>：</strong> 校验数字元素的最小值。</p><p>7.<strong><code>@Max</code>：</strong> 校验数字元素的最大值。</p><p>9.<strong><code>@DecimalMax</code>：</strong> 作用于<code>BigDecimal</code>类型字段， 校验字段的最大值，支持比较的值为字符串表示的十进制数。通常搭配它的<code>inclusive()</code>使用，区别边界问题。<code>value</code> 属性表示最大值，inclusive 属性表示是否包含最大值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DecimalMax(value = &quot;100.00&quot;, inclusive = true, message = &quot;Value must be less than or equal to 100.00&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BigDecimal amount;</span><br></pre></td></tr></table></figure><p>10.<strong><code>@DecimalMin</code>：</strong> 作用于<code>BigDecimal</code>类型字段， 校验字段的最小值，支持比较的值为字符串表示的十进制数。通常搭配它的<code>inclusive()</code>使用，区别边界问题。<code>value</code> 属性表示最小值，inclusive 属性表示是否包含最小值。</p><p>11.<strong><code>@Email</code>：</strong> 校验字符串元素是否为有效的电子邮件地址。可以通过<code>regexp</code>自定义邮箱匹配正则。</p><p>12.<strong><code>@Pattern</code>：</strong> 根据正则表达式校验字符串元素的格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pattern(regexp = &quot;[a-zA-Z0-9]+&quot;, message = &quot;Only alphanumeric characters are allowed&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>13.<strong><code>@Digits</code>：</strong> 校验数字元素的整数部分和小数部分的位数。作用于<code>BigDecimal</code>，<code>BigInteger</code>，字符串，以及<code>byte</code>, <code>short</code>,<code>int</code>, <code>long</code>以及它们的包装类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Digits(integer = 5, fraction = 2, message = &quot;Number must have up to 5 integer digits and 2 fraction digits&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BigDecimal amount;</span><br></pre></td></tr></table></figure><p>14.<strong><code>@Past</code>：</strong> 校验日期或时间元素是否在当前时间之前。即是否是过去时间。作用于Date相关类型的字段。</p><p>15.<strong><code>@Future</code>：</strong> 校验日期或时间元素是否在当前时间之后。即是否是未来时间。作用于Date相关类型的字段。</p><p>16.**<code>@AssertTrue</code>**：必须是true</p><p>17.**<code>@AssertFalse</code>**：必须是false</p><p>—— 2024&#x2F;05&#x2F;18 更新：</p><ol start="18"><li><code>@Valid</code>：注解校验提交的<code>List</code>、<code>Object</code>等，进行方法级验证，以及用于标记成员属性以进行验证。不过，该注解不支持分组验证。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min = 4, max = 15)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/saveBasicInfo&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveBasicInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;useraccount&quot;)</span> UserAccount useraccount, </span></span><br><span class="line"><span class="params">  BindingResult result, </span></span><br><span class="line"><span class="params">  ModelMap model)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在pojo层用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddress</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String countryCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAccount</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull(groups = AdvanceInfo.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserAddress useraddress;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="19"><li><code>@Validated</code>：对于分组级（Group-Level）验证，必须使用 Spring 的 <code>@Validated</code>，它是 JSR-303 的 <code>@Valid</code> 的变体，用于方法级。</li></ol><p>有时我们的入参是基本类型，例如使用<code>@RequestParam</code> 或<code>@PathVariable</code> 标记的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/validation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateController</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/boy-friends&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;BoyFriend&gt; <span class="title function_">updateBoyFriend</span><span class="params">(<span class="meta">@NotBlank</span> <span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要给参数添加上相应的约束注解，例如<code>@NotBlank</code>，然后再给Controller类添加上<code>@Validated</code>即可。</p><h3 id="分组验证"><a href="#分组验证" class="headerlink" title="分组验证"></a>分组验证</h3><p>有时一个类被多个方法使用，而每个方法对入参的要求却不一样，这种情况怎么办呢？例如我们的<code>BoyFriend</code>，里面有一个体重的属性，创建时要求不能高于85kg，由于条件苛刻，于是修改的时候要求不能高于100kg。</p><p>Spring提供了一种解决方法，那就是使用分组。每个注解里面都可以设置其属于哪些分组，在验证的时候只验证属于自己分组的那些约束。</p><p>例如我们这里设置两个分组：创建和更新，当调用创建方法的时候就只验证属于创建分组的约束，不高于85kg…</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoyFriend</span> &#123;</span><br><span class="line">    <span class="meta">@Max(groups = BoyFriendCreate.class, value = 85)</span></span><br><span class="line">    <span class="meta">@Max(groups = BoyFriendUpdate.class, value = 100)</span></span><br><span class="line">    <span class="keyword">private</span> Integer weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义分组</li></ul><p>分组必须是接口，例如我们这里定义了两个分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BoyFriendCreate</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BoyFriendUpdate</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给Controller方法添加分组</li></ul><p>先给Controller类添加<code>@Validated</code>，然后给方法添加带有分组信息的<code>@Validated</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated(BoyFriendUpdate.class)</span></span><br><span class="line">   <span class="meta">@PatchMapping(&quot;/boy-friends&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResponseEntity&lt;BoyFriend&gt; <span class="title function_">updateBoyFriend</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BoyFriend boy)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.ok(boy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>每个<code>Controller</code>方法中如果都写一遍<code>BindingResult</code>信息的处理还是很繁的。当我们写了<code>@validated</code>注解，不写<code>BindingResult</code>的时候，Spring 就会抛出异常。因此，我们可以通过全局异常处理的方式统一处理校验异常，从而免去重复编写异常信息的代码。全局异常处理类只需要在类上标注<code>@RestControllerAdvice</code>，并在处理相应异常的方法上使用<code>@ExceptionHandler</code>注解，写明处理哪个异常即可。</p><h2 id="全局异常处理类-GlobalExceptionHandler"><a href="#全局异常处理类-GlobalExceptionHandler" class="headerlink" title="全局异常处理类 GlobalExceptionHandler"></a>全局异常处理类 <code>GlobalExceptionHandler</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALID_FAIL_MSG</span> <span class="operator">=</span> <span class="string">&quot;参数检验不通过&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理 form data方式调用接口校验失败抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BindException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;String&gt;&gt; <span class="title function_">bindExceptionHandler</span><span class="params">(BindException e)</span> &#123;</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">        List&lt;String&gt; collect = fieldErrors.stream().map(o -&gt; o.getDefaultMessage()).toList();</span><br><span class="line">        <span class="keyword">return</span> Result.error(VALID_FAIL_MSG,collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  处理 json 请求体调用接口校验失败抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;String&gt;&gt; <span class="title function_">methodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">        List&lt;String&gt; collect = fieldErrors.stream().map(o -&gt; o.getDefaultMessage()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.error(VALID_FAIL_MSG,collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  处理单个参数校验失败抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;String&gt;&gt; <span class="title function_">constraintViolationExceptionHandler</span><span class="params">(ConstraintViolationException e)</span> &#123;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">        List&lt;String&gt; collect = constraintViolations.stream().map(o -&gt; o.getMessage()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.error(VALID_FAIL_MSG,collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理以上处理不了的其他异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(StringUtils.hasLength(e.getMessage())? e.getMessage() : <span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/dxiaol/article/details/88718186">@Valid 注解校验提交的List（list 集合） javax.validation.Valid_validlist-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/686882965">秒懂SpringBoot之参数验证全解析(@Validated与@Valid) - 知乎 (zhihu.com)</a></p><p><a href="https://springdoc.cn/spring-valid-vs-validated/">Spring 中 @Valid 和 @Validated 注解的区别 - spring 中文网 (springdoc.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】向春风（和声付）</title>
      <link href="/p/a9a25fcd/"/>
      <url>/p/a9a25fcd/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%90%91%E6%98%A5%E9%A3%8E_500.jpg"></p><p>已灌词，和声可能有扒错的，使用请注意！</p><p>BPM：70</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://y.qq.com/n/ryqq/songDetail/003FmDj52m2hg5">向春风 - 陈亦洺&#x2F;尚辰 - QQ音乐</a></p><p>作曲：陈亦洺</p><p>作词：予词</p><p>演唱：陈亦洺&#x2F;尚辰</p><p>和声：陈亦洺</p><p>编曲：孙煜东</p><p>混音：王近祯</p><p>母带：王近祯</p><p>监制：葡仙仙</p><p>海报：旧词</p><p>制作人：尚辰</p><p>发行：翼鸣音乐</p><p>大笛：笛呆子囚牛</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1qFy7tb2tNR25zwnBRaeLUg?pwd=jiy4">https://pan.baidu.com/s/1qFy7tb2tNR25zwnBRaeLUg?pwd=jiy4</a></p><p>提取码: jiy4</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>【陈亦洺】<br> 落雪覆盖了山  沿着江水蜿蜒<br> 春风吹破了雪  一眼望到天边</p><br><p>【尚辰】<br> 是谁翻山越海  还与往事纠缠<br> 越过千难万难  相思最难</p><br><p>【陈亦洺】<br> 走江南独留半阙唱段<br> 你在天涯那端与谁相见欢<br> 长夜漫漫孤单来作伴而我意阑珊</p><br><p>【尚辰】<br> 走江南春风又绿两岸<br> 今夜不睡让月色把酒斟满<br> 折一枝柳向着春风去不再回头看<br> 望江南</p><br><p>【尚辰】<br> 是谁翻山越海  还与往事纠缠</p><p>【陈亦洺】<br> 越过千难万难  相思最难</p><br><p>【尚辰】<br> 走江南独留半阙唱段<br> 你在天涯那端与谁相见欢<br> 长夜漫漫孤单来作伴而我意阑珊</p><br><p>【陈亦洺】<br> 走江南春风又绿两岸<br> 今夜不睡让月色把酒斟满<br> 折一枝柳向着春风去不再回头看<br> 望江南</p><br><p>【陈亦洺】<br> 走江南独留半阙唱段<br> 你在天涯那端与谁相见欢</p><br><p>【合唱】<br> 长夜漫漫孤单来作伴而我意阑珊<br> 走江南春风又绿两岸<br> 今夜不睡让月色把酒斟满<br> 折一枝柳向着春风去不再回头看<br> 望江南</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 陈亦洺 </tag>
            
            <tag> 尚辰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】UUID简介</title>
      <link href="/p/43bb383e/"/>
      <url>/p/43bb383e/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>UUID是通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，目的是让分布式系统中的所有元素，都能有唯一的辨识信息。</p><p>UUID是一个128比特的数值，这个数值可以通过一定的算法计算出来。为了提高效率，常用的UUID可缩短至16位。UUID用来识别属性类型，在所有空间和时间上被视为唯一的标识。一般来说，可以保证这个值是真正唯一的任何地方产生的任意一个UUID都不会有相同的值。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><font size="5" color="red">xxxxxxxx</font>—<font size="5" color="yellow">xxxx</font>—<font size="5" color="blue">xxxx</font>—<font size="5" color="orange">xxxx</font>—<font size="5" color="pink">xxxxxxxxxxxx</font></p><p><font color="red">8个十六进制数</font>—<font color="yellow">4个十六进制数</font>—<font color="blue">4个十六进制数</font>—<font color="orange">4个十六进制数</font>—<font color="pink">12个十六进制数</font></p><p>一共是<code>32</code>个十六进制数，<code>128bit</code>（和<code>IPV6</code>数目相等）。</p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>UUID具有多个版本，每个版本的算法不同，应用范围也不同。</p><h2 id="Version-1：基于时间的UUID"><a href="#Version-1：基于时间的UUID" class="headerlink" title="Version 1：基于时间的UUID"></a>Version 1<strong>：基于时间的UUID</strong></h2><p>基于时间的UUID通过计算<strong>当前时间戳</strong>、<strong>随机数</strong>和机器<strong>MAC地址</strong>得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址——Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。</p><h2 id="Version-2：DCE安全的UUID"><a href="#Version-2：DCE安全的UUID" class="headerlink" title="Version 2：DCE安全的UUID"></a>Version 2：DCE安全的UUID</h2><p>DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</p><h2 id="Version-3：基于名字的UUID（MD5）"><a href="#Version-3：基于名字的UUID（MD5）" class="headerlink" title="Version 3：基于名字的UUID（MD5）"></a>Version 3：基于名字的UUID（MD5）</h2><p>基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</p><h2 id="Version-4：随机UUID"><a href="#Version-4：随机UUID" class="headerlink" title="Version 4：随机UUID"></a>Version 4：随机UUID</h2><p>根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。</p><h2 id="Version-5：基于名字的UUID（SHA1）"><a href="#Version-5：基于名字的UUID（SHA1）" class="headerlink" title="Version 5：基于名字的UUID（SHA1）"></a>Version 5：基于名字的UUID（SHA1）</h2><p>和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</p><h1 id="获取UUID"><a href="#获取UUID" class="headerlink" title="获取UUID"></a>获取UUID</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UUID.randomUUID();  <span class="comment">//最常用，Version 4</span></span><br><span class="line">UUID.fromString(<span class="string">&quot;095c64fe-c5bf-11ea-aec6-a402b9e2b04d&quot;</span>);</span><br><span class="line">UUID.nameUUIDFromBytes(<span class="string">&quot;身份证号码&quot;</span>.getBytes()); <span class="comment">// Version 3</span></span><br></pre></td></tr></table></figure><ul><li><code>randomUUID()</code> 随机获取一个UUID，有极小的概率会重复</li><li><code>fromString()</code> 根据一个符合UUID格式的字符串获取，不常用，我都有了还获取干嘛。</li><li><code>nameUUIDFromBytes()</code> 根据一个字节数组获取，一般要求给定的字节数组不重复</li></ul><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">System.out.println(<span class="string">&quot;uuid.toString() = &quot;</span> + uuid.toString());</span><br><span class="line">System.out.println(<span class="string">&quot;uuid.version() = &quot;</span> + uuid.version());  <span class="comment">//版本号</span></span><br><span class="line">System.out.println(<span class="string">&quot;uuid.variant() = &quot;</span> + uuid.variant());  <span class="comment">//与该UUID相关的变体号码</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid.toString() = c68c4ead-e494-40be-a276-d5b5ef4b2c01</span><br><span class="line">uuid.version() = 4</span><br><span class="line">uuid.variant() = 2</span><br></pre></td></tr></table></figure><p>The variant number associated with this <code>UUID</code>. The variant number describes the layout of the <code>UUID</code>. The variant number has the following meaning:</p><ul><li>0：Reserved for NCS backward compatibility</li><li>2：<a href="http://www.ietf.org/rfc/rfc4122.txt">IETF RFC 4122</a> (Leach-Salz), used by this class</li><li>6：Reserved, Microsoft Corporation backward compatibility</li><li>7：Reserved for future definition</li></ul><p>剩下的看官方文档吧，反正也不常用（</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html">UUID (Java Platform SE 8 ) (oracle.com)</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_41621362/article/details/107344081">Java中的UUID简单介绍_uuid java-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/34876910">UUID是如何保证唯一性的？ - 知乎 (zhihu.com)</a></p><p><a href="https://baike.baidu.com/item/uuid/5921266">UUID_百度百科 (baidu.com)</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html">UUID (Java Platform SE 8 ) (oracle.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UUID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn.svm.SVC()参数解析</title>
      <link href="/p/b9aeb4/"/>
      <url>/p/b9aeb4/</url>
      
        <content type="html"><![CDATA[<p>sklearn.svm.SVC() 函数全称为 C-支持向量分类器 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sklearn</span>.svm.SVC(C=<span class="number">1.0</span>, kernel=’rbf’, degree=<span class="number">3</span>, gamma=’auto_deprecated’, </span><br><span class="line">coef0=<span class="number">0.0</span>, shrinking=<span class="literal">True</span>, probability=<span class="literal">False</span>, tol=<span class="number">0.001</span>, </span><br><span class="line">cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, verbose=<span class="literal">False</span>, max_iter=-<span class="number">1</span>, </span><br><span class="line">decision_function_shape=’ovr’, random_state=<span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>float，optional (default &#x3D; 1.0)</p><p>错误术语的惩罚参数<code>C</code>。<code>C</code>越大，相当于惩罚松弛变量，希望松弛变量接近0，即对误分类的惩罚增大，趋向于对训练集全分对的情况，这样对训练集测试时准确率很高，但容易<strong>过拟合</strong>，泛化能力弱。<code>C</code>值小，对误分类的惩罚减小，允许容错，将他们当成噪声点，泛化能力较强。</p><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p>string，optional (default &#x3D; ‘rbf’)</p><p>核函数类型，str类型，默认为’rbf’。可选参数为：</p><ul><li><code>linear</code>：线性核函数</li><li><code>poly</code>：多项式核函数</li><li><code>rbf</code>：径像核函数&#x2F;高斯核</li><li><code>sigmod</code>：sigmod核函数</li><li><code>precomputed</code>：核矩阵</li></ul><p>precomputed表示自己提前计算好核函数矩阵，这时候算法内部就不再用核函数去计算核矩阵，而是直接用你给的核矩阵，核矩阵需要为n*n的。</p><h3 id="degree"><a href="#degree" class="headerlink" title="degree"></a>degree</h3><p>int，optional (default &#x3D; 3)</p><p>多项式核函数的阶数，int类型，可选参数，默认为3。这个参数只对多项式核函数有用，是指多项式核函数的阶数n，如果给的核函数参数是其他核函数，则会自动忽略该参数。</p><h3 id="gamma"><a href="#gamma" class="headerlink" title="gamma"></a>gamma</h3><p>float，optional (default &#x3D; ‘auto’)</p><p>核函数系数，float类型，可选参数，默认为<code>auto</code>。只对’rbf’ ,’poly’ ,’sigmod’有效。如果<code>gamma</code>为<code>auto</code>，代表其值为样本特征数的倒数，即<code>1/n_features</code>。</p><h3 id="coef0"><a href="#coef0" class="headerlink" title="coef0"></a>coef0</h3><p>float，optional (default &#x3D; 0.0)</p><p>核函数中的独立项，float类型，可选参数，默认为0.0。只有对 ’poly’ 和 ’sigmod’ 核函数有用，是指其中的参数c。</p><h3 id="shrinking"><a href="#shrinking" class="headerlink" title="shrinking"></a>shrinking</h3><p>bool, optional (default &#x3D; True)</p><p>是否采用启发式收缩方式，bool类型，可选参数，默认为True。</p><p>启发式收缩方式就是：如果能预知哪些变量对应着支持向量，则只要在这些样本上训练就够了，其他样本可不予考虑，这不影响训练结果，但降低了问题的规模并有助于迅速求解，起到一个加速训练的效果。</p><h3 id="probability"><a href="#probability" class="headerlink" title="probability"></a>probability</h3><p>bool, optional (default &#x3D; True)</p><p>是否启用概率估计，bool类型，可选参数，默认为False，这必须在调用fit()之前启用，并且会fit()方法速度变慢。</p><h3 id="tol"><a href="#tol" class="headerlink" title="tol"></a>tol</h3><p>float，optional (default &#x3D; 1e-3)</p><p>svm停止训练的误差精度，float类型，可选参数，默认为1e^-3。</p><h3 id="cache-size"><a href="#cache-size" class="headerlink" title="cache_size"></a>cache_size</h3><p>float，optional (default &#x3D; 200)</p><p>内存大小，float类型，可选参数，默认为200。指定训练所需要的内存，以MB为单位，默认为200MB。</p><h3 id="class-weight"><a href="#class-weight" class="headerlink" title="class_weight"></a>class_weight</h3><p>{dict，‘balanced’}，可选</p><p>类别权重，dict类型或str类型，可选参数，默认为None。给每个类别分别设置不同的惩罚参数C，如果没有给，则会给所有类别都给C&#x3D;1，即前面参数指出的参数C。如果给定参数’balance’，则使用y的值自动调整与输入数据中的类频率成反比的权重。</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="verbose"></a>verbose</h3><p>bool, optional (default &#x3D; False)</p><p>是否启用详细输出，bool类型，默认为False，此设置利用libsvm中的每个进程运行时设置，如果启用，可能无法在多线程上下文中正常工作。一般情况都设为False，不用管它。</p><h3 id="max-iter"><a href="#max-iter" class="headerlink" title="max_iter"></a>max_iter</h3><p>int，optional (default &#x3D; -1)</p><p>最大迭代次数，int类型，默认为-1，表示不限制。</p><h3 id="decision-function-shape"><a href="#decision-function-shape" class="headerlink" title="decision_function_shape"></a>decision_function_shape</h3><p>‘ovo’，‘ovr’，默认&#x3D;‘ovr’</p><p>决策函数类型，可选参数’ovo’和’ovr’，默认为’ovr’。’ovo’表示one vs one，’ovr’表示one vs rest。</p><p>决定了分类时，是一对多的方式来构建超平面，还是一对一。</p><p>一对多：训练时依次把某个类别的样本归为一类，其他剩余的样本归为另一类，这样k个类别的样本就构造出了k个SVM。分类时将未知样本分类为具有最大分类函数值的那类。</p><p>一对一：其做法是在任意两类样本之间设计一个SVM，因此k个类别的样本就需要设计k(k-1)&#x2F;2个SVM。当对一个未知样本进行分类时，最后得票最多的类别即为该未知样本的类别。Libsvm中的多类分类就是根据这个方法实现的。</p><h3 id="random-state"><a href="#random-state" class="headerlink" title="random_state"></a>random_state</h3><p>int，RandomState实例或None，可选(默认&#x3D;无)</p><p>数据洗牌时的种子值，int类型，可选参数，默认为None。伪随机数发生器的种子,在混洗数据时用于概率估计。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/transformed/article/details/90437821">sklearn中SVC中的参数说明与常用函数_svc参数-CSDN博客</a></p><p><a href="https://blog.csdn.net/TeFuirnever/article/details/99646257">sklearn.svm.SVC()函数解析（最清晰的解释）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】墨隐侠声【忘川风华录·墨子】</title>
      <link href="/p/52eaf228/"/>
      <url>/p/52eaf228/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E5%A2%A8%E9%9A%90%E4%BE%A0%E5%A3%B0.jpg" alt="墨隐侠声"></p><p>已灌词~</p><p>BPM：135</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/video/BV1oJ4m147eN/?spm_id_from=444.41.header_right.history_list.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【忘川风华录·墨子】墨隐侠声【乐正龙牙原创】 “赴火蹈刃去 纵死不折腰”</a></p><p>企划运营：酷丘</p><p>演唱：乐正龙牙</p><p>调校：Creuzer | 作词：怀袖</p><p>作曲：潮汐-tide | 编曲&#x2F;分轨：1AN孙毅然</p><p>吉他实录：RK | Bass实录：1AN孙毅然 | 笛箫：囚牛</p><p>和声编写：沈雾敛 | 混音：Mr_曾经</p><p>曲绘：雪代薰、杉里沐</p><p>PV：宇言今年發發發、茶茶今年旺旺旺</p><p>协力：竹篮子、玄林</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1MYSpeL-FcAnzlFWaMkOY4w?pwd=eqmb">https://pan.baidu.com/s/1MYSpeL-FcAnzlFWaMkOY4w?pwd=eqmb</a></p><p>提取码: eqmb</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>命数何堪考 破衫亦有朗月照</p><p>赤足踏绝地 苦旅不辞遥</p><p> 灯火聚江河 人与君贤共怀抱</p><p>耕织法道 云泥同老</p> <br><p>奈何悲风起 势崩雷电魂飘摇</p><p>将军一泼酒 身后万骨销</p><p>离散不相和 落得胜败俱枯焦</p><p>义重于心 如何不煎熬</p> <br><p>弃他鸿儒道 偏筑众生桥</p><p>一石一木 凭血汗呼告</p><p>弦满破空来 钩绳连弩转机巧</p><p>遥指千军付一笑</p> <br><p>赴火蹈刃去 纵死不折腰</p><p>指掌泥泞 拦血海浪潮</p><p>蚍蜉起阵列 城中意滔滔</p><p>敢教时运捍今朝</p> <br><p>故人围故城 中有哀声可知晓</p><p>血肉捱饥寒 四时尽萧条</p><p>抬眸洞风云 不惧锋芒再相交</p><p>方能止戈 同安昏晓</p> <br><p>是时逢落雨 城门弃我于山道</p><p>笑人间烦恼 功者也难逃</p><p>躬身于群臣 但求君贤听吾道</p><p>至理真心 或可不寂寥</p> <br><p>弃他鸿儒道 偏筑众生桥</p><p>生灵岂能 因礼乐潦草</p><p>万民身在前 血脉贵贱俱可抛</p><p>神鬼眼中同辛劳</p> <br><p>赴火蹈刃去 纵死不折腰</p><p>人海宫阙 同览明月皎</p><p>兼爱之无涯 执义字昭昭</p><p>莫愁前路知音少</p> <br><p>万古江流 转身又续悲凉稿</p><p>墨隐如烟 今日谁能料</p> <br><p>回首望山河 万里星动摇</p><p>浩浩晚风 将人世观照</p><p>须臾同悲欢 千秋唯有浊酒浇</p><p>亦痛亦快 生未杳</p> <br><p>再望世路艰 悬崖生春草</p><p>残垣尽处 烟火自缭绕</p><p>黄土与高天 苍生双肩挑</p><p>筑世于尘 心未凋</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 忘川风华录 </tag>
            
            <tag> 乐正龙牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】仙舟旧纪（和声付）【崩坏：星穹铁道】</title>
      <link href="/p/4be90d2f/"/>
      <url>/p/4be90d2f/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E4%BB%99%E8%88%9F%E6%97%A7%E7%BA%AA.jpg" alt="仙舟旧纪"></p><p>已灌词（但没校对），和声可能有扒错的，使用请注意！</p><p>BPM：132</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/festival/honkaistarrail2024spring?bvid=BV1oZ421B7RM&spm_id_from=333.788.top_right_bar_window_default_collection.content.click"><strong>【星穹铁道新春会】仙舟罗浮印象燃曲《仙舟旧纪》</strong></a></p><p>作曲：KBShinya</p><p>作词：冉语优</p><p>编曲：向往</p><p>演唱：赤羽</p><p>调校：坐标P</p><p>混音：圈太Studio</p><p>笛子：囚牛</p><p>吉他：大牛</p><p>琵琶：余天易</p><p>和声编配&#x2F;人声吟唱：KBShinya</p><p>曲绘监修：姆姆mumumu</p><p>曲绘：-柏南-、饼喵松风、粉皮pi、高速旋转三文鱼、叫明明8、涟光、南瓜酱、瑞兰缇、叁猫白米饭、山参、为半、晓白说想睡觉、BAIYA_57、Clear-water、eeni、Enoch、ovosaki、Raku</p><p>导演：浮玉酱</p><p>视频制作：像素山海</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1Lkljs29cWSPeP1yFgc_jSA?pwd=2rxy">https://pan.baidu.com/s/1Lkljs29cWSPeP1yFgc_jSA?pwd=2rxy</a></p><p>提取码: 2rxy</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>昔有九艨冲 应帝诏求长生</p><p>远辞天阙接羽使 复遏仙宫</p><p>乘槎沧海隅 开天壤迎尘风</p><p>补天法眼中 翾翔探虚空</p><br><p>翾翔安有穷 逢敌诹沉仙艟</p><p>岱與翻涛殉火后 此兆始凶</p><p>金人乱三众 百馀战交兵戎</p><p>岁阳常闻见 狭路今更逢</p> <br><p>时有英雄 重侠不与世同</p><p>张胆轻生 数奇可当万师功</p><p>不见乱云如流夜烧红</p><p>人天讵无力 仙道更昌隆</p><br><p>药王垂 若木荣 罗浮祸无终</p><p>耄耋少年千岁翁 形寿以血肉供</p><p>欲向旧道归前踪 重树已遮空</p><p>星寰寥落绝交通 绝交通 仙舟转征蓬</p><p>不死不老迷航云汉中</p> <br><p>翾翔安有尽 罹三劫与日近</p><p>圆峤失道绝音讯 迹再难寻</p><p>四邻罔不惊 哀萌后思渐盈</p><p>坐谈共睦音 同誓会盟心</p><br><p>时有穹桑 挥甲戈忽然侵</p><p>雷动风行 天上矫躩地骎骎</p><p>不见万骑孤军蔽如云</p><p>生且不惜命 死亦助神灵</p><br><p>看帝弓 神气凝 长虚望太清</p><p>桑弧满张混沌惊 抬箭一指天垠</p><p>激弦贯风断若木 身去化寰星</p><p>衔珠君子御龙庭 御龙庭 云吟随势倾</p><p>一日千日永世镇太平</p> <br><p>君不见 又千年 苍城侵</p><p>万舲坠去 魂灭仍有灵</p><p>此身 如月曜星 如日光明</p><br><p>挥敕封 七将星 荡孽寇扫妖兵</p><p>万里驱天策电霆 奉号令无不钦</p><p>莫叹常胜总将军 白首事事新</p><p>宇宙无穷历苦辛 历苦辛 天海终扬名</p><p>巡猎不死永不止航行</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 崩坏：星穹铁道 </tag>
            
            <tag> 赤羽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】逆光 (live)【声生不息·家年华】</title>
      <link href="/p/ed500d41/"/>
      <url>/p/ed500d41/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E9%80%86%E5%85%89.jpg" alt="逆光"></p><p>已灌词~</p><p>BPM：87（变速）</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.mgtv.com/b/605259/20386670.html">《逆光》 - 高清视频在线观看 - 芒果TV (mgtv.com)</a></p><p>演唱：周深、陈楚生</p><p>作词 : 廖莹如</p><p>作曲 : 李伟菘</p><p>编曲 : Terence Teo</p><p>制作人 : 汤佩弦@牛班NEWBAND&#x2F;谷粟</p><p>作词：廖莹如  作曲：李伟菘</p><p>原唱：孙燕姿</p><p>SP：Universal Music Publishing CHINA&#x2F;华纳盛世音乐版权代理（北京）有限公司&#x2F;北京伟思音乐文化传播有限公司</p><p>音乐总监：谷粟@牛班NEWBAND</p><p>音响总监：何飚</p><p>舞台总监：李柯</p><p>舞蹈总监：莫小斐@ShowPro</p><p>艺术顾问：金兆钧</p><p>音乐设计：王皓@WONDERWALL</p><p>制作人：汤佩弦@牛班 NEWBAND&#x2F;谷粟@牛班NEWBAND</p><p>改编编曲：Terence Teo</p><p>混音：林梦洋</p><p>乐队队长：董音@牛班NEWBAND</p><p>键盘：董音@牛班NEWBAND&#x2F;洪信杰@牛班NEWBAND</p><p>吉他：黄仲贤@牛班NEWBAND&#x2F;毕赫宸@牛班NEWBAND</p><p>贝斯：宣一亨@牛班NEWBAND</p><p>鼓：郝稷伦@牛班NEWBAND</p><p>打击乐：郑瑀@牛班NEWBAND</p><p>和音：王梓琼@牛班NEWBAND&#x2F;杨画画@牛班NEWBAND</p><p>李郡洲@牛班NEWBAND&#x2F;张石荻@牛班NEWBAND</p><p>PGM：郭锦阳@牛班NEWBAND</p><p>弦乐：刘星弦乐团</p><p>舞蹈指导：莫小斐@ShowPro&#x2F;麦茵茹@ShowPro</p><p>合唱团：牛班合唱团@牛班NEWBAND &#x2F;湖南工商大学音乐学院长风合唱团 &#x2F;湖南信息学院</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1fKjpCwo-aDWomivteQmBfA?pwd=dnb6">https://pan.baidu.com/s/1fKjpCwo-aDWomivteQmBfA?pwd=dnb6</a></p><p>提取码: dnb6</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>【周深】</p><p>也许我一直害怕有答案</p><p>【合】</p><p>也许爱静静在风里打转</p><p>离开 释怀</p><p>很短暂又重来</p><p>有时候自问自答</p><p>【周深】</p><p>我不要困难把我们挤散</p><p>我责备自己那么不勇敢</p><p>遗憾没有到达</p><p>拥抱过还是害怕</p><p>用力推开你我依然留下</p><p>【合】</p><p>有一束光 那瞬间</p><p>是什么痛得刺眼</p><p>你的视线 是谅解</p><p>为什么舍不得熄灭</p><p>我逆着光 却看见</p><p>那是泪光 那力量</p><p>【周深】</p><p>我不想再去抵挡</p><p>【合】</p><p>面对希望 逆着光</p><p>【周深】</p><p>感觉爱存在的地方</p><p>一直就在</p><p>【合】</p><p>我身旁</p><p>【陈楚生】</p><p>我不要困难把我们挤散</p><p>我责备自己那么不勇敢</p><p>遗憾没有到达</p><p>拥抱过还是害怕</p><p>用力推开你我依然留下</p><p>【合】</p><p>有一束光</p><p>【陈楚生】</p><p>那瞬间 是什么痛得刺眼</p><p>【合】</p><p>你的视线</p><p>【陈楚生】</p><p>是谅解</p><p>【合】</p><p>为什么舍不得熄灭</p><p>我逆着光却看见</p><p>那是泪光 那力量</p><p>【陈楚生】</p><p>我不想再去</p><p>【合】</p><p>抵挡</p><p>【陈楚生】</p><p>面对希望 逆着光</p><p>【合】</p><p>感觉爱存在的地方</p><p>一直都在我身旁</p><p>我以为我能后退反复证明</p><p>这份爱有多不对</p><p>【周深】：</p><p>背对着你如此</p><p>【合】：漆黑</p><p>【周深】：</p><p>忍住</p><p>【合】：疲惫</p><p>睁开眼 打开窗</p><p>才发现你就是光芒</p><p>有一束光 那瞬间</p><p>是什么痛得刺眼</p><p>你的视线 是谅解</p><p>为什么舍不得熄灭</p><p>我逆着光 却看见（【周深】：我逆着光 【陈楚生】：却看见）</p><p>【合】</p><p>那是泪光 那力量</p><p>【周深】</p><p>我不想再去抵挡</p><p>【合】</p><p>面对希望 逆着光</p><p>【周深】</p><p>感觉爱存在的地方</p><p>一直就在</p><p>【合】</p><p>我身旁</p><p>（那是泪光 那力量）</p><p>【陈楚生】</p><p>面对希望 逆着光</p><p>【合】</p><p>那是泪光 那力量</p><p>面对希望 逆着光</p><p>你是光芒</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周深 </tag>
            
            <tag> 无参 </tag>
            
            <tag> 声生不息·家年华 </tag>
            
            <tag> 陈楚生 </tag>
            
            <tag> 孙燕姿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】红尘共长生（和声付）【未定事件簿】</title>
      <link href="/p/dcfbc8e5/"/>
      <url>/p/dcfbc8e5/</url>
      
        <content type="html"><![CDATA[<p>![红尘共长生](<a href="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E3%80%90%E5%8F%A4%E9%A3%8E%E5%90%88%E5%94%B1%E3%80%91%E3%80%8C%E7%BA%A2%E5%B0%98%E5%85%B1%E9%95%BF%E7%94%9F%E3%80%8D%E7%9C%8B%E5%80%A6%E9%95%BF%E7%94%9F%E9%83%BD%E5%8F%AA%E4%B8%BA">https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/【古风合唱】「红尘共长生」看倦长生都只为</a> 看红尘【三无KBShinya陈亦洺哦漏吾恩】【未定事件簿新春会】.jpg)</p><p>已灌词，和声可能有误，使用请注意</p><p>BPM：84</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/video/BV17F4m1376c/">BV17F4m1376c</a></p><p>演唱：三无&#x2F;KBShinya&#x2F;陈亦洺&#x2F;哦漏&#x2F;吾恩</p><p>作曲：塔库</p><p>作词：冉语优</p><p>编曲：1AN孙毅然</p><p>吉他：大牛</p><p>Bass：1AN孙毅然</p><p>笛箫：囚牛</p><p>和声：KBShinya&#x2F;雾敛</p><p>混音&#x2F;母带：圈太</p><p>视频：浮玉酱</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><h2 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h2><p>链接: <a href="https://pan.baidu.com/s/1c0AncrHFkGurUU_YkhUlag?pwd=f54s">https://pan.baidu.com/s/1c0AncrHFkGurUU_YkhUlag?pwd=f54s</a></p><p>提取码: f54s</p><h2 id="vsqx站"><a href="#vsqx站" class="headerlink" title="vsqx站"></a>vsqx站</h2><p><a href="https://www.vsqx.top/project/vn9929">【无参】红尘共长生（和声付）【未定事件簿】 (vsqx.top)</a></p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>【陈亦洺】</p><p>镜观多少世 沧海起乱尘</p><p>我心匪石愿以命与天争</p><p>【三无】</p><p>偶然人间望一眼 一瞬换一生</p><p>何幸最后与你 共醉几千春</p><p>【KB】</p><p>一息救孤魂 一命为苍生</p><p>心中纳天地何处容爱人</p><p>【吾恩】</p><p>白梅为剑雪纷纷</p><p>向死如能忘却生</p><p>梦魂相逢也该 奋不顾身</p><p>【哦漏、KB】</p><p>这人间 劫波滚滚 云旷海深</p><p>跌宕几千程</p><p>百年前梦过梦</p><p>千年才成真</p><p>【陈亦洺、吾恩】</p><p>天河随处作枕</p><p>若不见你 眼中数星灯</p><p>三万夜 凭风向谁奔</p> <br><p>【哦漏】</p><p>飞鸟见林依 枯木不知春</p><p>一朝天劫困渡谁改命轮</p><p>【KB】</p><p>从此身做神仙身 心是人间人</p><p>笑说此生未了 何以问来生</p><p>【陈亦洺】</p><p>符上朱砂痕 写来刻碑深</p><p>先忘前尘事再拜相思门</p><p>【吾恩】</p><p>长命未负当年身</p><p>长情应许眼前人</p><p>与你永以为好 天合地衬</p><p>【三无、陈亦洺】</p><p>这人间 劫波滚滚 若我未能</p><p>挣开些离分</p><p>天地轻易怎肯</p><p>成全有情人</p><p>【哦漏、吾恩】</p><p>明河随处作枕</p><p>若不见你 眼中数星灯</p><p>三万夜 凭风向谁奔</p><p>【三无】</p><p>前世天涯客</p><p>今世赏花人</p><p> 看倦长生都只为 看红尘</p><p>【全员】</p><p>这人间 劫波滚滚 云旷海深</p><p>跌宕几千程</p><p>百年前梦过梦</p><p>千年便成真</p> <br><p>借月眉目温存</p><p>凝眸看你 眼中万星灯</p><p>天地中 此刻最动人</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 未定事件簿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】Semantic &amp; Sentiment Analysis</title>
      <link href="/p/240e5e52/"/>
      <url>/p/240e5e52/</url>
      
        <content type="html"><![CDATA[<h1 id="Semantic-Analysis"><a href="#Semantic-Analysis" class="headerlink" title="Semantic Analysis"></a>Semantic Analysis</h1><p>draws <strong>meaning</strong> from natural language text, considers signs and symbols(semiotics) and collocations(words that often go together)</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><h3 id="Classification-Models"><a href="#Classification-Models" class="headerlink" title="Classification Models"></a>Classification Models</h3><p>Topic Classification</p><p>Sentiment Analysis</p><p>Intent Classification</p><h3 id="Extraction-Models"><a href="#Extraction-Models" class="headerlink" title="Extraction Models"></a>Extraction Models</h3><p>Keyword Extraction</p><p>Entity Extraction</p><h2 id="Word-Vectors"><a href="#Word-Vectors" class="headerlink" title="Word Vectors"></a>Word Vectors</h2><p>Word vectors - also called <em>word embeddings</em> - are mathematical descriptions of individual words such that words that appear frequently together in the language will have similar values. In this way we can mathematically derive <em>context</em>. As mentioned above, the word vector for “lion” will be closer in value to “cat” than to “dandelion”.</p><p>In <code>en_core_web_md</code>, there are 20k unique vectors (300 dimensions).</p><p>What’s interesting is that Doc and Span objects themselves have vectors, derived from the averages of individual token vectors.<br>This makes it possible to compare similarities between whole documents.</p><h3 id="Identifying-similar-vectors"><a href="#Identifying-similar-vectors" class="headerlink" title="Identifying similar vectors"></a>Identifying similar vectors</h3><p>The best way to expose vector relationships is through the <code>.similarity()</code> method of Doc tokens.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a three-token Doc object:</span></span><br><span class="line">tokens = nlp(<span class="string">u&#x27;dog cat monkey&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate through token combinations:</span></span><br><span class="line"><span class="keyword">for</span> token1 <span class="keyword">in</span> tokens:</span><br><span class="line">    <span class="keyword">for</span> token2 <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="built_in">print</span>(token1.text, token2.text, token1.similarity(token2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dog dog 1.0</span><br><span class="line">dog cat 0.80168545</span><br><span class="line">dog monkey 0.47752646</span><br><span class="line">cat dog 0.80168545</span><br><span class="line">cat cat 1.0</span><br><span class="line">cat monkey 0.5351813</span><br><span class="line">monkey dog 0.47752646</span><br><span class="line">monkey cat 0.5351813</span><br><span class="line">monkey monkey 1.0</span><br></pre></td></tr></table></figure><p><font color=green>Note that order doesn’t matter. <code>token1.similarity(token2)</code> has the same value as <code>token2.similarity(token1)</code>.</font></p><h3 id="Opposites-are-not-necessarily-different"><a href="#Opposites-are-not-necessarily-different" class="headerlink" title="Opposites are not necessarily different"></a>Opposites are not necessarily different</h3><p>Words that have opposite meaning, but that often appear in the same <em>context</em> may have similar vectors.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a three-token Doc object:</span></span><br><span class="line">tokens = nlp(<span class="string">u&#x27;like love dislike hate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate through token combinations:</span></span><br><span class="line"><span class="keyword">for</span> token1 <span class="keyword">in</span> tokens:</span><br><span class="line">    <span class="keyword">for</span> token2 <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="built_in">print</span>(token1.text, token2.text, token1.similarity(token2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like like 1.0</span><br><span class="line">like love 0.65790397</span><br><span class="line">like dislike 0.5194136</span><br><span class="line">like hate 0.6574652</span><br><span class="line">love like 0.65790397</span><br><span class="line">love love 1.0</span><br><span class="line">love dislike 0.49095604</span><br><span class="line">love hate 0.6393099</span><br><span class="line">dislike like 0.5194136</span><br><span class="line">dislike love 0.49095604</span><br><span class="line">dislike dislike 1.0</span><br><span class="line">dislike hate 0.77664256</span><br><span class="line">hate like 0.6574652</span><br><span class="line">hate love 0.6393099</span><br><span class="line">hate dislike 0.77664256</span><br><span class="line">hate hate 1.0</span><br></pre></td></tr></table></figure><h3 id="Vector-norms"><a href="#Vector-norms" class="headerlink" title="Vector norms"></a>Vector norms</h3><p>It’s sometimes helpful to aggregate 300 dimensions into a <a href="https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm">Euclidian (L2) norm</a>, computed as the square root of the sum-of-squared-vectors. This is accessible as the <code>.vector_norm</code> token attribute. Other helpful attributes include <code>.has_vector</code> and <code>.is_oov</code> or <em>out of vocabulary</em>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tokens = nlp(<span class="string">u&#x27;dog cat nowaythere&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">    <span class="built_in">print</span>(token.text, token.has_vector, token.vector_norm, token.is_oov)</span><br><span class="line"><span class="comment">#dog True 7.0336733 False</span></span><br><span class="line"><span class="comment">#cat True 6.6808186 False</span></span><br><span class="line"><span class="comment">#nowaythere False 0.0 True</span></span><br></pre></td></tr></table></figure><h3 id="Vector-arithmetic"><a href="#Vector-arithmetic" class="headerlink" title="Vector arithmetic"></a>Vector arithmetic</h3><p>Believe it or not, we can actually calculate new vectors by adding &amp; subtracting related vectors. A famous example suggests</p><pre>"king" - "man" + "woman" = "queen"</pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line">cosine_similarity = <span class="keyword">lambda</span> x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line">king = nlp.vocab[<span class="string">&#x27;king&#x27;</span>].vector</span><br><span class="line">man = nlp.vocab[<span class="string">&#x27;man&#x27;</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">&#x27;woman&#x27;</span>].vector</span><br><span class="line"></span><br><span class="line">queen = nlp.vocab[<span class="string">&#x27;queen&#x27;</span>].vector</span><br><span class="line"></span><br><span class="line">new_vector = king - man + woman</span><br><span class="line"></span><br><span class="line">cosine_similarity(new_vector, queen)</span><br><span class="line"><span class="comment">#0.7880843877792358</span></span><br><span class="line"></span><br><span class="line">cosine_similarity(new_vec, woman)</span><br><span class="line"><span class="comment">#0.5150813460350037</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Now we find the closest vector in the vocabulary to the result of &quot;man&quot; - &quot;woman&quot; + &quot;queen&quot;</span></span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="comment"># Ignore words without vectors and mixed-case words:</span></span><br><span class="line">    <span class="keyword">if</span> word.has_vector:</span><br><span class="line">        <span class="keyword">if</span> word.is_lower:</span><br><span class="line">            <span class="keyword">if</span> word.is_alpha:</span><br><span class="line">                similarity = cosine_similarity(new_vector, word.vector)</span><br><span class="line">                computed_similarities.append((word, similarity))</span><br><span class="line"></span><br><span class="line">computed_similarities = <span class="built_in">sorted</span>(computed_similarities, key=<span class="keyword">lambda</span> item: -item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([w[<span class="number">0</span>].text <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br><span class="line"><span class="comment">#[&#x27;king&#x27;, &#x27;queen&#x27;, &#x27;commoner&#x27;, &#x27;highness&#x27;, &#x27;prince&#x27;, &#x27;sultan&#x27;, &#x27;maharajas&#x27;, &#x27;princes&#x27;, &#x27;kumbia&#x27;, &#x27;kings&#x27;]</span></span><br></pre></td></tr></table></figure><h1 id="Sentiment-Analysis"><a href="#Sentiment-Analysis" class="headerlink" title="Sentiment Analysis"></a>Sentiment Analysis</h1><p>detects polarity(e.g., positive or negative opinion) within the text and emotions, urgency and intentions</p><h2 id="VADER"><a href="#VADER" class="headerlink" title="VADER"></a>VADER</h2><p>Valence Aware Dictionary for Sentiment Reasoning is a model in NLTK</p><p><strong>Download the VADER lexicon.</strong> You only need to do this once.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">nltk.download(<span class="string">&#x27;vader_lexicon&#x27;</span>)</span><br></pre></td></tr></table></figure><p>VADER’s <code>SentimentIntensityAnalyzer()</code> takes in a string and returns a dictionary of scores in each of four categories:</p><ul><li>negative</li><li>neutral</li><li>positive</li><li>compound <em>(computed by normalizing the scores above)</em></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.sentiment.vader <span class="keyword">import</span> SentimentIntensityAnalyzer</span><br><span class="line"></span><br><span class="line">sid = SentimentIntensityAnalyzer()</span><br><span class="line">a = <span class="string">&#x27;This was a good movie.&#x27;</span></span><br><span class="line">sid.polarity_scores(a)</span><br><span class="line"><span class="comment">#&#123;&#x27;neg&#x27;: 0.0, &#x27;neu&#x27;: 0.508, &#x27;pos&#x27;: 0.492, &#x27;compound&#x27;: 0.4404&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;This was the best, most awesome movie EVER MADE!!!&#x27;</span></span><br><span class="line">sid.polarity_scores(a)</span><br><span class="line"><span class="comment">#&#123;&#x27;neg&#x27;: 0.0, &#x27;neu&#x27;: 0.425, &#x27;pos&#x27;: 0.575, &#x27;compound&#x27;: 0.8877&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;This was the worst film to ever disgrace the screen.&#x27;</span></span><br><span class="line">sid.polarity_scores(a)</span><br><span class="line"><span class="comment">#&#123;&#x27;neg&#x27;: 0.477, &#x27;neu&#x27;: 0.523, &#x27;pos&#x27;: 0.0, &#x27;compound&#x27;: -0.8074&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Use-VADER-to-analyze-Amazon-Reviews"><a href="#Use-VADER-to-analyze-Amazon-Reviews" class="headerlink" title="Use VADER to analyze Amazon Reviews"></a>Use VADER to analyze Amazon Reviews</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;amazonreviews.tsv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">df.head()</span><br><span class="line"><span class="comment"># REMOVE NaN VALUES AND EMPTY STRINGS:</span></span><br><span class="line">df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">blanks = []  <span class="comment"># start with an empty list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,lb,rv <span class="keyword">in</span> df.itertuples():  <span class="comment"># iterate over the DataFrame</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(rv)==<span class="built_in">str</span>:            <span class="comment"># avoid NaN values</span></span><br><span class="line">        <span class="keyword">if</span> rv.isspace():         <span class="comment"># test &#x27;review&#x27; for whitespace</span></span><br><span class="line">            blanks.append(i)     <span class="comment"># add matching index numbers to the list</span></span><br><span class="line"></span><br><span class="line">df.drop(blanks, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sid.polarity_scores(df.loc[<span class="number">0</span>][<span class="string">&#x27;review&#x27;</span>])</span><br><span class="line"><span class="comment">#&#123;&#x27;neg&#x27;: 0.088, &#x27;neu&#x27;: 0.669, &#x27;pos&#x27;: 0.243, &#x27;compound&#x27;: 0.9454&#125;</span></span><br><span class="line">df.loc[<span class="number">0</span>][<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line"><span class="comment">#&#x27;pos&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Adding-Scores-and-Labels-to-the-DataFrame"><a href="#Adding-Scores-and-Labels-to-the-DataFrame" class="headerlink" title="Adding Scores and Labels to the DataFrame"></a>Adding Scores and Labels to the DataFrame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;scores&#x27;</span>] = df[<span class="string">&#x27;review&#x27;</span>].apply(<span class="keyword">lambda</span> review: sid.polarity_scores(review))</span><br><span class="line">df[<span class="string">&#x27;compound&#x27;</span>]  = df[<span class="string">&#x27;scores&#x27;</span>].apply(<span class="keyword">lambda</span> score_dict: score_dict[<span class="string">&#x27;compound&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;comp_score&#x27;</span>] = df[<span class="string">&#x27;compound&#x27;</span>].apply(<span class="keyword">lambda</span> c: <span class="string">&#x27;pos&#x27;</span> <span class="keyword">if</span> c &gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;neg&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Report-on-Accuracy"><a href="#Report-on-Accuracy" class="headerlink" title="Report on Accuracy"></a>Report on Accuracy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score,classification_report,confusion_matrix</span><br><span class="line">accuracy_score(df[<span class="string">&#x27;label&#x27;</span>],df[<span class="string">&#x27;comp_score&#x27;</span>])</span><br><span class="line"><span class="comment">#0.7091</span></span><br><span class="line"><span class="built_in">print</span>(classification_report(df[<span class="string">&#x27;label&#x27;</span>],df[<span class="string">&#x27;comp_score&#x27;</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">         neg       0.86      0.51      0.64      5097</span><br><span class="line">         pos       0.64      0.91      0.75      4903</span><br><span class="line"></span><br><span class="line">   micro avg       0.71      0.71      0.71     10000</span><br><span class="line">   macro avg       0.75      0.71      0.70     10000</span><br><span class="line">weighted avg       0.75      0.71      0.70     10000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> spaCy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】父子组件通信方法整理</title>
      <link href="/p/18cda1b3/"/>
      <url>/p/18cda1b3/</url>
      
        <content type="html"><![CDATA[<h1 id="props-defineProps"><a href="#props-defineProps" class="headerlink" title="props&#x2F;defineProps"></a>props&#x2F;defineProps</h1><p>props通过在子组件上绑定属性来实现父子组件之间的数据传递。父组件将数据作为prop传递给子组件，子组件在自己的作用域中可以访问和使用这些prop。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="title function_">defineProps</span>([<span class="string">&quot;page&quot;</span>]);</span><br><span class="line"><span class="comment">//第二种 </span></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">page</span>:<span class="title class_">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">page</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">default</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="attr">defineProps</span>:&#123;</span><br><span class="line">  <span class="attr">page</span>:[<span class="title class_">String</span>,<span class="title class_">Number</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若想在子组件内使用，可以用一个const常量接收<code>defineProps</code>的返回值，然后通过这个常量即可调用。</p><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><p>使用<code>:</code>来传递值</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in props.msg&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">msg</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">Array</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: <span class="function">() =&gt;</span> []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件-1"><a href="#父组件-1" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:msg</span>=<span class="string">&quot;list&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child1-1.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> list = <span class="title function_">ref</span>([<span class="string">&#x27;666&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      list.<span class="property">value</span>.<span class="title function_">push</span>(val.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/143440ecbc5d41a69e1d2362800bc51f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="QQ截图20230608105029.jpg"></p><h1 id="emits-defineEmits"><a href="#emits-defineEmits" class="headerlink" title="emits&#x2F;defineEmits"></a>emits&#x2F;defineEmits</h1><p>emits通过在子组件中声明可触发的事件，使得子组件可以在适当的时机触发这些事件。父组件可以在子组件上<strong>监听</strong>这些事件，并在触发时执行相应的处理逻辑。</p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><h3 id="父组件-2"><a href="#父组件-2" class="headerlink" title="父组件"></a>父组件</h3><p>使用<code>@</code>传递方法以监听</p><h3 id="子组件-2"><a href="#子组件-2" class="headerlink" title="子组件"></a>子组件</h3><p>首先声明一个变量<code>emits</code>来接收父组件的方法，然后在子组件内需要触发父组件方法的函数内使用<code>emits</code>即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;add&#x27;</span>])  <span class="comment">//定义一个变量来接收父组件的方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">emits</span>(<span class="string">&#x27;add&#x27;</span>, val.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="父组件-3"><a href="#父组件-3" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span>  @<span class="attr">add</span>=<span class="string">&quot;handleAdd&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child2-1.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> list = <span class="title function_">ref</span>([<span class="string">&#x27;默认测试数据&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">handleAdd</span> = (<span class="params">val</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">  list.<span class="property">value</span>.<span class="title function_">push</span>(val);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件-3"><a href="#子组件-3" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;add&#x27;</span>])  <span class="comment">//定义一个变量来接收父组件传来的方法</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">emits</span>(<span class="string">&#x27;add&#x27;</span>, val.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c46c282ddfb4679b7301934b0caf8d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="Dingtalk_20230608124512.jpg"></p><h1 id="ref-defineExpose"><a href="#ref-defineExpose" class="headerlink" title="ref&#x2F;defineExpose"></a>ref&#x2F;defineExpose</h1><p>通过使用<code>ref</code>将数据或方法包装，并使用<code>defineExpose</code>将其暴露给父组件。父组件可以通过在子组件上使用<code>ref</code>来访问这些暴露出来的数据或方法。这种方式使得父组件可以直接访问和操作子组件的内部状态。</p><p>和<code>defineProps</code>、<code>defineEmits</code>一样，<code>defineExpose</code>也是内置的，不需要import，不过<code>defineProps</code>，<code>defineEmits</code>都会返回一个实例，而<code>defineExpose</code>是没有返回值的，而且要在方法声明定义以后使用。</p><h2 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h2><h3 id="子组件-4"><a href="#子组件-4" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineExpose</span>(&#123;</span><br><span class="line">暴露给父组件的变量名:子组件内变量</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="父组件-4"><a href="#父组件-4" class="headerlink" title="父组件"></a>父组件</h3><p>首先使用ref包装子组件<code>&lt;Child ref=&quot;childRef&quot;/&gt;</code>，然后通过ref调用子组件暴露的变量即可。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="子组件-5"><a href="#子组件-5" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> list = <span class="title function_">ref</span>([<span class="string">&#x27;默认测试数据!&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      list.<span class="property">value</span>.<span class="title function_">push</span>(val.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineExpose</span>(&#123;<span class="attr">msg</span>:list&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件-5"><a href="#父组件-5" class="headerlink" title="父组件"></a>父组件</h3><p>在<code>template</code>内使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;childRef&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in childRef?.msg&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child4.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> childRef = <span class="title function_">ref</span>(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>childRef?.msg</code>这里的问号是等<code>childRef</code>数据加载完毕后才去取数据，否则这里可能取不到值，这里需要考虑到父组件和子组件的生命周期。</p><p>在script内使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formDialogRef = <span class="title function_">ref</span>(<span class="title class_">AddressFormDialog</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">openDialog</span>=(<span class="params">mode</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (!formDialogRef.<span class="property">value</span>) <span class="keyword">return</span></span><br><span class="line">  formDialogRef.<span class="property">value</span>.<span class="title function_">openDialog</span>(mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p>v-model是通过将属性和事件绑定到同一个值来实现双向数据绑定。相当于父组件将自己的数据源交给子组件处理，父组件里不需要写什么代码，操作大都放到子组件里去写。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="父组件-6"><a href="#父组件-6" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-model:msg</span>=<span class="string">&quot;list&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child3.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> list = <span class="title function_">ref</span>([<span class="string">&#x27;默认测试数据！&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件-6"><a href="#子组件-6" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;val&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">msg</span>:<span class="title class_">Array</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> val = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:msg&#x27;</span>]) </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> arr = props.<span class="property">msg</span>;  </span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">push</span>(val.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">emits</span>(<span class="string">&#x27;update:msg&#x27;</span>, arr);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h1><p>attrs用于子组件接收父组件中不是通过props接收的属性。父组件给子组件传递属性，可以是自定义属性，这对于在子组件中将额外的prop传递给子元素或子组件比较有用。</p><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="父组件-7"><a href="#父组件-7" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件 传送数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:fruit</span>=<span class="string">&quot;data1&quot;</span> <span class="attr">:type</span>=<span class="string">&quot;data2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child6.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> data1 = <span class="title function_">ref</span>(<span class="string">&quot;水果&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> data2 = <span class="title function_">ref</span>(<span class="string">&quot;哈密瓜&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件-7"><a href="#子组件-7" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件 接收数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件通过props收到的是: &#123;&#123;props.fruit&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件通过attrs收到的是: &#123;&#123;attrs.type&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; useAttrs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">fruit</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">default</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> attrs = <span class="title function_">useAttrs</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(attrs);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/452b42642c61470d9f5af0d23f1d85a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="QQ截图20230609115553.jpg"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/7046940339621330974">vue3中父子传值 defineProps和defineEmits用法 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7242493101088915512#heading-3">Vue父子组件通信的6种方式，props、emits、defineExpose、provide、attrs… - 掘金 (juejin.cn)</a></p><p>[<a href="https://juejin.cn/post/7202868242363711525">Vue3] defineExpose用法 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】Text Feature Extraction &amp; Classification</title>
      <link href="/p/66a6c396/"/>
      <url>/p/66a6c396/</url>
      
        <content type="html"><![CDATA[<h1 id="Text-Feature-Extraction"><a href="#Text-Feature-Extraction" class="headerlink" title="Text Feature Extraction"></a>Text Feature Extraction</h1><h2 id="Count-Vectorization"><a href="#Count-Vectorization" class="headerlink" title="Count Vectorization"></a>Count Vectorization</h2><p>Document Term Matrix (DTM) : a matrix of counts, with columns as words.</p><p>Term Frequency (TF)</p><p>Inverse Term Frequency (ITF)</p><p>TF-ITF : Term Frequency times Inverse Document Frequency</p><p>TF-ITF allows  us to understand the context of words across an entire corpus of documents, instead of just its relative importance in a single document</p><h2 id="Text-Feature-Extraction-using-Scikit-Learn’s-Vectorizer-classes"><a href="#Text-Feature-Extraction-using-Scikit-Learn’s-Vectorizer-classes" class="headerlink" title="Text Feature Extraction using Scikit-Learn’s Vectorizer classes"></a>Text Feature Extraction using Scikit-Learn’s Vectorizer classes</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">vect = CountVectorizer()</span><br><span class="line">messages = [<span class="string">&#x27;Hey, lets go to the game today!&#x27;</span>, <span class="string">&#x27;Call your sister.&#x27;</span>, <span class="string">&#x27;Want to go walk your dog?&#x27;</span>]</span><br><span class="line">vect = CountVectorizer()</span><br><span class="line">count = vect.fit_transform(messages)</span><br><span class="line"><span class="built_in">print</span>(vect.get_feature_names())</span><br><span class="line"><span class="built_in">print</span>(count.todense())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;call&#x27;, &#x27;dog&#x27;, &#x27;game&#x27;, &#x27;go&#x27;, &#x27;hey&#x27;, &#x27;lets&#x27;, &#x27;sister&#x27;, &#x27;the&#x27;, &#x27;to&#x27;, &#x27;today&#x27;, &#x27;walk&#x27;, &#x27;want&#x27;, &#x27;your&#x27;]</span><br><span class="line">[[0 0 1 1 1 1 0 1 1 1 0 0 0]</span><br><span class="line"> [1 0 0 0 0 0 1 0 0 0 0 0 1]</span><br><span class="line"> [0 1 0 1 0 0 0 0 1 0 1 1 1]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line">tdidfvect = TfidfVectorizer()</span><br><span class="line">tdidfcount = tdidfvect.fit_transform(messages)</span><br><span class="line"><span class="built_in">print</span>(tdidfvect.get_feature_names())</span><br><span class="line"><span class="built_in">print</span>(tdidfcount.todense())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;call&#x27;, &#x27;dog&#x27;, &#x27;game&#x27;, &#x27;go&#x27;, &#x27;hey&#x27;, &#x27;lets&#x27;, &#x27;sister&#x27;, &#x27;the&#x27;, &#x27;to&#x27;, &#x27;today&#x27;, &#x27;walk&#x27;, &#x27;want&#x27;, &#x27;your&#x27;]</span><br><span class="line">[[0.         0.         0.40301621 0.30650422 0.40301621 0.40301621</span><br><span class="line">  0.         0.40301621 0.30650422 0.40301621 0.         0.</span><br><span class="line">  0.        ]</span><br><span class="line"> [0.62276601 0.         0.         0.         0.         0.</span><br><span class="line">  0.62276601 0.         0.         0.         0.         0.</span><br><span class="line">  0.4736296 ]</span><br><span class="line"> [0.         0.45954803 0.         0.34949812 0.         0.</span><br><span class="line">  0.         0.         0.34949812 0.         0.45954803 0.45954803</span><br><span class="line">  0.34949812]]</span><br></pre></td></tr></table></figure><h2 id="Transform-Counts-to-Frequencies-with-Tf-idf"><a href="#Transform-Counts-to-Frequencies-with-Tf-idf" class="headerlink" title="Transform Counts to Frequencies with Tf-idf"></a>Transform Counts to Frequencies with Tf-idf</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer</span><br><span class="line">tfidf_transformer = TfidfTransformer()</span><br><span class="line"></span><br><span class="line">X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)</span><br><span class="line">X_train_tfidf.shape</span><br><span class="line"><span class="comment">#(3733, 7082)</span></span><br></pre></td></tr></table></figure><div class="note  flat info"><p>the <code>fit_transform()</code> method actually performs two operations: it fits an estimator to the data and then transforms our count-matrix to a tf-idf representation.</p></div><h2 id="Train-a-Classifier"><a href="#Train-a-Classifier" class="headerlink" title="Train a Classifier"></a>Train a Classifier</h2><p>Here we’ll introduce an SVM classifier that’s similar to SVC, called <a href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html">LinearSVC</a>. LinearSVC handles sparse input better, and scales well to large numbers of samples.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">clf = LinearSVC()</span><br><span class="line">clf.fit(X_train_tfidf,y_train)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,</span><br><span class="line">     intercept_scaling=1, loss=&#x27;squared_hinge&#x27;, max_iter=1000,</span><br><span class="line">     multi_class=&#x27;ovr&#x27;, penalty=&#x27;l2&#x27;, random_state=None, tol=0.0001,</span><br><span class="line">     verbose=0)</span><br></pre></td></tr></table></figure><h2 id="Build-a-Pipeline"><a href="#Build-a-Pipeline" class="headerlink" title="Build a Pipeline"></a>Build a Pipeline</h2><p>Remember that only our training set has been vectorized into a full vocabulary. In order to perform an analysis on our test set we’ll have to submit it to the same procedures. Fortunately scikit-learn offers a <a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html"><strong>Pipeline</strong></a> class that behaves like a compound classifier.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="comment"># from sklearn.feature_extraction.text import TfidfVectorizer</span></span><br><span class="line"><span class="comment"># from sklearn.svm import LinearSVC</span></span><br><span class="line"></span><br><span class="line">text_clf = Pipeline([(<span class="string">&#x27;tfidf&#x27;</span>, TfidfVectorizer()), (<span class="string">&#x27;clf&#x27;</span>, LinearSVC())])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feed the training data through the pipeline</span></span><br><span class="line">text_clf.fit(X_train, y_train) </span><br></pre></td></tr></table></figure><h2 id="Test-the-classifier-and-display-results"><a href="#Test-the-classifier-and-display-results" class="headerlink" title="Test the classifier and display results"></a>Test the classifier and display results</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Form a prediction set</span></span><br><span class="line">predictions = text_clf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report the confusion matrix</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="built_in">print</span>(metrics.confusion_matrix(y_test,predictions))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1586    7]</span><br><span class="line"> [  12  234]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Print a classification report</span></span><br><span class="line"><span class="built_in">print</span>(metrics.classification_report(y_test,predictions))</span><br></pre></td></tr></table></figure><pre><code>          precision    recall  f1-score   support     ham       0.99      1.00      0.99      1593    spam       0.97      0.95      0.96       246       micro avg       0.99      0.99      0.99      1839   macro avg       0.98      0.97      0.98      1839weighted avg       0.99      0.99      0.99      1839</code></pre><p>Using the text of the messages, our model performed exceedingly well; it correctly predicted spam <strong>98.97%</strong> of the time!</p><p>Now let’s apply what we’ve learned to a text classification project involving positive and negative movie reviews.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_clf.predict([<span class="string">&quot;Hello, how are you?&quot;</span>])</span><br><span class="line"><span class="comment">#array([&#x27;ham&#x27;], dtype=object)</span></span><br></pre></td></tr></table></figure><h1 id="Text-Classification-Project"><a href="#Text-Classification-Project" class="headerlink" title="Text Classification Project"></a>Text Classification Project</h1><h2 id="Step-1-Import-and-load-the-dataset"><a href="#Step-1-Import-and-load-the-dataset" class="headerlink" title="Step 1 - Import and load the dataset"></a>Step 1 - Import and load the dataset</h2><p>The dataset contains the text of 2000 movie reviews. 1000 are positive, 1000 are negative, and the text has been preprocessed as a tab-delimited file.</p><h2 id="Step-2-Prep-dataset-check-for-missing-values"><a href="#Step-2-Prep-dataset-check-for-missing-values" class="headerlink" title="Step 2 - Prep dataset, check for missing values"></a>Step 2 - Prep dataset, check for missing values</h2><p>We have intentionally included records with missing data. Some have NaN values, others have short strings composed of only spaces. This might happen if a reviewer declined to provide a comment with their review. We will show two ways using pandas to identify and remove records containing empty data.</p><ul><li>NaN records are efficiently handled with <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.isnull.html">.isnull()</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dropna.html">.dropna()</a></li><li>Strings that contain only whitespace can be handled with <a href="https://docs.python.org/3/library/stdtypes.html#str.isspace">.isspace()</a>, <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html">.itertuples()</a>, and <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html">.drop()</a></li></ul><h3 id="Detect-remove-NaN-values"><a href="#Detect-remove-NaN-values" class="headerlink" title="Detect &amp; remove NaN values"></a>Detect &amp; remove NaN values</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div class="note  flat warning"><p>By setting inplace&#x3D;True, we permanently affect the DataFrame currently in memory, and this can’t be undone. However, it does <em>not</em> affect the original source data. If we needed to, we could always load the original DataFrame from scratch.</p></div><h3 id="Detect-remove-empty-strings"><a href="#Detect-remove-empty-strings" class="headerlink" title="Detect &amp; remove empty strings"></a>Detect &amp; remove empty strings</h3><p>Technically, we’re dealing with “whitespace only” strings. If the original .tsv file had contained empty strings, pandas <strong>.read_csv()</strong> would have assigned NaN values to those cells by default.</p><p>In order to detect these strings we need to iterate over each row in the DataFrame. The <strong>.itertuples()</strong> pandas method is a good tool for this as it provides access to every field. For brevity we’ll assign the names <code>i</code>, <code>lb</code> and <code>rv</code> to the <code>index</code>, <code>label</code> and <code>review</code> columns.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blanks = []  <span class="comment"># start with an empty list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,lb,rv <span class="keyword">in</span> df.itertuples():  <span class="comment"># iterate over the DataFrame</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(rv)==<span class="built_in">str</span>:            <span class="comment"># avoid NaN values</span></span><br><span class="line">        <span class="keyword">if</span> rv.isspace():         <span class="comment"># test &#x27;review&#x27; for whitespace</span></span><br><span class="line">            blanks.append(i)     <span class="comment"># add matching index numbers to the list</span></span><br><span class="line">            </span><br><span class="line">df.drop(blanks, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Step-3-Split-the-data-into-train-test-sets"><a href="#Step-3-Split-the-data-into-train-test-sets" class="headerlink" title="Step 3 - Split the data into train &amp; test sets"></a>Step 3 - Split the data into train &amp; test sets</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X = df[<span class="string">&#x27;review&#x27;</span>]</span><br><span class="line">y = df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.33</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h2 id="Step-4-Build-pipelines-to-vectorize-the-data-then-train-and-fit-a-model"><a href="#Step-4-Build-pipelines-to-vectorize-the-data-then-train-and-fit-a-model" class="headerlink" title="Step 4 - Build pipelines to vectorize the data, then train and fit a model"></a>Step 4 - Build pipelines to vectorize the data, then train and fit a model</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line"><span class="comment"># Naïve Bayes:</span></span><br><span class="line">text_clf_nb = Pipeline([(<span class="string">&#x27;tfidf&#x27;</span>, TfidfVectorizer()),</span><br><span class="line">                     (<span class="string">&#x27;clf&#x27;</span>, MultinomialNB()),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linear SVC:</span></span><br><span class="line">text_clf_lsvc = Pipeline([(<span class="string">&#x27;tfidf&#x27;</span>, TfidfVectorizer()),</span><br><span class="line">                     (<span class="string">&#x27;clf&#x27;</span>, LinearSVC()),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="Step-5-Feed-the-training-data-through-the-first-pipeline"><a href="#Step-5-Feed-the-training-data-through-the-first-pipeline" class="headerlink" title="Step 5 - Feed the training data through the first pipeline"></a>Step 5 - Feed the training data through the first pipeline</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_clf_nb.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><h2 id="Step-6-Run-predictions-and-analyze-the-results-naive-Bayes"><a href="#Step-6-Run-predictions-and-analyze-the-results-naive-Bayes" class="headerlink" title="Step 6 - Run predictions and analyze the results (naïve Bayes)"></a>Step 6 - Run predictions and analyze the results (naïve Bayes)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Form a prediction set</span></span><br><span class="line">predictions = text_clf_nb.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report the confusion matrix</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="built_in">print</span>(metrics.confusion_matrix(y_test,predictions))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print a classification report</span></span><br><span class="line"><span class="built_in">print</span>(metrics.classification_report(y_test,predictions))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the overall accuracy</span></span><br><span class="line"><span class="built_in">print</span>(metrics.accuracy_score(y_test,predictions))</span><br></pre></td></tr></table></figure><h2 id="Advanced-Topic-Adding-Stopwords-to-CountVectorizer"><a href="#Advanced-Topic-Adding-Stopwords-to-CountVectorizer" class="headerlink" title="Advanced Topic - Adding Stopwords to CountVectorizer"></a>Advanced Topic - Adding Stopwords to CountVectorizer</h2><p>By default, <strong>CountVectorizer</strong> and <strong>TfidfVectorizer</strong> do <em>not</em> filter stopwords. However, they offer some optional settings, including passing in your own stopword list.</p><div class="note  flat info"><p>There are some <a href="http://aclweb.org/anthology/W18-2502">known issues</a> using Scikit-learn’s built-in stopwords list. Some words that are filtered may in fact aid in classification. In this section we’ll pass in our own stopword list, so that we know exactly what’s being filtered.</p></div><p>The <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html">CountVectorizer</a> class accepts the following arguments:</p><blockquote><p><em>CountVectorizer(input&#x3D;’content’, encoding&#x3D;’utf-8’, decode_error&#x3D;’strict’, strip_accents&#x3D;None, lowercase&#x3D;True, preprocessor&#x3D;None, tokenizer&#x3D;None, <strong>stop_words&#x3D;None</strong>, token_pattern&#x3D;’(?u)\b\w\w+\b’, ngram_range&#x3D;(1, 1), analyzer&#x3D;’word’, max_df&#x3D;1.0, min_df&#x3D;1, max_features&#x3D;None, vocabulary&#x3D;None, binary&#x3D;False, dtype&#x3D;&lt;class ‘numpy.int64’&gt;)</em></p></blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">TfidVectorizer</a> supports the same arguments and more. Under <em>stop_words</em> we have the following options:</p><blockquote><p>stop_words : <em>string {‘english’}, list, or None (default)</em></p></blockquote><p>That is, we can run <code>TfidVectorizer(stop_words=&#39;english&#39;)</code> to accept scikit-learn’s built-in list,<br>or <code>TfidVectorizer(stop_words=[a, and, the])</code> to filter these three words. In practice we would assign our list to a variable and pass that in instead.</p><p>Scikit-learn’s built-in list contains 318 stopwords. However, there are words in this list that may influence a classification of movie reviews. With this in mind, let’s trim the list to just 60 words:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stopwords = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;an&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;are&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;at&#x27;</span>, <span class="string">&#x27;be&#x27;</span>, <span class="string">&#x27;been&#x27;</span>, <span class="string">&#x27;but&#x27;</span>, <span class="string">&#x27;by&#x27;</span>, <span class="string">&#x27;can&#x27;</span>, \</span><br><span class="line">             <span class="string">&#x27;even&#x27;</span>, <span class="string">&#x27;ever&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;had&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;have&#x27;</span>, <span class="string">&#x27;he&#x27;</span>, <span class="string">&#x27;her&#x27;</span>, <span class="string">&#x27;hers&#x27;</span>, <span class="string">&#x27;his&#x27;</span>, \</span><br><span class="line">             <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;its&#x27;</span>, <span class="string">&#x27;just&#x27;</span>, <span class="string">&#x27;me&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, \</span><br><span class="line">             <span class="string">&#x27;see&#x27;</span>, <span class="string">&#x27;seen&#x27;</span>, <span class="string">&#x27;she&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;than&#x27;</span>, <span class="string">&#x27;that&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;their&#x27;</span>, <span class="string">&#x27;there&#x27;</span>, <span class="string">&#x27;they&#x27;</span>, <span class="string">&#x27;this&#x27;</span>, \</span><br><span class="line">             <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;was&#x27;</span>, <span class="string">&#x27;we&#x27;</span>, <span class="string">&#x27;were&#x27;</span>, <span class="string">&#x27;what&#x27;</span>, <span class="string">&#x27;when&#x27;</span>, <span class="string">&#x27;which&#x27;</span>, <span class="string">&#x27;who&#x27;</span>, <span class="string">&#x27;will&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;you&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_clf_lsvc2 = Pipeline([(<span class="string">&#x27;tfidf&#x27;</span>, TfidfVectorizer(stop_words=<span class="string">&#x27;english&#x27;</span>)),</span><br><span class="line">                     (<span class="string">&#x27;clf&#x27;</span>, LinearSVC()),</span><br><span class="line">])</span><br><span class="line">text_clf_lsvc2.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><h2 id="Feed-new-data-into-a-trained-model"><a href="#Feed-new-data-into-a-trained-model" class="headerlink" title="Feed new data into a trained model"></a>Feed new data into a trained model</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myreview = <span class="string">&quot;I enjoyed this movie&quot;</span></span><br><span class="line"><span class="built_in">print</span>(text_clf_nb.predict([myreview]))</span><br><span class="line"><span class="comment"># [&#x27;pos&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(text_clf_lsvc.predict([myreview]))</span><br><span class="line"><span class="comment"># [&#x27;neg&#x27;]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> spaCy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】岭风无岸【明日方舟新春会·重岳】</title>
      <link href="/p/5f33341/"/>
      <url>/p/5f33341/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/fc3669c83752460d501cccf92771704df276e803.jpg"></p><p>已灌词，没扒和声~</p><p>BPM：138</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>本家：<a href="https://www.bilibili.com/festival/2024mrfz?bvid=BV1qc411v7GB&spm_id_from=333.880.my_history.page.click">BV1qc411v7GB</a></p><p>“万山无阻，去路天涯。”</p><p>——</p><p>策划：杨颜</p><p>监制：似雨若离RainJaded、杨颜</p><p>作曲：KBShinya | 编曲：向往 | 作词：怀袖 | 吉他：大牛</p><p>演唱：KBShinya | 混音&#x2F;母带：圈太Studio | 和声：KBShinya、雾敛</p><p>映像：似雨若离RainJaded</p><p>美术：阿凯路过了、咸DOOOOOR、阿尼鸭Any-a、粒子溶液、米可、瞌睡厘</p><p>题字：长安</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1KrgnlgzOljxVHceMAJRV3A?pwd=2ctt">https://pan.baidu.com/s/1KrgnlgzOljxVHceMAJRV3A?pwd=2ctt</a></p><p>提取码: 2ctt</p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>天意莽莽 望故城 白云生灭</p><p>荒尘里 流年走马 春风未歇</p><p>恍惚仍是 鼓角声中初开眼</p><p>大梦浑然觉</p><p>生死如惊鹊 散成烟</p><p>&nbsp;</p><p>断 见神明鳞甲 凋若光电</p><p>重峦起 招式幻作骨血</p><p>剑 不映月 只映烟火人间</p><p>便以肉身试圆缺</p><p>&nbsp;</p><p>尝悲欢 路三千 一步煎熬一重天</p><p>平患难 共浴血 吞风赶日赴绝险</p><p>也守天堑 也笑望醉眼</p><p>世情淹心比酒烈</p><p>&nbsp;</p><p>青黄叶 又更迭 旧歌犹唱旧时节</p><p>锻剑声 还明灭 萧萧往事烧长夜</p><p>谈笑耳边 回首狂沙扑面</p><p>此刻 心底苍山 亦是故人肩</p><p> &nbsp;</p><p>攀 光阴生指掌 寸寸接天</p><p>我以我 穷尽形意深浅</p><p>战 腾挪间 隐隐奔雷欲现</p><p>足下沧海已桑田</p><p> &nbsp;</p><p>问造化 虚妄眼 岂知人事往来艰</p><p>浑不见 危墙下 以命相撑是草芥</p><p>前赴后继 白发望少年</p><p>唯有意气不衰谢</p><p> &nbsp;</p><p>冥顽者 寿万年 徒然雪里坐观天</p><p>凭瞬息 通无限 春秋不过一空茧</p><p>心神猎猎 终成大道至简</p><p>身后 天地群山 是众生无言</p><p> &nbsp;</p><p>远方鼓声未绝</p><p>恍若老友举杯 遥相别</p><p>泛起喧然醉意</p><p>如归雁流连</p><p>久看至今仍未厌</p><p>应谢这温厚人间</p><p>岭风无岸</p><p>浩荡去天边</p><p> &nbsp;</p><p>想来时 千钧剑 去时空明无弗届</p><p>散遗魂 托厚念 衣衫磊落拂云烟</p><p>物华自变 得失自无解</p><p>轻舟一叶枕潮眠</p><p> &nbsp;</p><p>行闹市 过旷野 一身漂泊才真切</p><p>访鬼神 伴苍生 也与斜阳几擦肩</p><p>大成若缺 憾事安放心尖</p><p>明日再隔山岳 万树月满天</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 明日方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】弹窗Dialog组件封装及使用</title>
      <link href="/p/f9bef31e/"/>
      <url>/p/f9bef31e/</url>
      
        <content type="html"><![CDATA[<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>将<code>el-dialog</code>进行封装，便于其他组件进行简单调用，同时简化代码</p><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/useDialogDemo221211.gif" alt="useDialogDemo221211"></p><h1 id="封装Dialog"><a href="#封装Dialog" class="headerlink" title="封装Dialog"></a>封装Dialog</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>主要是参考了 <a href="https://juejin.cn/post/7175821416237891644#heading-0">Vue3这样子结合hook写弹窗组件更快更高效</a> 这篇文章里面的内容，但是我的项目里面的脚本使用的是JavaScript，参考文章里面用的是typescript，因此进行了一些<del>翻译（不是）</del>修改。</p><p>首先记录一下一些踩坑实况（</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>点击触发弹窗的按钮后，弹窗并没有弹出来</p><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>修改一下<code>openDialog</code>，使其修改<code>visible</code>状态后在控制台<code>log</code>一下，发现状态是成功修改的，但是弹窗确实没有弹出来。</p><p>同时能够发现，浏览器的滚动条在点击按钮之前是有的，点击按钮后没有了，虽然也不知道为什么。<del>（此处应有图）</del></p><p>于是我再整一个按钮，调用<code>closeDialog</code>，随便点点试试。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240128115310307.png"></p><p>然后发现，点一次<code>open</code>，再点一次<code>close</code>，浏览器的滚动条又出现了，状态也是对应的修改了<code>true/false</code>。</p><p>然后重点来了！！！！</p><p>此时再点一次<code>open</code>，弹窗出来了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/ca0a96d9193d9a42122b662c7ef3eb4f.jpg" alt="" style="zoom:50%;" /><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/9a8c190f880ed93d41a3a052da888bcd.jpg" alt="" style="zoom: 25%;" /></p><p>然后我将<code>openDialog</code>改为先把<code>visible</code>改true，再false，再改true<del>（搁这搁这呢</del></p><p>发现还是不行</p><p>此时我再翻了一下控制台，发现其实是有报错的<del>，只是我之前都忽略了（</del></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240128120524588.png"></p><p>这里其实就是我初始化的时候用了<code>defineProps</code>定义了<code>hiddenFullBtn</code>，后面直接就调用了，显示没有定义，到底怎么会事呢。</p><p>请看VCR：[学习Vue3的defineProps方法](<a href="https://zhuanlan.zhihu.com/p/680340457#:~:text=defineProps">https://zhuanlan.zhihu.com/p/680340457#:~:text=defineProps</a> 方法是在  环境下使用的，这是Vue 3中推荐的语法糖，可以更紧凑地书写组件。 以下是 defineProps,&lt;%2Fscript&gt; 在上述代码中，我们通过 defineProps 定义了两个Props属性： prop1 和 prop2 。)</p><p><code>defineProps</code>其实是有返回值的，我这里直接参考其他组件的写法，没有拿到返回值，因此这里的<code>hiddenFullBtn</code>会报错为没有定义。</p><p>改了一下，OK了~</p><p>附上代码</p><h2 id="CommonDialog-vue"><a href="#CommonDialog-vue" class="headerlink" title="CommonDialog.vue"></a>CommonDialog.vue</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; computed, ref, useAttrs, useSlots &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; FullScreen, Close &#125; from &quot;@element-plus/icons-vue&quot;;</span><br><span class="line">const attrs = useAttrs();</span><br><span class="line">const slots = useSlots();</span><br><span class="line">const props=defineProps(&#123;</span><br><span class="line">  title:&#123;</span><br><span class="line">    type:String</span><br><span class="line">  &#125;,</span><br><span class="line">  isDraggable:&#123;</span><br><span class="line">    type:Boolean,</span><br><span class="line">    default:false</span><br><span class="line">  &#125;,</span><br><span class="line">  modelValue:&#123;</span><br><span class="line">    type:Boolean,</span><br><span class="line">    default:false</span><br><span class="line">  &#125;,</span><br><span class="line">  hiddenFullBtn:&#123;</span><br><span class="line">    type:Boolean,</span><br><span class="line">    default:false</span><br><span class="line">  &#125;,</span><br><span class="line">  loading:&#123;</span><br><span class="line">    type:Boolean,</span><br><span class="line">    default:false</span><br><span class="line">  &#125;,</span><br><span class="line">  confirmText:&#123;</span><br><span class="line">    type:String,</span><br><span class="line">    default:&quot;确认&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelText:&#123;</span><br><span class="line">    type:String,</span><br><span class="line">    default:&quot;关闭&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const isFullscreen = ref(false);</span><br><span class="line">// 是否显示全屏效果图标</span><br><span class="line">const isFullScreenBtn = computed(() =&gt; &#123;</span><br><span class="line">  if (props.hiddenFullBtn) return false;</span><br><span class="line">  return !attrs?.fullscreen;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const emits=defineEmits([&quot;update:modelValue&quot;,&quot;confirm&quot;,&quot;close&quot;])</span><br><span class="line"></span><br><span class="line">// 开启、关闭全屏效果</span><br><span class="line">const handleFullscreen = () =&gt; &#123;</span><br><span class="line">  if (attrs?.fullscreen) return;</span><br><span class="line">  isFullscreen.value = !isFullscreen.value;</span><br><span class="line">&#125;;</span><br><span class="line">// 关闭弹窗时向外部发送close事件</span><br><span class="line">const handleClose = () =&gt; &#123;</span><br><span class="line">  // 获取attrs.[&#x27;before-close&#x27;]属性，如果类型是函数函数，先执行它</span><br><span class="line">  if (</span><br><span class="line">      Reflect.has(attrs, &quot;before-close&quot;) &amp;&amp;</span><br><span class="line">      typeof attrs[&quot;before-close&quot;] === &quot;function&quot;</span><br><span class="line">  ) &#123;</span><br><span class="line">    attrs[&quot;before-close&quot;]();</span><br><span class="line">  &#125;</span><br><span class="line">  emits(&quot;close&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">const handleConfirm = () =&gt; &#123;</span><br><span class="line">  emits(&quot;confirm&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">        v-bind=&quot;attrs&quot;</span><br><span class="line">        :model-value=&quot;props.modelValue&quot;</span><br><span class="line">        :show-close=&quot;false&quot;</span><br><span class="line">        :fullscreen=&quot;attrs?.fullscreen ?? isFullscreen&quot;</span><br><span class="line">        :before-close=&quot;handleClose&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;template #header&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;span class=&quot;dialog-title&quot;&gt;&#123;&#123; props.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;btns&quot;&gt;</span><br><span class="line">          &lt;el-icon v-if=&quot;isFullScreenBtn&quot; @click=&quot;handleFullscreen&quot;</span><br><span class="line">          &gt;&lt;FullScreen</span><br><span class="line">          /&gt;&lt;/el-icon&gt;</span><br><span class="line">          &lt;el-icon @click=&quot;handleClose&quot;&gt;&lt;Close /&gt;&lt;/el-icon&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot; v-loading=&quot;props.loading&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;!-- 如果没有提供其他footer插槽，就使用默认的 --&gt;</span><br><span class="line">        &lt;span v-if=&quot;!slots.footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;</span><br><span class="line">              props.confirmText</span><br><span class="line">            &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button @click=&quot;handleClose&quot;&gt;&#123;&#123; props.cancelText &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;!-- 使用传入进来的插槽 --&gt;</span><br><span class="line">        &lt;slot v-else name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">:deep(.el-dialog__header) &#123;</span><br><span class="line">  border-bottom: 1px solid #eee;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 12px 16px;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.dialog-title &#123;</span><br><span class="line">  line-height: 24px;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  color: #303133;</span><br><span class="line">&#125;</span><br><span class="line">.btns &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  i &#123;</span><br><span class="line">    margin-right: 8px;</span><br><span class="line"></span><br><span class="line">    font-size: 16px;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">  i:last-child &#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="useDialog-js"><a href="#useDialog-js" class="headerlink" title="useDialog.js"></a>useDialog.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDialog</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> visible = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> loading = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">openDialog</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        visible.<span class="property">value</span>=<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">closeDialog</span> = (<span class="params"></span>) =&gt; (visible.<span class="property">value</span> = <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">openLoading</span> = (<span class="params"></span>) =&gt; (loading.<span class="property">value</span> = <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">closeLoading</span> = (<span class="params"></span>) =&gt; (loading.<span class="property">value</span> = <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        visible,</span><br><span class="line">        loading,</span><br><span class="line">        openDialog,</span><br><span class="line">        closeDialog,</span><br><span class="line">        openLoading,</span><br><span class="line">        closeLoading</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Dialog"><a href="#使用Dialog" class="headerlink" title="使用Dialog"></a>使用Dialog</h1><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useDialog&#125; <span class="keyword">from</span> <span class="string">&quot;@/composables/useDialog.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CommonDialog</span> <span class="keyword">from</span> <span class="string">&quot;@/components/dialog/CommonDialog.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ElMessage</span>&#125; <span class="keyword">from</span> <span class="string">&quot;element-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  visible,</span><br><span class="line">  openDialog,</span><br><span class="line">  closeDialog,</span><br><span class="line">&#125;=<span class="title function_">useDialog</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">ElMessage</span>(&#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;你点击了确定按钮&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">closeDialog</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClose</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">ElMessage</span>(&#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;关闭了窗口&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;info&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">closeDialog</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button @click=&quot;openDialog&quot;&gt;普通弹窗&lt;/el-button&gt;</span><br><span class="line">&lt;CommonDialog title=&quot;test111&quot; :hidden-full-btn=&quot;true&quot; v-model=&quot;visible&quot;</span><br><span class="line">              @confirm=&quot;handleConfirm&quot; @close=&quot;handleClose&quot;&gt;&lt;/CommonDialog&gt;</span><br></pre></td></tr></table></figure><h1 id="二次封装FormDialog"><a href="#二次封装FormDialog" class="headerlink" title="二次封装FormDialog"></a>二次封装FormDialog</h1><p>首先这里创建一个用于区分表格是添加&#x2F;编辑&#x2F;只读状态的js</p><h2 id="dialogTypes-js"><a href="#dialogTypes-js" class="headerlink" title="dialogTypes.js"></a>dialogTypes.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MODE</span> = &#123;</span><br><span class="line">    <span class="attr">ADD</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">    <span class="attr">EDIT</span>:<span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">    <span class="attr">READONLY</span>:<span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个管理表格弹窗状态的js以及<code>useFormDialog.js</code></p><h2 id="useDialogState-js"><a href="#useDialogState-js" class="headerlink" title="useDialogState.js"></a>useDialogState.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">MODE</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./dialogTypes.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useDialogState</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mode=<span class="title function_">ref</span>(<span class="variable constant_">MODE</span>.<span class="property">ADD</span>)</span><br><span class="line">    <span class="keyword">const</span> visible=<span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">updateMode</span>=(<span class="params">target</span>)=&gt;&#123;</span><br><span class="line">        mode.<span class="property">value</span>=target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        mode,</span><br><span class="line">        visible,</span><br><span class="line">        updateMode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useFormDialog-js"><a href="#useFormDialog-js" class="headerlink" title="useFormDialog.js"></a>useFormDialog.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useDialogState&#125; <span class="keyword">from</span> <span class="string">&quot;@/composables/useDialogState.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useFormDialog</span>=(<span class="params">formInstance</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; visible, mode, updateMode &#125; = <span class="title function_">useDialogState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">closeDialog</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        formInstance.<span class="property">value</span>?.<span class="title function_">resetFields</span>();</span><br><span class="line">        visible.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">openDialog</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">updateMode</span>(target);</span><br><span class="line">        visible.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">        formInstance.<span class="property">value</span>?.<span class="title function_">resetFields</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">modeText</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode.<span class="property">value</span> === <span class="string">&#x27;add&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;添加&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mode.<span class="property">value</span> === <span class="string">&#x27;edit&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;编辑&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mode.<span class="property">value</span> === <span class="string">&#x27;readonly&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;详情&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        visible, mode, openDialog, closeDialog, modeText</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>useFormDialog</code>传入的是表格对象，在关闭和打开弹窗时都要清空一下表格的内容。</p><h2 id="FormDialog-vue"><a href="#FormDialog-vue" class="headerlink" title="FormDialog.vue"></a>FormDialog.vue</h2><h3 id="script-1"><a href="#script-1" class="headerlink" title="script"></a>script</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略表格本身的定义等等</span></span><br><span class="line"><span class="keyword">const</span> &#123; visible, mode, closeDialog, openDialog &#125; = <span class="title function_">useFormDialog</span>(formRef)</span><br><span class="line"></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;</span><br><span class="line">  openDialog</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">confirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!formRef.<span class="property">value</span>) <span class="keyword">return</span>;</span><br><span class="line">  formRef.<span class="property">value</span>.<span class="title function_">validate</span>(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="title class_">ElMessage</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;提交成功&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(form)</span><br><span class="line">      <span class="title function_">closeDialog</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">customClose</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">closeDialog</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>defineExpose</code>，将<code>useFormDialog</code>中的<code>openDialog</code>导出供父组件使用。</p><h3 id="template-1"><a href="#template-1" class="headerlink" title="template"></a>template</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;CommonDialog</span><br><span class="line">    :before-close=&quot;customClose&quot;</span><br><span class="line">    @confirm=&quot;confirm&quot;</span><br><span class="line">    v-model=&quot;visible&quot;</span><br><span class="line">    title=&quot;标题标题&quot;</span><br><span class="line">    :confirm-text=&quot;mode === MODE.ADD ? &#x27;添加&#x27; : &#x27;修改&#x27;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div class=&quot;addressWrapper&quot;&gt;</span><br><span class="line">    &lt;el-form ref=&quot;formRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-position=&quot;right&quot; label-width=&quot;100px&quot;</span><br><span class="line">             status-icon&gt;</span><br><span class="line">      &lt;!-- 此处省略表格内容 --&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/CommonDialog&gt;</span><br></pre></td></tr></table></figure><h1 id="使用FormDialog"><a href="#使用FormDialog" class="headerlink" title="使用FormDialog"></a>使用FormDialog</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import AddressFormDialog from &quot;@/components/dialog/AddressFormDialog.vue&quot;;</span><br><span class="line">import &#123;MODE&#125; from &quot;@/composables/dialogTypes.js&quot;;</span><br><span class="line">import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">const formDialogRef = ref(AddressFormDialog)</span><br><span class="line"></span><br><span class="line">const openDialog=(mode)=&gt;&#123;</span><br><span class="line">  if (!formDialogRef.value) return</span><br><span class="line">  formDialogRef.value.openDialog(mode)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button @click=&quot;openDialog(MODE.EDIT)&quot;&gt;普通弹窗&lt;/el-button&gt;</span><br><span class="line">  &lt;AddressFormDialog ref=&quot;formDialogRef&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>大功告成！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240130155212539.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/7175821416237891644">Vue3这样子结合hook写弹窗组件更快更高效 - 掘金 (juejin.cn)</a></p><p>[学习Vue3的defineProps方法 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/680340457#:~:text=defineProps">https://zhuanlan.zhihu.com/p/680340457#:~:text=defineProps</a> 方法是在  环境下使用的，这是Vue 3中推荐的语法糖，可以更紧凑地书写组件。 以下是 defineProps,&lt;%2Fscript&gt; 在上述代码中，我们通过 defineProps 定义了两个Props属性： prop1 和 prop2 。)</p><p><a href="https://juejin.cn/post/7111686386645729317">关于Vue3的defineProps用法 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】NLP Techniques(POS/NER)</title>
      <link href="/p/acac46b/"/>
      <url>/p/acac46b/</url>
      
        <content type="html"><![CDATA[<h1 id="Part-of-Speech-Tagging"><a href="#Part-of-Speech-Tagging" class="headerlink" title="Part of Speech Tagging"></a>Part of Speech Tagging</h1><h2 id="View-token-tags"><a href="#View-token-tags" class="headerlink" title="View token tags"></a>View token tags</h2><ul><li>To view the coarse POS tag use <code>token.pos_</code></li><li>To view the fine-grained tag use <code>token.tag_</code></li><li>To view the syntactic dependency use <code>token.dep_</code></li><li>To view the description of either type of tag use <code>spacy.explain(tag_)</code></li></ul><div class="note  flat info"><p><code>token.pos</code> and <code>token.tag</code> return integer hash values !</p></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform standard imports</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a simple Doc object</span></span><br><span class="line">doc = nlp(<span class="string">u&quot;Apple is looking at buying U.K. startup for $1 Billion.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;token.text:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;token.pos_:&#123;<span class="number">8</span>&#125;</span>&#125; <span class="subst">&#123;token.tag_:&#123;<span class="number">6</span>&#125;</span>&#125; <span class="subst">&#123;spacy.explain(token.tag_)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple      PROPN    NNP    noun, proper singular</span><br><span class="line">is         VERB     VBZ    verb, 3rd person singular present</span><br><span class="line">looking    VERB     VBG    verb, gerund or present participle</span><br><span class="line">at         ADP      IN     conjunction, subordinating or preposition</span><br><span class="line">buying     VERB     VBG    verb, gerund or present participle</span><br><span class="line">U.K.       PROPN    NNP    noun, proper singular</span><br><span class="line">startup    NOUN     NN     noun, singular or mass</span><br><span class="line">for        ADP      IN     conjunction, subordinating or preposition</span><br><span class="line">$          SYM      $      symbol, currency</span><br><span class="line">1          NUM      CD     cardinal number</span><br><span class="line">Billion    NUM      CD     cardinal number</span><br><span class="line">.          PUNCT    .      punctuation mark, sentence closer</span><br></pre></td></tr></table></figure><h2 id="Coarse-grained-Part-of-speech-Tags"><a href="#Coarse-grained-Part-of-speech-Tags" class="headerlink" title="Coarse-grained Part-of-speech Tags"></a>Coarse-grained Part-of-speech Tags</h2><p>Every token is assigned a POS Tag from the following list:</p><table><thead><tr><th align="right">POS</th><th align="right">DESCRIPTION</th><th align="right">EXAMPLES</th></tr></thead><tbody><tr><td align="right">ADJ</td><td align="right">adjective</td><td align="right"><em>big, old, green, incomprehensible, first</em></td></tr><tr><td align="right">ADP</td><td align="right">adposition</td><td align="right"><em>in, to, during</em></td></tr><tr><td align="right">ADV</td><td align="right">adverb</td><td align="right"><em>very, tomorrow, down, where, there</em></td></tr><tr><td align="right">AUX</td><td align="right">auxiliary</td><td align="right"><em>is, has (done), will (do), should (do)</em></td></tr><tr><td align="right">CONJ</td><td align="right">conjunction</td><td align="right"><em>and, or, but</em></td></tr><tr><td align="right">CCONJ</td><td align="right">coordinating conjunction</td><td align="right"><em>and, or, but</em></td></tr><tr><td align="right">DET</td><td align="right">determiner</td><td align="right"><em>a, an, the</em></td></tr><tr><td align="right">INTJ</td><td align="right">interjection</td><td align="right"><em>psst, ouch, bravo, hello</em></td></tr><tr><td align="right">NOUN</td><td align="right">noun</td><td align="right"><em>girl, cat, tree, air, beauty</em></td></tr><tr><td align="right">NUM</td><td align="right">numeral</td><td align="right"><em>1, 2017, one, seventy-seven, IV, MMXIV</em></td></tr><tr><td align="right">PART</td><td align="right">particle</td><td align="right"><em>‘s, not,</em></td></tr><tr><td align="right">PRON</td><td align="right">pronoun</td><td align="right"><em>I, you, he, she, myself, themselves, somebody</em></td></tr><tr><td align="right">PROPN</td><td align="right">proper noun</td><td align="right"><em>Mary, John, London, NATO, HBO</em></td></tr><tr><td align="right">PUNCT</td><td align="right">punctuation</td><td align="right"><em>., (, ), ?</em></td></tr><tr><td align="right">SCONJ</td><td align="right">subordinating conjunction</td><td align="right"><em>if, while, that</em></td></tr><tr><td align="right">SYM</td><td align="right">symbol</td><td align="right"><em>$, %, §, ©, +, −, ×, ÷, &#x3D;, :), 😝</em></td></tr><tr><td align="right">VERB</td><td align="right">verb</td><td align="right"><em>run, runs, running, eat, ate, eating</em></td></tr><tr><td align="right">X</td><td align="right">other</td><td align="right"><em>sfpksdpsxmsa</em></td></tr><tr><td align="right">SPACE</td><td align="right">space</td><td align="right"></td></tr></tbody></table><h2 id="Fine-grained-Part-of-speech-Tags"><a href="#Fine-grained-Part-of-speech-Tags" class="headerlink" title="Fine-grained Part-of-speech Tags"></a>Fine-grained Part-of-speech Tags</h2><p>For a current list of tags for all languages visit <a href="https://spacy.io/api/annotation#pos-tagging">https://spacy.io/api/annotation#pos-tagging</a></p><h2 id="Working-with-POS-Tags"><a href="#Working-with-POS-Tags" class="headerlink" title="Working with POS Tags"></a>Working with POS Tags</h2><p>In the English language, the same string of characters can have different meanings, even within the same sentence. For this reason, morphology is important. <strong>spaCy</strong> uses machine learning algorithms to best predict the use of a token in a sentence. Is <em>“I read books on NLP”</em> present or past tense? Is <em>wind</em> a verb or a noun?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;I read books on NLP.&#x27;</span>)</span><br><span class="line">r = doc[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;r.text:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;r.pos_:&#123;<span class="number">8</span>&#125;</span>&#125; <span class="subst">&#123;r.tag_:&#123;<span class="number">6</span>&#125;</span>&#125; <span class="subst">&#123;spacy.explain(r.tag_)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#read       VERB     VBP    verb, non-3rd person singular present</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;I read a book on NLP.&#x27;</span>)</span><br><span class="line">r = doc[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;r.text:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;r.pos_:&#123;<span class="number">8</span>&#125;</span>&#125; <span class="subst">&#123;r.tag_:&#123;<span class="number">6</span>&#125;</span>&#125; <span class="subst">&#123;spacy.explain(r.tag_)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#read       VERB     VBD    verb, past tense</span></span><br></pre></td></tr></table></figure><p>In the first example, with no other cues to work from, spaCy assumed that <em><strong>read</strong></em> was present tense.</p><p>In the second example the present tense form would be <em><strong>I am reading a book</strong></em>, so spaCy assigned the past tense.</p><h2 id="Counting-POS-Tags"><a href="#Counting-POS-Tags" class="headerlink" title="Counting POS Tags"></a>Counting POS Tags</h2><p>The <code>Doc.count_by()</code> method accepts a specific token attribute as its argument, and returns a frequency count of the given attribute as a dictionary object. Keys in the dictionary are the integer values of the given attribute ID, and values are the frequency. Counts of zero are not included.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&quot;Apple is looking at buying U.K. startup for $1 Billion.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count the frequencies of different coarse-grained POS tags:</span></span><br><span class="line">POS_counts = doc.count_by(spacy.attrs.POS)</span><br><span class="line">POS_counts</span><br><span class="line"><span class="comment">#&#123;96: 1, 98: 1, 99: 3, 84: 2, 91: 1, 92: 2, 95: 2&#125;</span></span><br></pre></td></tr></table></figure><p>This isn’t very helpful until you decode the attribute ID:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc.vocab[<span class="number">96</span>].text</span><br><span class="line"><span class="comment"># &#x27;PUNCT&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Count the different fine-grained tags:</span></span><br><span class="line">TAG_counts = doc.count_by(spacy.attrs.TAG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">sorted</span>(TAG_counts.items()):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k:&lt;&#123;<span class="number">23</span>&#125;</span>&#125; <span class="subst">&#123;doc.vocab[k].text:&#123;<span class="number">4</span>&#125;</span>&#125;: <span class="subst">&#123;v:&lt;&#123;<span class="number">5</span>&#125;</span>&#125; <span class="subst">&#123;spacy.explain(doc.vocab[k].text)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1292078113972184607     IN  : 2     conjunction, subordinating or preposition</span><br><span class="line">1534113631682161808     VBG : 2     verb, gerund or present participle</span><br><span class="line">8427216679587749980     CD  : 2     cardinal number</span><br><span class="line">11283501755624150392    $   : 1     symbol, currency</span><br><span class="line">12646065887601541794    .   : 1     punctuation mark, sentence closer</span><br><span class="line">13927759927860985106    VBZ : 1     verb, 3rd person singular present</span><br><span class="line">15308085513773655218    NN  : 1     noun, singular or mass</span><br><span class="line">15794550382381185553    NNP : 2     noun, proper singular</span><br></pre></td></tr></table></figure><div class="note  flat info"><p><strong>Why did the ID numbers get so big?</strong></p><p>In spaCy, certain text values are hardcoded into <code>Doc.vocab</code> and take up the first several hundred ID numbers. Strings like ‘NOUN’ and ‘VERB’ are used frequently by internal operations. Others, like fine-grained tags, are assigned hash values as needed.</p></div><div class="note  flat info"><p><strong>Why don’t SPACE tags appear?</strong></p><p>In spaCy, only strings of spaces (two or more) are assigned tokens. Single spaces are not.</p></div><h1 id="Visualizing-Parts-of-Speech"><a href="#Visualizing-Parts-of-Speech" class="headerlink" title="Visualizing Parts of Speech"></a>Visualizing Parts of Speech</h1><p>spaCy offers an outstanding visualizer called <strong>displaCy</strong>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform standard imports</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import the displaCy library</span></span><br><span class="line"><span class="keyword">from</span> spacy <span class="keyword">import</span> displacy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a simple Doc object</span></span><br><span class="line">doc = nlp(<span class="string">u&quot;A quick brown fox jumps over the lazy dog.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Render the dependency parse immediately inside Jupyter:</span></span><br><span class="line">displacy.render(doc, style=<span class="string">&#x27;dep&#x27;</span>, jupyter=<span class="literal">True</span>, options=&#123;<span class="string">&#x27;distance&#x27;</span>: <span class="number">110</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240125110524573.png"></p><p>The dependency parse shows the coarse POS tag for each token, as well as the <strong>dependency tag</strong> if given:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;token.text:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;token.pos_:&#123;<span class="number">7</span>&#125;</span>&#125; <span class="subst">&#123;token.dep_:&#123;<span class="number">7</span>&#125;</span>&#125; <span class="subst">&#123;spacy.explain(token.dep_)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A          DET     det     determiner</span><br><span class="line">quick      ADJ     amod    adjectival modifier</span><br><span class="line">brown      ADJ     amod    adjectival modifier</span><br><span class="line">fox        NOUN    nsubj   nominal subject</span><br><span class="line">jumps      VERB    ROOT    None</span><br><span class="line">over       ADP     prep    prepositional modifier</span><br><span class="line">the        DET     det     determiner</span><br><span class="line">lazy       ADJ     amod    adjectival modifier</span><br><span class="line">dog        NOUN    pobj    object of preposition</span><br><span class="line">.          PUNCT   punct   punctuation</span><br></pre></td></tr></table></figure><h1 id="Creating-Visualizations-Outside-of-Jupyter"><a href="#Creating-Visualizations-Outside-of-Jupyter" class="headerlink" title="Creating Visualizations Outside of Jupyter"></a>Creating Visualizations Outside of Jupyter</h1><p>If you’re using another Python IDE or writing a script, you can choose to have spaCy serve up HTML separately.</p><p>Instead of <code>displacy.render()</code>, use <code>displacy.serve()</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">displacy.serve(doc, style=<span class="string">&#x27;dep&#x27;</span>, options=&#123;<span class="string">&#x27;distance&#x27;</span>: <span class="number">110</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="Handling-Large-Text"><a href="#Handling-Large-Text" class="headerlink" title="Handling Large Text"></a>Handling Large Text</h2><p><code>displacy.serve()</code> accepts a single Doc or list of Doc objects. Since large texts are difficult to view in one line, you may want to pass <strong>a list of spans</strong> instead. Each span will appear on its own line:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc2 = nlp(<span class="string">u&quot;This is a sentence. This is another, possibly longer sentence.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create spans from Doc.sents:</span></span><br><span class="line">spans = <span class="built_in">list</span>(doc2.sents)</span><br><span class="line"></span><br><span class="line">displacy.serve(spans, style=<span class="string">&#x27;dep&#x27;</span>, options=&#123;<span class="string">&#x27;distance&#x27;</span>: <span class="number">110</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="Customizing-the-Appearance"><a href="#Customizing-the-Appearance" class="headerlink" title="Customizing the Appearance"></a>Customizing the Appearance</h2><p>Besides setting the distance between tokens, you can pass other arguments to the <code>options</code> parameter:</p><table><thead><tr><th align="right">NAME</th><th align="right">TYPE</th><th align="right">DESCRIPTION</th><th align="right">DEFAULT</th></tr></thead><tbody><tr><td align="right"><code>compact</code></td><td align="right">bool</td><td align="right">“Compact mode” with square arrows that takes up less space.</td><td align="right"><code>False</code></td></tr><tr><td align="right"><code>color</code></td><td align="right">unicode</td><td align="right">Text color (HEX, RGB or color names).</td><td align="right"><code>#000000</code></td></tr><tr><td align="right"><code>bg</code></td><td align="right">unicode</td><td align="right">Background color (HEX, RGB or color names).</td><td align="right"><code>#ffffff</code></td></tr><tr><td align="right"><code>font</code></td><td align="right">unicode</td><td align="right">Font name or font family for all text.</td><td align="right"><code>Arial</code></td></tr></tbody></table><p>For a full list of options visit <a href="https://spacy.io/api/top-level#displacy_options">https://spacy.io/api/top-level#displacy_options</a></p><h1 id="Named-Entity-Recognition"><a href="#Named-Entity-Recognition" class="headerlink" title="Named Entity Recognition"></a>Named Entity Recognition</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform standard imports</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write a function to display basic entity info:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_ents</span>(<span class="params">doc</span>):</span><br><span class="line">    <span class="keyword">if</span> doc.ents:</span><br><span class="line">        <span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">            <span class="built_in">print</span>(ent.text+<span class="string">&#x27; - &#x27;</span>+ent.label_+<span class="string">&#x27; - &#x27;</span>+<span class="built_in">str</span>(spacy.explain(ent.label_)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No named entities found.&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">doc = nlp(<span class="string">&quot;I am heading to New York City and will visit Statue of Liberty tomorrow&quot;</span>)</span><br><span class="line"></span><br><span class="line">show_ents(doc)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New York City - GPE - Countries, cities, states</span><br><span class="line">Statue of Liberty - ORG - Companies, agencies, institutions, etc.</span><br><span class="line">tomorrow - DATE - Absolute or relative dates or periods</span><br></pre></td></tr></table></figure><h2 id="Entity-annotations"><a href="#Entity-annotations" class="headerlink" title="Entity annotations"></a>Entity annotations</h2><p><code>Doc.ents</code> are token spans with their own set of annotations.</p><table><thead><tr><th></th><th>Annotation</th></tr></thead><tbody><tr><td><code>ent.text</code></td><td>The original entity text</td></tr><tr><td><code>ent.label</code></td><td>The entity type’s hash value</td></tr><tr><td><code>ent.label_</code></td><td>The entity type’s string description</td></tr><tr><td><code>ent.start</code></td><td>The token span’s <em>start</em> index position in the Doc</td></tr><tr><td><code>ent.end</code></td><td>The token span’s <em>stop</em> index position in the Doc</td></tr><tr><td><code>ent.start_char</code></td><td>The entity text’s <em>start</em> index position in the Doc</td></tr><tr><td><code>ent.end_char</code></td><td>The entity text’s <em>stop</em> index position in the Doc</td></tr></tbody></table><h2 id="NER-Tags"><a href="#NER-Tags" class="headerlink" title="NER Tags"></a>NER Tags</h2><p>Tags are accessible through the <code>.label_</code> property of an entity.</p><table><thead><tr><th align="right">TYPE</th><th align="right">DESCRIPTION</th><th align="right">EXAMPLE</th></tr></thead><tbody><tr><td align="right"><code>PERSON</code></td><td align="right">People, including fictional.</td><td align="right"><em>Fred Flintstone</em></td></tr><tr><td align="right"><code>NORP</code></td><td align="right">Nationalities or religious or political groups.</td><td align="right"><em>The Republican Party</em></td></tr><tr><td align="right"><code>FAC</code></td><td align="right">Buildings, airports, highways, bridges, etc.</td><td align="right"><em>Logan International Airport, The Golden Gate</em></td></tr><tr><td align="right"><code>ORG</code></td><td align="right">Companies, agencies, institutions, etc.</td><td align="right"><em>Microsoft, FBI, MIT</em></td></tr><tr><td align="right"><code>GPE</code></td><td align="right">Countries, cities, states.</td><td align="right"><em>France, UAR, Chicago, Idaho</em></td></tr><tr><td align="right"><code>LOC</code></td><td align="right">Non-GPE locations, mountain ranges, bodies of water.</td><td align="right"><em>Europe, Nile River, Midwest</em></td></tr><tr><td align="right"><code>PRODUCT</code></td><td align="right">Objects, vehicles, foods, etc. (Not services.)</td><td align="right"><em>Formula 1</em></td></tr><tr><td align="right"><code>EVENT</code></td><td align="right">Named hurricanes, battles, wars, sports events, etc.</td><td align="right"><em>Olympic Games</em></td></tr><tr><td align="right"><code>WORK_OF_ART</code></td><td align="right">Titles of books, songs, etc.</td><td align="right"><em>The Mona Lisa</em></td></tr><tr><td align="right"><code>LAW</code></td><td align="right">Named documents made into laws.</td><td align="right"><em>Roe v. Wade</em></td></tr><tr><td align="right"><code>LANGUAGE</code></td><td align="right">Any named language.</td><td align="right"><em>English</em></td></tr><tr><td align="right"><code>DATE</code></td><td align="right">Absolute or relative dates or periods.</td><td align="right"><em>20 July 1969</em></td></tr><tr><td align="right"><code>TIME</code></td><td align="right">Times smaller than a day.</td><td align="right"><em>Four hours</em></td></tr><tr><td align="right"><code>PERCENT</code></td><td align="right">Percentage, including “%”.</td><td align="right"><em>Eighty percent</em></td></tr><tr><td align="right"><code>MONEY</code></td><td align="right">Monetary values, including unit.</td><td align="right"><em>Twenty Cents</em></td></tr><tr><td align="right"><code>QUANTITY</code></td><td align="right">Measurements, as of weight or distance.</td><td align="right"><em>Several kilometers, 55kg</em></td></tr><tr><td align="right"><code>ORDINAL</code></td><td align="right">“first”, “second”, etc.</td><td align="right"><em>9th, Ninth</em></td></tr><tr><td align="right"><code>CARDINAL</code></td><td align="right">Numerals that do not fall under another type.</td><td align="right"><em>2, Two, Fifty-two</em></td></tr></tbody></table><h2 id="Adding-a-Named-Entity-to-a-Span"><a href="#Adding-a-Named-Entity-to-a-Span" class="headerlink" title="Adding a Named Entity to a Span"></a>Adding a Named Entity to a Span</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;Tesla is planning build a new U.K. factory for $6 million&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show_ents(doc)</span><br><span class="line"><span class="comment">#U.K. - GPE - Countries, cities, states</span></span><br><span class="line"><span class="comment">#$6 million - MONEY - Monetary values, including unit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># doc.ents returns a tuple</span></span><br><span class="line"><span class="built_in">type</span>(doc.ents)</span><br><span class="line"><span class="comment">#tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># each elementin the entities tuple is of type Span</span></span><br><span class="line"><span class="built_in">type</span>(doc.ents[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#spacy.tokens.span.Span</span></span><br></pre></td></tr></table></figure><p><font color=green>Right now, spaCy does not recognize “Tesla” as a company.</font></p><p>The method to add a named entity of your own is simple. Create a span in document for the phrase you are interested in with the TYPE of entity you want (i.e. PERSON, or ORG) or  and manually add it to the entities tuple.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.tokens <span class="keyword">import</span> Span</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the hash value of the ORG entity label</span></span><br><span class="line">ORG = doc.vocab.strings[<span class="string">u&#x27;ORG&#x27;</span>]  </span><br><span class="line"><span class="comment"># ORG </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Span for the new entity</span></span><br><span class="line">new_ent = Span(doc, <span class="number">0</span>, <span class="number">1</span>, label=ORG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the entity to the existing Doc object</span></span><br><span class="line">doc.ents = <span class="built_in">list</span>(doc.ents) + [new_ent]</span><br></pre></td></tr></table></figure><p><font color=green>In the code above, the arguments passed to <code>Span()</code> are:</font></p><ul><li><code>doc</code> - the name of the Doc object</li><li><code>0</code> - the <em>start</em> index position of the <strong>span</strong></li><li><code>1</code> - the <em>stop</em> index position (exclusive)</li><li><code>label=ORG</code> - the label assigned to our entity</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">show_ents(doc)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tesla - ORG - Companies, agencies, institutions, etc.</span><br><span class="line">U.K. - GPE - Countries, cities, states</span><br><span class="line">$6 million - MONEY - Monetary values, including unit</span><br></pre></td></tr></table></figure><h2 id="Adding-Named-Entities-to-All-Matching-Spans"><a href="#Adding-Named-Entities-to-All-Matching-Spans" class="headerlink" title="Adding Named Entities to All Matching Spans"></a>Adding Named Entities to All Matching Spans</h2><p>What if we want to tag <em>all</em> occurrences of “Tesla”? In this section we show how to use the PhraseMatcher to identify a series of spans in the Doc</p><p>The process is slghtly involved. The steps are: </p><p>(1) build a simple list of phrases to match, </p><p>(2) Create a phrase matcher using vocab, </p><p>(3) Create phrase patterns and add them to the matcher, </p><p>(4) Apply matcher to the doc, which finds <strong>spans</strong> of matches, </p><p>(5) use the found matches to create spans and add to the doc.ents as we did previously</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import PhraseMatcher and create a matcher object:</span></span><br><span class="line"><span class="keyword">from</span> spacy.matcher <span class="keyword">import</span> PhraseMatcher</span><br><span class="line">matcher = PhraseMatcher(nlp.vocab)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the desired phrase patterns:</span></span><br><span class="line">phrase_list = [<span class="string">&#x27;vacuum cleaner&#x27;</span>, <span class="string">&#x27;vacuum-cleaner&#x27;</span>]</span><br><span class="line">phrase_patterns = [nlp(text) <span class="keyword">for</span> text <span class="keyword">in</span> phrase_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># notice the use of list comprehension above, each element is really a doc object</span></span><br><span class="line"><span class="built_in">type</span>(phrase_patterns[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#spacy.tokens.doc.Doc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the patterns to our matcher object:</span></span><br><span class="line">matcher.add(<span class="string">&#x27;newproduct&#x27;</span>, <span class="literal">None</span>, *phrase_patterns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the matcher to our Doc object:</span></span><br><span class="line">matches = matcher(doc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># See what matches occur:</span></span><br><span class="line">matches</span><br><span class="line"><span class="comment">#[(2689272359382549672, 7, 9), (2689272359382549672, 14, 16)]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Here we create Spans from each match, and create named entities from them:</span></span><br><span class="line"><span class="keyword">from</span> spacy.tokens <span class="keyword">import</span> Span</span><br><span class="line"></span><br><span class="line">PROD = doc.vocab.strings[<span class="string">u&#x27;PRODUCT&#x27;</span>]</span><br><span class="line"></span><br><span class="line">new_ents = [Span(doc, <span class="keyword">match</span>[<span class="number">1</span>],<span class="keyword">match</span>[<span class="number">2</span>],label=PROD) <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches]</span><br><span class="line"></span><br><span class="line">doc.ents = <span class="built_in">list</span>(doc.ents) + new_ents</span><br><span class="line"></span><br><span class="line">show_ents(doc)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vacuum cleaner - PRODUCT - Objects, vehicles, foods, etc. (not services)</span><br><span class="line">vacuum cleaner - PRODUCT - Objects, vehicles, foods, etc. (not services)</span><br><span class="line">first - ORDINAL - &quot;first&quot;, &quot;second&quot;, etc.</span><br></pre></td></tr></table></figure><h2 id="Counting-Entities"><a href="#Counting-Entities" class="headerlink" title="Counting Entities"></a>Counting Entities</h2><p>While spaCy may <strong>not</strong> have a built-in tool for counting entities, we can pass a conditional statement into a list comprehension:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;Originally priced at $29.50, the sweater was marked down to five dollars.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>([ent <span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents <span class="keyword">if</span> ent.label_==<span class="string">&#x27;MONEY&#x27;</span>])</span><br><span class="line"><span class="comment">#2</span></span><br></pre></td></tr></table></figure><h2 id="Problem-with-Line-Breaks"><a href="#Problem-with-Line-Breaks" class="headerlink" title="Problem with Line Breaks"></a><font color=blue>Problem with Line Breaks</font></h2><div class="alert alert-info" style="margin: 20px">There's a <a href='https://github.com/explosion/spaCy/issues/1717'>known issue</a> with <strong>spaCy v2.0.12</strong> where some linebreaks are interpreted as `GPE` entities:</div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;Originally priced at $29.50,\nthe sweater was marked down to five dollars.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show_ents(doc)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">29.50 - MONEY - Monetary values, including unit</span><br><span class="line"></span><br><span class="line"> - GPE - Countries, cities, states</span><br><span class="line">five dollars - MONEY - Monetary values, including unit</span><br></pre></td></tr></table></figure><p>However, there is a simple fix that can be added to the nlp pipeline:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Quick function to remove ents formed on whitespace:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_whitespace_entities</span>(<span class="params">doc</span>):</span><br><span class="line">    doc.ents = [e <span class="keyword">for</span> e <span class="keyword">in</span> doc.ents <span class="keyword">if</span> <span class="keyword">not</span> e.text.isspace()]</span><br><span class="line">    <span class="keyword">return</span> doc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Insert this into the pipeline AFTER the ner component:</span></span><br><span class="line">nlp.add_pipe(remove_whitespace_entities, after=<span class="string">&#x27;ner&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rerun nlp on the text above, and show ents:</span></span><br><span class="line">doc = nlp(<span class="string">u&#x27;Originally priced at $29.50,\nthe sweater was marked down to five dollars.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show_ents(doc)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">29.50 - MONEY - Monetary values, including unit</span><br><span class="line">five dollars - MONEY - Monetary values, including unit</span><br></pre></td></tr></table></figure><h2 id="Noun-Chunks"><a href="#Noun-Chunks" class="headerlink" title="Noun Chunks"></a>Noun Chunks</h2><p><code>Doc.noun_chunks</code> are <em>base noun phrases</em>: token spans that include the noun and words describing the noun. Noun chunks cannot be nested, cannot overlap, and do not involve prepositional phrases or relative clauses.</p><p>Where <code>Doc.ents</code> rely on the <strong>ner</strong> pipeline component, <code>Doc.noun_chunks</code> are provided by the <strong>parser</strong>.</p><h3 id="noun-chunks-components"><a href="#noun-chunks-components" class="headerlink" title="noun_chunks components:"></a><code>noun_chunks</code> components:</h3><table><thead><tr><th></th><th>Description</th></tr></thead><tbody><tr><td><code>.text</code></td><td>The original noun chunk text.</td></tr><tr><td><code>.root.text</code></td><td>The original text of the word connecting the noun chunk to the rest of the parse.</td></tr><tr><td><code>.root.dep_</code></td><td>Dependency relation connecting the root to its head.</td></tr><tr><td><code>.root.head.text</code></td><td>The text of the root token’s head.</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&quot;Autonomous cars shift insurance liability toward manufacturers.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc.noun_chunks:</span><br><span class="line">    <span class="built_in">print</span>(chunk.text+<span class="string">&#x27; - &#x27;</span>+chunk.root.text+<span class="string">&#x27; - &#x27;</span>+chunk.root.dep_+<span class="string">&#x27; - &#x27;</span>+chunk.root.head.text)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Autonomous cars - cars - nsubj - shift</span><br><span class="line">insurance liability - liability - dobj - shift</span><br><span class="line">manufacturers - manufacturers - pobj - toward</span><br></pre></td></tr></table></figure><h3 id="Doc-noun-chunks-is-a-generator-function"><a href="#Doc-noun-chunks-is-a-generator-function" class="headerlink" title="Doc.noun_chunks is a generator function"></a><code>Doc.noun_chunks</code> is a generator function</h3><p>Previously we mentioned that <code>Doc</code> objects do not retain a list of sentences, but they’re available through the <code>Doc.sents</code> generator.</p><p>It’s the same with <code>Doc.noun_chunks</code> - lists can be created if needed:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="built_in">list</span>(doc.noun_chunks))</span><br><span class="line"><span class="comment">#3</span></span><br></pre></td></tr></table></figure><h1 id="Visualizing-Named-Entities"><a href="#Visualizing-Named-Entities" class="headerlink" title="Visualizing Named Entities"></a>Visualizing Named Entities</h1><p>Besides viewing Part of Speech dependencies with <code>style=&#39;dep&#39;</code>, <strong>displaCy</strong> offers a <code>style=&#39;ent&#39;</code> visualizer:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform standard imports</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import the displaCy library</span></span><br><span class="line"><span class="keyword">from</span> spacy <span class="keyword">import</span> displacy</span><br><span class="line"></span><br><span class="line">doc = nlp(<span class="string">u&#x27;Over the last quarter Apple sold nearly 20 thousand iPods for a profit of $6 million. &#x27;</span></span><br><span class="line">         <span class="string">u&#x27;By contrast, Sony sold only 7 thousand Walkman music players.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">displacy.render(doc, style=<span class="string">&#x27;ent&#x27;</span>, jupyter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div class="entities" style="line-height:2.5">Over <mark class="entity" style="background:#bfe1d9;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    the last quarter    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">DATE</span></mark><mark class="entity" style="background:#7aecec;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Apple    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold <mark class="entity" style="background:#e4e7d2;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    nearly 20 thousand    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">CARDINAL</span></mark><mark class="entity" style="background:#bfeeb7;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    iPods    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> for a profit of <mark class="entity" style="background:#e4e7d2;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    $6 million    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">MONEY</span></mark>. By contrast, <mark class="entity" style="background:#7aecec;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Sony    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold <mark class="entity" style="background:#e4e7d2;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    only 7 thousand    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">CARDINAL</span></mark><mark class="entity" style="background:#bfeeb7;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Walkman    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> music players.</div><h2 id="Viewing-Sentences-Line-by-Line"><a href="#Viewing-Sentences-Line-by-Line" class="headerlink" title="Viewing Sentences Line by Line"></a>Viewing Sentences Line by Line</h2><p>Unlike the <strong>displaCy</strong> dependency parse, the NER viewer has to take in a Doc object with an <code>ents</code> attribute. For this reason, we can’t just pass a list of spans to <code>.render()</code>, we have to create a new Doc from each <code>span.text</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    displacy.render(nlp(sent.text), style=<span class="string">&#x27;ent&#x27;</span>, jupyter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div class="note  flat info"><p>If a span does not contain any entities, displaCy will issue a harmless warning</p></div><h2 id="Viewing-Specific-Entities"><a href="#Viewing-Specific-Entities" class="headerlink" title="Viewing Specific Entities"></a>Viewing Specific Entities</h2><p>You can pass a list of entity types to restrict the visualization:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">options = &#123;<span class="string">&#x27;ents&#x27;</span>: [<span class="string">&#x27;ORG&#x27;</span>, <span class="string">&#x27;PRODUCT&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">displacy.render(doc, style=<span class="string">&#x27;ent&#x27;</span>, jupyter=<span class="literal">True</span>, options=options)</span><br></pre></td></tr></table></figure><div class="entities" style="line-height:2.5">Over the last quarter <mark class="entity" style="background:#7aecec;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Apple    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold nearly 20 thousand <mark class="entity" style="background:#bfeeb7;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    iPods    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> for a profit of $6 million. By contrast, <mark class="entity" style="background:#7aecec;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Sony    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold only 7 thousand <mark class="entity" style="background:#bfeeb7;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Walkman    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> music players.</div><h2 id="Customizing-Colors-and-Effects"><a href="#Customizing-Colors-and-Effects" class="headerlink" title="Customizing Colors and Effects"></a>Customizing Colors and Effects</h2><p>You can also pass background color and gradient options:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#colors = &#123;&#x27;ORG&#x27;: &#x27;orange&#x27;, &#x27;PRODUCT&#x27;:&#x27;yellow&#x27;&#125;</span></span><br><span class="line">colors = &#123;<span class="string">&#x27;ORG&#x27;</span>: <span class="string">&#x27;Linear-gradient(90deg, orange, green)&#x27;</span>, <span class="string">&#x27;PRODUCT&#x27;</span>: <span class="string">&#x27;radial-gradient(pink, purple)&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#colors = &#123;&#x27;ORG&#x27;: &#x27;linear-gradient(90deg, #aa9cfc, #fc9ce7)&#x27;, &#x27;PRODUCT&#x27;: &#x27;radial-gradient(yellow, green)&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">options = &#123;<span class="string">&#x27;ents&#x27;</span>: [<span class="string">&#x27;ORG&#x27;</span>, <span class="string">&#x27;PRODUCT&#x27;</span>], <span class="string">&#x27;colors&#x27;</span>:colors&#125;</span><br><span class="line"></span><br><span class="line">displacy.render(doc, style=<span class="string">&#x27;ent&#x27;</span>, jupyter=<span class="literal">True</span>, options=options)</span><br></pre></td></tr></table></figure><div class="entities" style="line-height:2.5">Over the last quarter <mark class="entity" style="background:Linear-gradient(45deg, orange, green);padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Apple    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold nearly 20 thousand <mark class="entity" style="background:radial-gradient(pink, purple);padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    iPods    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> for a profit of $6 million. By contrast, <mark class="entity" style="background:Linear-gradient(45deg, orange, green);padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Sony    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark> sold only 7 thousand <mark class="entity" style="background:radial-gradient(pink, purple);padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Walkman    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark> music players.</div><h1 id="Sentence-Segmentation"><a href="#Sentence-Segmentation" class="headerlink" title="Sentence Segmentation"></a>Sentence Segmentation</h1><p>In this section we’ll learn how sentence segmentation works, and how to set our own segmentation rules.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform standard imports</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># From Spacy Basics:</span></span><br><span class="line">doc = nlp(<span class="string">u&#x27;This is the first sentence. This is another sentence. This is the last sentence.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is the first sentence.</span><br><span class="line">This is another sentence.</span><br><span class="line">This is the last sentence.</span><br></pre></td></tr></table></figure><h3 id="Doc-sents-is-a-generator"><a href="#Doc-sents-is-a-generator" class="headerlink" title="Doc.sents is a generator"></a><code>Doc.sents</code> is a generator</h3><p>It is important to note that <code>doc.sents</code> is a <em>generator</em>. That is, a Doc is not segmented until <code>doc.sents</code> is called. This means that, where you could print the second Doc token with <code>print(doc[1])</code>, you can’t call the “second Doc sentence” with <code>print(doc.sents[1])</code>:</p><h3 id="Convert-doc-sents-to-a-list"><a href="#Convert-doc-sents-to-a-list" class="headerlink" title="Convert doc.sents to a list"></a>Convert <code>doc.sents</code> to a list</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(doc.sents)</span><br></pre></td></tr></table></figure><h3 id="sents-are-spans"><a href="#sents-are-spans" class="headerlink" title="sents are spans"></a><code>sents</code> are spans</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">list</span>(doc.sents)[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#spacy.tokens.span.Span</span></span><br></pre></td></tr></table></figure><p>You <em>can</em> build a sentence collection by running <code>doc.sents</code> and saving the result to a list.</p><h2 id="Adding-Rules-for-sentence-segmentation"><a href="#Adding-Rules-for-sentence-segmentation" class="headerlink" title="Adding Rules for sentence segmentation"></a>Adding Rules for sentence segmentation</h2><p>spaCy’s built-in <code>sentencizer</code> relies on the dependency parse and end-of-sentence punctuation to determine segmentation rules. We can add rules of our own, but they have to be added <em>before</em> the creation of the Doc object, as that is where the parsing of segment start tokens happens:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Parsing the segmentation start tokens happens during the nlp pipeline</span></span><br><span class="line">doc2 = nlp(<span class="string">u&#x27;This is a sentence. This is a sentence. This is a sentence.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc2:</span><br><span class="line">    <span class="built_in">print</span>(token.is_sent_start, <span class="string">&#x27; &#x27;</span>+token.text)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">None  This</span><br><span class="line">None  is</span><br><span class="line">None  a</span><br><span class="line">None  sentence</span><br><span class="line">None  .</span><br><span class="line">True  This</span><br><span class="line">None  is</span><br><span class="line">None  a</span><br><span class="line">None  sentence</span><br><span class="line">None  .</span><br><span class="line">True  This</span><br><span class="line">None  is</span><br><span class="line">None  a</span><br><span class="line">None  sentence</span><br><span class="line">None  .</span><br></pre></td></tr></table></figure><p><font color=green>Notice we haven’t run <code>doc2.sents</code>, and yet <code>token.is_sent_start</code> was set to True on two tokens in the Doc.</font></p><p>Let’s add a semicolon to our existing segmentation rules. That is, whenever the sentencizer encounters a <strong>semicolon</strong>(;), the next token should start a new segment.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SPACY&#x27;S DEFAULT BEHAVIOR</span></span><br><span class="line">doc3 = nlp(<span class="string">u&#x27;&quot;Management is doing things right; leadership is doing the right things.&quot; -Peter Drucker&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc3.sents:</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br><span class="line"><span class="comment">#&quot;Management is doing things right; leadership is doing the right things.&quot;</span></span><br><span class="line"><span class="comment">#-Peter Drucker</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ADD A NEW RULE TO THE PIPELINE</span></span><br><span class="line"><span class="comment"># Every token in document object maintains a fixed index position, </span></span><br><span class="line"><span class="comment"># which does not change. We will take advantage of that.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_custom_boundaries</span>(<span class="params">doc</span>):</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> doc[:-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> token.text == <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">            doc[token.i+<span class="number">1</span>].is_sent_start = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> doc</span><br><span class="line"></span><br><span class="line">nlp.add_pipe(set_custom_boundaries, before=<span class="string">&#x27;parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">nlp.pipe_names</span><br><span class="line"><span class="comment">#[&#x27;tagger&#x27;, &#x27;set_custom_boundaries&#x27;, &#x27;parser&#x27;, &#x27;ner&#x27;]</span></span><br></pre></td></tr></table></figure><p><font color=green>The new rule has to run before the document is parsed. Here we can either pass the argument <code>before=&#39;parser&#39;</code> or <code>first=True</code>.</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Re-run the Doc object creation:</span></span><br><span class="line">doc4 = nlp(<span class="string">u&#x27;&quot;Management is doing things right; leadership is doing the right things.&quot; -Peter Drucker&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc4.sents:</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Management is doing things right;</span><br><span class="line">leadership is doing the right things.&quot;</span><br><span class="line">-Peter Drucker</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># And yet the new rule doesn&#x27;t apply to the older Doc object:</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc3.sents:</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br><span class="line"><span class="comment">#&quot;Management is doing things right; leadership is doing the right things.&quot;</span></span><br><span class="line"><span class="comment">#-Peter Drucker</span></span><br></pre></td></tr></table></figure><h3 id="Why-not-change-the-token-directly"><a href="#Why-not-change-the-token-directly" class="headerlink" title="Why not change the token directly?"></a>Why not change the token directly?</h3><p>Why not simply set the <code>.is_sent_start</code> value to True on existing tokens?</p><div class="note  flat info"><p>Because spaCy refuses to change the tag after the document is parsed to prevent inconsistencies in the data.</p></div><h2 id="Changing-the-Rules"><a href="#Changing-the-Rules" class="headerlink" title="Changing the Rules"></a>Changing the Rules</h2><p>In some cases we want to <em>replace</em> spaCy’s default sentencizer with our own set of rules. In this section we’ll see how the default sentencizer breaks on periods. We’ll then replace this behavior with a sentencizer that breaks on linebreaks.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystring = <span class="string">u&quot;This is a sentence. This is another.\n\nThis is a \nthird sentence.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPACY DEFAULT BEHAVIOR:</span></span><br><span class="line">doc = nlp(mystring)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    <span class="built_in">print</span>([token.text <span class="keyword">for</span> token <span class="keyword">in</span> sent])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;sentence&#x27;, &#x27;.&#x27;]</span><br><span class="line">[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;another&#x27;, &#x27;.&#x27;, &#x27;\n\n&#x27;]</span><br><span class="line">[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;\n&#x27;, &#x27;third&#x27;, &#x27;sentence&#x27;, &#x27;.&#x27;]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CHANGING THE RULES</span></span><br><span class="line"><span class="keyword">from</span> spacy.pipeline <span class="keyword">import</span> SentenceSegmenter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_on_newlines</span>(<span class="params">doc</span>):</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    seen_newline = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> doc:</span><br><span class="line">        <span class="keyword">if</span> seen_newline:</span><br><span class="line">            <span class="keyword">yield</span> doc[start:word.i]</span><br><span class="line">            start = word.i</span><br><span class="line">            seen_newline = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> word.text.startswith(<span class="string">&#x27;\n&#x27;</span>): <span class="comment"># handles multiple occurrences</span></span><br><span class="line">            seen_newline = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">yield</span> doc[start:]      <span class="comment"># handles the last group of tokens</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbd = SentenceSegmenter(nlp.vocab, strategy=split_on_newlines)</span><br><span class="line">nlp.add_pipe(sbd)</span><br><span class="line">nlp.pipe_names</span><br><span class="line"><span class="comment">#[&#x27;tagger&#x27;, &#x27;parser&#x27;, &#x27;ner&#x27;, &#x27;sbd&#x27;]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(mystring)</span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    <span class="built_in">print</span>([token.text <span class="keyword">for</span> token <span class="keyword">in</span> sent])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;sentence&#x27;, &#x27;.&#x27;, &#x27;This&#x27;, &#x27;is&#x27;, &#x27;another&#x27;, &#x27;.&#x27;, &#x27;\n\n&#x27;]</span><br><span class="line">[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;\n&#x27;]</span><br><span class="line">[&#x27;third&#x27;, &#x27;sentence&#x27;, &#x27;.&#x27;]</span><br></pre></td></tr></table></figure><p>Here we see that periods no longer affect segmentation, only linebreaks do. This would be appropriate when working with a long list of tweets, for instance.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> spaCy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Element表单中按钮的摆放（内嵌/追加）</title>
      <link href="/p/a4189438/"/>
      <url>/p/a4189438/</url>
      
        <content type="html"><![CDATA[<h1 id="内嵌用法"><a href="#内嵌用法" class="headerlink" title="内嵌用法"></a>内嵌用法</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240122215722256.png"></p><h2 id="实现代码（template）"><a href="#实现代码（template）" class="headerlink" title="实现代码（template）"></a>实现代码（template）</h2><p>在想要内嵌按钮的<code>el-input</code>中添加：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">suffix</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getPhoneCode&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: none&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;showPhoneCode&quot;</span>&gt;</span>发送验证码<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;!showPhoneCode&quot;</span> <span class="attr">class</span>=<span class="string">&quot;count&quot;</span>&gt;</span>&#123;&#123; formatTimeSecond &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>el-input</code>原本是单标签，这里需要改成双标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;confirmForm.phoneCode&quot;</span> <span class="attr">class</span>=<span class="string">&quot;code&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">clearable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">suffix</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getPhoneCode&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: none&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;showPhoneCode&quot;</span>&gt;</span>发送验证码<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;!showPhoneCode&quot;</span> <span class="attr">class</span>=<span class="string">&quot;count&quot;</span>&gt;</span>&#123;&#123; formatTimeSecond &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="美化代码（style）"><a href="#美化代码（style）" class="headerlink" title="美化代码（style）"></a>美化代码（style）</h2><ol><li>添加<code>el-button</code>后，会发现，<code>clear</code>图标会在<code>el-button</code>后，需将<code>clear</code>图标和<code>el-button</code>的位置颠倒过来：</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:deep &#123;</span><br><span class="line">  <span class="selector-class">.el-input__suffix</span> &#123;</span><br><span class="line">    <span class="selector-class">.el-input__suffix-inner</span> <span class="selector-class">.el-button</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#00aaf8</span>; // 修改el-<span class="selector-tag">button</span>字体颜色</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;-inner &#123;</span><br><span class="line">      <span class="attribute">flex-direction</span>: row-reverse;</span><br><span class="line">      -webkit-<span class="attribute">flex-direction</span>: row-reverse;</span><br><span class="line">      <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>另外，<code>el-input</code>会有自带的在尾部的×和√的图标，可通过以下方法去掉：</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-form-item</span> :deep .el-input__validateIcon &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="追加用法"><a href="#追加用法" class="headerlink" title="追加用法"></a>追加用法</h1><h2 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240122221702613-1705933325543-1.png"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>其实非常之简单，网上一堆教程我用了都不行（</p><p>只需要把<code>el-input</code>的width改小一点就可以了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">&quot;email&quot;</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:80%;&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;form.email&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;showEmailDialog=true&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/m0_50115641/article/details/128910124">Element表单el-input嵌入按钮样式修改_el-input 样式-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】NLP Fundamentals &amp; Introduction to spaCy</title>
      <link href="/p/ae6b0147/"/>
      <url>/p/ae6b0147/</url>
      
        <content type="html"><![CDATA[<h1 id="NLP-Fundamentals-Common-Techniques"><a href="#NLP-Fundamentals-Common-Techniques" class="headerlink" title="NLP Fundamentals &amp; Common Techniques"></a>NLP Fundamentals &amp; Common Techniques</h1><h2 id="What-is-NLP"><a href="#What-is-NLP" class="headerlink" title="What is NLP"></a>What is NLP</h2><p>NLP attempts to use a variety of common techniques to create structure out of raw text data, by applying language specific grammatical rules and semantics.</p><h2 id="Common-NLP-Techniques"><a href="#Common-NLP-Techniques" class="headerlink" title="Common NLP Techniques"></a>Common NLP Techniques</h2><table><thead><tr><th align="left">NLP Technique</th><th>Description</th></tr></thead><tbody><tr><td align="left">Tokenization(word segmentation)</td><td>Convert raw text into separate words or tokens.</td></tr><tr><td align="left">Parsing &amp; Tagging</td><td>Parsing is about creating a tree like structure with words, focusing on relationships between them. Tagging is attaching additional info with tokens.</td></tr><tr><td align="left">Stemming</td><td>Reducing words into their <strong>base form</strong> using rules</td></tr><tr><td align="left">Lemmatization</td><td>Reducing words into their <strong>base dictionary form</strong> (called as lemma)</td></tr><tr><td align="left">Stop Word Filtering</td><td></td></tr><tr><td align="left">Parts of Speech Tagging</td><td></td></tr><tr><td align="left">Named Entity Recognition</td><td></td></tr></tbody></table><h3 id="Tokenization"><a href="#Tokenization" class="headerlink" title="Tokenization"></a>Tokenization</h3><p>uses prefix, suffix and infix characters, and punctuation rules</p><h3 id="Stemming"><a href="#Stemming" class="headerlink" title="Stemming"></a>Stemming</h3><p>Portal’s Algorithm</p><p>cats→cat</p><h3 id="Lemmatization"><a href="#Lemmatization" class="headerlink" title="Lemmatization"></a>Lemmatization</h3><p>The lemma of <code>was</code> is <code>be</code></p><h3 id="Stop-word-Filtering"><a href="#Stop-word-Filtering" class="headerlink" title="Stop word Filtering"></a>Stop word Filtering</h3><p>Words like <code>a</code> and <code>the</code> appears so frequently that they don’t require tagging as thoroughly as nouns, verbs and modifiers.</p><p>We call these stop words.</p><h3 id="Part-of-Speech-Tagging"><a href="#Part-of-Speech-Tagging" class="headerlink" title="Part of Speech Tagging"></a>Part of Speech Tagging</h3><p>using linguistic knowledge to add useful information to tokens.</p><h3 id="Named-Entity-Recognition-NER"><a href="#Named-Entity-Recognition-NER" class="headerlink" title="Named Entity Recognition (NER)"></a>Named Entity Recognition (NER)</h3><p>seeks to locate and classify named entities.</p><h1 id="Introduction-to-NLTK-and-spcCy"><a href="#Introduction-to-NLTK-and-spcCy" class="headerlink" title="Introduction to NLTK and spcCy"></a>Introduction to NLTK and spcCy</h1><h2 id="What-is-NLTK"><a href="#What-is-NLTK" class="headerlink" title="What is NLTK"></a>What is NLTK</h2><p>Natural Language Toolkit</p><h2 id="What-is-spcCy"><a href="#What-is-spcCy" class="headerlink" title="What is spcCy"></a>What is spcCy</h2><p>choosing the most efficient method</p><h2 id="Getting-Started-with-spcCy"><a href="#Getting-Started-with-spcCy" class="headerlink" title="Getting Started with spcCy"></a>Getting Started with spcCy</h2><h3 id="Install-en-model"><a href="#Install-en-model" class="headerlink" title="Install en model"></a>Install en model</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --upgrade spacy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m spacy download en</span><br></pre></td></tr></table></figure><p>if failed, visit <a href="https://spacy.io/models/en#en_core_web_sm">English · spaCy Models Documentation</a>, and then download the <code>.whl</code> file to disk and install.</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240121105911708.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install somewhere/en_core_web_sm-3.7.1-py3-none-any.whl</span><br></pre></td></tr></table></figure><h3 id="Using-spcCy"><a href="#Using-spcCy" class="headerlink" title="Using spcCy"></a>Using spcCy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import spaCy and load the language library</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Doc object</span></span><br><span class="line">doc = nlp(<span class="string">u&#x27;Apple is looking at buying a U.K. startup for $1 Billion&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print each token separately</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    <span class="built_in">print</span>(token.text, token.pos_, token.dep_)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple PROPN nsubj</span><br><span class="line">is VERB aux</span><br><span class="line">looking VERB ROOT</span><br><span class="line">at ADP prep</span><br><span class="line">buying VERB pcomp</span><br><span class="line">a DET det</span><br><span class="line">U.K. PROPN compound</span><br><span class="line">startup NOUN dobj</span><br><span class="line">for ADP prep</span><br><span class="line">$ SYM quantmod</span><br><span class="line">1 NUM compound</span><br><span class="line">Billion NUM pobj</span><br></pre></td></tr></table></figure><h3 id="spcCy-Objects"><a href="#spcCy-Objects" class="headerlink" title="spcCy Objects"></a>spcCy Objects</h3><p>After importing the spacy module in the cell above we loaded a <strong>model</strong> and named it <code>nlp</code>.<br>Next we created a <strong>Doc</strong> object by applying the model to our text, and named it <code>doc</code>.<br>spaCy also builds a companion <strong>Vocab</strong> object that we’ll cover in later sections.<br>The <strong>Doc</strong> object that holds the processed text is our focus here.</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>When we run <code>nlp</code>, our text enters a <em>processing pipeline</em> that first breaks down the text and then performs a series of operations to tag, parse and describe the data.</p><h3 id="Tokenization-POS-Dependencies"><a href="#Tokenization-POS-Dependencies" class="headerlink" title="Tokenization &amp; POS &amp; Dependencies"></a>Tokenization &amp; POS &amp; Dependencies</h3><p>The first step in processing text is to split up all the component parts (words &amp; punctuation) into “tokens”. These tokens are annotated inside the Doc object to contain descriptive information. </p><p>The next step after splitting the text up into tokens is to assign parts of speech.</p><p>We also looked at the syntactic dependencies assigned to each token. <code>Apple</code> is identified as an <code>nsubj</code> or the <em><strong>nominal subject</strong></em> of the sentence.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc2 = nlp(<span class="string">u&quot;Apple isn&#x27;t looking into startups anymore.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;token.text:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;token.pos_:&#123;<span class="number">10</span>&#125;</span>&#125; <span class="subst">&#123;token.dep_:&#123;<span class="number">10</span>&#125;</span>&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple      PROPN      nsubj     </span><br><span class="line">is         VERB       aux       </span><br><span class="line">n&#x27;t        ADV        neg       </span><br><span class="line">looking    VERB       ROOT      </span><br><span class="line">into       ADP        prep      </span><br><span class="line">startups   NOUN       pobj      </span><br><span class="line">anymore    ADV        advmod    </span><br><span class="line">.          PUNCT      punct     </span><br></pre></td></tr></table></figure><p>Notice how <code>isn&#39;t</code> has been split into <strong>two tokens</strong>. spaCy recognizes both the root verb <code>is</code> and the negation attached to it. Notice also that both the extended whitespace and the period at the end of the sentence are assigned their own tokens.</p><p>To see the full name of a tag use <code>spacy.explain(tag)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spacy.explain(<span class="string">&#x27;nsubj&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;nominal subject&#x27;</span></span><br><span class="line">spacy.explain(<span class="built_in">str</span>(doc[<span class="number">0</span>].pos_))</span><br><span class="line"><span class="comment"># &#x27;proper noun&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Additional-Token-Attributes"><a href="#Additional-Token-Attributes" class="headerlink" title="Additional Token Attributes"></a>Additional Token Attributes</h4><table><thead><tr><th align="left">Tag</th><th align="center">Description</th><th align="left">doc2[0].tag</th></tr></thead><tbody><tr><td align="left"><code>.text</code></td><td align="center">The original word text</td><td align="left"><code>Apple</code></td></tr><tr><td align="left"><code>.lemma_</code></td><td align="center">The base form of the word</td><td align="left"><code>apple</code></td></tr><tr><td align="left"><code>.pos_</code></td><td align="center">The simple part-of-speech tag</td><td align="left"><code>PROPN</code>&#x2F;<code>proper noun</code></td></tr><tr><td align="left"><code>.tag_</code></td><td align="center">The detailed part-of-speech tag</td><td align="left"><code>NNP</code>&#x2F;<code>noun, proper singular</code></td></tr><tr><td align="left"><code>.shape_</code></td><td align="center">The word shape – capitalization, punctuation, digits</td><td align="left"><code>Xxxxx</code></td></tr><tr><td align="left"><code>.is_alpha</code></td><td align="center">Is the token an alpha character?</td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>.is_stop</code></td><td align="center">Is the token part of a stop list, i.e. the most common words of the language?</td><td align="left"><code>False</code></td></tr></tbody></table><h3 id="Spans"><a href="#Spans" class="headerlink" title="Spans"></a>Spans</h3><p>Large Doc objects can be hard to work with at times. A <strong>span</strong> is a slice of Doc object in the form <code>Doc[start:stop]</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc3 = nlp(<span class="string">u&#x27;Although commmonly attributed to John Lennon from his song &quot;Beautiful Boy&quot;, \</span></span><br><span class="line"><span class="string">the phrase &quot;Life is what happens to us while we are making other plans&quot; was written by \</span></span><br><span class="line"><span class="string">cartoonist Allen Saunders and published in Reader\&#x27;s Digest in 1957, when Lennon was 17.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">life_quote = doc3[<span class="number">16</span>:<span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(life_quote)</span><br><span class="line"><span class="comment"># &quot;Life is what happens to us while we are making other plans&quot;</span></span><br><span class="line"><span class="built_in">type</span>(life_quote)</span><br><span class="line"><span class="comment"># spacy.tokens.span.Span</span></span><br></pre></td></tr></table></figure><h3 id="Sentences"><a href="#Sentences" class="headerlink" title="Sentences"></a>Sentences</h3><p>Certain tokens inside a Doc object may also receive a “start of sentence” tag. While this doesn’t immediately build a list of sentences, these tags enable the generation of sentence segments through <code>Doc.sents</code>. Later we’ll write our own segmentation rules.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc4 = nlp(<span class="string">u&#x27;This is the first sentence. This is another sentence. This is the last sentence.&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc4.sents:</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br><span class="line"><span class="comment"># This is the first sentence.</span></span><br><span class="line"><span class="comment"># This is another sentence.</span></span><br><span class="line"><span class="comment"># This is the last sentence.</span></span><br></pre></td></tr></table></figure><hr><h2 id="Tokenization-1"><a href="#Tokenization-1" class="headerlink" title="Tokenization"></a>Tokenization</h2><ul><li><strong>Prefix</strong>: Character(s) at the beginning ▸ <code>$ ( “ ¿</code></li><li><strong>Suffix</strong>: Character(s) at the end ▸ <code>km ) , . ! ”</code></li><li><strong>Infix</strong>: Character(s) in between ▸ <code>- -- / ...</code></li><li><strong>Exception</strong>: Special-case rule to split a string into several tokens or prevent a token from being split when punctuation rules are applied ▸ <code>St. U.S.</code></li></ul><h3 id="Prefixes-Suffixes-and-Infixes"><a href="#Prefixes-Suffixes-and-Infixes" class="headerlink" title="Prefixes, Suffixes and Infixes"></a>Prefixes, Suffixes and Infixes</h3><p>However, punctuation that exists as part of an email address, website or numerical value will be kept as part of the token.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc2 = nlp(<span class="string">u&quot;We&#x27;re here to help! Send snail-mail, email support@oursite.com or visit us at http://www.oursite.com!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> doc2:</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">email</span><br><span class="line">support@oursite.com</span><br><span class="line">or</span><br><span class="line">visit</span><br><span class="line">us</span><br><span class="line">at</span><br><span class="line">http://www.oursite.com</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p><font color=green>Note that the exclamation points, comma, and the hyphen in ‘snail-mail’ are assigned their own tokens, yet both the email address and website are preserved.</font></p><h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>Punctuation that exists as part of a known abbreviation will be kept as part of the token.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc4 = nlp(<span class="string">u&quot;Let&#x27;s visit St. Louis in the U.S. next year.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> doc4:</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Let</span><br><span class="line">&#x27;s</span><br><span class="line">visit</span><br><span class="line">St.</span><br><span class="line">Louis</span><br><span class="line">in</span><br><span class="line">the</span><br><span class="line">U.S.</span><br><span class="line">next</span><br><span class="line">year</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p><font color=green>Here the abbreviations for “Saint” and “United States” are both preserved.</font></p><h3 id="Counting-Vocab-Entries"><a href="#Counting-Vocab-Entries" class="headerlink" title="Counting Vocab Entries"></a>Counting Vocab Entries</h3><p><code>Vocab</code> objects contain a full library of items!</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(doc.vocab)</span><br><span class="line"><span class="comment"># 57852</span></span><br></pre></td></tr></table></figure><p><font color=green>NOTE: This number changes based on the language library loaded at the start, and any new lexemes introduced to the <code>vocab</code> when the <code>Doc</code> was created.</font></p><h3 id="Tokens-cannot-be-reassigned"><a href="#Tokens-cannot-be-reassigned" class="headerlink" title="Tokens cannot be reassigned"></a>Tokens cannot be reassigned</h3><p>Although <code>Doc</code> objects can be considered lists of tokens, they do <em>not</em> support item reassignment.</p><h3 id="Named-Entities"><a href="#Named-Entities" class="headerlink" title="Named Entities"></a>Named Entities</h3><p>Going a step beyond tokens, <em>named entities</em> add another layer of context. The language model recognizes that certain words are organizational names while others are locations, and still other combinations relate to money, dates, etc. Named entities are accessible through the <code>ents</code> property of a <code>Doc</code> object.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc8 = nlp(<span class="string">u&#x27;Apple to build a Hong Kong factory for $6 million&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc8.ents:</span><br><span class="line">    <span class="built_in">print</span>(ent.text+<span class="string">&#x27; - &#x27;</span>+ent.label_+<span class="string">&#x27; - &#x27;</span>+<span class="built_in">str</span>(spacy.explain(ent.label_)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple - ORG - Companies, agencies, institutions, etc.</span><br><span class="line">Hong Kong - GPE - Countries, cities, states</span><br><span class="line">$6 million - MONEY - Monetary values, including unit</span><br></pre></td></tr></table></figure><h3 id="Noun-Chunks"><a href="#Noun-Chunks" class="headerlink" title="Noun Chunks"></a>Noun Chunks</h3><p>Similar to <code>Doc.ents</code>, <code>Doc.noun_chunks</code> are another object property. <em>Noun chunks</em> are “base noun <strong>phrases</strong>“ – flat phrases that have a noun as their head. You can think of noun chunks as a noun plus the words describing the noun – for example, in <a href="https://en.wikipedia.org/wiki/The_Purple_People_Eater">Sheb Wooley’s 1958 song</a>, a <em>“one-eyed, one-horned, flying, purple people-eater”</em> would be one long noun chunk.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc11 = nlp(<span class="string">u&quot;He was a one-eyed, one-horned, flying, purple people-eater.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc11.noun_chunks:</span><br><span class="line">    <span class="built_in">print</span>(chunk.text)</span><br><span class="line"><span class="comment"># He</span></span><br><span class="line"><span class="comment"># a one-eyed, one-horned, flying, purple people-eater</span></span><br></pre></td></tr></table></figure><h3 id="Built-in-Visualizers"><a href="#Built-in-Visualizers" class="headerlink" title="Built-in Visualizers"></a>Built-in Visualizers</h3><p>spaCy includes a built-in visualization tool called <strong>displaCy</strong>. displaCy is able to detect whether you’re working in a <strong>Jupyter notebook</strong>, and will return markup that can be rendered in a cell right away. When you export your notebook, the visualizations will be included as <strong>HTML</strong>.</p><p>For more info visit <a href="https://spacy.io/usage/visualizers">https://spacy.io/usage/visualizers</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">u&#x27;Over the last quarter Apple sold nearly 20 thousand iPods for a profit of $6 million.&#x27;</span>)</span><br><span class="line">displacy.render(doc, style=<span class="string">&#x27;ent&#x27;</span>, jupyter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div class="entities" style="line-height:2.5">Over <mark class="entity" style="background:#bfe1d9;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    the last quarter    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">DATE</span></mark><mark class="entity" style="background:#7aecec;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    Apple    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">ORG</span></mark>sold <mark class="entity" style="background:#e4e7d2;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    nearly 20 thousand    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">CARDINAL</span></mark><mark class="entity" style="background:#bfeeb7;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    iPods    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">PRODUCT</span></mark>     for a profit of <mark class="entity" style="background:#e4e7d2;padding:0.45em 0.6em;margin:0 0.25em;line-height:1;border-radius:0.35em;box-decoration-break:clone;-webkit-box-decoration-break:clone">    $6 million    <span style="font-size:0.8em;font-weight:bold;line-height:1;border-radius:0.35em;text-transform:uppercase;vertical-align:middle;margin-left:0.5rem">MONEY</span></mark>    .<hr><h2 id="Stemming-1"><a href="#Stemming-1" class="headerlink" title="Stemming"></a>Stemming</h2><p>Often when searching text for a certain keyword, it helps if the search returns variations of the word. For instance, searching for “boat” might also return “boats” and “boating”. Here, “boat” would be the <strong>stem</strong> for [boat, boater, boating, boats].</p><p>Instead, we’ll use another popular NLP tool called <strong>NLTK</strong>.</p><h3 id="Porter-Stemmer"><a href="#Porter-Stemmer" class="headerlink" title="Porter Stemmer"></a>Porter Stemmer</h3><p>One of the most common - and effective - stemming tools is <a href="https://tartarus.org/martin/PorterStemmer/"><em>Porter’s Algorithm</em></a> developed by Martin Porter in <a href="https://tartarus.org/martin/PorterStemmer/def.txt">1980</a>. The algorithm employs five phases of word reduction, each with its own set of mapping rules.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import the toolkit and the full Porter Stemmer library</span></span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> nltk.stem.porter <span class="keyword">import</span> *</span><br><span class="line">p_stemmer = PorterStemmer()</span><br><span class="line">words = [<span class="string">&#x27;run&#x27;</span>,<span class="string">&#x27;runner&#x27;</span>,<span class="string">&#x27;running&#x27;</span>,<span class="string">&#x27;ran&#x27;</span>,<span class="string">&#x27;runs&#x27;</span>,<span class="string">&#x27;easily&#x27;</span>,<span class="string">&#x27;fairly&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(word+<span class="string">&#x27; --&gt; &#x27;</span>+p_stemmer.stem(word))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run --&gt; run</span><br><span class="line">runner --&gt; runner</span><br><span class="line">running --&gt; run</span><br><span class="line">ran --&gt; ran</span><br><span class="line">runs --&gt; run</span><br><span class="line">easily --&gt; easili</span><br><span class="line">fairly --&gt; fairli</span><br><span class="line">eighteen --&gt; eighteen</span><br></pre></td></tr></table></figure><p><font color=green>Note how the stemmer recognizes “runner” as a noun, not a verb form or participle. Also, the adverbs “easily” and “fairly” are stemmed to the unusual root “easili” and “fairli”</font></p><h3 id="Snowball-Stemmer"><a href="#Snowball-Stemmer" class="headerlink" title="Snowball Stemmer"></a>Snowball Stemmer</h3><p>This is somewhat of a misnomer, as Snowball is the name of a stemming language developed by Martin Porter. The algorithm used here is more acurately called the “English Stemmer” or “Porter2 Stemmer”. It offers a slight improvement over the original Porter stemmer, both in logic and speed.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem.snowball <span class="keyword">import</span> SnowballStemmer</span><br><span class="line"></span><br><span class="line"><span class="comment"># The Snowball Stemmer requires that you pass a language parameter</span></span><br><span class="line">s_stemmer = SnowballStemmer(language=<span class="string">&#x27;english&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(word+<span class="string">&#x27; --&gt; &#x27;</span>+s_stemmer.stem(word))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run --&gt; run</span><br><span class="line">runner --&gt; runner</span><br><span class="line">running --&gt; run</span><br><span class="line">ran --&gt; ran</span><br><span class="line">runs --&gt; run</span><br><span class="line">easily --&gt; easili</span><br><span class="line">fairly --&gt; fair</span><br></pre></td></tr></table></figure><p><font color=green>In this case the stemmer performed the same as the Porter Stemmer, with the exception that it handled the stem of “fairly” more appropriately with “fair”</font></p><p>Stemming has its drawbacks. If given the token <code>saw</code>, stemming might always return <code>saw</code>, whereas lemmatization would likely return either <code>see</code> or <code>saw</code> depending on whether the use of the token was as a verb or a noun. As an example, consider the following:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phrase = <span class="string">&#x27;I am meeting him tomorrow at the meeting&#x27;</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> phrase.split():</span><br><span class="line">    <span class="built_in">print</span>(word+<span class="string">&#x27; --&gt; &#x27;</span>+p_stemmer.stem(word))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I --&gt; I</span><br><span class="line">am --&gt; am</span><br><span class="line">meeting --&gt; meet</span><br><span class="line">him --&gt; him</span><br><span class="line">tomorrow --&gt; tomorrow</span><br><span class="line">at --&gt; at</span><br><span class="line">the --&gt; the</span><br><span class="line">meeting --&gt; meet</span><br></pre></td></tr></table></figure><p>Here the word “meeting” appears twice - once as a verb, and once as a noun, and yet the stemmer treats both equally.</p><hr><h2 id="Lemmatization-1"><a href="#Lemmatization-1" class="headerlink" title="Lemmatization"></a>Lemmatization</h2><p>In contrast to stemming, lemmatization looks beyond word reduction, and considers a language’s full vocabulary to apply a <em>morphological analysis</em> to words. The lemma of ‘was’ is ‘be’ and the lemma of ‘mice’ is ‘mouse’. Further, the lemma of ‘meeting’ might be ‘meet’ or ‘meeting’ depending on its use in a sentence.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line">doc1 = nlp(<span class="string">u&quot;I am a runner running in a race because I love to run since I ran today&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc1:</span><br><span class="line">    <span class="built_in">print</span>(token.text, <span class="string">&#x27;\t\t&#x27;</span>, token.pos_, <span class="string">&#x27;\t&#x27;</span>, token.lemma, <span class="string">&#x27;\t\t&#x27;</span>, token.lemma_)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I  PRON  561228191312463089  -PRON-</span><br><span class="line">am  VERB  10382539506755952630  be</span><br><span class="line">a  DET  11901859001352538922  a</span><br><span class="line">runner  NOUN  12640964157389618806  runner</span><br><span class="line">running  VERB  12767647472892411841  run</span><br><span class="line">in  ADP  3002984154512732771  in</span><br><span class="line">a  DET  11901859001352538922  a</span><br><span class="line">race  NOUN  8048469955494714898  race</span><br><span class="line">because  ADP  16950148841647037698  because</span><br><span class="line">I  PRON  561228191312463089  -PRON-</span><br><span class="line">love  VERB  3702023516439754181  love</span><br><span class="line">to  PART  3791531372978436496  to</span><br><span class="line">run  VERB  12767647472892411841  run</span><br><span class="line">since  ADP  10066841407251338481  since</span><br><span class="line">I  PRON  561228191312463089  -PRON-</span><br><span class="line">ran  VERB  12767647472892411841  run</span><br><span class="line">today  NOUN  11042482332948150395  today</span><br></pre></td></tr></table></figure><p><font color=green>In the above sentence, <code>running</code>, <code>run</code> and <code>ran</code> all point to the same lemma <code>run</code> (…11841) to avoid duplication.</font> </p><p>Also notice that Spacy does not try to find lemma for personal pronouns, instead it assigns them the same symbol <strong>-PRON-</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_lemmas</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> text:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;token.text:&#123;<span class="number">12</span>&#125;</span>&#125; <span class="subst">&#123;token.pos_:&#123;<span class="number">6</span>&#125;</span>&#125; <span class="subst">&#123;token.lemma:&lt;&#123;<span class="number">22</span>&#125;</span>&#125; <span class="subst">&#123;token.lemma_&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc3 = nlp(<span class="string">u&quot;I am meeting him tomorrow at the meeting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">show_lemmas(doc3)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I            PRON   561228191312463089     -PRON-</span><br><span class="line">am           VERB   10382539506755952630   be</span><br><span class="line">meeting      VERB   6880656908171229526    meet</span><br><span class="line">him          PRON   561228191312463089     -PRON-</span><br><span class="line">tomorrow     NOUN   3573583789758258062    tomorrow</span><br><span class="line">at           ADP    11667289587015813222   at</span><br><span class="line">the          DET    7425985699627899538    the</span><br><span class="line">meeting      NOUN   14798207169164081740   meeting</span><br><span class="line">.            PUNCT  12646065887601541794   .</span><br></pre></td></tr></table></figure><p><font color=green>Here the lemma of <code>meeting</code> is determined by its Part of Speech tag.</font></p><hr><h2 id="Stop-Words"><a href="#Stop-Words" class="headerlink" title="Stop Words"></a>Stop Words</h2><p>Words like “a” and “the” appear so frequently that they don’t require tagging as thoroughly as nouns, verbs and modifiers. We call these <em>stop words</em>, and they can be filtered from the text to be processed. spaCy holds a built-in list of some 305 English stop words.</p><h3 id="Add-a-stop-word"><a href="#Add-a-stop-word" class="headerlink" title="Add a stop word"></a>Add a stop word</h3><p>There may be times when you wish to add a stop word to the default set. Perhaps you decide that <code>&#39;btw&#39;</code> (common shorthand for “by the way”) should be considered a stop word.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add the word to the set of stop words. Use lowercase!</span></span><br><span class="line">nlp.Defaults.stop_words.add(<span class="string">&#x27;btw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the stop_word tag on the lexeme</span></span><br><span class="line">nlp.vocab[<span class="string">&#x27;btw&#x27;</span>].is_stop = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><font color=green>When adding stop words, always use lowercase. Lexemes are converted to lowercase before being added to <strong>vocab</strong>.</font></p><h3 id="Remove-a-stop-word"><a href="#Remove-a-stop-word" class="headerlink" title="Remove a stop word"></a>Remove a stop word</h3><p>Alternatively, you may decide that <code>&#39;beyond&#39;</code> should not be considered a stop word.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Remove the word from the set of stop words</span></span><br><span class="line">nlp.Defaults.stop_words.remove(<span class="string">&#x27;beyond&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove the stop_word tag from the lexeme</span></span><br><span class="line">nlp.vocab[<span class="string">&#x27;beyond&#x27;</span>].is_stop = <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> spaCy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Class与Style绑定</title>
      <link href="/p/4e982f2d/"/>
      <url>/p/4e982f2d/</url>
      
        <content type="html"><![CDATA[<p>Vue 专门为 <code>class</code> 和 <code>style</code> 的 <code>v-bind</code> 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p><h1 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h1><h2 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h2><p>我们可以给 <code>:class</code> (<code>v-bind:class</code> 的缩写) 传递一个对象来动态切换 class：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> hasError = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们也可以绑定一个返回对象的<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。这是一个常见且很有用的技巧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line">  <span class="string">&#x27;text-danger&#x27;</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组*"></a>绑定数组*</h2><p>我们可以给 <code>:class</code> 绑定一个数组来渲染<strong>多个</strong> CSS class：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> activeClass = <span class="title function_">ref</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> errorClass = <span class="title function_">ref</span>(<span class="string">&#x27;text-danger&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果也想在数组中<font color=#ff0000>有条件地渲染</font>某个 class，可以使用三元表达式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>errorClass</code> 会一直存在，但 <code>activeClass</code> 只会在 <code>isActive</code> 为真时才存在。</p><p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h1><h2 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h2><p><code>:style</code> 支持绑定 JavaScript 对象值，对应的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style">HTML 元素的 <code>style</code> 属性</a>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> activeColor = <span class="title function_">ref</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = <span class="title function_">ref</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>尽管推荐使用 camelCase，但 <code>:style</code> 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>我们还可以给 <code>:style</code> 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h2><p>当你在 <code>:style</code> 中使用了需要<a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">浏览器特殊前缀</a>的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p><h2 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h2><p>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 <code>display: flex</code>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cn.vuejs.org/guide/essentials/class-and-style.html#binding-html-classes">Class 与 Style 绑定 | Vue.js (vuejs.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】ES6知识储备</title>
      <link href="/p/403e0cac/"/>
      <url>/p/403e0cac/</url>
      
        <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/ECMAScript/1889420">ECMAScript</a> 6（简称ES6）是于2015年6月正式发布的<a href="https://baike.baidu.com/item/JavaScript/321142">JavaScript</a>语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序。</p><p>另外，一些情况下ES6也泛指ES2015及之后的新增特性，虽然之后的版本应当称为ES7、ES8等。</p><h1 id="ES6的新语法"><a href="#ES6的新语法" class="headerlink" title="ES6的新语法"></a>ES6的新语法</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p><code>let</code>声明变量，<code>const</code>声明常量。</p><p>使用了<code>let</code>和<code>const</code>后，只能在其所在作用域中访问相关属性。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量。</p><p>下面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>()</span><br></pre></td></tr></table></figure><h2 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h2><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="title function_">f</span>();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对象赋值简写"><a href="#对象赋值简写" class="headerlink" title="对象赋值简写"></a>对象赋值简写</h2><p>当key和value重名时，可以直接简写为一个。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`$&#123;&#125;`</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;lux&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>) <span class="comment">//hello lux 此处使用的是反引号</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li>省略关键字<code>function</code>，花括号<code>&#123;&#125;</code>用<code>=&gt;</code>代替了。这种写法更简洁了。</li><li>优点，就是函数体内的<code>this</code>的指向始终是指向定义它所在的对象，而不会指向调用它的对象，我们知道<code>es5</code>中的函数是谁执行它，它就指向谁。</li><li>有些情况下可以省略return关键字。</li><li>自身没有this，继承上下文的this关键字。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规编写 明确的返回值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">x, y</span>) =&gt; &#123;<span class="keyword">return</span> x + y; &#125;; </span><br><span class="line"><span class="comment">// 支持使用ES6 rest参数（展开运算符）和默认参数语法:</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">demoFun</span> = (<span class="params">param1, param2, ...rest</span>) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><blockquote><p>rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中，多余指的是形参列表中没有罗列出来的参数，且 rest 参数之后不能再有其他参数（即只能是最后一个参数）</p></blockquote><p>当函数有且仅有一个参数的时候，是可以省略掉括号的。</p><p>当函数返回有且仅有一个表达式的时候可以省略<code>&#123;&#125;</code> 和 <code>return</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  参数name就没有括号</span><br><span class="line">var people = name =&gt; &#x27;hello&#x27; + name</span><br><span class="line">//  但是返回一个对象时，函数体外要加圆括号，不然会被解析为代码段</span><br><span class="line">let demoFun = params =&gt; (&#123;foo: bar&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>Promise</code>的构造函数接收一个<a href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0&spm=1001.2101.3001.7020">函数参数</a>，并且传入两个参数：<code>resolve</code>，<code>reject</code>，分别表示<a href="https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">异步操作</a>执行成功后的回调函数和异步操作执行失败后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;随便什么数据&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;       <span class="comment">//返回Promise对象     </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">runAsync</span>()<span class="comment">//执行runAsunc函数</span></span><br></pre></td></tr></table></figure><p>包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">runAsync</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;   <span class="comment">//调用函数返回值（Promise对象）的then方法，执行操作完成后的动作。</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>在<code>runAsync()</code>的返回上（Promise对象）直接调用<code>then</code>方法，<code>then</code>接收一个参数，是函数，并且会拿到我们在<code>runAsync</code>中调用<code>resolve</code>时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p><code>Promise</code>在功能上和回调函数类似，而<code>Promise</code>的优势在于，可以在<code>then</code>方法中继续写<code>Promise</code>对象并返回，然后继续调用then来进行回调操作。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/SiriusZHT/p/14310748.html">【VUE】看完这篇文章能够了解es6特性和vue基础 - 嗨Sirius - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/7202073809653973052">Vue进阶（二十一）：ES6 知识储备 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/sunhuaqiang1/article/details/89362266">JavaScript进阶（二十）：精解 ES6 Promise 用法_javascript promise使用-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】ES数组操作</title>
      <link href="/p/495b9f0f/"/>
      <url>/p/495b9f0f/</url>
      
        <content type="html"><![CDATA[<h1 id="一、find-与findIndex"><a href="#一、find-与findIndex" class="headerlink" title="一、find()与findIndex()"></a>一、find()与findIndex()</h1><p><code>find()</code>用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><p><code>find()</code>回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">9</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//找出数组中第一个小于 0 的成员</span></span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p><code>findIndex()</code>用法与find()非常类似，返回第一个符合条件的数组成员位置，如果所有成员都不符合条件，则返回-1。</p><p>另外，这两个方法都可以发现<code>NaN</code>。</p><h1 id="二、filter"><a href="#二、filter" class="headerlink" title="二、filter()"></a>二、filter()</h1><p><code>filter()</code>使用指定的函数测试所有元素，并创建一个<strong>包含所有通过测试元素</strong>的新数组（不会改变原数组）。 <code>filter()</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 <code>true</code> 或 等价于 <code>true</code> 的值元素创建一个新数组。那些没有通过 <code>callback</code> 测试的元素会被跳过，不会被包含在新数组中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">//[40, 50]</span></span><br></pre></td></tr></table></figure><h1 id="三、forEach"><a href="#三、forEach" class="headerlink" title="三、forEach()"></a>三、forEach()</h1><p>遍历数组全部元素，利用回调函数对数组进行操作，自动遍历整个数组，且无法<code>break</code>中途跳出循环，不可控，不支持<code>return</code>操作，<code>return</code>只用于控制循环是否跳出当前循环。</p><p>回调有三个参数：第一个参数是遍历的数组内容，第二个参数是对应的数组索引，第三个参数是数组本身。</p><p>该方法无返回值，仅仅是遍历数组中的每一项，不对原来数组进行修改。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">42</span>,<span class="number">1</span>];  </span><br><span class="line"><span class="keyword">var</span> res = ary.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item,index,input</span>) &#123;  </span><br><span class="line">   input[index] = item*<span class="number">10</span>;  </span><br><span class="line">&#125;)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//--&gt; undefined;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ary);<span class="comment">//--&gt; 通过数组索引改变了原数组；  </span></span><br></pre></td></tr></table></figure><h1 id="四、some-与every"><a href="#四、some-与every" class="headerlink" title="四、some()与every()"></a>四、some()与every()</h1><p><code>some()</code>判断数组中是否<strong>至少有一个</strong>元素满足条件，<code>every()</code>判断数组中是否<strong>每个元素</strong>都满足条件。</p><h1 id="五、map"><a href="#五、map" class="headerlink" title="五、map()"></a>五、map()</h1><p><code>map()</code> 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), thisValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123; <span class="comment">//接收新数组</span></span><br><span class="line">  <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="title function_">alert</span>(arrayOfSquares); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><h1 id="六、reduce"><a href="#六、reduce" class="headerlink" title="六、reduce()"></a>六、reduce()</h1><p><code>reduce()</code>接收一个函数作为累加器(<code>accumulator</code>)，数组中的每个值(从左到右)开始合并，最终为一个值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(callback, initialValue)</span><br></pre></td></tr></table></figure><p><code>callback</code>：执行数组中每个值的函数(也可以叫做<code>reducer</code>)，包含4个参数。</p><ol><li><code>previousValue</code>: 上一次调用回调返回的值，或者是提供的初始值(<code>initialValue</code>)；</li><li><code>currentValue</code>: 数组中当前被处理的元素；</li><li><code>index</code>: 当前元素在数组中的索引；</li><li><code>array</code>: 调用<code>reduce</code>的数组；</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取购物车中商品列表的价格总和</span></span><br><span class="line"><span class="keyword">let</span> goodList = [&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">price</span>: <span class="number">10</span>, <span class="attr">qty</span>: <span class="number">5</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">price</span>: <span class="number">15</span>, <span class="attr">qty</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">price</span>: <span class="number">20</span>, <span class="attr">qty</span>: <span class="number">1</span>&#125;]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> totalPrice = goodList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur.<span class="property">price</span> * cur.<span class="property">qty</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(totalPrice) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrString = <span class="string">&#x27;abcdaabc&#x27;</span></span><br><span class="line"><span class="comment">// 获取字符中中每个字母出现的次数</span></span><br><span class="line"><span class="keyword">let</span> count = arrString.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">res, cur</span>) &#123;</span><br><span class="line">res[cur] ? res[cur]++ : res[cur] = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123;a: 3, b: 2, c: 2, d: 1&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/7224181887371575357">Vue进阶（五十七）：ES数组操作：find(), findIndex(), filter(), forEach(), some(), every(), map - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH连接github.com:22超时解决方法</title>
      <link href="/p/8e966ab9/"/>
      <url>/p/8e966ab9/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>写完文章和代码提交到GitHub时，提示SSH连接超时了，提交不了。</p><div class="note  flat danger"><p>ssh: connect to host github.com port 22: Connection timed out</p><p>Please make sure you have the correct access rights and the repository exists.</p></div><p>这下给我整不会了，之前提交都是没问题的，怎么突然就出问题了呢？</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>用浏览器访问GitHub官网，可以访问，说明目前的网络没有墙掉（有时候会）。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240117153604836.png"></p><p>检查SSH连接：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>然后就是之前显示的报错（</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>总之遇事不决百度一下，找到以下方法，亲测有效（</p><p>具体是改变SSH连接的端口，从22变为443（HTTPs）</p><ol><li>首先进入系统用户目录下的<code>.ssh</code>目录：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ol start="2"><li>然后创建一个<code>config</code>文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑文件内容（<code>i</code>）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail（你的邮箱）</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><ol start="4"><li>然后<code>:wq</code>即可。<del>（顺便复习vim编辑器用法了属于是）</del></li></ol><p>然后再提交就可以了~</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/tsalita/p/16181711.html">SSH：连接到主机github.com端口22：连接时间超时 - 天使阿丽塔 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/weixin_45637036/article/details/106560217">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”_ssh: connect to host github.com port 22: connectio-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 修bug日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP】Python Refresh</title>
      <link href="/p/f6e1007e/"/>
      <url>/p/f6e1007e/</url>
      
        <content type="html"><![CDATA[<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><p>Containers are data types intended to hold a collection of data.</p><ul><li>List</li><li>Tuple</li><li>Set</li><li>Dictionary</li></ul><div class="tabs" id="containers"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#containers-1">List</button></li><li class="tab"><button type="button" data-href="#containers-2">Set</button></li><li class="tab"><button type="button" data-href="#containers-3">Tuple</button></li><li class="tab"><button type="button" data-href="#containers-4">Dictionary</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="containers-1"><p>ordered, mutable, allows duplicates</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="containers-2"><p>not ordered, mutable, <strong>no</strong> duplicates, sorted</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="containers-3"><p>ordered, <strong>immutable</strong>, allows duplicates</p><p>(Can’t modify. Read only)</p><ul><li>count</li><li>index</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="containers-4"><p>not ordered, mutable, no duplicate keys</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h2 id="Packing-and-unpacking-values"><a href="#Packing-and-unpacking-values" class="headerlink" title="Packing and unpacking values"></a>Packing and unpacking values</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># I am interested only in what is at the head and tail of the list</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">20</span>]</span><br><span class="line">head, *body, tail = l</span><br><span class="line"><span class="built_in">print</span>(head, tail)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 20</span><br></pre></td></tr></table></figure><h1 id="Formatted-String"><a href="#Formatted-String" class="headerlink" title="Formatted String"></a>Formatted String</h1><h2 id="Formatted-String-Literals"><a href="#Formatted-String-Literals" class="headerlink" title="Formatted String Literals"></a>Formatted String Literals</h2><p>Introduced in Python 3.6, <strong>f-strings</strong> offer several benefits over the older <code>.format()</code> string method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Antonio&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the old .format() method:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;His name is &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using f-strings:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;His name is <span class="subst">&#123;name&#125;</span>.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Pass <code>!r</code> to get the <strong>string representation</strong>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;His name is <span class="subst">&#123;name!r&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">His name is &#x27;Antonio&#x27;</span><br></pre></td></tr></table></figure><p>Be careful not to let quotation marks in the replacement fields conflict with the quoting used in the outer string:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;first&#x27;</span>:<span class="number">123</span>,<span class="string">&#x27;second&#x27;</span>:<span class="number">456</span>&#125;</span><br><span class="line"><span class="comment"># wrong</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Address: <span class="subst">&#123;d[<span class="string">&#x27;first&#x27;</span>]&#125;</span> Main Street&#x27;</span>)</span><br><span class="line"><span class="comment"># right</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Address: <span class="subst">&#123;d[<span class="string">&#x27;first&#x27;</span>]&#125;</span> Main Street&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Minimum-Widths-Alignment-and-Padding"><a href="#Minimum-Widths-Alignment-and-Padding" class="headerlink" title="Minimum Widths, Alignment and Padding"></a>Minimum Widths, Alignment and Padding</h2><p>To set the alignment, use the character <code>&lt;</code> for left-align, <code>^</code> for center, <code>&gt;</code> for right.</p><p>To set padding, precede the alignment character with the padding character (<code>-</code> and <code>.</code> are common choices).</p><h1 id="Text-Files"><a href="#Text-Files" class="headerlink" title="Text Files"></a>Text Files</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># I am creating a file using ipython</span></span><br><span class="line"><span class="comment"># This function is specific to jupyter notebooks</span></span><br><span class="line"><span class="comment"># Alternatively, quickly create a file using a text editor.</span></span><br><span class="line">%%writefile test.txt</span><br><span class="line">Hello, this <span class="keyword">is</span> first line</span><br><span class="line">This <span class="keyword">is</span> second line</span><br><span class="line"></span><br><span class="line">%%writefile -a test.txt</span><br></pre></td></tr></table></figure><h1 id="PDF-Files"><a href="#PDF-Files" class="headerlink" title="PDF Files"></a>PDF Files</h1><p>using PyPDF2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install PyPDF2</span><br></pre></td></tr></table></figure><h2 id="Reading-PDFs"><a href="#Reading-PDFs" class="headerlink" title="Reading PDFs"></a>Reading PDFs</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;Magna-carta-translation.pdf&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">pdf_reader = PyPDF2.PdfFileReader(f)</span><br><span class="line">page_one = pdf_reader.getPage(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>We can then extract the text:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">page_one_text = page_one.extractText()</span><br></pre></td></tr></table></figure><h2 id="Adding-to-PDFs"><a href="#Adding-to-PDFs" class="headerlink" title="Adding to PDFs"></a>Adding to PDFs</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pdf_output = <span class="built_in">open</span>(<span class="string">&quot;first_page_of_doi.pdf&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">pdf_writer.write(pdf_output)</span><br></pre></td></tr></table></figure><h1 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions*"></a>Regular Expressions*</h1><h2 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;mypattern&#x27;</span><br></pre></td></tr></table></figure><p>placing the <code>r</code> in front of the string allows python to understand that the \ in the pattern string are not meant to be escape slashes.</p><h3 id="Identifiers-for-Characters"><a href="#Identifiers-for-Characters" class="headerlink" title="Identifiers for Characters"></a>Identifiers for Characters</h3><p>Below you can find a table of all the possible identifiers:</p><table><thead><tr><th align="right">Character</th><th align="right">Description</th><th align="right">Example Pattern Code</th><th align="right">Example Match</th></tr></thead><tbody><tr><td align="right">\d</td><td align="right">A digit</td><td align="right">file_\d\d</td><td align="right">file_25</td></tr><tr><td align="right">\w</td><td align="right">Alphanumeric</td><td align="right">\w-\w\w\w</td><td align="right">A-b_1</td></tr><tr><td align="right">\s</td><td align="right">White space</td><td align="right">a\sb\sc</td><td align="right">a b c</td></tr><tr><td align="right">\D</td><td align="right">A non digit</td><td align="right">\D\D\D</td><td align="right">ABC</td></tr><tr><td align="right">\W</td><td align="right">Non-alphanumeric</td><td align="right">\W\W\W\W\W</td><td align="right">*-+&#x3D;)</td></tr><tr><td align="right">\S</td><td align="right">Non-whitespace</td><td align="right">\S\S\S\S</td><td align="right">Yoyo</td></tr></tbody></table><h3 id="Quantifiers"><a href="#Quantifiers" class="headerlink" title="Quantifiers"></a>Quantifiers</h3><table><thead><tr><th align="right">Character</th><th align="right">Description</th><th align="right">Example Pattern Code</th><th align="right">Example Match</th></tr></thead><tbody><tr><td align="right">+</td><td align="right">Occurs one or more times</td><td align="right">Version \w-\w+</td><td align="right">Version A-b1_1</td></tr><tr><td align="right">{3}</td><td align="right">Occurs exactly 3 times</td><td align="right">\D{3}</td><td align="right">abc</td></tr><tr><td align="right">{2,4}</td><td align="right">Occurs 2 to 4 times</td><td align="right">\d{2,4}</td><td align="right">123</td></tr><tr><td align="right">{3,}</td><td align="right">Occurs 3 or more</td><td align="right">\w{3,}</td><td align="right">anycharacters</td></tr><tr><td align="right">*</td><td align="right">Occurs zero or more times</td><td align="right">A*B*C*</td><td align="right">AAACC</td></tr><tr><td align="right">?</td><td align="right">Once or none</td><td align="right">plurals?</td><td align="right">plural</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;My phone number is 614-292-5800&quot;</span></span><br><span class="line">re.search(<span class="string">r&#x27;\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;&#x27;</span>,text)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span=(19, 31), match=&#x27;614-292-5800&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h3><p>What if we wanted to do two tasks, find phone numbers, but also be able to quickly <strong>extract their area code</strong> (the first three digits). We can use groups for any general task that involves grouping together regular expressions (so that we can later break them down).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phone_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&#x27;</span>)</span><br><span class="line">results = re.search(phone_pattern,text)</span><br><span class="line"><span class="comment"># The entire result</span></span><br><span class="line">results.group()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;614-292-5800&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Can then also call by group position.</span></span><br><span class="line"><span class="comment"># remember groups were separated by parentheses ()</span></span><br><span class="line"><span class="comment"># Something to note is that group ordering starts at 1. Passing in 0 returns everything</span></span><br><span class="line">results.group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;614&#x27;</span><br></pre></td></tr></table></figure><h3 id="Additional-Regax-Syntax"><a href="#Additional-Regax-Syntax" class="headerlink" title="Additional Regax Syntax"></a>Additional Regax Syntax</h3><h4 id="Or-operator"><a href="#Or-operator" class="headerlink" title="Or operator |"></a>Or operator <code>|</code></h4><p>Use the pipe operator to have an <strong>or</strong> statement. For example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(<span class="string">r&quot;man|woman&quot;</span>,<span class="string">&quot;This man was here.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="The-Wildcard-Character"><a href="#The-Wildcard-Character" class="headerlink" title="The Wildcard Character"></a>The Wildcard Character</h4><p>Use a “wildcard” as a placement that will match any character placed there. You can use a simple period <strong>.</strong> for this. For example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&quot;.at&quot;</span>,<span class="string">&quot;The cat in the hat sat here.&quot;</span>)</span><br><span class="line"><span class="comment"># [&#x27;cat&#x27;, &#x27;hat&#x27;, &#x27;sat&#x27;]</span></span><br><span class="line">re.findall(<span class="string">r&quot;...at&quot;</span>,<span class="string">&quot;The bat went splat&quot;</span>)</span><br><span class="line"><span class="comment"># [&#x27;e bat&#x27;, &#x27;splat&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>\S</code>：Non-whitespace</p><p><code>+</code>：Occurs one or more times </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># One or more non-whitespace that ends with &#x27;at&#x27;</span></span><br><span class="line">re.findall(<span class="string">r&#x27;\S+at&#x27;</span>,<span class="string">&quot;The bat went splat&quot;</span>)</span><br><span class="line"><span class="comment"># [&#x27;bat&#x27;, &#x27;splat&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="Starts-With-and-Ends-With"><a href="#Starts-With-and-Ends-With" class="headerlink" title="Starts With and Ends With"></a>Starts With and Ends With</h4><p>We can use the <code>^</code> to signal starts with, and the <code>$</code> to signal ends with.<strong>(for the entire string)</strong></p><h4 id="Exclusion"><a href="#Exclusion" class="headerlink" title="Exclusion"></a>Exclusion</h4><p>To exclude characters, we can use the <strong>^</strong> symbol in conjunction with a set of brackets <strong>[]</strong>. Anything inside the brackets is excluded. For example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phrase = <span class="string">&quot;there are 3 numbers 34 inside 5 this sentence.&quot;</span></span><br><span class="line">re.findall(<span class="string">r&#x27;[^\d]+&#x27;</span>,phrase)</span><br><span class="line"><span class="comment"># [&#x27;there are &#x27;, &#x27; numbers &#x27;, &#x27; inside &#x27;, &#x27; this sentence.&#x27;]</span></span><br></pre></td></tr></table></figure><p>We can use this to remove punctuation from a sentence.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_phrase = <span class="string">&#x27;This is a string! But it has punctuation. How can we remove it?&#x27;</span></span><br><span class="line">clean = <span class="string">&#x27; &#x27;</span>.join(re.findall(<span class="string">&#x27;[^!.? ]+&#x27;</span>,test_phrase))</span><br><span class="line"><span class="comment"># &#x27;This is a string But it has punctuation How can we remove it&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Brackets-for-Grouping"><a href="#Brackets-for-Grouping" class="headerlink" title="Brackets for Grouping"></a>Brackets for Grouping</h4><p>As we showed above we can use brackets to group together options, for example if we wanted to find hyphenated words:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;Only find the hypen-words in this sentence. But you do not know how long-ish they are&#x27;</span></span><br><span class="line">re.findall(<span class="string">r&#x27;[\w]+-[\w]+&#x27;</span>,text)</span><br><span class="line"><span class="comment"># [&#x27;hypen-words&#x27;, &#x27;long-ish&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="Parentheses-for-Multiple-Options"><a href="#Parentheses-for-Multiple-Options" class="headerlink" title="Parentheses for Multiple Options"></a>Parentheses for Multiple Options</h4><p>If we have multiple options for matching, we can use parentheses to list out these options. For Example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find words that start with cat and end with one of these options: &#x27;fish&#x27;,&#x27;nap&#x27;, or &#x27;claw&#x27;</span></span><br><span class="line">text = <span class="string">&#x27;Hello, would you like some catfish?&#x27;</span></span><br><span class="line">texttwo = <span class="string">&quot;Hello, would you like to take a catnap?&quot;</span></span><br><span class="line">textthree = <span class="string">&quot;Hello, have you seen this caterpillar?&quot;</span></span><br><span class="line">re.search(<span class="string">r&#x27;cat(fish|nap|claw)&#x27;</span>,text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】elementUI分页组件el-pagination重置当前页数方法</title>
      <link href="/p/6f562d19/"/>
      <url>/p/6f562d19/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240116222725177.png"></p><p>如图，这里需要实现的是，切换不同tab时，分页器的当前页数要重置到第1页，同时向后端发送的请求里面的<code>page</code>参数也要重置为1。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="修改tab切换时绑定的tabChange函数"><a href="#修改tab切换时绑定的tabChange函数" class="headerlink" title="修改tab切换时绑定的tabChange函数"></a>修改tab切换时绑定的tabChange函数</h2><p>设置<code>params.value.page</code>为1即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params= <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">orderState</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">page</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">pageSize</span>:<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// tab切换</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">tabChange</span>=(<span class="params">type</span>)=&gt;&#123;</span><br><span class="line">  params.<span class="property">value</span>.<span class="property">page</span>=<span class="number">1</span></span><br><span class="line">  params.<span class="property">value</span>.<span class="property">orderState</span>=type</span><br><span class="line">  <span class="comment">// 重新获取数据</span></span><br><span class="line">  <span class="title function_">getOrderList</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改el-pagination"><a href="#修改el-pagination" class="headerlink" title="修改el-pagination"></a>修改<code>el-pagination</code></h2><p>使用<code>current-page.sync</code>进行双向绑定。</p><p>添加<code>v-model:current-page.sync=&quot;params.page&quot;</code>，其中<code>params.page</code>即<code>script</code>区定义的<code>params</code>里面的<code>page</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-pagination :total=&quot;total&quot; :page-size=&quot;params.pageSize&quot; v-model:current-page.sync=&quot;params.page&quot;</span><br><span class="line">                           @current-change=&quot;pageChange&quot; background layout=&quot;prev, pager, next&quot; /&gt;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/jiangjunyuan168/article/details/121610780">elementUI分页中改变current-page绑定的值无效问题的解决_分页组件js直接修改页码绑定值不触发事件-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_22182989/article/details/122948310">elementui 分页el-pagination遇到的所有坑（current失效、分页组件不显示、视图不改变等）_el-pagination current-page问题-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Spring】@RequestMapping等方法注释用法</title>
      <link href="/p/10eac329/"/>
      <url>/p/10eac329/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 提供了一组新的 REST 请求注释，可以简化构建 RESTful Web 服务的过程。</p><p>在Spring 4.3之前，我们使用<code>@RequestMapping</code>注解来实现RESTful的URL映射。</p><p>在Spring 4.3之后，拓展简化了<code>@RequestMapping</code>的方法级别注解，新的方法注释更加简洁且更易于阅读。它们还提供更具体的功能，并有助于减少构建 RESTful Web 服务所需的样板代码量。</p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>不设置 <code>method</code> 请求方式是 <code>get</code> 还是 <code>post</code> 时，<code>GET</code>、<code>POST</code> 都可以访问。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><code>consumes</code> – 映射请求的消耗媒体类型，缩小主映射范围。（例如@RequestMapping(consumes &#x3D; {“application&#x2F;json”, “application&#x2F;xml”}））。</li><li><code>method</code> – 要映射的 HTTP 请求方法（例如method &#x3D; {RequestMethod.GET,RequestMethod.POST}).</li><li><code>header</code> – 映射请求的标头。</li><li><code>name</code> – 映射的名称。</li><li><code>value</code> – 该注释表达的<font color=#ff0000>主要映射</font>（例如：<code>/login</code>）</li><li><code>produces</code> – 映射请求的可产生媒体类型。</li><li><code>params</code> - 提供了一种有条件地将处理程序方法映射到包含某些具有预期值的参数的请求的方法。（如果是可选参数，则可以在名称前加上<code>!</code>）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/products&quot;, params = &quot;category=electronics&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listElectronicProducts</span><span class="params">()</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h2><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>用于读取请求体，将请求正文内容（例如<code>JSON</code>）映射到对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/users&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> MultiValueMap&lt;String, String&gt; formData)</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>用于从请求 URI 中提取值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(id);</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>从HTTP请求中提取查询参数或表单数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">search</span><span class="params">(<span class="meta">@RequestParam</span> String query, <span class="meta">@RequestParam</span> <span class="type">int</span> page)</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sub/filter&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> Result&lt;Map&lt;String,Object&gt;&gt; <span class="title function_">getCategoryFilter</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> String id)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Result.success(categoryService.getCategoryFilter(Integer.parseInt(id)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>访问 HTTP 请求标头。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">getUsers</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Language&quot;)</span> String language)</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h1><p>该注解用于处理 HTTP GET 请求。</p><p>参数：</p><ul><li><code>value</code>：一个字符串，指定此方法应处理的 URL 路径。</li><li><code>produces</code>：一个字符串或字符串数组，指定此方法生成的响应的媒体类型。</li><li><code>params</code>：一个字符串数组，指定调用此方法必须存在的请求参数。</li><li><code>headers</code>：一个字符串数组，指定调用此方法必须存在的标头。</li></ul><h1 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h1><p>该注解用于处理 HTTP POST 请求。</p><p>参数：</p><ul><li><code>value</code>：一个字符串，指定此方法应处理的 URL 路径。</li><li><code>consumes</code>：一个字符串或字符串数组，指定此方法使用的请求正文的媒体类型。</li><li><code>produces</code>：一个字符串或字符串数组，指定此方法生成的响应的媒体类型。</li><li><code>params</code>：一个字符串数组，指定调用此方法必须存在的请求参数。</li><li><code>headers</code>：一个字符串数组，指定调用此方法必须存在的标头。</li></ul><h1 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h1><p>该注解用于处理 HTTP PUT 请求。</p><h1 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h1><p>该注释用于处理 HTTP DELETE 请求。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/673748887">Spring框架@RequestMapping完整指南 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/m0_61285646/article/details/129579486">浅谈@RequestMapping和@GetMapping等其他请求注解的区别_requestmapping还是getmapping-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参整理】之前从vsqx下的工程整理</title>
      <link href="/p/cc53cf58/"/>
      <url>/p/cc53cf58/</url>
      
        <content type="html"><![CDATA[<div class="note  flat warning"><p>vsqx站复活了！这里的链接就下了</p></div><div class="note  flat info"><p>注：有一些无参下下来没有记录扒谱者是谁，原作者如果看到了可以私信我！或者侵权了也私信我！</p><p>自己扒的不在这里，在本站无参配布分类下查找！</p></div><h1 id="无参整理"><a href="#无参整理" class="headerlink" title="无参整理"></a>无参整理</h1><p>排名不分先后，善用<code>Ctrl+F</code>搜索</p><h2 id="中文（普通话）"><a href="#中文（普通话）" class="headerlink" title="中文（普通话）"></a>中文（普通话）</h2><table><thead><tr><th align="center">歌名</th><th align="center">扒谱</th><th align="center">本家</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">破云来</td><td align="center">余若</td><td align="center"><a href="https://www.bilibili.com/video/BV1zU4y1m7ej/?spm_id_from=333.999.0.0">【忘川风华录·王阳明】破云来【赤羽原创】“天地本与我为一，知行此中意。”</a></td><td align="center">和声付</td></tr><tr><td align="center">光与影的对白</td><td align="center">12033</td><td align="center"><a href="https://www.bilibili.com/festival/lty10th?bvid=BV1dZ4y1Y7bt&spm_id_from=333.999.0.0">【洛天依原创曲】光与影的对白【2022官方生贺曲】</a></td><td align="center"></td></tr><tr><td align="center">晚夜微雨问海棠</td><td align="center">玖玖玖玖玖尾</td><td align="center"><a href="https://www.bilibili.com/video/BV1pZ4y1H7H5/?spm_id_from=333.999.0.0">晚夜微雨问海棠——《二哈和他的白猫师尊》燃晚同人</a></td><td align="center">有伴奏</td></tr><tr><td align="center">好想好想你</td><td align="center">1040</td><td align="center"><a href="https://www.bilibili.com/video/BV1EQ4y1R7s6/?spm_id_from=333.999.0.0">【官方MV】G.E.M.邓紫棋《好想好想你》</a></td><td align="center">分了两轨唱</td></tr><tr><td align="center">易安难安</td><td align="center">磷元素p</td><td align="center"><a href="https://www.bilibili.com/video/BV19y4y1b7Kd/">【赤羽原创】易安难安【忘川风华录】</a></td><td align="center">和声付</td></tr><tr><td align="center">万象霜天</td><td align="center">伊水_Uryan、坐标P</td><td align="center"><a href="https://www.bilibili.com/video/BV1zN411d7dG/?spm_id_from=333.999.0.0">万象霜天【2021拜年纪单品】</a></td><td align="center">和声付</td></tr><tr><td align="center">万古生香</td><td align="center">流绪、伊水_Uryan</td><td align="center"><a href="https://www.bilibili.com/video/BV1KJ411C7CW/?spm_id_from=333.999.0.0">万古生香【2020拜年祭单品】</a></td><td align="center">和声付</td></tr><tr><td align="center">星星与玻璃</td><td align="center">氢氧化氢p</td><td align="center"><a href="https://www.bilibili.com/video/BV1g54y1J7UL/?spm_id_from=333.999.0.0">【星尘Minus原创曲】星星与玻璃【PV付】</a></td><td align="center"></td></tr><tr><td align="center">难过233秒</td><td align="center"><em>未知</em></td><td align="center"><a href="https://www.bilibili.com/video/BV1oy4y1M7zi/?spm_id_from=333.337.search-card.all.click">【ChiliChill】难过233秒【MV】</a></td><td align="center"></td></tr><tr><td align="center">不可道</td><td align="center">伊水_Uryan、坐标P</td><td align="center"><a href="https://www.bilibili.com/video/BV1xD4y127im/?spm_id_from=333.999.0.0">【赤羽原创】不可道【忘川风华录】</a></td><td align="center">和声付</td></tr><tr><td align="center">只因你太美</td><td align="center">zouhong</td><td align="center"><a href="https://y.qq.com/n/ryqq/songDetail/0020Nusb3QJGn9">只因你太美 - SWIN-S - QQ音乐</a></td><td align="center"></td></tr><tr><td align="center">临川浮梦</td><td align="center">暮色未量（无和声）、攻科大队长（有和声）</td><td align="center"><a href="https://www.bilibili.com/video/BV1Tx4y137YT/?spm_id_from=333.999.0.0">【忘川风华录·汤显祖】临川浮梦【赤羽&#x2F;星尘infinity原创】“黄粱酒尚温，孰醒孰梦深。拂面是红尘，亦幻亦当真。”</a></td><td align="center">有两种版本</td></tr><tr><td align="center">先生</td><td align="center">跨海星尘</td><td align="center"><a href="https://www.bilibili.com/festival/2023bnj?bvid=BV1Ax4y1g7RX&spm_id_from=333.999.0.0">先生【2023拜年纪单品】</a></td><td align="center"></td></tr><tr><td align="center">HELL</td><td align="center">iii逸轩</td><td align="center"><a href="https://www.bilibili.com/video/BV1oF411w7Kv/">【官方MV】G.E.M.邓紫棋《HELL》 | 第二章 | 启示录REVELATION</a></td><td align="center"><del>慎用（</del></td></tr><tr><td align="center">长梦应觉</td><td align="center">冬羽羽p</td><td align="center"><a href="https://www.bilibili.com/video/BV1wv4y1F7kK/?spm_id_from=333.999.0.0">《崩坏：星穹铁道》丹恒原创曲手书「长梦应觉」</a></td><td align="center">和声付</td></tr><tr><td align="center">数风流</td><td align="center">梦碎谓之林夕</td><td align="center"><a href="https://www.bilibili.com/video/BV1Wg4y1W7jK/?spm_id_from=333.999.0.0">【嬴政&#x2F;刘彻&#x2F;李世民&#x2F;武则天&#x2F;赵匡胤&#x2F;朱元璋】数风流【忘川风华录手游二周年主题曲】</a></td><td align="center"></td></tr><tr><td align="center">水星记</td><td align="center">白洛QAQ</td><td align="center"><a href="https://music.163.com/#/song?id=441491828">水星记 - 郭顶 - 单曲 - 网易云音乐 (163.com)</a></td><td align="center">未灌词</td></tr><tr><td align="center">问剑春秋</td><td align="center"><em>未知</em></td><td align="center"><a href="https://www.bilibili.com/video/BV1Uu4y1Z7vN/?spm_id_from=333.999.0.0">【忘川风华录·勾践&#x2F;夫差】问剑春秋【赤羽&#x2F;苍穹原创】“交逢问鼎春秋霸业，英雄几凭见？”</a></td><td align="center"></td></tr><tr><td align="center">弈</td><td align="center">暗恋ZHE小猫</td><td align="center"><a href="https://www.bilibili.com/festival/2022bnj?bvid=BV1q34y1271d&spm_id_from=333.999.0.0">弈【2022拜年纪单品】</a></td><td align="center">和声付</td></tr><tr><td align="center">王妃</td><td align="center">Alkaid0528</td><td align="center"><a href="https://music.163.com/#/song?id=167942">王妃 - 萧敬腾 - 单曲 - 网易云音乐 (163.com)</a></td><td align="center"></td></tr><tr><td align="center">不安灵魂收容所</td><td align="center">不存名</td><td align="center"><a href="https://www.bilibili.com/video/BV1Nu411t7Pj/?spm_id_from=333.999.0.0">ChiliChill「不安灵魂收容所」《申放送》ED主题曲</a></td><td align="center"></td></tr><tr><td align="center">有线耳机</td><td align="center">雷小枫同学</td><td align="center"><a href="https://www.bilibili.com/video/BV1jc411T7rG/?spm_id_from=333.999.0.0">ChiliChill feat. 电鸟「有线耳机」EP《V.T.A》vol. 2</a></td><td align="center"></td></tr><tr><td align="center">月既解饮</td><td align="center">冬羽羽p</td><td align="center"><a href="https://www.bilibili.com/video/BV1oP411Y7DV/">《崩坏：星穹铁道》丹恒•饮月原创曲「月既解饮」</a></td><td align="center">无和声（我记得她后面扒了和声！但是没存）</td></tr><tr><td align="center">天下局</td><td align="center"><em>未知</em></td><td align="center"><a href="https://www.bilibili.com/video/BV1z4411q74Y/?spm_id_from=333.999.0.0">【赤羽原创】天下局【忘川风华录】</a></td><td align="center">和声付</td></tr><tr><td align="center">剑与雪</td><td align="center">雪螢SiqYin</td><td align="center"><a href="https://www.bilibili.com/video/BV1H8411r74n/?spm_id_from=333.999.0.0">《崩坏：星穹铁道》镜流原创曲《剑与雪》</a></td><td align="center"></td></tr></tbody></table><h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><table><thead><tr><th align="center">歌名</th><th align="center">扒谱</th><th align="center">本家</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">夜に駆ける</td><td align="center"><em>未知</em></td><td align="center"><a href="https://www.bilibili.com/video/BV1Ph411C7S5/?spm_id_from=333.999.0.0">YOASOBI 夜に駆ける (Yoru ni Kakeru) Official Music Video</a></td><td align="center"></td></tr><tr><td align="center">ギターと孤独と蒼い惑星</td><td align="center">炎柳</td><td align="center"><a href="https://www.bilibili.com/video/BV1sv4y1U7j6/?spm_id_from=333.337.search-card.all.click">【中日歌词&#x2F;完整版】「吉他与孤独与蓝色星球」第五集live部分插曲—結束バンド【孤独摇滚】</a></td><td align="center"></td></tr><tr><td align="center">高音廚音域測試</td><td align="center"><em>未知</em></td><td align="center"><a href="https://www.bilibili.com/video/BV1QW411P7Xy/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【初音ミク】高音廚音域測試【木村わいP】【B站搬运】</a></td><td align="center"></td></tr></tbody></table><h1 id="有参整理"><a href="#有参整理" class="headerlink" title="有参整理"></a>有参整理</h1><table><thead><tr><th align="center">歌曲</th><th align="center">歌姬</th><th align="center">调教</th><th align="center">链接</th></tr></thead><tbody><tr><td align="center">红</td><td align="center">赤羽</td><td align="center">坐标P</td><td align="center"><a href="https://www.bilibili.com/video/BV1fX4y1P71e/?spm_id_from=333.999.0.0">【赤羽翻唱】红【坐标P】</a></td></tr><tr><td align="center">狼狈</td><td align="center">赤羽</td><td align="center">佑可猫</td><td align="center"><a href="https://www.bilibili.com/video/BV16M4y1M7od/?spm_id_from=333.999.0.0">【赤羽】狼狈【五维介质2021调校赛】</a></td></tr><tr><td align="center">天亮了</td><td align="center">苍穹</td><td align="center">牧儿P</td><td align="center"><a href="https://www.bilibili.com/video/BV1yg4y1p7rk/?spm_id_from=333.999.0.0&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【V吧赛SC096】苍穹《天亮了》</a></td></tr><tr><td align="center">舞娘</td><td align="center">赤羽</td><td align="center">陌生来访</td><td align="center"><a href="https://www.bilibili.com/video/BV1rR4y1e72T/?spm_id_from=333.999.0.0">【赤羽】舞娘【SYNTHESIZER V COVER】</a></td></tr><tr><td align="center">ドメスティックでバイオレンス</td><td align="center">Yuma</td><td align="center">正十字p</td><td align="center"><a href="https://www.bilibili.com/video/BV19G4y1P7Lw/?spm_id_from=333.999.0.0">【Yuma】ドメスティックでバイオレンス&#x2F;家庭而又暴力【2023V吧调音赛】【AF007】“无论何时这都是我的特权”</a></td></tr><tr><td align="center">拆穿</td><td align="center">牧心</td><td align="center">跨海星尘</td><td align="center"><a href="https://www.bilibili.com/video/BV1Eg4y1p7ww/?spm_id_from=333.999.0.0&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【牧心】拆穿【SYNTHESIZER V COVER】</a></td></tr><tr><td align="center">木兰行</td><td align="center">苍穹</td><td align="center">ice_moriarty</td><td align="center"><a href="https://www.bilibili.com/video/BV1FG4y1T7iu/?spm_id_from=333.337.search-card.all.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【SC035】木兰行【23V吧调音赛】</a></td></tr><tr><td align="center">向阳而生</td><td align="center">牧心 feat.五维全员</td><td align="center">StevenTham</td><td align="center"><a href="https://www.bilibili.com/video/BV1TP41167is/?spm_id_from=333.999.0.0">【牧心feat.五维全员】向阳而生【牧心出道日12:00】【原创pv付】【Tham&#x2F;忆想诗P】</a></td></tr><tr><td align="center">月既解饮</td><td align="center">岸晓</td><td align="center">盐水是言和水</td><td align="center"><a href="https://www.bilibili.com/video/BV1Yh4y1m7xd/?spm_id_from=333.999.0.0">《崩坏：星穹铁道》岸晓翻唱曲「月既解饮」</a></td></tr></tbody></table><h1 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h1><p>某只泽的无参配布（持续更新中）：<a href="https://weibo.com/ttarticle/p/show?ua=Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/120.0.0.0+Safari/537.36+Edg/120.0.0.0&id=2309404537122294989001">工程配布 (weibo.com)</a></p><p>VSQx工程文件交流平台（有很多叠在里面分享无参）：<a href="https://docs.qq.com/sheet/DWVdLTExySmFzY0VU?tab=BB08J2">VSQx工程文件交流平台 (qq.com)</a></p><p>vsqx配布站整合（很久没更新）：<a href="https://miaovsqx.lofter.com/post/1eaf6558_1227b561">vsqx配布站整合（不定期更新）-『结云村的迅喵』vsqx发布中心 (lofter.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 无参整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的电商网站修bug日常②——支付宝踩坑实录</title>
      <link href="/p/4f2beac6/"/>
      <url>/p/4f2beac6/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>其实在提交之前我就发现了，但是当时来不及了，就没管，现在修修（（</p><p>具体表现是收不到回调结果，无法执行完成支付的逻辑。（支付成功后，修改订单状态、修改库存）</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p><code>AliPayController</code>中调起支付宝支付页面的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aliPay.setSubject(<span class="string">&quot;Test Pay&quot;</span>);</span><br><span class="line">                aliPay.setTotalAmount(orderMapper.getPayMoneyById(Integer.parseInt(aliPay.getOrderId())));</span><br><span class="line">                response = Factory.Payment.Page()</span><br><span class="line">                        .pay(aliPay.getSubject(), aliPay.getOrderId(), String.valueOf(aliPay.getTotalAmount()),</span><br><span class="line">                                aliPay.getRedirect());</span><br></pre></td></tr></table></figure><p>其中<code>aliPay.getRedirect()</code>由前端传入。</p><p>查看<code>response</code>的<code>body</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;punchout_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://openapi-sandbox.dl.alipaydev.com/gateway.do?alipay_sdk=alipay-easysdk-java-2.1.2&amp;app_id=9021000131656346&amp;charset=UTF-8&amp;format=json&amp;method=alipay.trade.page.pay&amp;notify_url=http%3A%2F%2F127.0.0.1%3A5173%2F%23%2Fpaycallback&amp;return_url=http%3A%2F%2F127.0.0.1%3A5173%2F%23%2Fpaycallback&amp;sign=dwYqWfor3YLR%2BsO35VWVrCnzVKSWjNoZOs68TMpP9SYtvmtkxKYINnQlQDWR0g7qzJsCkKEtjJgNwQSg%2Bh60c4ppr1JM0ndsH5KzgNBxKH9G7ScybN5FaXgP%2F3jQNRa8jVUx7m%2B2nkKqhLBlgim4CYTsaVo5SOu5bSwSkJNWt9JxSwWuoodILag6lHlMw%2BAY0wDM2YZMDlxYW6eTOOzVGztVyaRMcLHoelRlqFE6yMbcNi3gbkqm18UTbusvb%2BCyaM93Yg7gqS1pm3VLvlRKpBv%2FUavGJEoQhGl478xsCXAG%2BgXpY0aMKNVQML%2FAzO%2FKo1levhAxUuqw0CRoOj%2F0Hw%3D%3D&amp;sign_type=RSA2&amp;timestamp=2024-01-13+20%3A34%3A36&amp;version=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;biz_content&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;<span class="symbol">&amp;quot;</span>out_trade_no<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>31<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>total_amount<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>677.0<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>subject<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>Test Pay<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>product_code<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>FAST_INSTANT_TRADE_PAY<span class="symbol">&amp;quot;</span>&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;立即支付&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>notify_url</code>为支付宝异步回调地址（回调给后端处理），<code>return_url</code>为完成支付后前端跳转的地址（前端传入）。</p><p>很好，都错了（</p><p>尝试修改后端<code>application.yml</code>：<del>《尝试》</del></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240114003221743.png"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">alipay:</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">notifyUrl:</span> <span class="string">http://127.0.0.1:8080/paycallback</span></span><br></pre></td></tr></table></figure><p>以及前端的url：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> backURL = <span class="string">&#x27;http://localhost:5173/#/paycallback&#x27;</span></span><br></pre></td></tr></table></figure><p>改完之后，再测测。</p><p>然而还是不行，后端还是收不到回调。（此处没图）</p><p>用Apifox测一下接口。（没带参数）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240114003257732.png"></p><p>能返回错误信息，说明后端接口应该没错的。</p><p>此时<code>response</code>的<code>body</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;punchout_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://openapi-sandbox.dl.alipaydev.com/gateway.do?alipay_sdk=alipay-easysdk-java-2.1.2&amp;app_id=9021000131656346&amp;charset=UTF-8&amp;format=json&amp;method=alipay.trade.page.pay&amp;notify_url=http%3A%2F%2F127.0.0.1%3A8080%2Fpaycallback&amp;return_url=http%3A%2F%2Flocalhost%3A5173%2F%23%2Fpaycallback&amp;sign=ACrRQgcE5De7Fkx%2FZKEjbS4iM9U%2F3huYlschr5HHd4TZzKSSBB6oY%2FhHkwaIrwRrd1mdsEozMH9hfSO5dtlCRguRw58PNcRpUmvyPPM%2Ftdh3JbM6iAlTeXN05e41Cq7tX0DiQp%2Fg%2BIltBneHLkzTZn2QPA1Ixt9vVJCDCEFuhq8xdSZvEInxva6Zhtp4%2Fwrx5xlRwQHZ5TGgCMMspi0269wZbxtGgtOhe3DuMJFitRZPGSWxj18QodRLuzDP24FsFAAHF1ZUW%2FRUItAhu0SeQj4BhZjjrfF5%2F2230pgvIpsPNr8G5l%2FAZbVlqnyYsn0gcf9A0wiyt2KpLUQTSpBKbg%3D%3D&amp;sign_type=RSA2&amp;timestamp=2024-01-13+20%3A41%3A50&amp;version=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;biz_content&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;<span class="symbol">&amp;quot;</span>out_trade_no<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>33<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>total_amount<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>607.0<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>subject<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>Test Pay<span class="symbol">&amp;quot;</span>,<span class="symbol">&amp;quot;</span>product_code<span class="symbol">&amp;quot;</span>:<span class="symbol">&amp;quot;</span>FAST_INSTANT_TRADE_PAY<span class="symbol">&amp;quot;</span>&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;立即支付&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么问题到底在哪里呢？</p><p>搜了一堆（过程就略去了）之后，我看到这个评论，有点醍醐灌顶了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240114004359016.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>于是修改后端的<code>application.yml</code>里面的<code>notifyUrl</code>以及数据库用户密码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">alipay:</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">notifyUrl:</span> <span class="string">http://8.138.110.114:8080/paycallback</span></span><br></pre></td></tr></table></figure><p>然后部署到云上（过程略），并且修改前端的<code>baseUrl</code>（在前几篇文章里面有！）</p><p>然后再测！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240114005614599.png"></p><p><font size=4>噔 噔 咚</font></p><p>这里过程就不展开了，总之原因是支付宝那边是不允许订单号重复（商户端）的，然后我这边本地数据库和云端数据库之间有差异，而且订单号是自增的，这样就会导致重复。</p><p>改好之后，这下总算ok了！</p><p>云端数据库中订单状态成功修改。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240114010612985.png"></p><p>前端结果显示成功。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240113224116400.png"></p><p>顺便这里还改了一下前端，因为原本的代码里面是利用<code>redirectUrl</code>里面的<code>payResult</code>参数判断，但是这里并没有这个参数，应该是原本的后端处理的，这里就改前端了，因为这个页面启动的时候会首先获取这个订单的数据，所以根据订单数据中的<code>orderState</code>来判断就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> payResult=<span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getOrderInfo</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res=<span class="keyword">await</span> <span class="title function_">getOrderAPI</span>(route.<span class="property">query</span>.<span class="property">out_trade_no</span>)</span><br><span class="line">  orderInfo.<span class="property">value</span>=res.<span class="property">result</span></span><br><span class="line">  <span class="keyword">if</span>(res.<span class="property">result</span>.<span class="property">orderState</span>!==<span class="number">1</span>)&#123;</span><br><span class="line">    payResult.<span class="property">value</span>=<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span class=&quot;iconfont icon-queren2 green&quot; v-if=&quot;payResult===1&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;iconfont icon-shanchu red&quot; v-else&gt;&lt;/span&gt;</span><br><span class="line">      &lt;p class=&quot;tit&quot;&gt;支付&#123;&#123;payResult===1?&#x27;成功&#x27;:&#x27;失败&#x27;&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://open.alipay.com/portal/forum/post/142301028">web页面支付成功没有触发异步回调，查看异常回调也没有显示具体错误信息-支付宝开发者社区 (alipay.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 修bug日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 支付宝 </tag>
            
            <tag> Apifox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【无参配布】故我逢真（含和声）【崩坏：星穹铁道·阮梅】</title>
      <link href="/p/73e2aa1/"/>
      <url>/p/73e2aa1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://rean-song-bucket.oss-cn-guangzhou.aliyuncs.com/assets/cover/%E6%95%85%E6%88%91%E9%80%A2%E7%9C%9F.jpg" alt="故我逢真"></p><p>按照三无翻唱的版本扒的，比原曲低2key，和声可能有扒错的，使用请注意！</p><h1 id="本家staff"><a href="#本家staff" class="headerlink" title="本家staff"></a>本家staff</h1><p>原曲：<a href="https://www.bilibili.com/video/BV1v94y1M74S/?spm_id_from=333.788.video.desc.click">BV1v94y1M74S</a></p><p>作曲：KBShinya&#x2F;轩染 | 作词：骆栖淮</p><p>演唱：星尘infinity</p><p>编曲：Fsy小诺 | 视频制作&#x2F;绘图：浮玉酱</p><p>翻唱：三无 | MMD：鬼瞳</p><p>吉他：大牛</p><h1 id="无参链接"><a href="#无参链接" class="headerlink" title="无参链接"></a>无参链接</h1><p>链接: <a href="https://pan.baidu.com/s/1KCXr_tSCq1YrXZU9W--a2w?pwd=5jae">https://pan.baidu.com/s/1KCXr_tSCq1YrXZU9W--a2w?pwd=5jae</a></p><p>提取码: 5jae</p><h1 id="试听"><a href="#试听" class="headerlink" title="试听"></a>试听</h1><p><a href="https://www.bilibili.com/video/BV1PT4y1p75Z/?spm_id_from=444.41.header_right.fav_list.click&vd_source=cba1de56c49ce9d6c65f7f484f8c525f">【三无翻唱】故我逢真【崩坏：星穹铁道 阮梅同人曲】</a></p><h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>闻道雪里逢春</p><p>寻来久历机深</p><p>何故四时不同辰</p><p>寒风濯霜洗尘</p><p>冰刀俱催折痕</p><p>上下求索而兼程</p> <br><p>唯有其志坚忍</p><p>可秉其心最诚</p><p>何惧迢迢路孤身</p><p>观往复孰能盖棺定论</p>  <br><p>此生意在求本</p><p>不惜探津逐根</p><p>游太虚向命理发问</p><p>为何时节未改</p><p>四弦遗音尚沉</p><p>词律已不作当时声</p>  <br><p>岁月疾驰难困</p><p>大道至简识真</p><p>浩浩寂寂著就此身</p><p>万物凋零缤纷</p><p>造化彻骨最不仁</p>  <br><p>谁知 天地乾坤 日月浮沉</p><p>宇宙老星神</p><p>如我等 片叶苍生</p><p>衰朽如微尘</p><p>偏要探 壶中有方寸</p><p>能藏多少万古春</p><p>终散落另一个</p><p>星与辰</p>  <br><p>此生意在求本</p><p>不惜探津逐根</p><p>游太虚向命理发问</p><p>为何时节未改</p><p>四弦遗音尚沉</p><p>词律已不作当时声</p>  <br><p>岁月疾驰难困</p><p>大道至简识真</p><p>浩浩无穷著就此身</p><p>万物凋零缤纷</p><p>造化彻骨最不仁</p>  <br><p>谁知 天地乾坤 日月浮沉</p><p>宇宙老星神</p><p>如我等 片叶苍生</p><p>衰朽如微尘</p><p>偏要探 壶中有方寸</p><p>能藏多少万古春</p><p>终散落另一个</p><p>星与辰</p>  <br><p>吾道千万去</p><p>仍觉无极甚</p><p>等云开雨霁</p><p>忽然故我已逢真</p><p>谁能永婆娑</p><p>不受一滓风尘</p><p>来是冰雪加身</p><p>去是戏中人</p>  <br><p>谁知 天地乾坤 日月浮沉</p><p>宇宙老星神</p><p>如我等 片叶苍生</p><p>衰朽如微尘</p><p>偏要探 一生和一瞬</p><p>为何而留存</p><p>终散落另一个</p><p>心与魂</p>]]></content>
      
      
      <categories>
          
          <category> 无参配布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无参 </tag>
            
            <tag> 古风 </tag>
            
            <tag> 崩坏：星穹铁道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js(Vite)项目部署云服务器</title>
      <link href="/p/c677e75e/"/>
      <url>/p/c677e75e/</url>
      
        <content type="html"><![CDATA[<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><p>这一步可以解决配置后访问出现404、空白页的问题（</p><h2 id="1-修改vite-config-js"><a href="#1-修改vite-config-js" class="headerlink" title="1. 修改vite.config.js"></a>1. 修改<code>vite.config.js</code></h2><p>添加 base，意思是 build 之后的外部资源都从当前目录的相对路径获取。<br>比如 <code>main.js</code> 不是 <code>/main.js</code> 而是 <code>./main.js</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-修改router-index-js"><a href="#2-修改router-index-js" class="headerlink" title="2. 修改router/index.js"></a>2. 修改<code>router/index.js</code></h2><p>默认的<code>createWebHistory</code>路由模式路径不带#号（生产环境下不能直接访问项目，需要nginx转发）</p><blockquote><p><a href="http://localhost:8080/#/">http://localhost:8080/#/</a></p></blockquote><p>所以我们需要改为<code>createWebHashHistory</code>路由模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="comment">// 它本来默认是  createWebHistory()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-修改baseURL"><a href="#3-修改baseURL" class="headerlink" title="3. 修改baseURL"></a>3. 修改<code>baseURL</code></h2><p>修改<code>http.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改<code>vite.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 实际后端地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 不可以省略rewrite</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>原理是通过代理，将原本以<code>/api</code>开头的请求地址替换为实际的地址。</p><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h2><p>运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>结束后可以在项目的目录下看到生成的<code>dist</code>目录。</p><h1 id="云服务器配置"><a href="#云服务器配置" class="headerlink" title="云服务器配置"></a>云服务器配置</h1><p><del>如何购买云服务器、初始化云服务器这里就不介绍了~（因为已经配完了（（</del></p><p>这里以阿里云为例，通过宝塔去完成网站的上线。</p><p>2024&#x2F;05&#x2F;15 更新：翻了一下之前的实验报告，竟然发现还有一个图，补上！（就是有点糊）顺便抄一下自己之前写的这篇（（</p><h2 id="0-初始化云服务器"><a href="#0-初始化云服务器" class="headerlink" title="0. 初始化云服务器"></a>0. 初始化云服务器</h2><p>首先创建实例，此处选择操作系统为CentOS 8.4 64位 SCC版，配置为<strong>2</strong>核(vCPU)  <strong>4</strong> GiB  100 Mbps的服务器。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/essay/image-20240515212115552.png"></p><p>接着远程连接云服务器，安装宝塔</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br></pre></td></tr></table></figure><p>安装完成后，开放宝塔端口，登陆宝塔，绑定手机号，点一键安装！</p><p>检查宝塔各软件是否完成安装</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111231628656.png"></p><p>其中<code>Nginx</code>是本教程重点使用的软件（还有PHP也会用到，其他的这里暂时用不着），如果没安装上记得安装好（一开始的一键安装可能会安装失败）</p><h2 id="1-开放ECS端口"><a href="#1-开放ECS端口" class="headerlink" title="1. 开放ECS端口"></a>1. 开放ECS端口</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111225142537.png"></p><p>手动添加一条入站规则，端口为你想要配置网站所用的端口，源IP设为<code>0.0.0.0/0</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111225210955.png"></p><h2 id="2-添加宝塔内的防火墙端口规则"><a href="#2-添加宝塔内的防火墙端口规则" class="headerlink" title="2. 添加宝塔内的防火墙端口规则"></a>2. 添加宝塔内的防火墙端口规则</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111225510895.png"></p><p>端口填上一步同一个端口即可。</p><h2 id="3-添加PHP项目站点"><a href="#3-添加PHP项目站点" class="headerlink" title="3. 添加PHP项目站点"></a>3. 添加PHP项目站点</h2><p>点击左侧栏中的网站，添加站点。</p><p>其中第一行随便写一个方便自己辨别的域名（要是有真的域名那也可以直接用），第二行写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECS公网IP地址:你想设置的端口（和前面开放的一致）</span><br></pre></td></tr></table></figure><p>其中如果设置1025端口，我这边最后会出现访问超时的情况，服务器也没有日志记录，原因未知。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111230146413.png"></p><h2 id="4-站点设置"><a href="#4-站点设置" class="headerlink" title="4. 站点设置"></a>4. 站点设置</h2><h3 id="4-1-域名管理"><a href="#4-1-域名管理" class="headerlink" title="4.1 域名管理"></a>4.1 域名管理</h3><p>删除刚刚第一行的域名，留下IP:端口那条即可。</p><h3 id="4-2-网站目录"><a href="#4-2-网站目录" class="headerlink" title="4.2 网站目录"></a>4.2 网站目录</h3><p>运行目录设为<code>/</code>（有时候删了文件再重新传这里会变成别的，要改回来）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111230821831.png"></p><h3 id="4-3-默认文档"><a href="#4-3-默认文档" class="headerlink" title="4.3 默认文档"></a>4.3 默认文档</h3><p>在最上面加上<code>dist</code></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111230921696.png"></p><h3 id="4-4-配置文件（重要）"><a href="#4-4-配置文件（重要）" class="headerlink" title="4.4 配置文件（重要）"></a>4.4 配置文件（重要）</h3><p>添加（记得换成自己的后端地址）</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 添加上这个配置</span></span><br><span class="line">        </span><br><span class="line">    location /api&#123;</span><br><span class="line">        rewrite  ^/api/(.*)$ /$1 break<span class="comment">;</span></span><br><span class="line">        proxy_pass http://后端IP:后端端口<span class="comment">;</span></span><br><span class="line">        index index.html<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-上传文件"><a href="#5-上传文件" class="headerlink" title="5. 上传文件"></a>5. 上传文件</h2><p>打开第3步创建的根目录，将打包好的<code>dist</code>文件夹传进去即可。</p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240111231335047.png" alt="" style="zoom:200%;" /><h2 id="6-完成"><a href="#6-完成" class="headerlink" title="6. 完成"></a>6. 完成</h2><p>访问<code>ECS公网IP地址:设置的端口</code>，大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宝塔 </tag>
            
            <tag> Vue </tag>
            
            <tag> Vite </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vocalremover网站测BPM的算法是什么？</title>
      <link href="/p/3f13b766/"/>
      <url>/p/3f13b766/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我个人偶然发现的网站，用多了觉得这个网站测出来的BPM准确率还挺高的，几乎就没错过，就算有也只是差那么一点点（比我自己用librosa还有wave库要高，这两个准的时候很准，不准的时候差十万八千里），于是就想看看抄抄算法。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240110221734848.png"></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>查看源代码，发现有两个核心的js：<code>AppBpmFinder</code>以及<code>key-finder</code>。</p><p>先看<code>AppBpmFinder</code>，搜索bpm，找到和bpm处理有关的代码。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240110202158376.png"></p><p>我这里首先下的断点是最下面那个，运行，发现到这里的时候BPM已经测出来了，于是往上再设断点。</p><p>在这里设置断点后，运行，此时BPM还没测出来，单步执行下一个函数调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">                <span class="attr">sampleRate</span>: e.<span class="property">sampleRate</span>,</span><br><span class="line">                <span class="attr">arrayPCM</span>: e.<span class="property">numberOfChannels</span> &gt; <span class="number">1</span> ? [e.<span class="title function_">getChannelData</span>(<span class="number">0</span>), e.<span class="title function_">getChannelData</span>(<span class="number">1</span>)] : [e.<span class="title function_">getChannelData</span>(<span class="number">0</span>)]</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>然后发现这里是post了采样率以及PCM数组的message到了<code>key-finder</code>中。<del>（所以为什么是在key-finder里面测BPM）</del></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240110202242870.png"></p><p>感觉快找到真相了<del>（并不）</del>，贴一个上图用到的一些函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ZB</span> = <span class="number">16e3</span></span><br><span class="line">      , lB = <span class="keyword">new</span> <span class="title class_">Essentia</span>(h)</span><br><span class="line">      , wg = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title function_">arrayToVector</span>(A)</span><br><span class="line">      , <span class="title class_">Yg</span> = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title class_">KeyExtractor</span>(A, !<span class="number">0</span>, <span class="number">4096</span>, <span class="number">4096</span>, <span class="number">12</span>, <span class="number">3500</span>, <span class="number">60</span>, <span class="number">25</span>, <span class="number">.2</span>, <span class="string">&quot;bgate&quot;</span>, <span class="variable constant_">ZB</span>, <span class="number">1e-4</span>, <span class="number">440</span>, <span class="string">&quot;cosine&quot;</span>, <span class="string">&quot;hann&quot;</span>)</span><br><span class="line">      , yg = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title class_">PercivalBpmEstimator</span>(A, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">210</span>, <span class="number">50</span>, <span class="variable constant_">ZB</span>)</span><br><span class="line">      , <span class="title class_">Ug</span> = <span class="function"><span class="params">A</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> I = A[<span class="number">0</span>]</span><br><span class="line">              , E = A[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> I.<span class="title function_">map</span>(<span class="function">(<span class="params">C,g</span>)=&gt;</span><span class="number">.5</span> * (C + E[g]))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Sg</span>(<span class="params">A, I, E</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E === I)</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">let</span> C = I / E</span><br><span class="line">          , g = <span class="title class_">Math</span>.<span class="title function_">round</span>(A.<span class="property">length</span> / C)</span><br><span class="line">          , B = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(g)</span><br><span class="line">          , Q = <span class="number">0</span></span><br><span class="line">          , G = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; Q &lt; B.<span class="property">length</span>; ) &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">round</span>((Q + <span class="number">1</span>) * C)</span><br><span class="line">              , o = <span class="number">0</span></span><br><span class="line">              , a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> F = G; F &lt; i &amp;&amp; F &lt; A.<span class="property">length</span>; F++)</span><br><span class="line">                o += A[F],</span><br><span class="line">                a++;</span><br><span class="line">            B[Q] = o / a,</span><br><span class="line">            Q++,</span><br><span class="line">            G = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先看看</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">I = <span class="title class_">Ug</span>(I)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Ug</span> = <span class="function"><span class="params">A</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> I = A[<span class="number">0</span>]</span><br><span class="line">              , E = A[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> I.<span class="title function_">map</span>(<span class="function">(<span class="params">C,g</span>)=&gt;</span><span class="number">.5</span> * (C + E[g]))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Ug 这个函数首先判断 A 的 length 是否为 2 （对应音频是否为双声道），从一个二维数组 A 中取出第一行和第二行，分别赋值给 I 和 E，然后返回一个新的数组，它的每个元素是 I 和 E 对应位置元素的平均值。例如，如果 A 是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1, 2, 3],</span><br><span class="line"> [4, 5, 6]]</span><br></pre></td></tr></table></figure><p>那么 I 就是 <code>[1, 2, 3]</code>，E 就是 <code>[4, 5, 6]</code>，返回的数组就是 <code>[2.5, 3.5, 4.5]</code>。</p><p>这段代码使用了 JavaScript 的 map 方法，它可以对一个数组的每个元素执行一个函数，并返回一个新的数组。这里的函数是 <code>(C,g)=&gt;.5 * (C + E[g])</code>，它的参数是 C 和 g，其中 C 是 I 的每个元素，g 是它的索引。函数的返回值是 C 和 E 在相同索引位置的元素的平均值，即 <code>.5 * (C + E[g])</code>。</p><p>如果 A 的 length 为 1 ，则直接返回 A[0]。</p><p>所以这个函数的作用是将双声道音频的数据压缩（取平均）。</p><p>然后再看</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">I = <span class="title class_">Sg</span>(I,E,C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sg</span>(<span class="params">A, I, E</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E === I)</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">let</span> C = I / E</span><br><span class="line">          , g = <span class="title class_">Math</span>.<span class="title function_">round</span>(A.<span class="property">length</span> / C)</span><br><span class="line">          , B = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(g)</span><br><span class="line">          , Q = <span class="number">0</span></span><br><span class="line">          , G = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; Q &lt; B.<span class="property">length</span>; ) &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">round</span>((Q + <span class="number">1</span>) * C)</span><br><span class="line">              , o = <span class="number">0</span></span><br><span class="line">              , a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> F = G; F &lt; i &amp;&amp; F &lt; A.<span class="property">length</span>; F++)</span><br><span class="line">                o += A[F],</span><br><span class="line">                a++;</span><br><span class="line">            B[Q] = o / a,</span><br><span class="line">            Q++,</span><br><span class="line">            G = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数的意思是，它可以将一个音频信号的采样率从 I 转换为 E（16000），返回一个新的 Float32Array，它的长度是原来的 I &#x2F; E 倍。这个函数使用了一种简单的重采样算法，它将原始信号分成若干个等长的区间，每个区间的长度是 I &#x2F; E，然后计算每个区间内的信号的平均值，作为新信号的一个采样点。这种算法可以有效地减少信号的长度，但是也会损失一些信号的细节和质量。</p><p>接下来就是关键了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="title function_">wg</span>(I), B = <span class="title function_">yg</span>(g);</span><br><span class="line"></span><br><span class="line">wg = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title function_">arrayToVector</span>(A)</span><br><span class="line">yg = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title class_">PercivalBpmEstimator</span>(A, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">210</span>, <span class="number">50</span>, <span class="variable constant_">ZB</span>)</span><br></pre></td></tr></table></figure><p>这里首先 <code>wg</code> 是一个箭头函数，它接受一个参数 A，然后返回 lB 的 arrayToVector 方法的结果，这个方法可以将一个数组转换成一个向量<a href="https://blog.csdn.net/lanzhihui_10086/article/details/39995869">2</a>，然后调用 <code>yg</code> 计算出BPM。</p><p>那么这个lb是何方神圣呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lB = <span class="keyword">new</span> <span class="title class_">Essentia</span>(h)</span><br></pre></td></tr></table></figure><p>lB 是一个 Essentia 类的实例，它是一个音频分析和处理的库<a href="https://zhuanlan.zhihu.com/p/90720012">1</a>。</p><p>噔 噔 咚</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><font size=5>原来是Essentia库。</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yg = <span class="function"><span class="params">A</span>=&gt;</span>lB.<span class="title class_">PercivalBpmEstimator</span>(A, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">210</span>, <span class="number">50</span>, <span class="variable constant_">ZB</span>)</span><br></pre></td></tr></table></figure><p>所以这个网站是调用<code>Essentia</code>库中<code>PercivalBpmEstimator</code>的方法得到的BPM。</p><p>但是问题来了，我一开始调研的时候是有考虑过<code>Essentia</code>库的，但是这个库在Windows上不能直接<code>pip install</code>，所以我就没用这个库。</p><p>贴一个作者在不同issue下的回复。</p><blockquote><p>You can run <code>pip install essentia</code> inside a <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a> (WSL). We do not provide pip wheels for Windows yet.</p><p>Wheels aren’t yet supported for Windows (see <a href="https://github.com/MTG/essentia/issues/1157">#1157</a>).</p></blockquote><p>唉，把这个库安装，然后用上，实在是太难了。要么换一个操作系统再开发、打包等等进行一系列操作；要么花大把时间看着也不知到能不能成的英文教程（<a href="https://github.com/MTG/essentia/blob/python_win/INSTALL_windows.md">贴一下链接</a>，真的看着就头大）去install，感觉都是非常吃力不讨好的。遂放弃。（反正我的项目中有究极无敌准确的人工测算法（不是）</p><p><del>世上无难事，只要肯放弃。</del></p>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vocalremover </tag>
            
            <tag> BPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js项目起步</title>
      <link href="/p/cc30f00/"/>
      <url>/p/cc30f00/</url>
      
        <content type="html"><![CDATA[<p>基于<strong>Vue3小兔鲜新版（公司营销版）</strong>，根据实际情况修改~</p><h1 id="创建项目并整理目录"><a href="#创建项目并整理目录" class="headerlink" title="创建项目并整理目录"></a>创建项目并整理目录</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm init vue@latest</span><br></pre></td></tr></table></figure><div class="note  flat"><p>使用 cnpm 而不是 npm ，会快亿点！</p></div><p><img src="https://cdn.nlark.com/yuque/0/2022/png/274425/1670247123883-f43f81f8-7600-4fd7-aa82-2751d9032a54.png#averageHue=%23212120&clientId=ufebee43b-b163-4&from=paste&height=494&id=u1b534575&name=image.png&originHeight=659&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3380277&status=done&style=none&taskId=ud39028ba-b1d4-47ed-adf7-79865628edd&title=&width=960" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure><h2 id="2-整理目录"><a href="#2-整理目录" class="headerlink" title="2. 整理目录"></a>2. 整理目录</h2><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240109221234273.png"></p><h1 id="jsconfig-json配置别名路径"><a href="#jsconfig-json配置别名路径" class="headerlink" title="jsconfig.json配置别名路径"></a>jsconfig.json配置别名路径</h1><blockquote><p>配置别名路径可以在写代码时联想提示路径</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><div class="note  flat"><p>项目初始化后似乎已经配置好了，不用修改</p></div><h1 id="elementPlus引入"><a href="#elementPlus引入" class="headerlink" title="elementPlus引入"></a>elementPlus引入</h1><h2 id="1-安装elementPlus和自动导入插件"><a href="#1-安装elementPlus和自动导入插件" class="headerlink" title="1. 安装elementPlus和自动导入插件"></a>1. 安装elementPlus和自动导入插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install element-plus --save</span><br><span class="line">cnpm install -D unplugin-vue-components unplugin-auto-import</span><br></pre></td></tr></table></figure><h2 id="2-配置自动按需导入"><a href="#2-配置自动按需导入" class="headerlink" title="2. 配置自动按需导入"></a>2. 配置自动按需导入</h2><p>修改<code>vite.config.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-测试组件"><a href="#3-测试组件" class="headerlink" title="3. 测试组件"></a>3. 测试组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button type=&quot;primary&quot;&gt;i am button&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="定制elementPlus主题"><a href="#定制elementPlus主题" class="headerlink" title="定制elementPlus主题"></a>定制elementPlus主题</h1><h2 id="1-安装sass"><a href="#1-安装sass" class="headerlink" title="1. 安装sass"></a>1. 安装sass</h2><blockquote><p>基于vite的项目默认不支持css预处理器，需要开发者单独安装</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i sass -D</span><br></pre></td></tr></table></figure><h2 id="2-准备定制化的样式文件"><a href="#2-准备定制化的样式文件" class="headerlink" title="2. 准备定制化的样式文件"></a>2. 准备定制化的样式文件</h2><p>新建<code>styles/element/index.scss</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 只需要重写你需要的即可 */</span></span><br><span class="line">@forward <span class="string">&#x27;element-plus/theme-chalk/src/common/var.scss&#x27;</span> <span class="keyword">with</span> (</span><br><span class="line">  <span class="attr">$colors</span>: (</span><br><span class="line">    <span class="string">&#x27;primary&#x27;</span>: (</span><br><span class="line">      <span class="comment">// 主色</span></span><br><span class="line">      <span class="string">&#x27;base&#x27;</span>: #27ba9b,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;success&#x27;</span>: (</span><br><span class="line">      <span class="comment">// 成功色</span></span><br><span class="line">      <span class="string">&#x27;base&#x27;</span>: #1dc779,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;warning&#x27;</span>: (</span><br><span class="line">      <span class="comment">// 警告色</span></span><br><span class="line">      <span class="string">&#x27;base&#x27;</span>: #ffb302,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;danger&#x27;</span>: (</span><br><span class="line">      <span class="comment">// 危险色</span></span><br><span class="line">      <span class="string">&#x27;base&#x27;</span>: #e26237,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;error&#x27;</span>: (</span><br><span class="line">      <span class="comment">// 错误色</span></span><br><span class="line">      <span class="string">&#x27;base&#x27;</span>: #cf4444,</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-自动导入配置"><a href="#3-自动导入配置" class="headerlink" title="3. 自动导入配置"></a>3. 自动导入配置</h2><blockquote><p>这里自动导入需要深入到elementPlus的组件中，按照官方的配置文档来</p><ol><li>自动导入定制化样式文件进行样式覆盖</li><li>按需定制主题配置 （需要安装 unplugin-element-plus）</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath, <span class="variable constant_">URL</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:url&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span></span><br><span class="line"><span class="comment">// 导入对应包</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-element-plus/vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 按需定制主题配置</span></span><br><span class="line">    <span class="title class_">ElementPlus</span>(&#123;</span><br><span class="line">      <span class="attr">useSource</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./src&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="comment">// 自动导入定制化样式文件进行样式覆盖</span></span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">`</span></span><br><span class="line"><span class="string">          @use &quot;@/styles/element/index.scss&quot; as *;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="axios安装并简单封装"><a href="#axios安装并简单封装" class="headerlink" title="axios安装并简单封装"></a>axios安装并简单封装</h1><h2 id="1-安装axios"><a href="#1-安装axios" class="headerlink" title="1. 安装axios"></a>1. 安装axios</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i axios</span><br></pre></td></tr></table></figure><h2 id="2-基础配置"><a href="#2-基础配置" class="headerlink" title="2. 基础配置"></a>2. 基础配置</h2><blockquote><p>官方文档地址：<a href="https://axios-http.com/zh/docs/intro">https://axios-http.com/zh/docs/intro</a><br>基础配置通常包括：</p><ol><li>实例化 - baseURL + timeout</li><li>拦截器 - 携带token 401拦截等</li></ol></blockquote><p>新建<code>utils/http.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios请求拦截器</span></span><br><span class="line">http.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">e</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios响应式拦截器</span></span><br><span class="line">http.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="property">data</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(e)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> http</span><br></pre></td></tr></table></figure><h2 id="3-修改基地址"><a href="#3-修改基地址" class="headerlink" title="3. 修改基地址"></a>3. 修改基地址</h2><p>修改<code>http.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// baseURL: &#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net&#x27;,</span></span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改<code>vite.config.js</code>，在末尾添加：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 不可以省略rewrite</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>target</code>为后端地址。注意后端的跨域配置代理（可能后面还会发一篇教程~）</p><h2 id="4-封装请求函数并测试"><a href="#4-封装请求函数并测试" class="headerlink" title="4. 封装请求函数并测试"></a>4. 封装请求函数并测试</h2><p>此处测试使用的是小兔鲜的基地址，根据自己后端修改即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;@/utils/http&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getCategoryAPI</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">http</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;home/category/head&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路由整体设计"><a href="#路由整体设计" class="headerlink" title="路由整体设计"></a>路由整体设计</h1><h2 id="1-删除自带页面"><a href="#1-删除自带页面" class="headerlink" title="1. 删除自带页面"></a>1. 删除自带页面</h2><p>修改<code>router/index.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>然后删除<code>view</code>目录下的文件</p><p>修改<code>App.vue</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!--  一级路由出口组件  --&gt;</span><br><span class="line">  &lt;RouterView /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="2-路由设计"><a href="#2-路由设计" class="headerlink" title="2. 路由设计"></a>2. 路由设计</h2><p>路由设计原则：找页面的切换方式，如果是整体切换，则为一级路由，如果是在一级路由的内部进行的内容切换，则为二级路由。</p><p>分别在<code>views</code>目录下新建Home、Layout、Login目录，然后分别新建<code>index.vue</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  我是登录页</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  我是首页</span><br><span class="line">    &lt;!--  二级路由出口  --&gt;</span><br><span class="line">  &lt;RouterView /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  我是home</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  我是分类</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createRouter：创建router实例对象</span></span><br><span class="line"><span class="comment">// createWebHistory：创建history模式的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Login/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Layout/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Home/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Category</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Category/index.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="comment">// path和component对应关系的位置</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="title class_">Category</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Login</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h2 id="3-修改eslint配置"><a href="#3-修改eslint配置" class="headerlink" title="3. 修改eslint配置"></a>3. 修改eslint配置</h2><p>修改<code>.eslintrc.cjs</code>，添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rules:&#123;</span><br><span class="line">    &#x27;vue/multi-word-component-names&#x27;:0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="静态资源引入和Error-Lens安装"><a href="#静态资源引入和Error-Lens安装" class="headerlink" title="静态资源引入和Error Lens安装"></a>静态资源引入和Error Lens安装</h1><h2 id="1-静态资源引入"><a href="#1-静态资源引入" class="headerlink" title="1. 静态资源引入"></a>1. 静态资源引入</h2><ol><li><p>图片资源 - assets 目录下新建 images 文件夹</p></li><li><p>样式资源 - 把 common.scss 文件（小兔鲜配套素材）放到 styles 目录下</p></li><li><p>修改<code>main.js</code>，引入初始化样式文件，<font color=#ff0000>同时注掉自带的<code>main.css</code></font>：</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#x27;./assets/main.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/styles/common.scss&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-Error-Lens插件安装"><a href="#2-Error-Lens插件安装" class="headerlink" title="2. Error Lens插件安装"></a>2. Error Lens插件安装</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/274425/1677637778086-7314f9de-8130-4388-9fc3-0cf4c59b8454.png#averageHue=%232a2e36&clientId=u68bde7ec-09c8-4&from=paste&height=196&id=udc027a23&name=image.png&originHeight=392&originWidth=1528&originalType=binary&ratio=2&rotation=0&showTitle=false&size=87943&status=done&style=none&taskId=ue37b0611-a082-4595-9dde-66e51632ef7&title=&width=764" alt="image.png"></p><p>IDEA没有这个插件，跳过（</p><h1 id="scss变量自动导入"><a href="#scss变量自动导入" class="headerlink" title="scss变量自动导入"></a>scss变量自动导入</h1><p>新建<code>styles/var.scss</code>：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$xtxColor: <span class="number">#27ba9b</span>;</span><br><span class="line">$helpColor: <span class="number">#e26237</span>;</span><br><span class="line">$sucColor: <span class="number">#1dc779</span>;</span><br><span class="line">$warnColor: <span class="number">#ffb302</span>;</span><br><span class="line">$priceColor: <span class="number">#cf4444</span>;</span><br></pre></td></tr></table></figure><p>修改<code>vite.config.js</code>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">css<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    preprocessorOptions<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      scss<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 自动导入scss文件</span></span><br><span class="line">        additionalData<span class="punctuation">:</span> `</span><br><span class="line">          @use <span class="string">&quot;@/styles/element/index.scss&quot;</span> as *;</span><br><span class="line">          @use <span class="string">&quot;@/styles/var.scss&quot;</span> as *;</span><br><span class="line">        `<span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.yuque.com/fechaichai/td99ck/slubxnbeeigegsp5">3. 项目起步 (yuque.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的电商网站修bug日常①——登陆失败</title>
      <link href="/p/807cab5e/"/>
      <url>/p/807cab5e/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我无聊想试试如果登陆的时候填一些奇怪的东西进去，我的后端会不会爆炸。<del>（别问我为什么现在才想起来测这个）</del></p><p>结果后端没爆炸（后面才知道），前端爆炸了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108224555234.png"></p><p>而且登陆失败的时候没有提示错误信息，因为想的是前端有一个统一的响应式拦截，应该会提示的，然而实际上并没有。</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>查看请求，响应正常。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108231552374.png"></p><p>使用无痕模式，正常访问（未登录）。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108231711382.png"></p><p>使用Apifox测试后端，也正常响应。</p><p>那么可以肯定的是，后端没有问题。</p><p>那么肯定是前端的代码中存在问题。</p><p>于是大概猜到了（并且看了一下），响应中的为<code>null</code>的<code>result</code>赋给了<code>userInfo</code>，并存到local storage中，然后发送请求，然后就寄了。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108233413398.png"></p><p>还记得前面说过的前端有一个统一的响应式拦截吗？理论上如果有问题，拦截了，那么<code>null</code>的<code>result</code>是不会赋给<code>userInfo</code>的。这个拦截是有用的嗷，之前后端返回401的响应是能够拦截并弹出错误信息的。<del>《理论上》</del></p><p>然后我一看这个状态代码</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108231420735.png"></p><p><font color=#198639 size=5>《200 OK》</font></p><p>噔 噔 咚</p><p>哈哈，怪不得不会被拦截呢</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>原因找到了，那就很好解决了。这里选择的是改前端的代码，因为后端都是统一用一个<code>Result</code>类去封装响应信息的，然后所有的<code>Controller</code>都是用<code>Result</code>类中的<code>success</code>或者<code>error</code>方法封装信息，改后端不太现实，牵一发而动全身了属于是。</p><h3 id="修改-userStore"><a href="#修改-userStore" class="headerlink" title="修改 userStore"></a>修改 userStore</h3><p>修改登陆用到的<code>getUserInfo</code>方法，根据<code>res.result</code>是否为空判断登录是否成功（用<code>res.code</code>效果一样）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(res.<span class="property">result</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">            userInfo.<span class="property">value</span>=res.<span class="property">result</span></span><br><span class="line">            <span class="comment">// 合并购物车</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">mergeCartAPI</span>(cartStore.<span class="property">cartList</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>&#123;</span><br><span class="line">                    <span class="attr">skuId</span>:item.<span class="property">skuId</span>,</span><br><span class="line">                    <span class="attr">selected</span>:item.<span class="property">selected</span>,</span><br><span class="line">                    <span class="attr">count</span>:item.<span class="property">count</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">            <span class="keyword">await</span> cartStore.<span class="title function_">updateNewList</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title class_">ElMessage</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;warning&#x27;</span>,</span><br><span class="line">                <span class="attr">message</span>:res.<span class="property">message</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="修改登录页面的script"><a href="#修改登录页面的script" class="headerlink" title="修改登录页面的script"></a>修改登录页面的script</h3><p>还有登录页面的<code>doLogin</code>方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (userStore.<span class="property">userInfo</span>.<span class="property">value</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;登录成功&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">await</span> router.<span class="title function_">replace</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>完成！</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108233322607.png"></p><p>userInfo也是正常存储。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240108233455050.png"></p>]]></content>
      
      
      <categories>
          
          <category> 修bug日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Apifox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题下标签外挂的使用</title>
      <link href="/p/5b5991e4/"/>
      <url>/p/5b5991e4/</url>
      
        <content type="html"><![CDATA[<div class="note  info tips"><p>标签外挂是Hexo独有的功能，并不是标准的Markdown格式。</p><p>以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p></div><h2 id="1-Note"><a href="#1-Note" class="headerlink" title="1. Note"></a>1. Note</h2><p>修改主题配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>icons</code>和<code>light_bg_offset</code>只对方法一生效</p><p>Note 标签外挂有两种用法：</p><h3 id="用法1"><a href="#用法1" class="headerlink" title="用法1"></a>用法1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">名称</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">【可选】标识，不同的标识有不同的配色<br/>（ default &#x2F; primary &#x2F; success &#x2F; info &#x2F; warning &#x2F; danger ）</td></tr><tr><td align="center">no-icon</td><td align="center">【可选】不显示 icon</td></tr><tr><td align="center">style</td><td align="center">【可选】可以覆盖配置中的 style<br/>（simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table><p>示例：</p><div class="tabs" id="note"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#note-1">modern</button></li><li class="tab"><button type="button" data-href="#note-2">flat</button></li><li class="tab"><button type="button" data-href="#note-3">disabled</button></li><li class="tab"><button type="button" data-href="#note-4">no-icon</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="note-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  modern"><p>默认 提示块标签</p></div><div class="note  default modern"><p>default 提示块标签</p></div><div class="note  primary modern"><p>primary 提示块标签</p></div><div class="note  success modern"><p>success 提示块标签</p></div><div class="note  info modern"><p>info 提示块标签</p></div><div class="note  warning modern"><p>warning 提示块标签</p></div><div class="note  danger modern"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  flat"><p>默认 提示块标签</p></div><div class="note  default flat"><p>default 提示块标签</p></div><div class="note  primary flat"><p>primary 提示块标签</p></div><div class="note  success flat"><p>success 提示块标签</p></div><div class="note  info flat"><p>info 提示块标签</p></div><div class="note  warning flat"><p>warning 提示块标签</p></div><div class="note  danger flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note disabled %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  disabled"><p>默认 提示块标签</p></div><div class="note  default disabled"><p>default 提示块标签</p></div><div class="note  primary disabled"><p>primary 提示块标签</p></div><div class="note  success disabled"><p>success 提示块标签</p></div><div class="note  info disabled"><p>info 提示块标签</p></div><div class="note  warning disabled"><p>warning 提示块标签</p></div><div class="note  danger disabled"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  no-icon"><p>默认 提示块标签</p></div><div class="note  default no-icon"><p>default 提示块标签</p></div><div class="note  primary no-icon"><p>primary 提示块标签</p></div><div class="note  success no-icon"><p>success 提示块标签</p></div><div class="note  info no-icon"><p>info 提示块标签</p></div><div class="note  warning no-icon"><p>warning 提示块标签</p></div><div class="note  danger no-icon"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h3 id="用法2（自定义icon）"><a href="#用法2（自定义icon）" class="headerlink" title="用法2（自定义icon）"></a>用法2（自定义icon）</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">名称</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">【可选】顔色<br/>(default &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green)</td></tr><tr><td align="center">icon</td><td align="center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td align="center">style</td><td align="center">【可选】可以覆盖配置中的 style （simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table><p>示例：</p><div class="tabs" id="note2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#note2-1">modern</button></li><li class="tab"><button type="button" data-href="#note2-2">flat</button></li><li class="tab"><button type="button" data-href="#note2-3">disabled</button></li><li class="tab"><button type="button" data-href="#note2-4">no-icon</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="note2-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  fab fa-cc-visa modern"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  blue fas fa-bullhorn modern"><p>2021年快到了….</p></div><div class="note  pink fas fa-car-crash modern"><p>小心开车 安全至上</p></div><div class="note  red fas fa-fan modern"><p>这是三片呢？还是四片？</p></div><div class="note  orange fas fa-battery-half modern"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  purple far fa-hand-scissors modern"><p>剪刀石头布</p></div><div class="note  green fab fa-internet-explorer modern"><p>前端最讨厌的浏览器</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note2-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  fab fa-cc-visa flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  blue fas fa-bullhorn flat"><p>2021年快到了….</p></div><div class="note  pink fas fa-car-crash flat"><p>小心开车 安全至上</p></div><div class="note  red fas fa-fan flat"><p>这是三片呢？还是四片？</p></div><div class="note  orange fas fa-battery-half flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  purple far fa-hand-scissors flat"><p>剪刀石头布</p></div><div class="note  green fab fa-internet-explorer flat"><p>前端最讨厌的浏览器</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note2-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  fab fa-cc-visa disabled"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  blue fas fa-bullhorn disabled"><p>2021年快到了….</p></div><div class="note  pink fas fa-car-crash disabled"><p>小心开车 安全至上</p></div><div class="note  red fas fa-fan disabled"><p>这是三片呢？还是四片？</p></div><div class="note  orange fas fa-battery-half disabled"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  purple far fa-hand-scissors disabled"><p>剪刀石头布</p></div><div class="note  green fab fa-internet-explorer disabled"><p>前端最讨厌的浏览器</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="note2-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue no-icon %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink no-icon %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red no-icon %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple no-icon %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green no-icon %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note  no-icon"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  blue no-icon"><p>2021年快到了….</p></div><div class="note  pink no-icon"><p>小心开车 安全至上</p></div><div class="note  red no-icon"><p>这是三片呢？还是四片？</p></div><div class="note  orange no-icon"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note  purple no-icon"><p>剪刀石头布</p></div><div class="note  green no-icon"><p>前端最讨厌的浏览器</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><h2 id="2-Tabs"><a href="#2-Tabs" class="headerlink" title="2. Tabs"></a>2. Tabs</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><p>示例：</p><div class="note  info flat"><p>自定义Tab名 + 只有icon + icon和Tab名</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i  style="text-align: center;" class="tab solitude fab fa-apple-pay"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i  class="tab solitude fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><div class="note  info flat"><p>预设选择tabs</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><div class="note  info flat"><p>没有预设值</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><p>目前就用到这两个，其他的用到在更新（</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#Tabs">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客配置</title>
      <link href="/p/e941ffc/"/>
      <url>/p/e941ffc/</url>
      
        <content type="html"><![CDATA[<div class="note  flat success"><p>推荐阅读：<a href="https://rean-schwarze.github.io/p/b5223f80/">Halo 博客配置</a></p><p>选择Halo还是Hexo？看完↑的第一小节后，相信你就会有答案了</p></div><h1 id="一、Hexo-博客基础配置"><a href="#一、Hexo-博客基础配置" class="headerlink" title="一、Hexo 博客基础配置"></a>一、Hexo 博客基础配置</h1><h2 id="0-配置-GitHub-的-SSH-Key"><a href="#0-配置-GitHub-的-SSH-Key" class="headerlink" title="0. 配置 GitHub 的 SSH Key"></a>0. 配置 GitHub 的 SSH Key</h2><p>略</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240107200914367.png"></p><p><del><em>建议 SSH 创建时密码留空，因为真的会忘（</em></del></p><h2 id="1-创建-GitHub-Pages-仓库"><a href="#1-创建-GitHub-Pages-仓库" class="headerlink" title="1. 创建 GitHub Pages 仓库"></a>1. 创建 GitHub Pages 仓库</h2><p>输入 <code>username.github.io</code> 作为存储库名称。 将 <code>username</code> 替换为你的 GitHub 用户名。 例如，如果用户名为 <code>octocat</code>，则存储库名称应为 <code>octocat.github.io</code>。</p><p><img src="https://docs.github.com/assets/cb-48482/images/help/pages/create-repository-name-pages.png" alt="存储库中 GitHub Pages 设置的屏幕截图。 存储库名称字段包含文本“octocat.github.io”，并用深橙色框出。"></p><h2 id="2-本地安装-Hexo-博客程序"><a href="#2-本地安装-Hexo-博客程序" class="headerlink" title="2. 本地安装 Hexo 博客程序"></a>2. 本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。</p><h3 id="2-1-安装-Hexo"><a href="#2-1-安装-Hexo" class="headerlink" title="2.1 安装 Hexo"></a>2.1 安装 Hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="2-2-Hexo-初始化和本地预览"><a href="#2-2-Hexo-初始化和本地预览" class="headerlink" title="2.2 Hexo 初始化和本地预览"></a>2.2 Hexo 初始化和本地预览</h3><p>初始化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">cnpm install    # 安装组件</span><br><span class="line">cnpm install hexo-util</span><br></pre></td></tr></table></figure><p>启动本地预览</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><h3 id="2-3-Hexo博客文件夹目录结构"><a href="#2-3-Hexo博客文件夹目录结构" class="headerlink" title="2.3 Hexo博客文件夹目录结构"></a>2.3 Hexo博客文件夹目录结构</h3><p><img src="https://pic1.zhimg.com/80/v2-264c75c0e493ae8cc5f283567c64ff2c_1440w.webp" alt="img"></p><h3 id="2-4-部署-Hexo-到-GitHub-Pages"><a href="#2-4-部署-Hexo-到-GitHub-Pages" class="headerlink" title="2.4 部署 Hexo 到 GitHub Pages"></a>2.4 部署 Hexo 到 GitHub Pages</h3><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后在根目录下<code>_config.yml</code> 文件末尾的 Deployment 部分添加：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>将<code>_config.yml</code> 文件中的 <strong>url</strong> 修改成自己的：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://用户名.github.io/</span></span><br></pre></td></tr></table></figure><p>完成后运行如下命令，将网站上传部署到 GitHub Pages：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后稍等片刻，等待 GitHub 中 workflows 运行完毕（大约需要 1min），即可访问我们的 GitHub 域名。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240107194324697.png"></p><h3 id="2-5-Hexo-命令总结"><a href="#2-5-Hexo-命令总结" class="headerlink" title="2.5 Hexo 命令总结"></a>2.5 Hexo 命令总结</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;    # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo <span class="built_in">help</span>             # 帮助</span><br></pre></td></tr></table></figure><h1 id="二、Hexo-博客进阶配置"><a href="#二、Hexo-博客进阶配置" class="headerlink" title="二、Hexo 博客进阶配置"></a>二、Hexo 博客进阶配置</h1><div class="note  flat info"><p>本站已采用<code>solitude</code>主题，这里<strong>主题配置</strong>相关的内容就仅供参考了，<code>solitude</code>主题使用及配置可以看官方文档</p></div><h2 id="1-安装-Butterfly"><a href="#1-安装-Butterfly" class="headerlink" title="1. 安装 Butterfly"></a>1. 安装 Butterfly</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>在 Hexo 根目录中运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="1-2-修改主题"><a href="#1-2-修改主题" class="headerlink" title="1.2 修改主题"></a>1.2 修改主题</h3><p>修改 Hexo 根目录下的<code>_config.yml</code>文件，将主题改为<code>butterfly</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h3 id="1-3-创建新的配置文件"><a href="#1-3-创建新的配置文件" class="headerlink" title="1.3 创建新的配置文件"></a>1.3 创建新的配置文件</h3><p>在 Hexo 根目录下创建<code>_config.butterfly.yml</code>。Hexo会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code>里的配置，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。</p><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><p>修改<code>_config.yml</code>：</p><div class="note  info tab"><p>注意修改配置文件（包括主题配置文件）时的<strong>缩进问题</strong>！</p></div><h3 id="2-1-设置博客个人资料"><a href="#2-1-设置博客个人资料" class="headerlink" title="2.1 设置博客个人资料"></a>2.1 设置博客个人资料</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Rean&#x27;s</span> <span class="string">Blog</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Enjoy</span> <span class="string">technology</span> <span class="string">and</span> <span class="string">music</span><span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span><span class="comment">#个性签名</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Rean</span><span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span><span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span>    <span class="comment">#中国的时区</span></span><br></pre></td></tr></table></figure><h3 id="2-2-图片懒加载"><a href="#2-2-图片懒加载" class="headerlink" title="2.2 图片懒加载"></a>2.2 图片懒加载</h3><p>安装<code>hexo-lazyload-image</code>模块：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>新增：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="string">/img/spin.svg</span></span><br></pre></td></tr></table></figure><h3 id="2-3-引入图片"><a href="#2-3-引入图片" class="headerlink" title="2.3 引入图片"></a>2.3 引入图片</h3><h4 id="引入本地图片（不推荐）"><a href="#引入本地图片（不推荐）" class="headerlink" title="引入本地图片（不推荐）"></a>引入本地图片（不推荐）</h4><p>修改：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始使用本地静态资源</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>安装插件<code>hexo-asset-image</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在项目根目录下执行</span></span><br><span class="line">npm install https://github.com/xcodebuild/hexo-asset-image.git --save</span><br></pre></td></tr></table></figure><p>完成上述配置后，在使用命令<code>hexo new post</code>新建文章时，将会在<code>source/_posts</code>目录下创建一个与文章同名的目录。</p><p>然后配置Markdown编辑器，使得插入图片保存的目录为与文章同名的目录即可。Typora配置如下所示。</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/image-20240107225914436.png"></p><p>图片引用方式：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 引用图片的时候一定要带上目录名称作为路径（相对路径）</span></span><br><span class="line">![<span class="string">本地图片</span>](<span class="link">测试文章/本地图片.jpg</span>)</span><br></pre></td></tr></table></figure><p>原理详见：<a href="https://www.cnblogs.com/nuccch/p/17010471.html">在Hexo中引入本地图片的实现 - nuccch - 博客园 (cnblogs.com)</a></p><h4 id="使用图床（推荐）"><a href="#使用图床（推荐）" class="headerlink" title="使用图床（推荐）"></a>使用图床（推荐）</h4><p>这里以阿里云OSS为例，创建一个Bucket</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/53b64053b683d64c5f2373b5bf3f245d.png"></p><p>（有需要的可以设置一下防盗链）</p><p>然后设置访问控制RAM，创建用户</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694094234.png"></p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694159619.png"></p><p>设置授权，图省事可以直接用<code>AliyunOSSFullAccess</code>（），粒度小一点可以<code>AliyunOSSReadOnlyAccess</code>+自定义策略，再小一点就只给自定义策略</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694259195.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;oss:GetObject&quot;,</span><br><span class="line">                &quot;oss:PutObject&quot;,</span><br><span class="line">                &quot;oss:DeleteObject&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;acs:oss:*:*:你的bucket/你的路径/*&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建AccessKey（注意保存！）</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694492555.png"></p><p>然后安装PicGo，图床设置如下，区域根据自己创建桶时选的区域来填写</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694554634.png"></p><p>最后设置Typora</p><p><img src="https://rean-blog-bucket.oss-cn-guangzhou.aliyuncs.com/assets/img/QQ_1723694616684.png"></p><h3 id="2-4-永久短链生成（2024-3-18更新）"><a href="#2-4-永久短链生成（2024-3-18更新）" class="headerlink" title="2.4 永久短链生成（2024&#x2F;3&#x2F;18更新）"></a>2.4 永久短链生成（2024&#x2F;3&#x2F;18更新）</h3><p>Hexo 默认生成的链接太长了，而且一旦文章名字改变，链接也跟着改变。 <a href="https://github.com/rozbo/hexo-abbrlink">rozbo&#x2F;hexo-abbrlink</a>这个插件可以使得Hexo 生成的链接变短，而且不会因文章名字改变而改变。</p><p>安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code> 配置文件写入：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span> <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改 permalink 值</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">p/:abbrlink/</span></span><br></pre></td></tr></table></figure><p><font color="red">记得把原来的<code>permalink:</code>删除&#x2F;注释掉（或者直接修改原来的值）！！</font></p><h2 id="3-修改主题配置文件"><a href="#3-修改主题配置文件" class="headerlink" title="3. 修改主题配置文件"></a>3. 修改主题配置文件</h2><p>修改<code>_config.butterfly.yml</code>：</p><h3 id="3-1-菜单（导航）栏"><a href="#3-1-菜单（导航）栏" class="headerlink" title="3.1 菜单（导航）栏"></a>3.1 菜单（导航）栏</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章</span> <span class="string">||</span> <span class="attr">fa fa-graduation-cap:</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="comment"># 关于作者: /about/ || fas fa-heart</span></span><br></pre></td></tr></table></figure><h3 id="3-2-代码块显示设置"><a href="#3-2-代码块显示设置" class="headerlink" title="3.2 代码块显示设置"></a>3.2 代码块显示设置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span>  <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false 代码主题</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 复制按钮</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">false</span> <span class="comment"># 是否显示代码语言</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: 代码块默认不展开 / false: 代码块默认展开 | none: 展开并隐藏折叠按钮</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span> <span class="comment">#代码自动换行，关闭滚动条</span></span><br></pre></td></tr></table></figure><div class="tabs" id="highlight_theme"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#highlight_theme-1">darker</button></li><li class="tab"><button type="button" data-href="#highlight_theme-2">pale night</button></li><li class="tab"><button type="button" data-href="#highlight_theme-3">light</button></li><li class="tab"><button type="button" data-href="#highlight_theme-4">ocean</button></li><li class="tab"><button type="button" data-href="#highlight_theme-5">mac</button></li><li class="tab"><button type="button" data-href="#highlight_theme-6">mac light</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="highlight_theme-1"><p><img src="https://pic1.zhimg.com/80/v2-a28e0ab39989ac0ccbddb70646f1bd84_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="highlight_theme-2"><p><img src="https://pic1.zhimg.com/80/v2-4e3e4bd2a87aabc389b94489c2a7a384_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="highlight_theme-3"><p><img src="https://pic1.zhimg.com/80/v2-18ead3b8a2796bfe37ae8828ff3389a4_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="highlight_theme-4"><p><img src="https://pic4.zhimg.com/80/v2-966ebdb8933cc6298cb12113fb6b1cff_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="highlight_theme-5"><p><img src="https://pic3.zhimg.com/80/v2-a2c8b16e081ccf3a82fc5fc21d9b46a6_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div><div class="tab-item-content" id="highlight_theme-6"><p><img src="https://pic1.zhimg.com/80/v2-c856d3dbac834eeb19d165bf25d148ac_1440w.webp" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="solitude st-arrow-up-line"></i></button></div></div></div><p>同时将<code>_config.yml</code>中的<code>highlight</code>进行设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-3-本地搜索"><a href="#3-3-本地搜索" class="headerlink" title="3.3 本地搜索"></a>3.3 本地搜索</h3><p>首先安装搜索插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>然后修改<code>_config.butterfly.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;此关键词下没有搜索结果: $&#123;query&#125;&quot;</span> <span class="comment"># 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure><h3 id="3-4-修改副标题"><a href="#3-4-修改副标题" class="headerlink" title="3.4 修改副标题"></a>3.4 修改副标题</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (开启打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循環打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用搏天api的隨機語錄（簡體）</span></span><br><span class="line">  <span class="comment"># source: 2  調用一言網的一句話（簡體）</span></span><br><span class="line">  <span class="comment"># source: 3  調用一句網（簡體）</span></span><br><span class="line">  <span class="comment"># source: 4  調用今日詩詞（簡體）</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果有英文逗号&#x27; , &#x27;,请使用转义字元 &amp;#44;</span></span><br><span class="line">  <span class="comment"># 如果有英文双引号&#x27; &quot; &#x27;,请使用转义字元 &amp;quot;</span></span><br><span class="line">  <span class="comment"># 开头不允許转义字元，如需要，请把整個句子用双引号包住</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle只会现示sub的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Enjoy</span> <span class="string">technology</span> <span class="string">and</span> <span class="string">music</span></span><br><span class="line">  <span class="comment"># 可以不止一个副标题，下面还可以接着</span></span><br><span class="line">  <span class="comment"># - 其他副标题</span></span><br></pre></td></tr></table></figure><h3 id="3-5-图片设置"><a href="#3-5-图片设置" class="headerlink" title="3.5 图片设置"></a>3.5 图片设置</h3><p>图片可以用云链接或者本地路径：<code>/themes/butterfly/source/img</code>。</p><h4 id="3-5-1-网站图标"><a href="#3-5-1-网站图标" class="headerlink" title="3.5.1 网站图标"></a>3.5.1 网站图标</h4><p>可以更换成自己的图标，我这里图片分辨率取同样32*32。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-个人头像"><a href="#3-5-2-个人头像" class="headerlink" title="3.5.2 个人头像"></a>3.5.2 个人头像</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span> <span class="comment">#图片路径</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment">#头像会一直转圈  </span></span><br></pre></td></tr></table></figure><h4 id="3-5-3-主页封面图片"><a href="#3-5-3-主页封面图片" class="headerlink" title="3.5.3 主页封面图片"></a>3.5.3 主页封面图片</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/banner-1.png</span></span><br></pre></td></tr></table></figure><h4 id="3-5-4-文章详情页的顶部图片"><a href="#3-5-4-文章详情页的顶部图片" class="headerlink" title="3.5.4 文章详情页的顶部图片"></a>3.5.4 文章详情页的顶部图片</h4><p>当没有在文章<code>front-matter</code>设置<code>top_img</code>和<code>cover</code>的情况下会显示该图。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If the banner of page not setting, it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/img/banner-1.png</span></span><br></pre></td></tr></table></figure><h4 id="3-5-5-归档页顶部图片"><a href="#3-5-5-归档页顶部图片" class="headerlink" title="3.5.5 归档页顶部图片"></a>3.5.5 归档页顶部图片</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归档子标签页图片</span></span><br><span class="line"><span class="comment"># The banner image of archive page</span></span><br><span class="line"><span class="attr">archive_img:</span> <span class="string">/img/banner-1.png</span></span><br></pre></td></tr></table></figure><h4 id="3-5-6-标签页顶部图片"><a href="#3-5-6-标签页顶部图片" class="headerlink" title="3.5.6 标签页顶部图片"></a>3.5.6 标签页顶部图片</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tag页（标签页）</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">/img/banner-1.png</span></span><br></pre></td></tr></table></figure><h4 id="3-5-7-归档页顶部图片"><a href="#3-5-7-归档页顶部图片" class="headerlink" title="3.5.7 归档页顶部图片"></a>3.5.7 归档页顶部图片</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># category页</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">/img/banner-1.png</span></span><br></pre></td></tr></table></figure><h3 id="3-6-文章封面统一设置"><a href="#3-6-文章封面统一设置" class="headerlink" title="3.6 文章封面统一设置"></a>3.6 文章封面统一设置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span> <span class="comment">#  是否展示文章封面</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span> <span class="comment"># 封面展示的位置 left/right/both</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认展示的文章封面</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br><span class="line">  <span class="comment"># 当配置多张图片时，会随机选择一张作为 cover. 此时写法为</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/img/SynthV_banner_Image_BG1.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover1.JPG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover3.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover4.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG</span></span><br></pre></td></tr></table></figure><h3 id="3-7-404图片替换"><a href="#3-7-404图片替换" class="headerlink" title="3.7 404图片替换"></a>3.7 404图片替换</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Replace Broken Images (替換無法顯示的圖片)</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/img/friend_404.gif</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/img/404.jpg</span></span><br></pre></td></tr></table></figure><h3 id="3-8-图片大图查看"><a href="#3-8-图片大图查看" class="headerlink" title="3.8 图片大图查看"></a>3.8 图片大图查看</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-9-版权样式"><a href="#3-9-版权样式" class="headerlink" title="3.9 版权样式"></a>3.9 版权样式</h3><p>复制内容后面加上版权信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启网站复制权限</span></span><br><span class="line">  <span class="attr">copyright:</span>  <span class="comment"># 复制的内容后面加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 是否开启复制版权信息添加</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span> <span class="comment"># 字数限制，当复制文字大于这个字数限制时</span></span><br></pre></td></tr></table></figure><p>文章版权信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure><h3 id="3-10-相关文章"><a href="#3-10-相关文章" class="headerlink" title="3.10 相关文章"></a>3.10 相关文章</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Related Articles</span></span><br><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># Number of posts displayed</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期顯示創建日或者更新日</span></span><br></pre></td></tr></table></figure><h3 id="3-11-侧边栏"><a href="#3-11-侧边栏" class="headerlink" title="3.11 侧边栏"></a>3.11 侧边栏</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 侧边栏</span></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right </span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/Rean-Schwarze</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">随缘更新~</span> <span class="comment">#修改公告栏信息</span></span><br></pre></td></tr></table></figure><p>社交平台信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">   <span class="attr">fab fa-github:</span> <span class="string">https://github.com/</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">   <span class="attr">fab fa-bilibili:</span> <span class="string">https://space.bilibili.com/6531436</span> <span class="string">||</span> <span class="string">bilibili</span></span><br></pre></td></tr></table></figure><p>可以在 <a href="https://fontawesome.com/icons">Find Icons with the Perfect Look &amp; Feel | Font Awesome</a> 中找到想要的图标加上其他平台的信息。</p><p><img src="/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/image-20240107210306901.png" alt="image-20240107210306901"></p><h3 id="3-12-主页文章节选"><a href="#3-12-主页文章节选" class="headerlink" title="3.12 主页文章节选"></a>3.12 主页文章节选</h3><p>在<code>butterfly</code>里，有四种可供选择</p><ol><li><strong>description</strong>： 只显示description</li><li><strong>both</strong>： 优先选择description，如果没有配置description，则显示自动节选的内容</li><li><strong>auto_excerpt</strong>：只显示自动节选</li><li><strong>false</strong>： 不显示文章内容</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p><code>description</code>在Markdown的front-matter里添加。</p><h3 id="3-13-Toc-目录"><a href="#3-13-Toc-目录" class="headerlink" title="3.13 Toc 目录"></a>3.13 Toc 目录</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># toc (目錄)</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">true</span> <span class="comment"># 是否展开</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># for post</span></span><br><span class="line">  <span class="attr">scroll_percent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-14-背景特效"><a href="#3-14-背景特效" class="headerlink" title="3.14 背景特效"></a>3.14 背景特效</h3><p>打字效果：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode</span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>背景特效：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Background effects (背景特效)</span></span><br><span class="line"><span class="comment"># canvas_ribbon (静止彩带)</span></span><br><span class="line"><span class="comment"># See: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Fluttering Ribbon (动态彩带)</span></span><br><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#星空特效</span></span><br><span class="line"><span class="comment"># canvas_nest</span></span><br><span class="line"><span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>footer背景</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># footer是否显示图片背景(与top_img一致)</span></span><br><span class="line"><span class="attr">footer_bg:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-15-字数统计"><a href="#3-15-字数统计" class="headerlink" title="3.15 字数统计"></a>3.15 字数统计</h3><p>安装统计组件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-wordcount --save or yarn add hexo-wordcount</span><br></pre></td></tr></table></figure><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-16-访问人数-busuanzi-UV-和-PV"><a href="#3-16-访问人数-busuanzi-UV-和-PV" class="headerlink" title="3.16 访问人数 busuanzi (UV 和 PV)"></a>3.16 访问人数 busuanzi (UV 和 PV)</h3><p>下列代码似乎不需要添加也能生效。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note  warning adblocker"><p>需要关闭浏览器中的广告拦截插件才能正常显示统计！</p></div><h2 id="4-创建页面"><a href="#4-创建页面" class="headerlink" title="4. 创建页面"></a>4. 创建页面</h2><h3 id="4-1-创建分类页"><a href="#4-1-创建分类页" class="headerlink" title="4.1 创建分类页"></a>4.1 创建分类页</h3><p>在 Hexo 根目录下运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>运行完毕后，打开<code>/source/categories/index.md</code>，设置其 type：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure><h3 id="4-2-创建标签页"><a href="#4-2-创建标签页" class="headerlink" title="4.2 创建标签页"></a>4.2 创建标签页</h3><p>在 Hexo 根目录下运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>运行完毕后，打开<code>/source/tags/index.md</code>，设置其 type：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><h3 id="4-3-创建音乐页"><a href="#4-3-创建音乐页" class="headerlink" title="4.3 创建音乐页"></a>4.3 创建音乐页</h3><p>在 Hexo 根目录下运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page music</span><br><span class="line"></span><br><span class="line">npm install aplayer</span><br><span class="line"></span><br><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>假如安装成功，则可以定位到<code>主题目录\layout\includes</code>，看看<code>layout.pug</code>应该出现以下字段，若不存在请手动加上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line">   include ./head.pug</span><br><span class="line">    link(rel=&quot;stylesheet&quot; href=&quot;APlayer.min.css&quot;)</span><br><span class="line">    div(id=&quot;aplayer&quot;)</span><br><span class="line">    script(src=&quot;https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js&quot; async)</span><br><span class="line">    script(src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot; async)</span><br><span class="line"> body</span><br></pre></td></tr></table></figure><p>然后在<code>_config.yml</code>最后添加代码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#aplayer</span></span><br><span class="line"><span class="attr">aplayer:</span> </span><br><span class="line">  <span class="attr">script_dir:</span> <span class="string">js</span>                      <span class="comment"># Public 目录下脚本目录路径，默认: &#x27;assets/js&#x27;</span></span><br><span class="line">  <span class="attr">style_dir:</span> <span class="string">css</span>                         <span class="comment"># Public 目录下样式目录路径，默认: &#x27;assets/css&#x27;</span></span><br><span class="line">  <span class="comment">#cdn: http://xxx/aplayer.min.js                # 引用 APlayer.js 外部 CDN 地址 (默认不开启)</span></span><br><span class="line">  <span class="comment">#style_cdn: http://xxx/aplayer.min.css         # 引用 APlayer.css 外部 CDN 地址 (默认不开启)</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span>                                  <span class="comment"># MetingJS 支持</span></span><br><span class="line">  <span class="comment">#meting_api: http://xxx/api.php                # 自定义 Meting API 地址</span></span><br><span class="line">  <span class="comment">#meting_cdn: http://xxx/Meing.min.js           # 引用 Meting.js 外部 CDN 地址 (默认不开启)</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">true</span>                            <span class="comment"># 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启</span></span><br><span class="line">  <span class="comment">#externalLink: http://xxx/aplayer.min.js       # 老版本参数，功能与参数 cdn 相同meting: true</span></span><br></pre></td></tr></table></figure><p>最后，在<code>\source\music\index.md</code>中修改：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 来听歌吧</span><br><span class="line">date: 2024-01-07 12:41:51</span><br><span class="line">type: music</span><br><span class="line">aplayer: true</span><br><span class="line">top<span class="emphasis">_img: false</span></span><br><span class="line"><span class="emphasis">comments: false</span></span><br><span class="line"><span class="emphasis">aside: false</span></span><br><span class="line"><span class="emphasis">---</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#31c27c</span> <span class="attr">size</span>=<span class="string">3</span>&gt;</span></span>QQ音乐（好像听不了）<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% meting &quot;002tswK804XaPE&quot; &quot;tencent&quot; &quot;song&quot; &quot;mutex:false&quot; &quot;preload:none&quot; %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#e60026</span> <span class="attr">size</span>=<span class="string">3</span>&gt;</span></span>网易云音乐<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% meting &quot;2106465174&quot; &quot;netease&quot; &quot;song&quot; &quot;mutex:false&quot; &quot;preload:none&quot; %&#125;</span></span><br></pre></td></tr></table></figure><p>有关 <code>&#123;% meting %&#125;</code> 的选项列表如下：</p><table><thead><tr><th align="center">选项</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">id</td><td align="center"><strong>必须值</strong></td><td align="center">歌曲 id &#x2F; 播放列表 id &#x2F; 相册 id &#x2F; 搜索关键字</td></tr><tr><td align="center">server</td><td align="center"><strong>必须值</strong></td><td align="center">音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td align="center">type</td><td align="center"><strong>必须值</strong></td><td align="center"><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td align="center">fixed</td><td align="center"><code>false</code></td><td align="center">开启固定模式</td></tr><tr><td align="center">mini</td><td align="center"><code>false</code></td><td align="center">开启迷你模式</td></tr><tr><td align="center">loop</td><td align="center"><code>all</code></td><td align="center">列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td align="center">order</td><td align="center"><code>list</code></td><td align="center">列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td align="center">volume</td><td align="center">0.7</td><td align="center">播放器音量</td></tr><tr><td align="center">lrctype</td><td align="center">0</td><td align="center">歌词格式类型</td></tr><tr><td align="center">listfolded</td><td align="center"><code>false</code></td><td align="center">指定音乐播放列表是否折叠</td></tr><tr><td align="center">storagename</td><td align="center"><code>metingjs</code></td><td align="center">LocalStorage 中存储播放器设定的键名</td></tr><tr><td align="center">autoplay</td><td align="center"><code>true</code></td><td align="center">自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td align="center">mutex</td><td align="center"><code>true</code></td><td align="center">该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td align="center">listmaxheight</td><td align="center"><code>340px</code></td><td align="center">播放列表的最大长度</td></tr><tr><td align="center">preload</td><td align="center"><code>auto</code></td><td align="center">音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td align="center">theme</td><td align="center"><code>#ad7a86</code></td><td align="center">播放器风格色彩设置</td></tr></tbody></table><h4 id="添加本地音乐"><a href="#添加本地音乐" class="headerlink" title="添加本地音乐"></a>添加本地音乐</h4><p>在<code>music</code>文件夹内新建<code>index</code>文件夹（若不存在），然后将资源文件都放进去。</p><h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>在<code>index.md</code>内添加：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;孤帆和岛&quot; &quot;尚辰、喧笑、朝歌夜弦&quot; &quot;/music/index/尚辰、喧笑、朝歌夜弦 - 孤帆和岛.flac&quot; &quot;/music/index/尚辰、喧笑、朝歌夜弦 - 孤帆和岛.jpg&quot; %&#125;</span><br></pre></td></tr></table></figure><h5 id="标签参数"><a href="#标签参数" class="headerlink" title="标签参数"></a>标签参数</h5><ul><li><code>title</code> : 曲目标题</li><li><code>author</code>: 曲目作者</li><li><code>url</code>: 音乐文件 URL 地址</li><li><code>picture_url</code>: (可选) 音乐对应的图片地址</li><li><code>narrow</code>: （可选）播放器袖珍风格</li><li><code>autoplay</code>: (可选) 自动播放，移动端浏览器暂时不支持此功能</li><li><code>width:xxx</code>: (可选) 播放器宽度 (默认: 100%)</li><li><code>lrc:xxx</code>: （可选）歌词文件 URL 地址</li></ul><div class="note  info flat"><p>此方法调用.lrc文件目前没摸索到正确的方法，所以采用另一个比较笨的办法。</p></div><h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>除了使用标签 <code>lrc</code> 选项来设定歌词，你也可以直接使用 <code>aplayerlrc</code> 标签来直接插入歌词文本在博客中：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlrc &quot;title&quot; &quot;author&quot; &quot;url&quot; &quot;autoplay&quot; %&#125;</span><br><span class="line">[00:00.00]lrc here</span><br><span class="line">&#123;% endaplayerlrc %&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-添加全局吸底APlayer"><a href="#4-4-添加全局吸底APlayer" class="headerlink" title="4.4 添加全局吸底APlayer"></a>4.4 添加全局吸底APlayer</h3><p>在主题配置文件中，插入：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject the css and script (aplayer/meting)</span></span><br><span class="line"><span class="attr">aplayerInject:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Pjax</span></span><br><span class="line"><span class="comment"># It may contain bugs and unstable, give feedback when you find the bugs.</span></span><br><span class="line"><span class="comment"># https://github.com/MoOx/pjax</span></span><br><span class="line"><span class="attr">pjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - xxxx</span></span><br><span class="line">    <span class="comment"># - xxxx</span></span><br></pre></td></tr></table></figure><h4 id="美化与调整"><a href="#美化与调整" class="headerlink" title="美化与调整"></a>美化与调整</h4><p>在<code>\themes\butterfly\source\css\custom.css</code>中添加：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Aplayer日间模式调整 */</span></span><br><span class="line"><span class="comment">/* 背景色 */</span></span><br><span class="line"><span class="selector-class">.aplayer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.07</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.07</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line"><span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span>::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span>::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span>::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 圆角 */</span></span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-list</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-miniswitcher</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">6px</span> <span class="number">6px</span> <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span><span class="selector-class">.aplayer-narrow</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.28s</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选中与播放中歌曲激活颜色 */</span></span><br><span class="line"><span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 歌词 */</span></span><br><span class="line"><span class="selector-class">.aplayer-lrc</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">#000000</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span>, <span class="number">#000000</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>, <span class="number">#000000</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">0</span>, <span class="number">#000000</span></span><br><span class="line">      <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aplayer黑暗模式 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">0.6</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.07</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span><span class="selector-class">.aplayer-fixed</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">0.6</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.07</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span></span><br><span class="line">  <span class="selector-class">.aplayer</span></span><br><span class="line">  <span class="selector-class">.aplayer-info</span></span><br><span class="line">  <span class="selector-class">.aplayer-controller</span></span><br><span class="line">  <span class="selector-class">.aplayer-time</span></span><br><span class="line">  <span class="selector-class">.aplayer-icon</span></span><br><span class="line">  path &#123;</span><br><span class="line">  fill: <span class="number">#d4d4d4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-time</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#d4d4d4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> <span class="selector-class">.aplayer-list-index</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#d4d4d4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> <span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#d4d4d4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注入css"><a href="#注入css" class="headerlink" title="注入css"></a>注入css</h4><p>在主题配置文件中，插入：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># ps：引入自定义css、js</span></span><br><span class="line"><span class="comment">#     css文件在head引入，js文件在bottom里引入，有的js要求在head引入，不然无法生效</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># ps: 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="comment">#注入自定义css</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="comment">#注入自定义js</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;421801417&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-autoplay=&quot;false&quot;&gt;</span> <span class="string">&lt;/div&gt;</span></span><br><span class="line">      <span class="comment"># - &lt;script src=&quot;/js/script.js?v1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;/xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Aplayer-html-参数解释"><a href="#Aplayer-html-参数解释" class="headerlink" title="Aplayer html 参数解释"></a>Aplayer html 参数解释</h4><p>与 meting 参数基本相同，区别是选项名称前面多了<code>data-</code>字段。</p><h2 id="5-添加评论功能"><a href="#5-添加评论功能" class="headerlink" title="5. 添加评论功能"></a>5. 添加评论功能</h2><p>此处选择使用 Giscus 以及 Valine 双评论系统。</p><h3 id="5-1-更改主题配置"><a href="#5-1-更改主题配置" class="headerlink" title="5.1 更改主题配置"></a>5.1 更改主题配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Giscus,Valine</span> <span class="comment"># 可实现单评论、双评论(最多两个)</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># 是否显示评论服务商的名字</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span> <span class="comment"># 是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示）</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># 是否在文章顶部显示评论数，livere、Giscus 和 utterances 不支持评论数显示</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># 是否在首页文章卡片显示评论数，gitalk、livere 、Giscus 和 utterances 不支持评论数显示</span></span><br></pre></td></tr></table></figure><h3 id="5-2-Giscus"><a href="#5-2-Giscus" class="headerlink" title="5.2 Giscus"></a>5.2 Giscus</h3><p>利用 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> 实现的评论系统，让访客借助 GitHub 在你的网站上留下评论和反应吧！本项目深受 <a href="https://github.com/utterance/utterances">utterances</a> 的启发。</p><ul><li><a href="https://github.com/giscus/giscus">开源</a>。🌏</li><li>无跟踪，无广告，永久免费。📡 🚫</li><li>无需数据库。所有数据均储存在 GitHub Discussions 中。:octocat:</li><li>支持<a href="https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#data-theme">自定义主题</a>！🌗</li><li>支持<a href="https://github.com/giscus/giscus/blob/main/CONTRIBUTING.md#adding-localizations">多种语言</a>。🌐</li><li><a href="https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md">高可配置性</a>。🔧</li><li>自动从 GitHub 拉取新评论与编辑。🔃</li><li><a href="https://github.com/giscus/giscus/blob/main/SELF-HOSTING.md">可自建服务</a>！🤳</li></ul><h4 id="5-2-1-安装-Giscus"><a href="#5-2-1-安装-Giscus" class="headerlink" title="5.2.1 安装 Giscus"></a>5.2.1 安装 Giscus</h4><p>点击链接：<a href="https://github.com/apps/giscus">GitHub Apps - giscus</a></p><p><img src="https://pic4.zhimg.com/80/v2-c1318395adf509c6158a704a4b56031f_1440w.webp" alt="img"></p><p>选择自己博客的仓库，点击install。</p><h4 id="5-2-2-配置仓库-Discussions"><a href="#5-2-2-配置仓库-Discussions" class="headerlink" title="5.2.2 配置仓库 Discussions"></a>5.2.2 配置仓库 Discussions</h4><p>打开仓库的 Settiing ，在 Features 中找到 Discussions 勾选上。</p><p><img src="/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/image-20240108122131371.png" alt="image-20240108122131371"></p><p>然后建立一个Announcements的分类。</p><p><img src="https://pic3.zhimg.com/80/v2-d312dfee9a5a221075a7ee9786d976f6_1440w.webp" alt="img"></p><h4 id="5-2-3-进入-Giscus-配置"><a href="#5-2-3-进入-Giscus-配置" class="headerlink" title="5.2.3 进入 Giscus 配置"></a>5.2.3 进入 Giscus 配置</h4><p>打开链接：<a href="https://giscus.app/zh-CN">giscus</a></p><p><img src="/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/image-20240108122345633.png" alt="image-20240108122345633"></p><p>选择自己的博客仓库，映射关系选择<code>URL</code>，分类选择Announcemes。</p><p>配置完后，可以在启用 giscus 部分复制相关信息到<code>主题配置文件</code>中。</p><p><img src="/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/image-20240108122508662.png" alt="image-20240108122508662"></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Giscus</span></span><br><span class="line"><span class="comment"># https://giscus.app/</span></span><br><span class="line"><span class="attr">giscus:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">repo_id:</span></span><br><span class="line">  <span class="attr">category_id:</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">light</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><h3 id="5-3-Valine"><a href="#5-3-Valine" class="headerlink" title="5.3 Valine"></a>5.3 Valine</h3><ol><li>访问<a href="https://www.leancloud.cn/">LeanCloud</a>，进行注册，登陆，实名认证。</li><li>创建 Valine 应用，名称任意。</li><li>进入对应的应用，点击 <code>设置 -&gt; 应用 凭证，获取</code><strong>AppID</strong>、<strong>AppKey</strong>、<strong>服务器地址</strong>。</li><li>修改主题配置文件：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine</span></span><br><span class="line"><span class="comment"># https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> </span><br><span class="line">  <span class="attr">appKey:</span> </span><br><span class="line">  <span class="comment">#查询下面的网站，选择评论的适合出现的图像 https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style </span></span><br><span class="line">  <span class="comment">#你的对应的服务器的地址，就在appid那一页的下面</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="comment">#评论系统的背景</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="comment">#是否允许游客评论</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#评论区显示的文字</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下你的足迹o(*￣▽￣*)ブ</span></span><br><span class="line">  <span class="comment">#每一页最大的评论数量</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><h1 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h1><h2 id="1-创建文章"><a href="#1-创建文章" class="headerlink" title="1. 创建文章"></a>1. 创建文章</h2><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>然后就可以在<code>source/_post</code>文件夹内找到创建的.md文件进行编辑。</p><h2 id="2-编辑格式"><a href="#2-编辑格式" class="headerlink" title="2. 编辑格式"></a>2. 编辑格式</h2><p>在Markdown文件顶部可以进行格式的编辑。</p><h3 id="2-1-分类-categories"><a href="#2-1-分类-categories" class="headerlink" title="2.1 分类 categories"></a>2.1 分类 categories</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这是默认的写法，给文章添加一个分类123。</span></span><br><span class="line">categories: 123</span><br><span class="line"><span class="section"># 这会将文章分类123/456子分类目录下。</span></span><br><span class="line">categories: [123, 456]</span><br><span class="line"><span class="section"># 同样，这会将文章分类到123/456子分类目录下。</span></span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">   -</span> 123</span><br><span class="line"><span class="bullet">   -</span> 456</span><br><span class="line"><span class="section"># 多标签写法，文章被分类到123、456以及123的子分类789这3个分类下面，官方指定写法。</span></span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">   -</span> [123]</span><br><span class="line"><span class="bullet">   -</span> [456]</span><br><span class="line"><span class="bullet">   -</span> [123, 789]</span><br></pre></td></tr></table></figure><h3 id="2-2-标签-tags"><a href="#2-2-标签-tags" class="headerlink" title="2.2 标签 tags"></a>2.2 标签 tags</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 方法1：</span></span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> 123</span><br><span class="line"><span class="bullet">  -</span> 456</span><br><span class="line"><span class="section"># 方法2：</span></span><br><span class="line">tags: [123, 456]</span><br></pre></td></tr></table></figure><h3 id="2-3-文章封面设置"><a href="#2-3-文章封面设置" class="headerlink" title="2.3 文章封面设置"></a>2.3 文章封面设置</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">top<span class="emphasis">_img: /img/hello-1.png # 顶部背景图</span></span><br><span class="line"><span class="emphasis">cover: /img/hello-1.png   # 文章封面</span></span><br></pre></td></tr></table></figure><div class="note  warning flat"><p>放在<code>themes\butterfly\source\img</code>里面哦</p></div><h3 id="2-4-文章描述"><a href="#2-4-文章描述" class="headerlink" title="2.4 文章描述"></a>2.4 文章描述</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">description: 描述</span><br></pre></td></tr></table></figure><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>等待约 1min 即可。</p><h1 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p><p><a href="https://docs.github.com/zh/pages/quickstart">GitHub Pages 快速入门 - GitHub 文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/348131730">hexo博客中tags与categories用法 - 知乎 (zhihu.com)</a></p><p><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题butterfly配置-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/1917948">Hexo博客 | 采用随机图片作为博客封面背景，真香！-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://blog.csdn.net/weixin_41287260/article/details/97758641">Hexo新建标签、分类、归档等页面_hexo new page-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/7e30afa09fab">hexo侧边栏社交小图标设置 - 简书 (jianshu.com)</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%BB%A3%E7%A2%BC%E8%A4%87%E8%A3%BD">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></p><p><a href="https://www.cnblogs.com/nuccch/p/17010471.html">在Hexo中引入本地图片的实现 - nuccch - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_46435629/article/details/106295515">如何在Hexo博客Butterfly主题开启Aplayer和“音乐”页面_butterfly 增加音乐页-CSDN博客</a></p><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer&#x2F;docs&#x2F;README-zh_cn.md at master · MoePlayer&#x2F;hexo-tag-aplayer (github.com)</a></p><p><a href="https://blog.saop.cc/p/8dc9/">https://blog.saop.cc/p/8dc9/</a></p><p><a href="https://zhuanlan.zhihu.com/p/603658639">hexo-butterfly主题-giscus评论系统设置 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
